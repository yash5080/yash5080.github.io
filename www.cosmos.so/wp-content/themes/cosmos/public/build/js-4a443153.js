var I1 = Object.defineProperty;
var F1 = (r, e, t) =>
  e in r
    ? I1(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
    : (r[e] = t);
var q = (r, e, t) => (F1(r, typeof e != "symbol" ? e + "" : e, t), t);
function O1(r, e) {
  for (var t = 0; t < e.length; t++) {
    const i = e[t];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const n in i)
        if (n !== "default" && !(n in r)) {
          const s = Object.getOwnPropertyDescriptor(i, n);
          s &&
            Object.defineProperty(
              r,
              n,
              s.get ? s : { enumerable: !0, get: () => i[n] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(r, Symbol.toStringTag, { value: "Module" })
  );
}
const i0 = (window._SVG_SPRITE_IDS_ = window._SVG_SPRITE_IDS_ || []),
  su = document.createElementNS("http://www.w3.org/2000/svg", "svg");
su.style.position = "absolute";
su.style.width = "0";
su.style.height = "0";
function n0() {
  document.body.insertBefore(su, document.body.firstChild);
}
document.readyState === "loading"
  ? document.addEventListener("DOMContentLoaded", n0)
  : n0();
function ii(r, e) {
  (i0.indexOf(e) > -1 || document.getElementById(e)) &&
    console.warn(
      `Icon #${e} was duplicately registered. It must be globally unique.`
    ),
    i0.push(e),
    su.insertAdjacentHTML("beforeend", r);
}
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" id="arena"><path d="m22.836 16.008-2.357-1.842c-.144-.112-.144-.297 0-.41l2.357-1.84c.145-.113.205-.303.135-.423-.071-.119-.269-.162-.44-.094l-2.801 1.11c-.17.068-.331-.025-.357-.206l-.421-2.974c-.026-.181-.163-.329-.305-.329-.14 0-.277.148-.303.329l-.421 2.974c-.026.181-.186.274-.357.206l-2.756-1.091a.971.971 0 0 0-.62 0l-2.756 1.09c-.17.069-.331-.024-.357-.205l-.421-2.974C10.63 9.148 10.493 9 10.352 9s-.278.148-.303.329l-.422 2.974c-.026.181-.186.274-.357.206l-2.802-1.11c-.17-.067-.367-.025-.438.095-.07.12-.01.31.134.422l2.357 1.84c.144.114.144.298 0 .41l-2.357 1.841c-.145.113-.205.315-.134.448.07.134.268.188.438.12l2.777-1.109c.17-.068.33.025.353.206l.4 3c.025.18.184.328.354.328.17 0 .328-.148.352-.328l.402-3c.023-.181.183-.274.353-.206l2.731 1.09c.17.068.449.068.62 0l2.73-1.09c.17-.068.33.025.354.206l.401 3c.024.18.183.328.352.328.17 0 .329-.148.353-.328l.401-3c.024-.181.183-.274.353-.206l2.778 1.109c.17.068.367.014.438-.12.07-.133.01-.335-.134-.447ZM16.84 14.19l-2.075 1.588a.46.46 0 0 1-.529 0L12.16 14.19c-.145-.112-.146-.295-.002-.408l2.08-1.628a.448.448 0 0 1 .524 0l2.08 1.628c.144.113.143.296-.002.408Z" opacity=".8" /></symbol>',
  "arena"
);
ii(
  '<symbol fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10" id="arrow-right"><path d="M.334 5.583h7.099L4.175 8.841 5 9.666 9.667 5 5 .333l-.825.826 3.258 3.257h-7.1v1.167Z" fill="currentColor" /></symbol>',
  "arrow-right"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44" id="chevron-down"><path d="M28.323 19.702a1.202 1.202 0 0 0-.767-.198c-.277.021-.533.133-.712.31L22.4 24.258l-4.444-4.444a1.128 1.128 0 0 0-.712-.31 1.196 1.196 0 0 0-.767.2.84.84 0 0 0-.373.592.782.782 0 0 0 .24.64l5.25 5.25c.098.098.222.177.361.232a1.227 1.227 0 0 0 .89 0 1.05 1.05 0 0 0 .361-.232l5.25-5.25a.783.783 0 0 0 .24-.64.842.842 0 0 0-.373-.594Z" /></symbol>',
  "chevron-down"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 22" id="chrome"><path d="M11 .2c3.8 0 7.3 2 9.3 5.2h-9.4c-2.5.1-4.5 1.7-5.2 4l-3-5.3c2-2.5 5-3.9 8.3-3.9Zm0 14.6c-2.1 0-3.7-1.7-3.7-3.7C7.3 9 9 7.3 11 7.3c2.1 0 3.7 1.7 3.7 3.7.1 2.1-1.6 3.8-3.7 3.8Zm-1.8 6.9c-5.1-.9-9-5.4-9-10.7 0-1.9.5-3.7 1.4-5.3l4.3 7.4c.9 2.1 2.9 3.4 5.1 3.4.4 0 .9-.1 1.3-.2l-3.1 5.4Zm1.9.1 4.3-7.4c.8-1 1.2-2.2 1.2-3.4 0-1.5-.6-2.9-1.6-3.9h6.2c.5 1.2.7 2.6.7 3.9-.1 5.9-4.9 10.8-10.8 10.8Z" /></symbol>',
  "chrome"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 9" id="close"><path d="m9 8.5-8-8m8 0-8 8" /></symbol>',
  "close"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44" id="dark-mode"><path d="M29.6 23.7h-.2c-1.4 1.1-3 1.6-4.7 1.6-4.2 0-7.6-3.4-7.6-7.6 0-.9.1-1.7.4-2.5v-.1h-.2c-1.9 1.5-3 3.7-3 6.1 0 2.1.8 4.1 2.3 5.5 1.5 1.5 3.4 2.3 5.5 2.3 1.6 0 3.2-.5 4.6-1.5 1.3-.9 2.3-2.2 2.8-3.7.1 0 .1-.1.1-.1z" style="fill:#fff" /></symbol>',
  "dark-mode"
);
ii(
  '<symbol viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" id="drag-horizontal"><path d="M71.71 47H28.29v-9.62L7.79 50l20.5 12.62V53h43.42v9.62L92.21 50l-20.5-12.62V47z" data-name="Calque 4" /></symbol>',
  "drag-horizontal"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" id="drag"><path d="M14 8.167v-2.5L17.333 9 14 12.333v-2.5H9.833V14h2.5L9 17.333 5.667 14h2.5V9.833H4v2.5L.667 9 4 5.667v2.5h4.167V4h-2.5L9 .667 12.333 4h-2.5v4.167H14Z" /></symbol>',
  "drag"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 12" id="enter"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.5 0a.5.5 0 0 1 .5.5v4.8a2.5 2.5 0 0 1-2.5 2.5H1.709l3.347 3.346a.5.5 0 1 1-.708.708l-4.2-4.2a.5.5 0 0 1 0-.708l4-4a.5.5 0 0 1 .708.708L1.708 6.8H11.5A1.5 1.5 0 0 0 13 5.3V.5a.5.5 0 0 1 .5-.5Z" /></symbol>',
  "enter"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" id="instagram"><g opacity=".8"><path d="M14 10.359a3.62 3.62 0 0 0-3.613 3.613A3.602 3.602 0 0 0 14 17.585a3.62 3.62 0 0 0 3.613-3.613c0-1.976-1.637-3.613-3.613-3.613Zm0 5.927a2.325 2.325 0 0 1-2.314-2.314A2.325 2.325 0 0 1 14 11.657a2.325 2.325 0 0 1 2.315 2.315A2.325 2.325 0 0 1 14 16.286ZM17.754 11.093a.819.819 0 1 0 0-1.637.819.819 0 0 0 0 1.637Z" /><path d="M19.871 8.157C19.137 7.395 18.093 7 16.907 7h-5.814C8.637 7 7 8.637 7 11.093v5.786c0 1.214.395 2.258 1.185 3.02.763.734 1.779 1.101 2.936 1.101h5.758c1.214 0 2.23-.395 2.964-1.1.762-.735 1.157-1.779 1.157-2.993v-5.814c0-1.186-.395-2.202-1.129-2.936Zm-.113 8.75c0 .875-.31 1.58-.819 2.06-.508.48-1.213.735-2.06.735h-5.758c-.847 0-1.552-.254-2.06-.734-.509-.508-.763-1.214-.763-2.089v-5.786c0-.847.254-1.553.762-2.06.48-.48 1.214-.735 2.061-.735h5.815c.846 0 1.552.254 2.06.762.48.509.762 1.214.762 2.033v5.814Z" /></g></symbol>',
  "instagram"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15 18" id="ios"><path d="M12.368 9.573c.009-.69.194-1.367.539-1.967a4.11 4.11 0 0 1 1.43-1.465 4.219 4.219 0 0 0-1.454-1.282 4.27 4.27 0 0 0-1.881-.502c-1.404-.146-2.764.83-3.48.83-.729 0-1.83-.816-3.016-.791a4.479 4.479 0 0 0-2.17.64A4.416 4.416 0 0 0 .768 6.65C-.85 9.418.357 13.486 1.905 15.723 2.68 16.82 3.585 18.043 4.77 18c1.16-.047 1.593-.731 2.992-.731 1.386 0 1.793.731 3.002.703 1.244-.02 2.027-1.1 2.775-2.206a9.02 9.02 0 0 0 1.269-2.556 3.987 3.987 0 0 1-1.774-1.455 3.922 3.922 0 0 1-.666-2.181ZM10.073 2.885A3.998 3.998 0 0 0 11.004 0a4.159 4.159 0 0 0-2.68 1.372 3.793 3.793 0 0 0-.956 2.779 3.458 3.458 0 0 0 1.5-.326c.468-.219.88-.54 1.205-.94Z" /></symbol>',
  "ios"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44" id="light-mode"><path d="M31.1 21.6c-3.5 0-5.6 0-6.8-.5.5-1.2 2-2.7 4.5-5.2l.1-.1v-.4c0-.1-.1-.1-.1-.1l-.1-.1h-.4c-.1 0-.1.1-.1.1-2.5 2.5-4 4-5.2 4.5-.5-1.2-.5-3.4-.5-6.8 0-.1 0-.2-.1-.3-.1-.1-.2-.1-.3-.1s-.2 0-.3.1c-.1.1-.1.2-.1.3 0 3.5 0 5.6-.5 6.8-1.2-.5-2.7-2-5.2-4.5l-.1-.1h-.4c-.1 0-.1.1-.1.1l-.1.1v.4c0 .1.1.1.1.1 2.5 2.5 4 4 4.5 5.2-1.2.5-3.4.5-6.8.5h-.2c-.1 0-.1.1-.1.1l-.1.1v.4c0 .1.1.1.1.1l.1.1h.2c3.5 0 5.6 0 6.8.5-.5 1.2-2 2.7-4.5 5.2-.1.1-.1.2-.1.3 0 .1 0 .2.1.3.1.1.2.1.3.1.1 0 .2 0 .3-.1 2.5-2.5 4-4 5.2-4.5.5 1.2.5 3.4.5 6.8 0 .1 0 .2.1.3.1.1.2.1.3.1s.2 0 .3-.1c.1-.1.1-.2.1-.3 0-3.5 0-5.6.5-6.8 1.2.5 2.7 2 5.2 4.5l.1.1h.4c.1 0 .1-.1.1-.1l.1-.1v-.4c0-.1-.1-.1-.1-.1-2.5-2.5-4-4-4.5-5.2 1.2-.5 3.4-.5 6.8-.5.1 0 .2 0 .3-.1.1-.1.1-.2.1-.3s0-.2-.1-.3c-.1-.1-.2-.1-.3-.1z" /></symbol>',
  "light-mode"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 22" id="logomark"><path d="M11 4.6c1.2 0 2.3-1 2.3-2.3C13.3 1 12.2 0 11 0 9.8 0 8.7 1 8.7 2.3c0 1.3 1.1 2.3 2.3 2.3zM11 22c1.2 0 2.3-1 2.3-2.3 0-1.3-1-2.3-2.3-2.3-1.2 0-2.3 1-2.3 2.3C8.7 21 9.8 22 11 22zM3.6 8.9c1.2 0 2.3-1 2.3-2.3 0-1.3-1-2.3-2.3-2.3-1.2 0-2.3 1-2.3 2.3.1 1.3 1.1 2.3 2.3 2.3zM18.4 17.6c1.2 0 2.3-1 2.3-2.3s-1-2.3-2.3-2.3c-1.2 0-2.3 1-2.3 2.3s1 2.3 2.3 2.3zM18.4 8.9c1.2 0 2.3-1 2.3-2.3 0-1.3-1-2.3-2.3-2.3-1.2 0-2.3 1-2.3 2.3 0 1.3 1 2.3 2.3 2.3zM3.6 17.6c1.2 0 2.3-1 2.3-2.3S4.9 13 3.6 13c-1.2 0-2.3 1-2.3 2.3s1.1 2.3 2.3 2.3z" /></symbol>',
  "logomark"
);
ii(
  '<symbol fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 12" id="menu-close"><path d="M10.839 0 12 1.161 7.161 6 12 10.839 10.839 12 6 7.161 1.161 12l-1.16-1.161L4.838 6 0 1.161 1.161 0 6 4.839 10.839 0Z" fill="currentColor" /></symbol>',
  "menu-close"
);
ii(
  '<symbol fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 8" id="menu"><path stroke="#E9E8E3" stroke-width="2" stroke-linecap="round" d="M1 1h14M1 7h14" /></symbol>',
  "menu"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" id="pinterest"><path d="M14.568 6C10.202 6 8 9.13 8 11.741c0 1.581.598 2.987 1.882 3.51.21.087.399.004.46-.23.042-.16.143-.567.188-.737.061-.23.037-.31-.133-.512-.37-.436-.607-1.001-.607-1.802 0-2.322 1.738-4.402 4.525-4.402 2.468 0 3.824 1.508 3.824 3.522 0 2.65-1.172 4.887-2.913 4.887-.962 0-1.681-.795-1.45-1.77.275-1.165.81-2.42.81-3.262 0-.752-.404-1.38-1.239-1.38-.983 0-1.772 1.017-1.772 2.38 0 .867.293 1.454.293 1.454l-1.182 5.008c-.351 1.486-.053 3.308-.028 3.491.015.11.155.136.219.054.09-.119 1.261-1.564 1.659-3.008.113-.409.646-2.526.646-2.526.32.61 1.253 1.145 2.245 1.145 2.954 0 4.959-2.693 4.959-6.298C20.386 8.54 18.077 6 14.568 6Z" opacity=".8" /></symbol>',
  "pinterest"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" id="plus"><path fill-rule="evenodd" clip-rule="evenodd" d="M23.143 16h1.714v7.143H32v1.714h-7.143V32h-1.714v-7.143H16v-1.714h7.143V16Z" /></symbol>',
  "plus"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="safari"><path d="m12.876 12.876-1.752-1.752-3.343 5.095 5.095-3.343ZM12 .375C5.578.375.375 5.578.375 12S5.578 23.625 12 23.625 23.625 18.422 23.625 12 18.422.375 12 .375Zm7.305 8.193.693-.287a.375.375 0 0 1 .287.694l-.691.286a.375.375 0 0 1-.289-.693ZM14.74 4.406l.287-.693a.375.375 0 0 1 .693.289l-.288.693a.375.375 0 1 1-.692-.289ZM12 2.813a.375.375 0 0 1 .375.374v.75a.375.375 0 1 1-.75 0v-.75A.375.375 0 0 1 12 2.813Zm-3.516.699a.375.375 0 0 1 .49.203l.287.691a.375.375 0 1 1-.693.287L8.281 4a.375.375 0 0 1 .203-.488Zm-2.98 1.992a.375.375 0 0 1 .53 0l.529.53a.375.375 0 0 1-.53.529l-.53-.53a.375.375 0 0 1 0-.53h.001ZM2.813 12a.375.375 0 0 1 .374-.375h.75a.375.375 0 1 1 0 .75h-.75A.375.375 0 0 1 2.813 12Zm1.882 3.432-.693.287a.376.376 0 0 1-.287-.694l.691-.286a.375.375 0 0 1 .289.693Zm.202-6.375a.375.375 0 0 1-.49.204l-.694-.287a.375.375 0 0 1 .289-.693l.693.288a.375.375 0 0 1 .202.49v-.002Zm4.364 10.537-.287.693A.376.376 0 0 1 8.281 20l.287-.693a.375.375 0 1 1 .693.287Zm3.114 1.218a.375.375 0 0 1-.75 0v-.75a.375.375 0 0 1 .75 0v.75Zm3.14-.324a.374.374 0 0 1-.49-.203l-.286-.691a.375.375 0 0 1 .693-.287l.287.693a.375.375 0 0 1-.203.488Zm2.98-1.992a.375.375 0 0 1-.53 0l-.527-.53a.375.375 0 0 1 .53-.529l.53.53a.375.375 0 0 1-.002.53Zm-5.077-5.078-8.246 5.41 5.41-8.246 8.246-5.41-5.41 8.246Zm7.07 2.098a.374.374 0 0 1-.49.203l-.693-.288a.375.375 0 1 1 .289-.692l.693.287a.375.375 0 0 1 .201.49Zm.325-3.141h-.75a.375.375 0 0 1 0-.75h.75a.375.375 0 0 1 0 .75Z" /></symbol>',
  "safari"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14" id="search"><path d="m13.298 12.248-3.236-3.236a5.17 5.17 0 0 0 1.04-3.11 5.2 5.2 0 1 0-5.2 5.2 5.17 5.17 0 0 0 3.11-1.04l3.236 3.236 1.05-1.05ZM2.188 5.902a3.719 3.719 0 0 1 3.714-3.715 3.719 3.719 0 0 1 3.714 3.715 3.719 3.719 0 0 1-3.714 3.714 3.719 3.719 0 0 1-3.715-3.714Z" /></symbol>',
  "search"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15 12" id="tick"><path d="M14.707.143a.497.497 0 0 0-.699 0L4.782 10.524.875 7.395a.51.51 0 1 0-.632.792l4.338 3.425a.51.51 0 0 0 .698 0L14.76.869a.51.51 0 0 0-.053-.726Z" /></symbol>',
  "tick"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" id="twitter"><path d="M21.186 9.42a5.745 5.745 0 0 1-1.693.477 3.022 3.022 0 0 0 1.296-1.676c-.57.348-1.2.6-1.872.736A2.909 2.909 0 0 0 16.765 8c-1.629 0-2.949 1.356-2.949 3.03 0 .237.026.468.076.69-2.45-.127-4.623-1.333-6.078-3.165-.254.447-.399.967-.399 1.523 0 1.05.52 1.978 1.312 2.521a2.881 2.881 0 0 1-1.336-.379v.038c0 1.468 1.016 2.692 2.365 2.971a2.892 2.892 0 0 1-1.331.052c.375 1.203 1.464 2.08 2.754 2.103a5.817 5.817 0 0 1-4.366 1.255A8.184 8.184 0 0 0 11.333 20c5.425 0 8.39-4.616 8.39-8.62 0-.13-.002-.262-.008-.392a6.066 6.066 0 0 0 1.471-1.568Z" /></symbol>',
  "twitter"
);
ii(
  '<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1263.3 159.6" id="unseen-logo"><style>#unseen-logo .st0{fill:#fff}</style><path class="st0" d="M1233.6 45c0-8.7 6.5-15.1 14.8-15.1s14.8 6.4 14.8 15.1-6.5 15.1-14.8 15.1-14.8-6.4-14.8-15.1zm27.3 0c0-7.5-5.3-13-12.5-13s-12.5 5.5-12.5 13 5.3 13 12.5 13 12.5-5.5 12.5-13zm-18.3-8h7.4c3 0 5 1.8 5 4.4 0 1.9-.9 3.3-3 3.9v.1c1.6.5 2.2 1.4 2.4 3.5.2 2.4.3 3.7.7 3.9v.2h-2.7c-.4-.2-.5-1.6-.6-3.7-.1-2-1.1-2.9-3.2-2.9h-3.4V53h-2.7l.1-16zm2.8 7.3h4c1.9 0 2.9-1 2.9-2.5 0-1.6-.9-2.5-2.9-2.5h-4.1v5zM87.7 53v103.5H69.1v-16.8C50.7 168.3 0 168 0 117.8V53h18.6v64.8c0 41 50.5 30.6 50.5-1.5V53h18.6zM192.2 91.7v64.8h-18.6V91.7c0-41-51.1-30.6-51.1 1.5v63.3h-18.6V53h18.6v16.1c19.3-27.9 69.7-27.3 69.7 22.6zM203.2 124.2h18.6c0 11.8 11.4 18.4 24.8 18.4 13.9 0 24.8-6.4 24.8-18.4 0-23.8-67-1.9-67-43.2 0-18.6 18.6-29.6 40.3-29.6 21.9 0 39.9 10.3 39.9 29.6h-17.2c0-10.1-10.1-15.3-22.8-15.3S222 71 222 80.9c0 23.8 68.1.6 68.1 43.2 0 20.3-18.6 34.1-43.5 34.1-24.8.1-43.4-11.9-43.4-34zM348.7 143c19.5 0 29.8-11 33.7-20.3l14.3 6.8c-6 12.8-21.1 28.3-48 28.3-29.6 0-50.7-21.9-50.7-53.6 0-31 21.1-53 50.7-53 29.4 0 53.8 22.1 49.7 61.2H316c2.7 17.6 14.1 30.6 32.7 30.6zm33.5-46.4c-2.7-19.2-16.6-30.4-33.5-30.4-18.8 0-30.2 13-32.7 30.4h66.2zM459.4 143c19.4 0 29.8-11 33.7-20.3l14.3 6.8c-6 12.8-21.1 28.3-48 28.3-29.6 0-50.7-21.9-50.7-53.6 0-31 21.1-53 50.7-53 29.4 0 53.8 22.1 49.7 61.2h-82.4c2.7 17.6 14.1 30.6 32.7 30.6zm33.5-46.4c-2.7-19.2-16.6-30.4-33.5-30.4-18.8 0-30.2 13-32.7 30.4h66.2zM609.8 91.7v64.8h-18.6V91.7c0-41-51.1-30.6-51.1 1.5v63.3h-18.6V53h18.6v16.1c19.2-27.9 69.7-27.3 69.7 22.6zM726.6 136c-.8-23.2-74.1-21.9-76.6-53.2-2.9-31.5 36.4-41.2 82.2-25v31H731c-2.5-17.2-14.9-38.7-49.7-35.2-8.1 1-23.2 3.5-21.7 17 2.1 26.9 75.7 19.7 78 53.2.8 12-6.4 21.9-9.7 25-16.1 14.7-44.5 10.8-74.5 6.6l-.4-42.2 1.2.4c0 52.8 72.4 53.2 72.4 22.4zM760.3 130.2V65h-13.4l30.2-37v25h42.8l-10.3 12h-32.5l-.6 71.2c-.2 25.2 35 21.9 55.5-10.3h1.9c-25.1 45.7-73.6 39-73.6 4.3zM842.5 117.3l-.2-64.3h17.2v60.6c0 38.3 38.3 57.3 63.4 15.7v-4.5l.4-71.8H940v72c0 20.9 4.6 30 12.4 31.7-24.2 0-28.8-9.5-29.6-23.8-26.3 45.3-80.1 26-80.3-15.6zM1047 59.2l.6-44.1L1063.7 0v125c0 19.9 4.6 29.8 12.4 31.5-20.7 0-28.3-8.3-29.6-18.2-8.3 11.6-21.7 20.5-41.6 20.5-35.8 0-54.2-39.5-44.3-67.9 7.9-22.8 39-58 86.4-31.7zm-28.8 90.6c12.8 0 21.3-6 28.1-15.3v-1.7l.7-54.8c-17.2-19.5-48-30.8-65.8-8.1-20.1 22.8-4.2 79.9 37 79.9zM1098.5 11.4c6 0 11 5 11 11s-5 10.8-11 10.8-10.8-4.8-10.8-10.8 4.8-11 10.8-11zm8.9 145.1h-18.6l.8-12.4V53h17v91l.8 12.5zM1238.6 106c-.4 29.8-28.3 53.6-57.7 53.6-29 0-56.3-23.8-55.7-53.6.2-29.4 28.6-55 57.7-55 29.2-.1 56.1 25.6 55.7 55zm-19 0c-.8-36.2-21.3-51.7-41.4-51.7-20.3 0-37.2 18-34.6 51.7 2.3 31.7 21.3 49.5 41.4 49.5 20.5-.1 34.8-15.8 34.6-49.5z" /></symbol>',
  "unseen-logo"
);
ii(
  '<symbol fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" id="verified"><path d="M10.85 1.212a1.07 1.07 0 0 1 1.623.435l.35.813a1.07 1.07 0 0 0 1.11.642l.88-.107A1.07 1.07 0 0 1 16 4.184l-.107.88a1.071 1.071 0 0 0 .642 1.108l.813.35a1.071 1.071 0 0 1 .435 1.624l-.535.71a1.07 1.07 0 0 0 0 1.285l.535.71a1.071 1.071 0 0 1-.435 1.623l-.813.35a1.07 1.07 0 0 0-.642 1.11l.107.88a1.071 1.071 0 0 1-1.189 1.188l-.88-.108a1.07 1.07 0 0 0-1.109.643l-.35.813a1.071 1.071 0 0 1-1.623.435l-.71-.535a1.07 1.07 0 0 0-1.285 0l-.71.535a1.07 1.07 0 0 1-1.623-.435l-.35-.813a1.07 1.07 0 0 0-1.11-.643l-.88.107a1.07 1.07 0 0 1-1.187-1.188l.107-.88a1.07 1.07 0 0 0-.643-1.109l-.813-.35a1.07 1.07 0 0 1-.434-1.625l.535-.71a1.07 1.07 0 0 0 0-1.284l-.535-.71a1.07 1.07 0 0 1 .435-1.624l.813-.35a1.07 1.07 0 0 0 .643-1.109l-.107-.88a1.07 1.07 0 0 1 1.188-1.188l.88.107a1.07 1.07 0 0 0 1.109-.642l.35-.814a1.07 1.07 0 0 1 1.627-.433l.71.535a1.07 1.07 0 0 0 1.284 0l.706-.535Z" fill="#2F3031" /><path d="M8.4 12.63 5.374 9.706l.915-.947L8.4 10.802l4.251-4.106.915.947L8.4 12.63Z" fill="#EAE9E8" /></symbol>',
  "verified"
);
ii(
  '<symbol viewBox="0 0 120 20" xmlns="http://www.w3.org/2000/svg" id="wordmark"><path d="M36.295 10.026c0 6.235-3.975 9.974-9.17 9.974-5.194 0-9.17-3.74-9.17-9.974S21.932.053 27.126.053c5.195 0 9.17 3.742 9.17 9.973Zm-9.03 7.485c3.554 0 6.3-2.771 6.3-7.482 0-4.71-2.746-7.478-6.3-7.478h-.262c-3.553 0-6.3 2.771-6.3 7.478 0 4.708 2.732 7.482 6.3 7.482h.262ZM95.442 10.026c0 6.235-3.975 9.974-9.17 9.974s-9.17-3.74-9.17-9.974S81.077.053 86.272.053c5.194 0 9.17 3.742 9.17 9.973Zm-9.034 7.485c3.554 0 6.301-2.771 6.301-7.482 0-4.71-2.744-7.478-6.3-7.478h-.274c-3.554 0-6.3 2.771-6.3 7.478 0 4.708 2.746 7.482 6.3 7.482h.273ZM16.972 13.627C16.704 17.867 12.965 20 9.17 20 3.975 20 0 16.26 0 10.026S3.975.053 9.17.053c4.102 0 7.511 2.271 7.802 6.372h-2.744c-.1-2.106-2.108-3.88-4.936-3.88h-.273c-3.554 0-6.301 2.771-6.301 7.481s2.758 7.485 6.315 7.485h.273c2.245 0 4.75-1.22 4.936-3.878l2.73-.005ZM45.125 2.548h-.273c-2.378 0-3.963 1.303-3.963 3.018 0 1.498 1.01 2.383 2.613 2.716l3.06.609c3.31.665 5.227 2.439 5.227 5.59 0 3.407-2.843 5.513-7.082 5.513-4.51 0-7.381-2.215-7.518-6.51h2.736c0 2.632 2.032 4.018 4.892 4.018h.273c2.57 0 3.963-1.303 3.963-2.91 0-1.606-.984-2.491-3.005-2.91l-3.063-.635c-3.06-.638-4.837-2.383-4.837-5.457 0-3.075 2.706-5.54 6.832-5.54 4.239 0 6.945 2.354 7.082 6.093h-2.735c-.128-2.21-1.876-3.595-4.202-3.595ZM57.16 2.768v16.956h-2.735V.332h4.539l5.714 16.788L70.282.332h4.512v19.392h-2.732V2.686l-5.633 17.038h-3.502L57.16 2.768ZM104.193 2.548h-.273c-2.378 0-3.963 1.303-3.963 3.018 0 1.498 1.01 2.383 2.613 2.716l3.06.609c3.31.665 5.227 2.439 5.227 5.59 0 3.407-2.843 5.513-7.082 5.513-4.512 0-7.381-2.215-7.518-6.51h2.756c0 2.632 2.032 4.018 4.895 4.018h.273c2.57 0 3.964-1.303 3.964-2.91 0-1.606-.985-2.491-3.006-2.91l-3.063-.635c-3.063-.638-4.84-2.383-4.84-5.457 0-3.075 2.706-5.54 6.835-5.54 4.239 0 6.945 2.354 7.082 6.093h-2.735c-.151-2.21-1.899-3.595-4.225-3.595ZM116.005 6.167a3.012 3.012 0 0 0 1.688-.527c.5-.34.888-.823 1.116-1.388a3.12 3.12 0 0 0-.672-3.357 3.035 3.035 0 0 0-1.562-.838 3.005 3.005 0 0 0-1.757.182 3.05 3.05 0 0 0-1.361 1.141 3.111 3.111 0 0 0-.507 1.715c.006.817.33 1.599.902 2.174a3.032 3.032 0 0 0 2.153.898Zm0-.568a2.457 2.457 0 0 1-1.386-.415 2.504 2.504 0 0 1-.923-1.127 2.547 2.547 0 0 1-.148-1.456c.094-.49.33-.94.678-1.293a2.452 2.452 0 0 1 2.712-.547c.454.191.843.516 1.115.931.272.416.416.904.414 1.403.002.664-.256 1.3-.717 1.772a2.46 2.46 0 0 1-1.742.743l-.003-.011Zm.032-.998c.781 0 1.208-.385 1.248-1.059h-.601a.568.568 0 0 1-.201.382.556.556 0 0 1-.409.127h-.069c-.508 0-.741-.456-.741-1.012s.233-1.012.741-1.012h.064a.577.577 0 0 1 .407.131c.114.095.189.23.208.378h.601c-.04-.674-.467-1.06-1.248-1.06-.781 0-1.382.536-1.382 1.563s.563 1.562 1.382 1.562Z" /></symbol>',
  "wordmark"
);
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const vm = "148",
  wa = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  ya = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  N1 = 0,
  s0 = 1,
  B1 = 2,
  K_ = 1,
  V1 = 2,
  gc = 3,
  Bs = 0,
  Bn = 1,
  ru = 2,
  zu = 3,
  dr = 0,
  Oo = 1,
  bf = 2,
  xf = 3,
  wf = 4,
  Z_ = 5,
  Ga = 100,
  z1 = 101,
  U1 = 102,
  r0 = 103,
  o0 = 104,
  G1 = 200,
  H1 = 201,
  W1 = 202,
  j1 = 203,
  J_ = 204,
  Q_ = 205,
  q1 = 206,
  X1 = 207,
  $1 = 208,
  Y1 = 209,
  K1 = 210,
  Z1 = 0,
  J1 = 1,
  Q1 = 2,
  yf = 3,
  eS = 4,
  tS = 5,
  iS = 6,
  nS = 7,
  eb = 0,
  sS = 1,
  rS = 2,
  pr = 0,
  oS = 1,
  aS = 2,
  lS = 3,
  cS = 4,
  uS = 5,
  tb = 300,
  al = 301,
  ll = 302,
  Sf = 303,
  Mf = 304,
  ld = 306,
  Zr = 1e3,
  bn = 1001,
  Wh = 1002,
  Ai = 1003,
  Tf = 1004,
  Ah = 1005,
  Ui = 1006,
  ib = 1007,
  mr = 1008,
  Ko = 1009,
  hS = 1010,
  dS = 1011,
  nb = 1012,
  pS = 1013,
  Ro = 1014,
  Gr = 1015,
  Vc = 1016,
  fS = 1017,
  mS = 1018,
  el = 1020,
  gS = 1021,
  vS = 1022,
  es = 1023,
  _S = 1024,
  bS = 1025,
  No = 1026,
  cl = 1027,
  xS = 1028,
  wS = 1029,
  yS = 1030,
  SS = 1031,
  MS = 1033,
  up = 33776,
  hp = 33777,
  dp = 33778,
  pp = 33779,
  a0 = 35840,
  l0 = 35841,
  c0 = 35842,
  u0 = 35843,
  TS = 36196,
  h0 = 37492,
  d0 = 37496,
  p0 = 37808,
  f0 = 37809,
  m0 = 37810,
  g0 = 37811,
  v0 = 37812,
  _0 = 37813,
  b0 = 37814,
  x0 = 37815,
  w0 = 37816,
  y0 = 37817,
  S0 = 37818,
  M0 = 37819,
  T0 = 37820,
  E0 = 37821,
  C0 = 36492,
  zc = 2300,
  ul = 2301,
  fp = 2302,
  D0 = 2400,
  P0 = 2401,
  A0 = 2402,
  ES = 2500,
  CS = 1,
  sb = 2,
  gr = 3e3,
  Ht = 3001,
  DS = 3200,
  PS = 3201,
  rb = 0,
  AS = 1,
  Ds = "srgb",
  Uc = "srgb-linear",
  mp = 7680,
  LS = 519,
  Ef = 35044,
  L0 = "300 es",
  Cf = 1035;
class ra {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const s = n.indexOf(t);
      s !== -1 && n.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const n = i.slice(0);
      for (let s = 0, a = n.length; s < a; s++) n[s].call(this, e);
      e.target = null;
    }
  }
}
const Bi = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let R0 = 1234567;
const Sc = Math.PI / 180,
  Gc = 180 / Math.PI;
function bs() {
  const r = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0;
  return (
    Bi[r & 255] +
    Bi[(r >> 8) & 255] +
    Bi[(r >> 16) & 255] +
    Bi[(r >> 24) & 255] +
    "-" +
    Bi[e & 255] +
    Bi[(e >> 8) & 255] +
    "-" +
    Bi[((e >> 16) & 15) | 64] +
    Bi[(e >> 24) & 255] +
    "-" +
    Bi[(t & 63) | 128] +
    Bi[(t >> 8) & 255] +
    "-" +
    Bi[(t >> 16) & 255] +
    Bi[(t >> 24) & 255] +
    Bi[i & 255] +
    Bi[(i >> 8) & 255] +
    Bi[(i >> 16) & 255] +
    Bi[(i >> 24) & 255]
  ).toLowerCase();
}
function Li(r, e, t) {
  return Math.max(e, Math.min(t, r));
}
function _m(r, e) {
  return ((r % e) + e) % e;
}
function RS(r, e, t, i, n) {
  return i + ((r - e) * (n - i)) / (t - e);
}
function kS(r, e, t) {
  return r !== e ? (t - r) / (e - r) : 0;
}
function Mc(r, e, t) {
  return (1 - t) * r + t * e;
}
function IS(r, e, t, i) {
  return Mc(r, e, 1 - Math.exp(-t * i));
}
function FS(r, e = 1) {
  return e - Math.abs(_m(r, e * 2) - e);
}
function OS(r, e, t) {
  return r <= e
    ? 0
    : r >= t
    ? 1
    : ((r = (r - e) / (t - e)), r * r * (3 - 2 * r));
}
function NS(r, e, t) {
  return r <= e
    ? 0
    : r >= t
    ? 1
    : ((r = (r - e) / (t - e)), r * r * r * (r * (r * 6 - 15) + 10));
}
function BS(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function VS(r, e) {
  return r + Math.random() * (e - r);
}
function zS(r) {
  return r * (0.5 - Math.random());
}
function US(r) {
  r !== void 0 && (R0 = r);
  let e = (R0 += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function GS(r) {
  return r * Sc;
}
function HS(r) {
  return r * Gc;
}
function Df(r) {
  return (r & (r - 1)) === 0 && r !== 0;
}
function ob(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function jh(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function WS(r, e, t, i, n) {
  const s = Math.cos,
    a = Math.sin,
    o = s(t / 2),
    u = a(t / 2),
    h = s((e + i) / 2),
    f = a((e + i) / 2),
    c = s((e - i) / 2),
    d = a((e - i) / 2),
    m = s((i - e) / 2),
    x = a((i - e) / 2);
  switch (n) {
    case "XYX":
      r.set(o * f, u * c, u * d, o * h);
      break;
    case "YZY":
      r.set(u * d, o * f, u * c, o * h);
      break;
    case "ZXZ":
      r.set(u * c, u * d, o * f, o * h);
      break;
    case "XZX":
      r.set(o * f, u * x, u * m, o * h);
      break;
    case "YXY":
      r.set(u * m, o * f, u * x, o * h);
      break;
    case "ZYZ":
      r.set(u * x, u * m, o * f, o * h);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          n
      );
  }
}
function lr(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function $t(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var Bo = Object.freeze({
  __proto__: null,
  DEG2RAD: Sc,
  RAD2DEG: Gc,
  generateUUID: bs,
  clamp: Li,
  euclideanModulo: _m,
  mapLinear: RS,
  inverseLerp: kS,
  lerp: Mc,
  damp: IS,
  pingpong: FS,
  smoothstep: OS,
  smootherstep: NS,
  randInt: BS,
  randFloat: VS,
  randFloatSpread: zS,
  seededRandom: US,
  degToRad: GS,
  radToDeg: HS,
  isPowerOfTwo: Df,
  ceilPowerOfTwo: ob,
  floorPowerOfTwo: jh,
  setQuaternionFromProperEuler: WS,
  normalize: $t,
  denormalize: lr,
});
class Ue {
  constructor(e = 0, t = 0) {
    (Ue.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      n = e.elements;
    return (
      (this.x = n[0] * t + n[3] * i + n[6]),
      (this.y = n[1] * t + n[4] * i + n[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      n = Math.sin(t),
      s = this.x - e.x,
      a = this.y - e.y;
    return (this.x = s * i - a * n + e.x), (this.y = s * n + a * i + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Nn {
  constructor() {
    (Nn.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
  }
  set(e, t, i, n, s, a, o, u, h) {
    const f = this.elements;
    return (
      (f[0] = e),
      (f[1] = n),
      (f[2] = o),
      (f[3] = t),
      (f[4] = s),
      (f[5] = u),
      (f[6] = i),
      (f[7] = a),
      (f[8] = h),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      n = t.elements,
      s = this.elements,
      a = i[0],
      o = i[3],
      u = i[6],
      h = i[1],
      f = i[4],
      c = i[7],
      d = i[2],
      m = i[5],
      x = i[8],
      v = n[0],
      b = n[3],
      y = n[6],
      M = n[1],
      D = n[4],
      C = n[7],
      A = n[2],
      I = n[5],
      F = n[8];
    return (
      (s[0] = a * v + o * M + u * A),
      (s[3] = a * b + o * D + u * I),
      (s[6] = a * y + o * C + u * F),
      (s[1] = h * v + f * M + c * A),
      (s[4] = h * b + f * D + c * I),
      (s[7] = h * y + f * C + c * F),
      (s[2] = d * v + m * M + x * A),
      (s[5] = d * b + m * D + x * I),
      (s[8] = d * y + m * C + x * F),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      n = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      u = e[6],
      h = e[7],
      f = e[8];
    return (
      t * a * f - t * o * h - i * s * f + i * o * u + n * s * h - n * a * u
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      n = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      u = e[6],
      h = e[7],
      f = e[8],
      c = f * a - o * h,
      d = o * u - f * s,
      m = h * s - a * u,
      x = t * c + i * d + n * m;
    if (x === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const v = 1 / x;
    return (
      (e[0] = c * v),
      (e[1] = (n * h - f * i) * v),
      (e[2] = (o * i - n * a) * v),
      (e[3] = d * v),
      (e[4] = (f * t - n * u) * v),
      (e[5] = (n * s - o * t) * v),
      (e[6] = m * v),
      (e[7] = (i * u - h * t) * v),
      (e[8] = (a * t - i * s) * v),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, i, n, s, a, o) {
    const u = Math.cos(s),
      h = Math.sin(s);
    return (
      this.set(
        i * u,
        i * h,
        -i * (u * a + h * o) + a + e,
        -n * h,
        n * u,
        -n * (-h * a + u * o) + o + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(gp.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(gp.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(gp.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
  }
  makeRotation(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let n = 0; n < 9; n++) if (t[n] !== i[n]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const gp = new Nn();
function ab(r) {
  for (let e = r.length - 1; e >= 0; --e) if (r[e] >= 65535) return !0;
  return !1;
}
function Hc(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function Vo(r) {
  return r < 0.04045
    ? r * 0.0773993808
    : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Lh(r) {
  return r < 0.0031308 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
const vp = { [Ds]: { [Uc]: Vo }, [Uc]: { [Ds]: Lh } },
  Ki = {
    legacyMode: !0,
    get workingColorSpace() {
      return Uc;
    },
    set workingColorSpace(r) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function (r, e, t) {
      if (this.legacyMode || e === t || !e || !t) return r;
      if (vp[e] && vp[e][t] !== void 0) {
        const i = vp[e][t];
        return (r.r = i(r.r)), (r.g = i(r.g)), (r.b = i(r.b)), r;
      }
      throw new Error("Unsupported color space conversion.");
    },
    fromWorkingColorSpace: function (r, e) {
      return this.convert(r, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function (r, e) {
      return this.convert(r, e, this.workingColorSpace);
    },
  },
  lb = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  wi = { r: 0, g: 0, b: 0 },
  ds = { h: 0, s: 0, l: 0 },
  Uu = { h: 0, s: 0, l: 0 };
function _p(r, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? r + (e - r) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? r + (e - r) * 6 * (2 / 3 - t)
      : r
  );
}
function Gu(r, e) {
  return (e.r = r.r), (e.g = r.g), (e.b = r.b), e;
}
class ct {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i)
    );
  }
  set(e) {
    return (
      e && e.isColor
        ? this.copy(e)
        : typeof e == "number"
        ? this.setHex(e)
        : typeof e == "string" && this.setStyle(e),
      this
    );
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = Ds) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Ki.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, i, n = Ki.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      Ki.toWorkingColorSpace(this, n),
      this
    );
  }
  setHSL(e, t, i, n = Ki.workingColorSpace) {
    if (((e = _m(e, 1)), (t = Li(t, 0, 1)), (i = Li(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        a = 2 * i - s;
      (this.r = _p(a, s, e + 1 / 3)),
        (this.g = _p(a, s, e)),
        (this.b = _p(a, s, e - 1 / 3));
    }
    return Ki.toWorkingColorSpace(this, n), this;
  }
  setStyle(e, t = Ds) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let n;
    if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
      let s;
      const a = n[1],
        o = n[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              (this.r = Math.min(255, parseInt(s[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(s[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(s[3], 10)) / 255),
              Ki.toWorkingColorSpace(this, t),
              i(s[4]),
              this
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              (this.r = Math.min(100, parseInt(s[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(s[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(s[3], 10)) / 100),
              Ki.toWorkingColorSpace(this, t),
              i(s[4]),
              this
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          ) {
            const u = parseFloat(s[1]) / 360,
              h = parseFloat(s[2]) / 100,
              f = parseFloat(s[3]) / 100;
            return i(s[4]), this.setHSL(u, h, f, t);
          }
          break;
      }
    } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = n[1],
        a = s.length;
      if (a === 3)
        return (
          (this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255),
          (this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255),
          (this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255),
          Ki.toWorkingColorSpace(this, t),
          this
        );
      if (a === 6)
        return (
          (this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255),
          (this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255),
          (this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255),
          Ki.toWorkingColorSpace(this, t),
          this
        );
    }
    return e && e.length > 0 ? this.setColorName(e, t) : this;
  }
  setColorName(e, t = Ds) {
    const i = lb[e.toLowerCase()];
    return (
      i !== void 0
        ? this.setHex(i, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Vo(e.r)), (this.g = Vo(e.g)), (this.b = Vo(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = Lh(e.r)), (this.g = Lh(e.g)), (this.b = Lh(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Ds) {
    return (
      Ki.fromWorkingColorSpace(Gu(this, wi), e),
      (Li(wi.r * 255, 0, 255) << 16) ^
        (Li(wi.g * 255, 0, 255) << 8) ^
        (Li(wi.b * 255, 0, 255) << 0)
    );
  }
  getHexString(e = Ds) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Ki.workingColorSpace) {
    Ki.fromWorkingColorSpace(Gu(this, wi), t);
    const i = wi.r,
      n = wi.g,
      s = wi.b,
      a = Math.max(i, n, s),
      o = Math.min(i, n, s);
    let u, h;
    const f = (o + a) / 2;
    if (o === a) (u = 0), (h = 0);
    else {
      const c = a - o;
      switch (((h = f <= 0.5 ? c / (a + o) : c / (2 - a - o)), a)) {
        case i:
          u = (n - s) / c + (n < s ? 6 : 0);
          break;
        case n:
          u = (s - i) / c + 2;
          break;
        case s:
          u = (i - n) / c + 4;
          break;
      }
      u /= 6;
    }
    return (e.h = u), (e.s = h), (e.l = f), e;
  }
  getRGB(e, t = Ki.workingColorSpace) {
    return (
      Ki.fromWorkingColorSpace(Gu(this, wi), t),
      (e.r = wi.r),
      (e.g = wi.g),
      (e.b = wi.b),
      e
    );
  }
  getStyle(e = Ds) {
    return (
      Ki.fromWorkingColorSpace(Gu(this, wi), e),
      e !== Ds
        ? `color(${e} ${wi.r} ${wi.g} ${wi.b})`
        : `rgb(${(wi.r * 255) | 0},${(wi.g * 255) | 0},${(wi.b * 255) | 0})`
    );
  }
  offsetHSL(e, t, i) {
    return (
      this.getHSL(ds),
      (ds.h += e),
      (ds.s += t),
      (ds.l += i),
      this.setHSL(ds.h, ds.s, ds.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(ds), e.getHSL(Uu);
    const i = Mc(ds.h, Uu.h, t),
      n = Mc(ds.s, Uu.s, t),
      s = Mc(ds.l, Uu.l, t);
    return this.setHSL(i, n, s), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
ct.NAMES = lb;
let Sa;
class cb {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      Sa === void 0 && (Sa = Hc("canvas")),
        (Sa.width = e.width),
        (Sa.height = e.height);
      const i = Sa.getContext("2d");
      e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (t = Sa);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = Hc("canvas");
      (t.width = e.width), (t.height = e.height);
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const n = i.getImageData(0, 0, e.width, e.height),
        s = n.data;
      for (let a = 0; a < s.length; a++) s[a] = Vo(s[a] / 255) * 255;
      return i.putImageData(n, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[i] = Math.floor(Vo(t[i] / 255) * 255))
          : (t[i] = Vo(t[i]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
class ub {
  constructor(e = null) {
    (this.isSource = !0),
      (this.uuid = bs()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" },
      n = this.data;
    if (n !== null) {
      let s;
      if (Array.isArray(n)) {
        s = [];
        for (let a = 0, o = n.length; a < o; a++)
          n[a].isDataTexture ? s.push(bp(n[a].image)) : s.push(bp(n[a]));
      } else s = bp(n);
      i.url = s;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function bp(r) {
  return (typeof HTMLImageElement < "u" && r instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && r instanceof ImageBitmap)
    ? cb.getDataURL(r)
    : r.data
    ? {
        data: Array.from(r.data),
        width: r.width,
        height: r.height,
        type: r.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let jS = 0;
class xi extends ra {
  constructor(
    e = xi.DEFAULT_IMAGE,
    t = xi.DEFAULT_MAPPING,
    i = bn,
    n = bn,
    s = Ui,
    a = mr,
    o = es,
    u = Ko,
    h = xi.DEFAULT_ANISOTROPY,
    f = gr
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: jS++ }),
      (this.uuid = bs()),
      (this.name = ""),
      (this.source = new ub(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.wrapS = i),
      (this.wrapT = n),
      (this.magFilter = s),
      (this.minFilter = a),
      (this.anisotropy = h),
      (this.format = o),
      (this.internalFormat = null),
      (this.type = u),
      (this.offset = new Ue(0, 0)),
      (this.repeat = new Ue(1, 1)),
      (this.center = new Ue(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Nn()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = f),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.encoding = e.encoding),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = {
      metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      t || (e.textures[this.uuid] = i),
      i
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== tb) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Zr:
          e.x = e.x - Math.floor(e.x);
          break;
        case bn:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Wh:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Zr:
          e.y = e.y - Math.floor(e.y);
          break;
        case bn:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Wh:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
}
xi.DEFAULT_IMAGE = null;
xi.DEFAULT_MAPPING = tb;
xi.DEFAULT_ANISOTROPY = 1;
class Kt {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    (Kt.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      (this.w = n);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, n) {
    return (this.x = e), (this.y = t), (this.z = i), (this.w = n), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      n = this.z,
      s = this.w,
      a = e.elements;
    return (
      (this.x = a[0] * t + a[4] * i + a[8] * n + a[12] * s),
      (this.y = a[1] * t + a[5] * i + a[9] * n + a[13] * s),
      (this.z = a[2] * t + a[6] * i + a[10] * n + a[14] * s),
      (this.w = a[3] * t + a[7] * i + a[11] * n + a[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, n, s;
    const u = e.elements,
      h = u[0],
      f = u[4],
      c = u[8],
      d = u[1],
      m = u[5],
      x = u[9],
      v = u[2],
      b = u[6],
      y = u[10];
    if (
      Math.abs(f - d) < 0.01 &&
      Math.abs(c - v) < 0.01 &&
      Math.abs(x - b) < 0.01
    ) {
      if (
        Math.abs(f + d) < 0.1 &&
        Math.abs(c + v) < 0.1 &&
        Math.abs(x + b) < 0.1 &&
        Math.abs(h + m + y - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const D = (h + 1) / 2,
        C = (m + 1) / 2,
        A = (y + 1) / 2,
        I = (f + d) / 4,
        F = (c + v) / 4,
        P = (x + b) / 4;
      return (
        D > C && D > A
          ? D < 0.01
            ? ((i = 0), (n = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(D)), (n = I / i), (s = F / i))
          : C > A
          ? C < 0.01
            ? ((i = 0.707106781), (n = 0), (s = 0.707106781))
            : ((n = Math.sqrt(C)), (i = I / n), (s = P / n))
          : A < 0.01
          ? ((i = 0.707106781), (n = 0.707106781), (s = 0))
          : ((s = Math.sqrt(A)), (i = F / s), (n = P / s)),
        this.set(i, n, s, t),
        this
      );
    }
    let M = Math.sqrt(
      (b - x) * (b - x) + (c - v) * (c - v) + (d - f) * (d - f)
    );
    return (
      Math.abs(M) < 0.001 && (M = 1),
      (this.x = (b - x) / M),
      (this.y = (c - v) / M),
      (this.z = (d - f) / M),
      (this.w = Math.acos((h + m + y - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Zo extends ra {
  constructor(e = 1, t = 1, i = {}) {
    super(),
      (this.isWebGLRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new Kt(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Kt(0, 0, e, t));
    const n = { width: e, height: t, depth: 1 };
    (this.texture = new xi(
      n,
      i.mapping,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.encoding
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps =
        i.generateMipmaps !== void 0 ? i.generateMipmaps : !1),
      (this.texture.internalFormat =
        i.internalFormat !== void 0 ? i.internalFormat : null),
      (this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : Ui),
      (this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0),
      (this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1),
      (this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null),
      (this.samples = i.samples !== void 0 ? i.samples : 0);
  }
  setSize(e, t, i = 1) {
    (this.width !== e || this.height !== t || this.depth !== i) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = i),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = i),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new ub(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class hb extends xi {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: n }),
      (this.magFilter = Ai),
      (this.minFilter = Ai),
      (this.wrapR = bn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class qS extends xi {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: n }),
      (this.magFilter = Ai),
      (this.minFilter = Ai),
      (this.wrapR = bn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class ws {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = n);
  }
  static slerpFlat(e, t, i, n, s, a, o) {
    let u = i[n + 0],
      h = i[n + 1],
      f = i[n + 2],
      c = i[n + 3];
    const d = s[a + 0],
      m = s[a + 1],
      x = s[a + 2],
      v = s[a + 3];
    if (o === 0) {
      (e[t + 0] = u), (e[t + 1] = h), (e[t + 2] = f), (e[t + 3] = c);
      return;
    }
    if (o === 1) {
      (e[t + 0] = d), (e[t + 1] = m), (e[t + 2] = x), (e[t + 3] = v);
      return;
    }
    if (c !== v || u !== d || h !== m || f !== x) {
      let b = 1 - o;
      const y = u * d + h * m + f * x + c * v,
        M = y >= 0 ? 1 : -1,
        D = 1 - y * y;
      if (D > Number.EPSILON) {
        const A = Math.sqrt(D),
          I = Math.atan2(A, y * M);
        (b = Math.sin(b * I) / A), (o = Math.sin(o * I) / A);
      }
      const C = o * M;
      if (
        ((u = u * b + d * C),
        (h = h * b + m * C),
        (f = f * b + x * C),
        (c = c * b + v * C),
        b === 1 - o)
      ) {
        const A = 1 / Math.sqrt(u * u + h * h + f * f + c * c);
        (u *= A), (h *= A), (f *= A), (c *= A);
      }
    }
    (e[t] = u), (e[t + 1] = h), (e[t + 2] = f), (e[t + 3] = c);
  }
  static multiplyQuaternionsFlat(e, t, i, n, s, a) {
    const o = i[n],
      u = i[n + 1],
      h = i[n + 2],
      f = i[n + 3],
      c = s[a],
      d = s[a + 1],
      m = s[a + 2],
      x = s[a + 3];
    return (
      (e[t] = o * x + f * c + u * m - h * d),
      (e[t + 1] = u * x + f * d + h * c - o * m),
      (e[t + 2] = h * x + f * m + o * d - u * c),
      (e[t + 3] = f * x - o * c - u * d - h * m),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, i, n) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = n),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    const i = e._x,
      n = e._y,
      s = e._z,
      a = e._order,
      o = Math.cos,
      u = Math.sin,
      h = o(i / 2),
      f = o(n / 2),
      c = o(s / 2),
      d = u(i / 2),
      m = u(n / 2),
      x = u(s / 2);
    switch (a) {
      case "XYZ":
        (this._x = d * f * c + h * m * x),
          (this._y = h * m * c - d * f * x),
          (this._z = h * f * x + d * m * c),
          (this._w = h * f * c - d * m * x);
        break;
      case "YXZ":
        (this._x = d * f * c + h * m * x),
          (this._y = h * m * c - d * f * x),
          (this._z = h * f * x - d * m * c),
          (this._w = h * f * c + d * m * x);
        break;
      case "ZXY":
        (this._x = d * f * c - h * m * x),
          (this._y = h * m * c + d * f * x),
          (this._z = h * f * x + d * m * c),
          (this._w = h * f * c - d * m * x);
        break;
      case "ZYX":
        (this._x = d * f * c - h * m * x),
          (this._y = h * m * c + d * f * x),
          (this._z = h * f * x - d * m * c),
          (this._w = h * f * c + d * m * x);
        break;
      case "YZX":
        (this._x = d * f * c + h * m * x),
          (this._y = h * m * c + d * f * x),
          (this._z = h * f * x - d * m * c),
          (this._w = h * f * c - d * m * x);
        break;
      case "XZY":
        (this._x = d * f * c - h * m * x),
          (this._y = h * m * c - d * f * x),
          (this._z = h * f * x + d * m * c),
          (this._w = h * f * c + d * m * x);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a
        );
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      n = Math.sin(i);
    return (
      (this._x = e.x * n),
      (this._y = e.y * n),
      (this._z = e.z * n),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      n = t[4],
      s = t[8],
      a = t[1],
      o = t[5],
      u = t[9],
      h = t[2],
      f = t[6],
      c = t[10],
      d = i + o + c;
    if (d > 0) {
      const m = 0.5 / Math.sqrt(d + 1);
      (this._w = 0.25 / m),
        (this._x = (f - u) * m),
        (this._y = (s - h) * m),
        (this._z = (a - n) * m);
    } else if (i > o && i > c) {
      const m = 2 * Math.sqrt(1 + i - o - c);
      (this._w = (f - u) / m),
        (this._x = 0.25 * m),
        (this._y = (n + a) / m),
        (this._z = (s + h) / m);
    } else if (o > c) {
      const m = 2 * Math.sqrt(1 + o - i - c);
      (this._w = (s - h) / m),
        (this._x = (n + a) / m),
        (this._y = 0.25 * m),
        (this._z = (u + f) / m);
    } else {
      const m = 2 * Math.sqrt(1 + c - i - o);
      (this._w = (a - n) / m),
        (this._x = (s + h) / m),
        (this._y = (u + f) / m),
        (this._z = 0.25 * m);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Li(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const n = Math.min(1, t / i);
    return this.slerp(e, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      n = e._y,
      s = e._z,
      a = e._w,
      o = t._x,
      u = t._y,
      h = t._z,
      f = t._w;
    return (
      (this._x = i * f + a * o + n * h - s * u),
      (this._y = n * f + a * u + s * o - i * h),
      (this._z = s * f + a * h + i * u - n * o),
      (this._w = a * f - i * o - n * u - s * h),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x,
      n = this._y,
      s = this._z,
      a = this._w;
    let o = a * e._w + i * e._x + n * e._y + s * e._z;
    if (
      (o < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (o = -o))
        : this.copy(e),
      o >= 1)
    )
      return (this._w = a), (this._x = i), (this._y = n), (this._z = s), this;
    const u = 1 - o * o;
    if (u <= Number.EPSILON) {
      const m = 1 - t;
      return (
        (this._w = m * a + t * this._w),
        (this._x = m * i + t * this._x),
        (this._y = m * n + t * this._y),
        (this._z = m * s + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const h = Math.sqrt(u),
      f = Math.atan2(h, o),
      c = Math.sin((1 - t) * f) / h,
      d = Math.sin(t * f) / h;
    return (
      (this._w = a * c + this._w * d),
      (this._x = i * c + this._x * d),
      (this._y = n * c + this._y * d),
      (this._z = s * c + this._z * d),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      i = Math.sqrt(e),
      n = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(n),
      i * Math.sin(s),
      i * Math.cos(s),
      t * Math.sin(n)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class Z {
  constructor(e = 0, t = 0, i = 0) {
    (Z.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
  }
  set(e, t, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(k0.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(k0.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      n = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * i + s[6] * n),
      (this.y = s[1] * t + s[4] * i + s[7] * n),
      (this.z = s[2] * t + s[5] * i + s[8] * n),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      n = this.z,
      s = e.elements,
      a = 1 / (s[3] * t + s[7] * i + s[11] * n + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * i + s[8] * n + s[12]) * a),
      (this.y = (s[1] * t + s[5] * i + s[9] * n + s[13]) * a),
      (this.z = (s[2] * t + s[6] * i + s[10] * n + s[14]) * a),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      n = this.z,
      s = e.x,
      a = e.y,
      o = e.z,
      u = e.w,
      h = u * t + a * n - o * i,
      f = u * i + o * t - s * n,
      c = u * n + s * i - a * t,
      d = -s * t - a * i - o * n;
    return (
      (this.x = h * u + d * -s + f * -o - c * -a),
      (this.y = f * u + d * -a + c * -s - h * -o),
      (this.z = c * u + d * -o + h * -a - f * -s),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      n = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * n),
      (this.y = s[1] * t + s[5] * i + s[9] * n),
      (this.z = s[2] * t + s[6] * i + s[10] * n),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x,
      n = e.y,
      s = e.z,
      a = t.x,
      o = t.y,
      u = t.z;
    return (
      (this.x = n * u - s * o),
      (this.y = s * a - i * u),
      (this.z = i * o - n * a),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return xp.copy(this).projectOnVector(e), this.sub(xp);
  }
  reflect(e) {
    return this.sub(xp.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Li(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      n = this.z - e.z;
    return t * t + i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const n = Math.sin(t) * e;
    return (
      (this.x = n * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = n * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      n = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = i), (this.z = n), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      i = Math.sqrt(1 - e ** 2);
    return (
      (this.x = i * Math.cos(t)), (this.y = i * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const xp = new Z(),
  k0 = new ws();
class Tl {
  constructor(
    e = new Z(1 / 0, 1 / 0, 1 / 0),
    t = new Z(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    let t = 1 / 0,
      i = 1 / 0,
      n = 1 / 0,
      s = -1 / 0,
      a = -1 / 0,
      o = -1 / 0;
    for (let u = 0, h = e.length; u < h; u += 3) {
      const f = e[u],
        c = e[u + 1],
        d = e[u + 2];
      f < t && (t = f),
        c < i && (i = c),
        d < n && (n = d),
        f > s && (s = f),
        c > a && (a = c),
        d > o && (o = d);
    }
    return this.min.set(t, i, n), this.max.set(s, a, o), this;
  }
  setFromBufferAttribute(e) {
    let t = 1 / 0,
      i = 1 / 0,
      n = 1 / 0,
      s = -1 / 0,
      a = -1 / 0,
      o = -1 / 0;
    for (let u = 0, h = e.count; u < h; u++) {
      const f = e.getX(u),
        c = e.getY(u),
        d = e.getZ(u);
      f < t && (t = f),
        c < i && (i = c),
        d < n && (n = d),
        f > s && (s = f),
        c > a && (a = c),
        d > o && (o = d);
    }
    return this.min.set(t, i, n), this.max.set(s, a, o), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = vo.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0)
      if (t && i.attributes != null && i.attributes.position !== void 0) {
        const s = i.attributes.position;
        for (let a = 0, o = s.count; a < o; a++)
          vo.fromBufferAttribute(s, a).applyMatrix4(e.matrixWorld),
            this.expandByPoint(vo);
      } else
        i.boundingBox === null && i.computeBoundingBox(),
          wp.copy(i.boundingBox),
          wp.applyMatrix4(e.matrixWorld),
          this.union(wp);
    const n = e.children;
    for (let s = 0, a = n.length; s < a; s++) this.expandByObject(n[s], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, vo),
      vo.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, i;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Ql),
      Hu.subVectors(this.max, Ql),
      Ma.subVectors(e.a, Ql),
      Ta.subVectors(e.b, Ql),
      Ea.subVectors(e.c, Ql),
      Rr.subVectors(Ta, Ma),
      kr.subVectors(Ea, Ta),
      _o.subVectors(Ma, Ea);
    let t = [
      0,
      -Rr.z,
      Rr.y,
      0,
      -kr.z,
      kr.y,
      0,
      -_o.z,
      _o.y,
      Rr.z,
      0,
      -Rr.x,
      kr.z,
      0,
      -kr.x,
      _o.z,
      0,
      -_o.x,
      -Rr.y,
      Rr.x,
      0,
      -kr.y,
      kr.x,
      0,
      -_o.y,
      _o.x,
      0,
    ];
    return !yp(t, Ma, Ta, Ea, Hu) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !yp(t, Ma, Ta, Ea, Hu))
      ? !1
      : (Wu.crossVectors(Rr, kr),
        (t = [Wu.x, Wu.y, Wu.z]),
        yp(t, Ma, Ta, Ea, Hu));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return vo.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return (
      this.getCenter(e.center), (e.radius = this.getSize(vo).length() * 0.5), e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Ks[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Ks[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Ks[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Ks[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Ks[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Ks[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Ks[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Ks[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Ks),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ks = [
    new Z(),
    new Z(),
    new Z(),
    new Z(),
    new Z(),
    new Z(),
    new Z(),
    new Z(),
  ],
  vo = new Z(),
  wp = new Tl(),
  Ma = new Z(),
  Ta = new Z(),
  Ea = new Z(),
  Rr = new Z(),
  kr = new Z(),
  _o = new Z(),
  Ql = new Z(),
  Hu = new Z(),
  Wu = new Z(),
  bo = new Z();
function yp(r, e, t, i, n) {
  for (let s = 0, a = r.length - 3; s <= a; s += 3) {
    bo.fromArray(r, s);
    const o =
        n.x * Math.abs(bo.x) + n.y * Math.abs(bo.y) + n.z * Math.abs(bo.z),
      u = e.dot(bo),
      h = t.dot(bo),
      f = i.dot(bo);
    if (Math.max(-Math.max(u, h, f), Math.min(u, h, f)) > o) return !1;
  }
  return !0;
}
const XS = new Tl(),
  ec = new Z(),
  Sp = new Z();
class El {
  constructor(e = new Z(), t = -1) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : XS.setFromPoints(e).getCenter(i);
    let n = 0;
    for (let s = 0, a = e.length; s < a; s++)
      n = Math.max(n, i.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(n)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    ec.subVectors(e, this.center);
    const t = ec.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t),
        n = (i - this.radius) * 0.5;
      this.center.addScaledVector(ec, n / i), (this.radius += n);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (Sp.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(ec.copy(e.center).add(Sp)),
            this.expandByPoint(ec.copy(e.center).sub(Sp))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Zs = new Z(),
  Mp = new Z(),
  ju = new Z(),
  Ir = new Z(),
  Tp = new Z(),
  qu = new Z(),
  Ep = new Z();
class cd {
  constructor(e = new Z(), t = new Z(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Zs)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.direction).multiplyScalar(i).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Zs.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Zs.copy(this.direction).multiplyScalar(t).add(this.origin),
        Zs.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, n) {
    Mp.copy(e).add(t).multiplyScalar(0.5),
      ju.copy(t).sub(e).normalize(),
      Ir.copy(this.origin).sub(Mp);
    const s = e.distanceTo(t) * 0.5,
      a = -this.direction.dot(ju),
      o = Ir.dot(this.direction),
      u = -Ir.dot(ju),
      h = Ir.lengthSq(),
      f = Math.abs(1 - a * a);
    let c, d, m, x;
    if (f > 0)
      if (((c = a * u - o), (d = a * o - u), (x = s * f), c >= 0))
        if (d >= -x)
          if (d <= x) {
            const v = 1 / f;
            (c *= v),
              (d *= v),
              (m = c * (c + a * d + 2 * o) + d * (a * c + d + 2 * u) + h);
          } else
            (d = s),
              (c = Math.max(0, -(a * d + o))),
              (m = -c * c + d * (d + 2 * u) + h);
        else
          (d = -s),
            (c = Math.max(0, -(a * d + o))),
            (m = -c * c + d * (d + 2 * u) + h);
      else
        d <= -x
          ? ((c = Math.max(0, -(-a * s + o))),
            (d = c > 0 ? -s : Math.min(Math.max(-s, -u), s)),
            (m = -c * c + d * (d + 2 * u) + h))
          : d <= x
          ? ((c = 0),
            (d = Math.min(Math.max(-s, -u), s)),
            (m = d * (d + 2 * u) + h))
          : ((c = Math.max(0, -(a * s + o))),
            (d = c > 0 ? s : Math.min(Math.max(-s, -u), s)),
            (m = -c * c + d * (d + 2 * u) + h));
    else
      (d = a > 0 ? -s : s),
        (c = Math.max(0, -(a * d + o))),
        (m = -c * c + d * (d + 2 * u) + h);
    return (
      i && i.copy(this.direction).multiplyScalar(c).add(this.origin),
      n && n.copy(ju).multiplyScalar(d).add(Mp),
      m
    );
  }
  intersectSphere(e, t) {
    Zs.subVectors(e.center, this.origin);
    const i = Zs.dot(this.direction),
      n = Zs.dot(Zs) - i * i,
      s = e.radius * e.radius;
    if (n > s) return null;
    const a = Math.sqrt(s - n),
      o = i - a,
      u = i + a;
    return o < 0 && u < 0 ? null : o < 0 ? this.at(u, t) : this.at(o, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, n, s, a, o, u;
    const h = 1 / this.direction.x,
      f = 1 / this.direction.y,
      c = 1 / this.direction.z,
      d = this.origin;
    return (
      h >= 0
        ? ((i = (e.min.x - d.x) * h), (n = (e.max.x - d.x) * h))
        : ((i = (e.max.x - d.x) * h), (n = (e.min.x - d.x) * h)),
      f >= 0
        ? ((s = (e.min.y - d.y) * f), (a = (e.max.y - d.y) * f))
        : ((s = (e.max.y - d.y) * f), (a = (e.min.y - d.y) * f)),
      i > a ||
      s > n ||
      ((s > i || isNaN(i)) && (i = s),
      (a < n || isNaN(n)) && (n = a),
      c >= 0
        ? ((o = (e.min.z - d.z) * c), (u = (e.max.z - d.z) * c))
        : ((o = (e.max.z - d.z) * c), (u = (e.min.z - d.z) * c)),
      i > u || o > n) ||
      ((o > i || i !== i) && (i = o), (u < n || n !== n) && (n = u), n < 0)
        ? null
        : this.at(i >= 0 ? i : n, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Zs) !== null;
  }
  intersectTriangle(e, t, i, n, s) {
    Tp.subVectors(t, e), qu.subVectors(i, e), Ep.crossVectors(Tp, qu);
    let a = this.direction.dot(Ep),
      o;
    if (a > 0) {
      if (n) return null;
      o = 1;
    } else if (a < 0) (o = -1), (a = -a);
    else return null;
    Ir.subVectors(this.origin, e);
    const u = o * this.direction.dot(qu.crossVectors(Ir, qu));
    if (u < 0) return null;
    const h = o * this.direction.dot(Tp.cross(Ir));
    if (h < 0 || u + h > a) return null;
    const f = -o * Ir.dot(Ep);
    return f < 0 ? null : this.at(f / a, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class At {
  constructor() {
    (At.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  set(e, t, i, n, s, a, o, u, h, f, c, d, m, x, v, b) {
    const y = this.elements;
    return (
      (y[0] = e),
      (y[4] = t),
      (y[8] = i),
      (y[12] = n),
      (y[1] = s),
      (y[5] = a),
      (y[9] = o),
      (y[13] = u),
      (y[2] = h),
      (y[6] = f),
      (y[10] = c),
      (y[14] = d),
      (y[3] = m),
      (y[7] = x),
      (y[11] = v),
      (y[15] = b),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new At().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements;
    return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      n = 1 / Ca.setFromMatrixColumn(e, 0).length(),
      s = 1 / Ca.setFromMatrixColumn(e, 1).length(),
      a = 1 / Ca.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = i[0] * n),
      (t[1] = i[1] * n),
      (t[2] = i[2] * n),
      (t[3] = 0),
      (t[4] = i[4] * s),
      (t[5] = i[5] * s),
      (t[6] = i[6] * s),
      (t[7] = 0),
      (t[8] = i[8] * a),
      (t[9] = i[9] * a),
      (t[10] = i[10] * a),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      i = e.x,
      n = e.y,
      s = e.z,
      a = Math.cos(i),
      o = Math.sin(i),
      u = Math.cos(n),
      h = Math.sin(n),
      f = Math.cos(s),
      c = Math.sin(s);
    if (e.order === "XYZ") {
      const d = a * f,
        m = a * c,
        x = o * f,
        v = o * c;
      (t[0] = u * f),
        (t[4] = -u * c),
        (t[8] = h),
        (t[1] = m + x * h),
        (t[5] = d - v * h),
        (t[9] = -o * u),
        (t[2] = v - d * h),
        (t[6] = x + m * h),
        (t[10] = a * u);
    } else if (e.order === "YXZ") {
      const d = u * f,
        m = u * c,
        x = h * f,
        v = h * c;
      (t[0] = d + v * o),
        (t[4] = x * o - m),
        (t[8] = a * h),
        (t[1] = a * c),
        (t[5] = a * f),
        (t[9] = -o),
        (t[2] = m * o - x),
        (t[6] = v + d * o),
        (t[10] = a * u);
    } else if (e.order === "ZXY") {
      const d = u * f,
        m = u * c,
        x = h * f,
        v = h * c;
      (t[0] = d - v * o),
        (t[4] = -a * c),
        (t[8] = x + m * o),
        (t[1] = m + x * o),
        (t[5] = a * f),
        (t[9] = v - d * o),
        (t[2] = -a * h),
        (t[6] = o),
        (t[10] = a * u);
    } else if (e.order === "ZYX") {
      const d = a * f,
        m = a * c,
        x = o * f,
        v = o * c;
      (t[0] = u * f),
        (t[4] = x * h - m),
        (t[8] = d * h + v),
        (t[1] = u * c),
        (t[5] = v * h + d),
        (t[9] = m * h - x),
        (t[2] = -h),
        (t[6] = o * u),
        (t[10] = a * u);
    } else if (e.order === "YZX") {
      const d = a * u,
        m = a * h,
        x = o * u,
        v = o * h;
      (t[0] = u * f),
        (t[4] = v - d * c),
        (t[8] = x * c + m),
        (t[1] = c),
        (t[5] = a * f),
        (t[9] = -o * f),
        (t[2] = -h * f),
        (t[6] = m * c + x),
        (t[10] = d - v * c);
    } else if (e.order === "XZY") {
      const d = a * u,
        m = a * h,
        x = o * u,
        v = o * h;
      (t[0] = u * f),
        (t[4] = -c),
        (t[8] = h * f),
        (t[1] = d * c + v),
        (t[5] = a * f),
        (t[9] = m * c - x),
        (t[2] = x * c - m),
        (t[6] = o * f),
        (t[10] = v * c + d);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose($S, e, YS);
  }
  lookAt(e, t, i) {
    const n = this.elements;
    return (
      Dn.subVectors(e, t),
      Dn.lengthSq() === 0 && (Dn.z = 1),
      Dn.normalize(),
      Fr.crossVectors(i, Dn),
      Fr.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (Dn.x += 1e-4) : (Dn.z += 1e-4),
        Dn.normalize(),
        Fr.crossVectors(i, Dn)),
      Fr.normalize(),
      Xu.crossVectors(Dn, Fr),
      (n[0] = Fr.x),
      (n[4] = Xu.x),
      (n[8] = Dn.x),
      (n[1] = Fr.y),
      (n[5] = Xu.y),
      (n[9] = Dn.y),
      (n[2] = Fr.z),
      (n[6] = Xu.z),
      (n[10] = Dn.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      n = t.elements,
      s = this.elements,
      a = i[0],
      o = i[4],
      u = i[8],
      h = i[12],
      f = i[1],
      c = i[5],
      d = i[9],
      m = i[13],
      x = i[2],
      v = i[6],
      b = i[10],
      y = i[14],
      M = i[3],
      D = i[7],
      C = i[11],
      A = i[15],
      I = n[0],
      F = n[4],
      P = n[8],
      k = n[12],
      O = n[1],
      J = n[5],
      ee = n[9],
      X = n[13],
      j = n[2],
      Y = n[6],
      ie = n[10],
      Q = n[14],
      V = n[3],
      ve = n[7],
      U = n[11],
      oe = n[15];
    return (
      (s[0] = a * I + o * O + u * j + h * V),
      (s[4] = a * F + o * J + u * Y + h * ve),
      (s[8] = a * P + o * ee + u * ie + h * U),
      (s[12] = a * k + o * X + u * Q + h * oe),
      (s[1] = f * I + c * O + d * j + m * V),
      (s[5] = f * F + c * J + d * Y + m * ve),
      (s[9] = f * P + c * ee + d * ie + m * U),
      (s[13] = f * k + c * X + d * Q + m * oe),
      (s[2] = x * I + v * O + b * j + y * V),
      (s[6] = x * F + v * J + b * Y + y * ve),
      (s[10] = x * P + v * ee + b * ie + y * U),
      (s[14] = x * k + v * X + b * Q + y * oe),
      (s[3] = M * I + D * O + C * j + A * V),
      (s[7] = M * F + D * J + C * Y + A * ve),
      (s[11] = M * P + D * ee + C * ie + A * U),
      (s[15] = M * k + D * X + C * Q + A * oe),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      n = e[8],
      s = e[12],
      a = e[1],
      o = e[5],
      u = e[9],
      h = e[13],
      f = e[2],
      c = e[6],
      d = e[10],
      m = e[14],
      x = e[3],
      v = e[7],
      b = e[11],
      y = e[15];
    return (
      x *
        (+s * u * c -
          n * h * c -
          s * o * d +
          i * h * d +
          n * o * m -
          i * u * m) +
      v *
        (+t * u * m -
          t * h * d +
          s * a * d -
          n * a * m +
          n * h * f -
          s * u * f) +
      b *
        (+t * h * c -
          t * o * m -
          s * a * c +
          i * a * m +
          s * o * f -
          i * h * f) +
      y *
        (-n * o * f - t * u * c + t * o * d + n * a * c - i * a * d + i * u * f)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, i) {
    const n = this.elements;
    return (
      e.isVector3
        ? ((n[12] = e.x), (n[13] = e.y), (n[14] = e.z))
        : ((n[12] = e), (n[13] = t), (n[14] = i)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      n = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      u = e[6],
      h = e[7],
      f = e[8],
      c = e[9],
      d = e[10],
      m = e[11],
      x = e[12],
      v = e[13],
      b = e[14],
      y = e[15],
      M = c * b * h - v * d * h + v * u * m - o * b * m - c * u * y + o * d * y,
      D = x * d * h - f * b * h - x * u * m + a * b * m + f * u * y - a * d * y,
      C = f * v * h - x * c * h + x * o * m - a * v * m - f * o * y + a * c * y,
      A = x * c * u - f * v * u - x * o * d + a * v * d + f * o * b - a * c * b,
      I = t * M + i * D + n * C + s * A;
    if (I === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const F = 1 / I;
    return (
      (e[0] = M * F),
      (e[1] =
        (v * d * s -
          c * b * s -
          v * n * m +
          i * b * m +
          c * n * y -
          i * d * y) *
        F),
      (e[2] =
        (o * b * s -
          v * u * s +
          v * n * h -
          i * b * h -
          o * n * y +
          i * u * y) *
        F),
      (e[3] =
        (c * u * s -
          o * d * s -
          c * n * h +
          i * d * h +
          o * n * m -
          i * u * m) *
        F),
      (e[4] = D * F),
      (e[5] =
        (f * b * s -
          x * d * s +
          x * n * m -
          t * b * m -
          f * n * y +
          t * d * y) *
        F),
      (e[6] =
        (x * u * s -
          a * b * s -
          x * n * h +
          t * b * h +
          a * n * y -
          t * u * y) *
        F),
      (e[7] =
        (a * d * s -
          f * u * s +
          f * n * h -
          t * d * h -
          a * n * m +
          t * u * m) *
        F),
      (e[8] = C * F),
      (e[9] =
        (x * c * s -
          f * v * s -
          x * i * m +
          t * v * m +
          f * i * y -
          t * c * y) *
        F),
      (e[10] =
        (a * v * s -
          x * o * s +
          x * i * h -
          t * v * h -
          a * i * y +
          t * o * y) *
        F),
      (e[11] =
        (f * o * s -
          a * c * s -
          f * i * h +
          t * c * h +
          a * i * m -
          t * o * m) *
        F),
      (e[12] = A * F),
      (e[13] =
        (f * v * n -
          x * c * n +
          x * i * d -
          t * v * d -
          f * i * b +
          t * c * b) *
        F),
      (e[14] =
        (x * o * n -
          a * v * n -
          x * i * u +
          t * v * u +
          a * i * b -
          t * o * b) *
        F),
      (e[15] =
        (a * c * n -
          f * o * n +
          f * i * u -
          t * c * u -
          a * i * d +
          t * o * d) *
        F),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      n = e.y,
      s = e.z;
    return (
      (t[0] *= i),
      (t[4] *= n),
      (t[8] *= s),
      (t[1] *= i),
      (t[5] *= n),
      (t[9] *= s),
      (t[2] *= i),
      (t[6] *= n),
      (t[10] *= s),
      (t[3] *= i),
      (t[7] *= n),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, n));
  }
  makeTranslation(e, t, i) {
    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      n = Math.sin(t),
      s = 1 - i,
      a = e.x,
      o = e.y,
      u = e.z,
      h = s * a,
      f = s * o;
    return (
      this.set(
        h * a + i,
        h * o - n * u,
        h * u + n * o,
        0,
        h * o + n * u,
        f * o + i,
        f * u - n * a,
        0,
        h * u - n * o,
        f * u + n * a,
        s * u * u + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, i, n, s, a) {
    return this.set(1, i, s, 0, e, 1, a, 0, t, n, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, i) {
    const n = this.elements,
      s = t._x,
      a = t._y,
      o = t._z,
      u = t._w,
      h = s + s,
      f = a + a,
      c = o + o,
      d = s * h,
      m = s * f,
      x = s * c,
      v = a * f,
      b = a * c,
      y = o * c,
      M = u * h,
      D = u * f,
      C = u * c,
      A = i.x,
      I = i.y,
      F = i.z;
    return (
      (n[0] = (1 - (v + y)) * A),
      (n[1] = (m + C) * A),
      (n[2] = (x - D) * A),
      (n[3] = 0),
      (n[4] = (m - C) * I),
      (n[5] = (1 - (d + y)) * I),
      (n[6] = (b + M) * I),
      (n[7] = 0),
      (n[8] = (x + D) * F),
      (n[9] = (b - M) * F),
      (n[10] = (1 - (d + v)) * F),
      (n[11] = 0),
      (n[12] = e.x),
      (n[13] = e.y),
      (n[14] = e.z),
      (n[15] = 1),
      this
    );
  }
  decompose(e, t, i) {
    const n = this.elements;
    let s = Ca.set(n[0], n[1], n[2]).length();
    const a = Ca.set(n[4], n[5], n[6]).length(),
      o = Ca.set(n[8], n[9], n[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = n[12]),
      (e.y = n[13]),
      (e.z = n[14]),
      ps.copy(this);
    const h = 1 / s,
      f = 1 / a,
      c = 1 / o;
    return (
      (ps.elements[0] *= h),
      (ps.elements[1] *= h),
      (ps.elements[2] *= h),
      (ps.elements[4] *= f),
      (ps.elements[5] *= f),
      (ps.elements[6] *= f),
      (ps.elements[8] *= c),
      (ps.elements[9] *= c),
      (ps.elements[10] *= c),
      t.setFromRotationMatrix(ps),
      (i.x = s),
      (i.y = a),
      (i.z = o),
      this
    );
  }
  makePerspective(e, t, i, n, s, a) {
    const o = this.elements,
      u = (2 * s) / (t - e),
      h = (2 * s) / (i - n),
      f = (t + e) / (t - e),
      c = (i + n) / (i - n),
      d = -(a + s) / (a - s),
      m = (-2 * a * s) / (a - s);
    return (
      (o[0] = u),
      (o[4] = 0),
      (o[8] = f),
      (o[12] = 0),
      (o[1] = 0),
      (o[5] = h),
      (o[9] = c),
      (o[13] = 0),
      (o[2] = 0),
      (o[6] = 0),
      (o[10] = d),
      (o[14] = m),
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = -1),
      (o[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, i, n, s, a) {
    const o = this.elements,
      u = 1 / (t - e),
      h = 1 / (i - n),
      f = 1 / (a - s),
      c = (t + e) * u,
      d = (i + n) * h,
      m = (a + s) * f;
    return (
      (o[0] = 2 * u),
      (o[4] = 0),
      (o[8] = 0),
      (o[12] = -c),
      (o[1] = 0),
      (o[5] = 2 * h),
      (o[9] = 0),
      (o[13] = -d),
      (o[2] = 0),
      (o[6] = 0),
      (o[10] = -2 * f),
      (o[14] = -m),
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = 0),
      (o[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let n = 0; n < 16; n++) if (t[n] !== i[n]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    );
  }
}
const Ca = new Z(),
  ps = new At(),
  $S = new Z(0, 0, 0),
  YS = new Z(1, 1, 1),
  Fr = new Z(),
  Xu = new Z(),
  Dn = new Z(),
  I0 = new At(),
  F0 = new ws();
class Cl {
  constructor(e = 0, t = 0, i = 0, n = Cl.DefaultOrder) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = n);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, i, n = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = n),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const n = e.elements,
      s = n[0],
      a = n[4],
      o = n[8],
      u = n[1],
      h = n[5],
      f = n[9],
      c = n[2],
      d = n[6],
      m = n[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(Li(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(-f, m)), (this._z = Math.atan2(-a, s)))
            : ((this._x = Math.atan2(d, h)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Li(f, -1, 1))),
          Math.abs(f) < 0.9999999
            ? ((this._y = Math.atan2(o, m)), (this._z = Math.atan2(u, h)))
            : ((this._y = Math.atan2(-c, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Li(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._y = Math.atan2(-c, m)), (this._z = Math.atan2(-a, h)))
            : ((this._y = 0), (this._z = Math.atan2(u, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Li(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._x = Math.atan2(d, m)), (this._z = Math.atan2(u, s)))
            : ((this._x = 0), (this._z = Math.atan2(-a, h)));
        break;
      case "YZX":
        (this._z = Math.asin(Li(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(-f, h)), (this._y = Math.atan2(-c, s)))
            : ((this._x = 0), (this._y = Math.atan2(o, m)));
        break;
      case "XZY":
        (this._z = Math.asin(-Li(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(d, h)), (this._y = Math.atan2(o, s)))
            : ((this._x = Math.atan2(-f, m)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return (
      I0.makeRotationFromQuaternion(e), this.setFromRotationMatrix(I0, t, i)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return F0.setFromEuler(this), this.setFromQuaternion(F0, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
  toVector3() {
    console.error(
      "THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead"
    );
  }
}
Cl.DefaultOrder = "XYZ";
Cl.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class bm {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let KS = 0;
const O0 = new Z(),
  Da = new ws(),
  Js = new At(),
  $u = new Z(),
  tc = new Z(),
  ZS = new Z(),
  JS = new ws(),
  N0 = new Z(1, 0, 0),
  B0 = new Z(0, 1, 0),
  V0 = new Z(0, 0, 1),
  QS = { type: "added" },
  z0 = { type: "removed" };
class ei extends ra {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: KS++ }),
      (this.uuid = bs()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = ei.DefaultUp.clone());
    const e = new Z(),
      t = new Cl(),
      i = new ws(),
      n = new Z(1, 1, 1);
    function s() {
      i.setFromEuler(t, !1);
    }
    function a() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(s),
      i._onChange(a),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: n },
        modelViewMatrix: { value: new At() },
        normalMatrix: { value: new Nn() },
      }),
      (this.matrix = new At()),
      (this.matrixWorld = new At()),
      (this.matrixAutoUpdate = ei.DefaultMatrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = ei.DefaultMatrixWorldAutoUpdate),
      (this.layers = new bm()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Da.setFromAxisAngle(e, t), this.quaternion.multiply(Da), this;
  }
  rotateOnWorldAxis(e, t) {
    return Da.setFromAxisAngle(e, t), this.quaternion.premultiply(Da), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(N0, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(B0, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(V0, e);
  }
  translateOnAxis(e, t) {
    return (
      O0.copy(e).applyQuaternion(this.quaternion),
      this.position.add(O0.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(N0, e);
  }
  translateY(e) {
    return this.translateOnAxis(B0, e);
  }
  translateZ(e) {
    return this.translateOnAxis(V0, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Js.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, i) {
    e.isVector3 ? $u.copy(e) : $u.set(e, t, i);
    const n = this.parent;
    this.updateWorldMatrix(!0, !1),
      tc.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Js.lookAt(tc, $u, this.up)
        : Js.lookAt($u, tc, this.up),
      this.quaternion.setFromRotationMatrix(Js),
      n &&
        (Js.extractRotation(n.matrixWorld),
        Da.setFromRotationMatrix(Js),
        this.quaternion.premultiply(Da.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(QS))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(z0)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      (t.parent = null), t.dispatchEvent(z0);
    }
    return (this.children.length = 0), this;
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Js.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Js.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Js),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, n = this.children.length; i < n; i++) {
      const a = this.children[i].getObjectByProperty(e, t);
      if (a !== void 0) return a;
    }
  }
  getObjectsByProperty(e, t) {
    let i = [];
    this[e] === t && i.push(this);
    for (let n = 0, s = this.children.length; n < s; n++) {
      const a = this.children[n].getObjectsByProperty(e, t);
      a.length > 0 && (i = i.concat(a));
    }
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(tc, e, ZS), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(tc, JS, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++) {
      const s = t[i];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (
      (e === !0 &&
        i !== null &&
        i.matrixWorldAutoUpdate === !0 &&
        i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const n = this.children;
      for (let s = 0, a = n.length; s < a; s++) {
        const o = n[s];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      i = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const n = {};
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== "" && (n.name = this.name),
      this.castShadow === !0 && (n.castShadow = !0),
      this.receiveShadow === !0 && (n.receiveShadow = !0),
      this.visible === !1 && (n.visible = !1),
      this.frustumCulled === !1 && (n.frustumCulled = !1),
      this.renderOrder !== 0 && (n.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      (n.layers = this.layers.mask),
      (n.matrix = this.matrix.toArray()),
      this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((n.type = "InstancedMesh"),
        (n.count = this.count),
        (n.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (n.instanceColor = this.instanceColor.toJSON()));
    function s(o, u) {
      return o[u.uuid] === void 0 && (o[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (n.background = this.background.toJSON())
          : this.background.isTexture &&
            (n.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (n.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      n.geometry = s(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const u = o.shapes;
        if (Array.isArray(u))
          for (let h = 0, f = u.length; h < f; h++) {
            const c = u[h];
            s(e.shapes, c);
          }
        else s(e.shapes, u);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((n.bindMode = this.bindMode),
        (n.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (n.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const o = [];
        for (let u = 0, h = this.material.length; u < h; u++)
          o.push(s(e.materials, this.material[u]));
        n.material = o;
      } else n.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      n.children = [];
      for (let o = 0; o < this.children.length; o++)
        n.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      n.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const u = this.animations[o];
        n.animations.push(s(e.animations, u));
      }
    }
    if (t) {
      const o = a(e.geometries),
        u = a(e.materials),
        h = a(e.textures),
        f = a(e.images),
        c = a(e.shapes),
        d = a(e.skeletons),
        m = a(e.animations),
        x = a(e.nodes);
      o.length > 0 && (i.geometries = o),
        u.length > 0 && (i.materials = u),
        h.length > 0 && (i.textures = h),
        f.length > 0 && (i.images = f),
        c.length > 0 && (i.shapes = c),
        d.length > 0 && (i.skeletons = d),
        m.length > 0 && (i.animations = m),
        x.length > 0 && (i.nodes = x);
    }
    return (i.object = n), i;
    function a(o) {
      const u = [];
      for (const h in o) {
        const f = o[h];
        delete f.metadata, u.push(f);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const n = e.children[i];
        this.add(n.clone());
      }
    return this;
  }
}
ei.DefaultUp = new Z(0, 1, 0);
ei.DefaultMatrixAutoUpdate = !0;
ei.DefaultMatrixWorldAutoUpdate = !0;
const fs = new Z(),
  Qs = new Z(),
  Cp = new Z(),
  er = new Z(),
  Pa = new Z(),
  Aa = new Z(),
  U0 = new Z(),
  Dp = new Z(),
  Pp = new Z(),
  Ap = new Z();
class or {
  constructor(e = new Z(), t = new Z(), i = new Z()) {
    (this.a = e), (this.b = t), (this.c = i);
  }
  static getNormal(e, t, i, n) {
    n.subVectors(i, t), fs.subVectors(e, t), n.cross(fs);
    const s = n.lengthSq();
    return s > 0 ? n.multiplyScalar(1 / Math.sqrt(s)) : n.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, n, s) {
    fs.subVectors(n, t), Qs.subVectors(i, t), Cp.subVectors(e, t);
    const a = fs.dot(fs),
      o = fs.dot(Qs),
      u = fs.dot(Cp),
      h = Qs.dot(Qs),
      f = Qs.dot(Cp),
      c = a * h - o * o;
    if (c === 0) return s.set(-2, -1, -1);
    const d = 1 / c,
      m = (h * u - o * f) * d,
      x = (a * f - o * u) * d;
    return s.set(1 - m - x, x, m);
  }
  static containsPoint(e, t, i, n) {
    return (
      this.getBarycoord(e, t, i, n, er),
      er.x >= 0 && er.y >= 0 && er.x + er.y <= 1
    );
  }
  static getUV(e, t, i, n, s, a, o, u) {
    return (
      this.getBarycoord(e, t, i, n, er),
      u.set(0, 0),
      u.addScaledVector(s, er.x),
      u.addScaledVector(a, er.y),
      u.addScaledVector(o, er.z),
      u
    );
  }
  static isFrontFacing(e, t, i, n) {
    return fs.subVectors(i, t), Qs.subVectors(e, t), fs.cross(Qs).dot(n) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, n) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this;
  }
  setFromAttributeAndIndices(e, t, i, n) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, n),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      fs.subVectors(this.c, this.b),
      Qs.subVectors(this.a, this.b),
      fs.cross(Qs).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return or.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return or.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, i, n, s) {
    return or.getUV(e, this.a, this.b, this.c, t, i, n, s);
  }
  containsPoint(e) {
    return or.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return or.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      n = this.b,
      s = this.c;
    let a, o;
    Pa.subVectors(n, i), Aa.subVectors(s, i), Dp.subVectors(e, i);
    const u = Pa.dot(Dp),
      h = Aa.dot(Dp);
    if (u <= 0 && h <= 0) return t.copy(i);
    Pp.subVectors(e, n);
    const f = Pa.dot(Pp),
      c = Aa.dot(Pp);
    if (f >= 0 && c <= f) return t.copy(n);
    const d = u * c - f * h;
    if (d <= 0 && u >= 0 && f <= 0)
      return (a = u / (u - f)), t.copy(i).addScaledVector(Pa, a);
    Ap.subVectors(e, s);
    const m = Pa.dot(Ap),
      x = Aa.dot(Ap);
    if (x >= 0 && m <= x) return t.copy(s);
    const v = m * h - u * x;
    if (v <= 0 && h >= 0 && x <= 0)
      return (o = h / (h - x)), t.copy(i).addScaledVector(Aa, o);
    const b = f * x - m * c;
    if (b <= 0 && c - f >= 0 && m - x >= 0)
      return (
        U0.subVectors(s, n),
        (o = (c - f) / (c - f + (m - x))),
        t.copy(n).addScaledVector(U0, o)
      );
    const y = 1 / (b + v + d);
    return (
      (a = v * y),
      (o = d * y),
      t.copy(i).addScaledVector(Pa, a).addScaledVector(Aa, o)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let eM = 0;
class Is extends ra {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: eM++ }),
      (this.uuid = bs()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Oo),
      (this.side = Bs),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = J_),
      (this.blendDst = Q_),
      (this.blendEquation = Ga),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = yf),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = LS),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = mp),
      (this.stencilZFail = mp),
      (this.stencilZPass = mp),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.");
          continue;
        }
        const n = this[t];
        if (n === void 0) {
          console.warn(
            "THREE." +
              this.type +
              ": '" +
              t +
              "' is not a property of this material."
          );
          continue;
        }
        n && n.isColor
          ? n.set(i)
          : n && n.isVector3 && i && i.isVector3
          ? n.copy(i)
          : (this[t] = i);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const i = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Oo && (i.blending = this.blending),
      this.side !== Bs && (i.side = this.side),
      this.vertexColors && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = this.transparent),
      (i.depthFunc = this.depthFunc),
      (i.depthTest = this.depthTest),
      (i.depthWrite = this.depthWrite),
      (i.colorWrite = this.colorWrite),
      (i.stencilWrite = this.stencilWrite),
      (i.stencilWriteMask = this.stencilWriteMask),
      (i.stencilFunc = this.stencilFunc),
      (i.stencilRef = this.stencilRef),
      (i.stencilFuncMask = this.stencilFuncMask),
      (i.stencilFail = this.stencilFail),
      (i.stencilZFail = this.stencilZFail),
      (i.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (i.premultipliedAlpha = this.premultipliedAlpha),
      this.wireframe === !0 && (i.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = this.flatShading),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function n(s) {
      const a = [];
      for (const o in s) {
        const u = s[o];
        delete u.metadata, a.push(u);
      }
      return a;
    }
    if (t) {
      const s = n(e.textures),
        a = n(e.images);
      s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const n = t.length;
      i = new Array(n);
      for (let s = 0; s !== n; ++s) i[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class cr extends Is {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new ct(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = eb),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const vi = new Z(),
  Yu = new Ue();
class an {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = Ef),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.itemSize), (i *= t.itemSize);
    for (let n = 0, s = this.itemSize; n < s; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        Yu.fromBufferAttribute(this, t),
          Yu.applyMatrix3(e),
          this.setXY(t, Yu.x, Yu.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        vi.fromBufferAttribute(this, t),
          vi.applyMatrix3(e),
          this.setXYZ(t, vi.x, vi.y, vi.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      vi.fromBufferAttribute(this, t),
        vi.applyMatrix4(e),
        this.setXYZ(t, vi.x, vi.y, vi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      vi.fromBufferAttribute(this, t),
        vi.applyNormalMatrix(e),
        this.setXYZ(t, vi.x, vi.y, vi.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      vi.fromBufferAttribute(this, t),
        vi.transformDirection(e),
        this.setXYZ(t, vi.x, vi.y, vi.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = lr(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = $t(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = lr(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = $t(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = lr(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = $t(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = lr(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = $t(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = $t(t, this.array)), (i = $t(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, n) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = $t(t, this.array)),
        (i = $t(i, this.array)),
        (n = $t(n, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = n),
      this
    );
  }
  setXYZW(e, t, i, n, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = $t(t, this.array)),
        (i = $t(i, this.array)),
        (n = $t(n, this.array)),
        (s = $t(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = n),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Ef && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    );
  }
  copyColorsArray() {
    console.error(
      "THREE.BufferAttribute: copyColorsArray() was removed in r144."
    );
  }
  copyVector2sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector2sArray() was removed in r144."
    );
  }
  copyVector3sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector3sArray() was removed in r144."
    );
  }
  copyVector4sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector4sArray() was removed in r144."
    );
  }
}
class db extends an {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class pb extends an {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class xn extends an {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
let tM = 0;
const $n = new At(),
  Lp = new ei(),
  La = new Z(),
  Pn = new Tl(),
  ic = new Tl(),
  Ci = new Z();
class cn extends ra {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: tM++ }),
      (this.uuid = bs()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (ab(e) ? pb : db)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new Nn().getNormalMatrix(e);
      i.applyNormalMatrix(s), (i.needsUpdate = !0);
    }
    const n = this.attributes.tangent;
    return (
      n !== void 0 && (n.transformDirection(e), (n.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return $n.makeRotationFromQuaternion(e), this.applyMatrix4($n), this;
  }
  rotateX(e) {
    return $n.makeRotationX(e), this.applyMatrix4($n), this;
  }
  rotateY(e) {
    return $n.makeRotationY(e), this.applyMatrix4($n), this;
  }
  rotateZ(e) {
    return $n.makeRotationZ(e), this.applyMatrix4($n), this;
  }
  translate(e, t, i) {
    return $n.makeTranslation(e, t, i), this.applyMatrix4($n), this;
  }
  scale(e, t, i) {
    return $n.makeScale(e, t, i), this.applyMatrix4($n), this;
  }
  lookAt(e) {
    return Lp.lookAt(e), Lp.updateMatrix(), this.applyMatrix4(Lp.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(La).negate(),
      this.translate(La.x, La.y, La.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const s = e[i];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new xn(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Tl());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new Z(-1 / 0, -1 / 0, -1 / 0),
          new Z(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, n = t.length; i < n; i++) {
          const s = t[i];
          Pn.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Ci.addVectors(this.boundingBox.min, Pn.min),
                this.boundingBox.expandByPoint(Ci),
                Ci.addVectors(this.boundingBox.max, Pn.max),
                this.boundingBox.expandByPoint(Ci))
              : (this.boundingBox.expandByPoint(Pn.min),
                this.boundingBox.expandByPoint(Pn.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new El());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new Z(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if ((Pn.setFromBufferAttribute(e), t))
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s];
          ic.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (Ci.addVectors(Pn.min, ic.min),
                Pn.expandByPoint(Ci),
                Ci.addVectors(Pn.max, ic.max),
                Pn.expandByPoint(Ci))
              : (Pn.expandByPoint(ic.min), Pn.expandByPoint(ic.max));
        }
      Pn.getCenter(i);
      let n = 0;
      for (let s = 0, a = e.count; s < a; s++)
        Ci.fromBufferAttribute(e, s),
          (n = Math.max(n, i.distanceToSquared(Ci)));
      if (t)
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s],
            u = this.morphTargetsRelative;
          for (let h = 0, f = o.count; h < f; h++)
            Ci.fromBufferAttribute(o, h),
              u && (La.fromBufferAttribute(e, h), Ci.add(La)),
              (n = Math.max(n, i.distanceToSquared(Ci)));
        }
      (this.boundingSphere.radius = Math.sqrt(n)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const i = e.array,
      n = t.position.array,
      s = t.normal.array,
      a = t.uv.array,
      o = n.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new an(new Float32Array(4 * o), 4));
    const u = this.getAttribute("tangent").array,
      h = [],
      f = [];
    for (let O = 0; O < o; O++) (h[O] = new Z()), (f[O] = new Z());
    const c = new Z(),
      d = new Z(),
      m = new Z(),
      x = new Ue(),
      v = new Ue(),
      b = new Ue(),
      y = new Z(),
      M = new Z();
    function D(O, J, ee) {
      c.fromArray(n, O * 3),
        d.fromArray(n, J * 3),
        m.fromArray(n, ee * 3),
        x.fromArray(a, O * 2),
        v.fromArray(a, J * 2),
        b.fromArray(a, ee * 2),
        d.sub(c),
        m.sub(c),
        v.sub(x),
        b.sub(x);
      const X = 1 / (v.x * b.y - b.x * v.y);
      isFinite(X) &&
        (y
          .copy(d)
          .multiplyScalar(b.y)
          .addScaledVector(m, -v.y)
          .multiplyScalar(X),
        M.copy(m)
          .multiplyScalar(v.x)
          .addScaledVector(d, -b.x)
          .multiplyScalar(X),
        h[O].add(y),
        h[J].add(y),
        h[ee].add(y),
        f[O].add(M),
        f[J].add(M),
        f[ee].add(M));
    }
    let C = this.groups;
    C.length === 0 && (C = [{ start: 0, count: i.length }]);
    for (let O = 0, J = C.length; O < J; ++O) {
      const ee = C[O],
        X = ee.start,
        j = ee.count;
      for (let Y = X, ie = X + j; Y < ie; Y += 3)
        D(i[Y + 0], i[Y + 1], i[Y + 2]);
    }
    const A = new Z(),
      I = new Z(),
      F = new Z(),
      P = new Z();
    function k(O) {
      F.fromArray(s, O * 3), P.copy(F);
      const J = h[O];
      A.copy(J),
        A.sub(F.multiplyScalar(F.dot(J))).normalize(),
        I.crossVectors(P, J);
      const X = I.dot(f[O]) < 0 ? -1 : 1;
      (u[O * 4] = A.x),
        (u[O * 4 + 1] = A.y),
        (u[O * 4 + 2] = A.z),
        (u[O * 4 + 3] = X);
    }
    for (let O = 0, J = C.length; O < J; ++O) {
      const ee = C[O],
        X = ee.start,
        j = ee.count;
      for (let Y = X, ie = X + j; Y < ie; Y += 3)
        k(i[Y + 0]), k(i[Y + 1]), k(i[Y + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        (i = new an(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", i);
      else for (let d = 0, m = i.count; d < m; d++) i.setXYZ(d, 0, 0, 0);
      const n = new Z(),
        s = new Z(),
        a = new Z(),
        o = new Z(),
        u = new Z(),
        h = new Z(),
        f = new Z(),
        c = new Z();
      if (e)
        for (let d = 0, m = e.count; d < m; d += 3) {
          const x = e.getX(d + 0),
            v = e.getX(d + 1),
            b = e.getX(d + 2);
          n.fromBufferAttribute(t, x),
            s.fromBufferAttribute(t, v),
            a.fromBufferAttribute(t, b),
            f.subVectors(a, s),
            c.subVectors(n, s),
            f.cross(c),
            o.fromBufferAttribute(i, x),
            u.fromBufferAttribute(i, v),
            h.fromBufferAttribute(i, b),
            o.add(f),
            u.add(f),
            h.add(f),
            i.setXYZ(x, o.x, o.y, o.z),
            i.setXYZ(v, u.x, u.y, u.z),
            i.setXYZ(b, h.x, h.y, h.z);
        }
      else
        for (let d = 0, m = t.count; d < m; d += 3)
          n.fromBufferAttribute(t, d + 0),
            s.fromBufferAttribute(t, d + 1),
            a.fromBufferAttribute(t, d + 2),
            f.subVectors(a, s),
            c.subVectors(n, s),
            f.cross(c),
            i.setXYZ(d + 0, f.x, f.y, f.z),
            i.setXYZ(d + 1, f.x, f.y, f.z),
            i.setXYZ(d + 2, f.x, f.y, f.z);
      this.normalizeNormals(), (i.needsUpdate = !0);
    }
  }
  merge() {
    return (
      console.error(
        "THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."
      ),
      this
    );
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      Ci.fromBufferAttribute(e, t),
        Ci.normalize(),
        e.setXYZ(t, Ci.x, Ci.y, Ci.z);
  }
  toNonIndexed() {
    function e(o, u) {
      const h = o.array,
        f = o.itemSize,
        c = o.normalized,
        d = new h.constructor(u.length * f);
      let m = 0,
        x = 0;
      for (let v = 0, b = u.length; v < b; v++) {
        o.isInterleavedBufferAttribute
          ? (m = u[v] * o.data.stride + o.offset)
          : (m = u[v] * f);
        for (let y = 0; y < f; y++) d[x++] = h[m++];
      }
      return new an(d, f, c);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new cn(),
      i = this.index.array,
      n = this.attributes;
    for (const o in n) {
      const u = n[o],
        h = e(u, i);
      t.setAttribute(o, h);
    }
    const s = this.morphAttributes;
    for (const o in s) {
      const u = [],
        h = s[o];
      for (let f = 0, c = h.length; f < c; f++) {
        const d = h[f],
          m = e(d, i);
        u.push(m);
      }
      t.morphAttributes[o] = u;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, u = a.length; o < u; o++) {
      const h = a[o];
      t.addGroup(h.start, h.count, h.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const u = this.parameters;
      for (const h in u) u[h] !== void 0 && (e[h] = u[h]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const i = this.attributes;
    for (const u in i) {
      const h = i[u];
      e.data.attributes[u] = h.toJSON(e.data);
    }
    const n = {};
    let s = !1;
    for (const u in this.morphAttributes) {
      const h = this.morphAttributes[u],
        f = [];
      for (let c = 0, d = h.length; c < d; c++) {
        const m = h[c];
        f.push(m.toJSON(e.data));
      }
      f.length > 0 && ((n[u] = f), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = n),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return (
      o !== null &&
        (e.data.boundingSphere = {
          center: o.center.toArray(),
          radius: o.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const n = e.attributes;
    for (const h in n) {
      const f = n[h];
      this.setAttribute(h, f.clone(t));
    }
    const s = e.morphAttributes;
    for (const h in s) {
      const f = [],
        c = s[h];
      for (let d = 0, m = c.length; d < m; d++) f.push(c[d].clone(t));
      this.morphAttributes[h] = f;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let h = 0, f = a.length; h < f; h++) {
      const c = a[h];
      this.addGroup(c.start, c.count, c.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const u = e.boundingSphere;
    return (
      u !== null && (this.boundingSphere = u.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      e.parameters !== void 0 &&
        (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const G0 = new At(),
  Ra = new cd(),
  Rp = new El(),
  nc = new Z(),
  sc = new Z(),
  rc = new Z(),
  kp = new Z(),
  Ku = new Z(),
  Zu = new Ue(),
  Ju = new Ue(),
  Qu = new Ue(),
  Ip = new Z(),
  eh = new Z();
class Wi extends ei {
  constructor(e = new cn(), t = new cr()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = n.length; s < a; s++) {
          const o = n[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      n = i.attributes.position,
      s = i.morphAttributes.position,
      a = i.morphTargetsRelative;
    t.fromBufferAttribute(n, e);
    const o = this.morphTargetInfluences;
    if (s && o) {
      Ku.set(0, 0, 0);
      for (let u = 0, h = s.length; u < h; u++) {
        const f = o[u],
          c = s[u];
        f !== 0 &&
          (kp.fromBufferAttribute(c, e),
          a ? Ku.addScaledVector(kp, f) : Ku.addScaledVector(kp.sub(t), f));
      }
      t.add(Ku);
    }
    return this.isSkinnedMesh && this.boneTransform(e, t), t;
  }
  raycast(e, t) {
    const i = this.geometry,
      n = this.material,
      s = this.matrixWorld;
    if (
      n === void 0 ||
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Rp.copy(i.boundingSphere),
      Rp.applyMatrix4(s),
      e.ray.intersectsSphere(Rp) === !1) ||
      (G0.copy(s).invert(),
      Ra.copy(e.ray).applyMatrix4(G0),
      i.boundingBox !== null && Ra.intersectsBox(i.boundingBox) === !1)
    )
      return;
    let a;
    const o = i.index,
      u = i.attributes.position,
      h = i.attributes.uv,
      f = i.attributes.uv2,
      c = i.groups,
      d = i.drawRange;
    if (o !== null)
      if (Array.isArray(n))
        for (let m = 0, x = c.length; m < x; m++) {
          const v = c[m],
            b = n[v.materialIndex],
            y = Math.max(v.start, d.start),
            M = Math.min(
              o.count,
              Math.min(v.start + v.count, d.start + d.count)
            );
          for (let D = y, C = M; D < C; D += 3) {
            const A = o.getX(D),
              I = o.getX(D + 1),
              F = o.getX(D + 2);
            (a = th(this, b, e, Ra, h, f, A, I, F)),
              a &&
                ((a.faceIndex = Math.floor(D / 3)),
                (a.face.materialIndex = v.materialIndex),
                t.push(a));
          }
        }
      else {
        const m = Math.max(0, d.start),
          x = Math.min(o.count, d.start + d.count);
        for (let v = m, b = x; v < b; v += 3) {
          const y = o.getX(v),
            M = o.getX(v + 1),
            D = o.getX(v + 2);
          (a = th(this, n, e, Ra, h, f, y, M, D)),
            a && ((a.faceIndex = Math.floor(v / 3)), t.push(a));
        }
      }
    else if (u !== void 0)
      if (Array.isArray(n))
        for (let m = 0, x = c.length; m < x; m++) {
          const v = c[m],
            b = n[v.materialIndex],
            y = Math.max(v.start, d.start),
            M = Math.min(
              u.count,
              Math.min(v.start + v.count, d.start + d.count)
            );
          for (let D = y, C = M; D < C; D += 3) {
            const A = D,
              I = D + 1,
              F = D + 2;
            (a = th(this, b, e, Ra, h, f, A, I, F)),
              a &&
                ((a.faceIndex = Math.floor(D / 3)),
                (a.face.materialIndex = v.materialIndex),
                t.push(a));
          }
        }
      else {
        const m = Math.max(0, d.start),
          x = Math.min(u.count, d.start + d.count);
        for (let v = m, b = x; v < b; v += 3) {
          const y = v,
            M = v + 1,
            D = v + 2;
          (a = th(this, n, e, Ra, h, f, y, M, D)),
            a && ((a.faceIndex = Math.floor(v / 3)), t.push(a));
        }
      }
  }
}
function iM(r, e, t, i, n, s, a, o) {
  let u;
  if (
    (e.side === Bn
      ? (u = i.intersectTriangle(a, s, n, !0, o))
      : (u = i.intersectTriangle(n, s, a, e.side === Bs, o)),
    u === null)
  )
    return null;
  eh.copy(o), eh.applyMatrix4(r.matrixWorld);
  const h = t.ray.origin.distanceTo(eh);
  return h < t.near || h > t.far
    ? null
    : { distance: h, point: eh.clone(), object: r };
}
function th(r, e, t, i, n, s, a, o, u) {
  r.getVertexPosition(a, nc),
    r.getVertexPosition(o, sc),
    r.getVertexPosition(u, rc);
  const h = iM(r, e, t, i, nc, sc, rc, Ip);
  if (h) {
    n &&
      (Zu.fromBufferAttribute(n, a),
      Ju.fromBufferAttribute(n, o),
      Qu.fromBufferAttribute(n, u),
      (h.uv = or.getUV(Ip, nc, sc, rc, Zu, Ju, Qu, new Ue()))),
      s &&
        (Zu.fromBufferAttribute(s, a),
        Ju.fromBufferAttribute(s, o),
        Qu.fromBufferAttribute(s, u),
        (h.uv2 = or.getUV(Ip, nc, sc, rc, Zu, Ju, Qu, new Ue())));
    const f = { a, b: o, c: u, normal: new Z(), materialIndex: 0 };
    or.getNormal(nc, sc, rc, f.normal), (h.face = f);
  }
  return h;
}
class ou extends cn {
  constructor(e = 1, t = 1, i = 1, n = 1, s = 1, a = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: n,
        heightSegments: s,
        depthSegments: a,
      });
    const o = this;
    (n = Math.floor(n)), (s = Math.floor(s)), (a = Math.floor(a));
    const u = [],
      h = [],
      f = [],
      c = [];
    let d = 0,
      m = 0;
    x("z", "y", "x", -1, -1, i, t, e, a, s, 0),
      x("z", "y", "x", 1, -1, i, t, -e, a, s, 1),
      x("x", "z", "y", 1, 1, e, i, t, n, a, 2),
      x("x", "z", "y", 1, -1, e, i, -t, n, a, 3),
      x("x", "y", "z", 1, -1, e, t, i, n, s, 4),
      x("x", "y", "z", -1, -1, e, t, -i, n, s, 5),
      this.setIndex(u),
      this.setAttribute("position", new xn(h, 3)),
      this.setAttribute("normal", new xn(f, 3)),
      this.setAttribute("uv", new xn(c, 2));
    function x(v, b, y, M, D, C, A, I, F, P, k) {
      const O = C / F,
        J = A / P,
        ee = C / 2,
        X = A / 2,
        j = I / 2,
        Y = F + 1,
        ie = P + 1;
      let Q = 0,
        V = 0;
      const ve = new Z();
      for (let U = 0; U < ie; U++) {
        const oe = U * J - X;
        for (let ue = 0; ue < Y; ue++) {
          const fe = ue * O - ee;
          (ve[v] = fe * M),
            (ve[b] = oe * D),
            (ve[y] = j),
            h.push(ve.x, ve.y, ve.z),
            (ve[v] = 0),
            (ve[b] = 0),
            (ve[y] = I > 0 ? 1 : -1),
            f.push(ve.x, ve.y, ve.z),
            c.push(ue / F),
            c.push(1 - U / P),
            (Q += 1);
        }
      }
      for (let U = 0; U < P; U++)
        for (let oe = 0; oe < F; oe++) {
          const ue = d + oe + Y * U,
            fe = d + oe + Y * (U + 1),
            le = d + (oe + 1) + Y * (U + 1),
            be = d + (oe + 1) + Y * U;
          u.push(ue, fe, be), u.push(fe, le, be), (V += 6);
        }
      o.addGroup(m, V, k), (m += V), (d += Q);
    }
  }
  static fromJSON(e) {
    return new ou(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function hl(r) {
  const e = {};
  for (const t in r) {
    e[t] = {};
    for (const i in r[t]) {
      const n = r[t][i];
      n &&
      (n.isColor ||
        n.isMatrix3 ||
        n.isMatrix4 ||
        n.isVector2 ||
        n.isVector3 ||
        n.isVector4 ||
        n.isTexture ||
        n.isQuaternion)
        ? (e[t][i] = n.clone())
        : Array.isArray(n)
        ? (e[t][i] = n.slice())
        : (e[t][i] = n);
    }
  }
  return e;
}
function Qi(r) {
  const e = {};
  for (let t = 0; t < r.length; t++) {
    const i = hl(r[t]);
    for (const n in i) e[n] = i[n];
  }
  return e;
}
function nM(r) {
  const e = [];
  for (let t = 0; t < r.length; t++) e.push(r[t].clone());
  return e;
}
function fb(r) {
  return r.getRenderTarget() === null && r.outputEncoding === Ht ? Ds : Uc;
}
const sM = { clone: hl, merge: Qi };
var rM = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  oM = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class vr extends Is {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = rM),
      (this.fragmentShader = oM),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = hl(e.uniforms)),
      (this.uniformsGroups = nM(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const n in this.uniforms) {
      const a = this.uniforms[n].value;
      a && a.isTexture
        ? (t.uniforms[n] = { type: "t", value: a.toJSON(e).uuid })
        : a && a.isColor
        ? (t.uniforms[n] = { type: "c", value: a.getHex() })
        : a && a.isVector2
        ? (t.uniforms[n] = { type: "v2", value: a.toArray() })
        : a && a.isVector3
        ? (t.uniforms[n] = { type: "v3", value: a.toArray() })
        : a && a.isVector4
        ? (t.uniforms[n] = { type: "v4", value: a.toArray() })
        : a && a.isMatrix3
        ? (t.uniforms[n] = { type: "m3", value: a.toArray() })
        : a && a.isMatrix4
        ? (t.uniforms[n] = { type: "m4", value: a.toArray() })
        : (t.uniforms[n] = { value: a });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader);
    const i = {};
    for (const n in this.extensions) this.extensions[n] === !0 && (i[n] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class xm extends ei {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new At()),
      (this.projectionMatrix = new At()),
      (this.projectionMatrixInverse = new At());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Gi extends xm {
  constructor(e = 50, t = 1, i = 0.1, n = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = n),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = Gc * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Sc * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return Gc * 2 * Math.atan(Math.tan(Sc * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, i, n, s, a) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = n),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(Sc * 0.5 * this.fov)) / this.zoom,
      i = 2 * t,
      n = this.aspect * i,
      s = -0.5 * n;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const u = a.fullWidth,
        h = a.fullHeight;
      (s += (a.offsetX * n) / u),
        (t -= (a.offsetY * i) / h),
        (n *= a.width / u),
        (i *= a.height / h);
    }
    const o = this.filmOffset;
    o !== 0 && (s += (e * o) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(s, s + n, t, t - i, e, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const ka = -90,
  Ia = 1;
class aM extends ei {
  constructor(e, t, i) {
    super(), (this.type = "CubeCamera"), (this.renderTarget = i);
    const n = new Gi(ka, Ia, e, t);
    (n.layers = this.layers), n.up.set(0, 1, 0), n.lookAt(1, 0, 0), this.add(n);
    const s = new Gi(ka, Ia, e, t);
    (s.layers = this.layers),
      s.up.set(0, 1, 0),
      s.lookAt(-1, 0, 0),
      this.add(s);
    const a = new Gi(ka, Ia, e, t);
    (a.layers = this.layers),
      a.up.set(0, 0, -1),
      a.lookAt(0, 1, 0),
      this.add(a);
    const o = new Gi(ka, Ia, e, t);
    (o.layers = this.layers),
      o.up.set(0, 0, 1),
      o.lookAt(0, -1, 0),
      this.add(o);
    const u = new Gi(ka, Ia, e, t);
    (u.layers = this.layers), u.up.set(0, 1, 0), u.lookAt(0, 0, 1), this.add(u);
    const h = new Gi(ka, Ia, e, t);
    (h.layers = this.layers),
      h.up.set(0, 1, 0),
      h.lookAt(0, 0, -1),
      this.add(h);
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const i = this.renderTarget,
      [n, s, a, o, u, h] = this.children,
      f = e.getRenderTarget(),
      c = e.toneMapping,
      d = e.xr.enabled;
    (e.toneMapping = pr), (e.xr.enabled = !1);
    const m = i.texture.generateMipmaps;
    (i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0),
      e.render(t, n),
      e.setRenderTarget(i, 1),
      e.render(t, s),
      e.setRenderTarget(i, 2),
      e.render(t, a),
      e.setRenderTarget(i, 3),
      e.render(t, o),
      e.setRenderTarget(i, 4),
      e.render(t, u),
      (i.texture.generateMipmaps = m),
      e.setRenderTarget(i, 5),
      e.render(t, h),
      e.setRenderTarget(f),
      (e.toneMapping = c),
      (e.xr.enabled = d),
      (i.texture.needsPMREMUpdate = !0);
  }
}
class mb extends xi {
  constructor(e, t, i, n, s, a, o, u, h, f) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : al),
      super(e, t, i, n, s, a, o, u, h, f),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class lM extends Zo {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const i = { width: e, height: e, depth: 1 },
      n = [i, i, i, i, i, i];
    (this.texture = new mb(
      n,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.encoding
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Ui);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.encoding = t.encoding),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      n = new ou(5, 5, 5),
      s = new vr({
        name: "CubemapFromEquirect",
        uniforms: hl(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: Bn,
        blending: dr,
      });
    s.uniforms.tEquirect.value = t;
    const a = new Wi(n, s),
      o = t.minFilter;
    return (
      t.minFilter === mr && (t.minFilter = Ui),
      new aM(1, 10, this).update(e, a),
      (t.minFilter = o),
      a.geometry.dispose(),
      a.material.dispose(),
      this
    );
  }
  clear(e, t, i, n) {
    const s = e.getRenderTarget();
    for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, i, n);
    e.setRenderTarget(s);
  }
}
const Fp = new Z(),
  cM = new Z(),
  uM = new Nn();
class Mo {
  constructor(e = new Z(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, i, n) {
    return this.normal.set(e, t, i), (this.constant = n), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const n = Fp.subVectors(i, t).cross(cM.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(n, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, t) {
    const i = e.delta(Fp),
      n = this.normal.dot(i);
    if (n === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / n;
    return s < 0 || s > 1 ? null : t.copy(i).multiplyScalar(s).add(e.start);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (t < 0 && i > 0) || (i < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || uM.getNormalMatrix(e),
      n = this.coplanarPoint(Fp).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize();
    return (this.constant = -n.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Fa = new El(),
  ih = new Z();
class wm {
  constructor(
    e = new Mo(),
    t = new Mo(),
    i = new Mo(),
    n = new Mo(),
    s = new Mo(),
    a = new Mo()
  ) {
    this.planes = [e, t, i, n, s, a];
  }
  set(e, t, i, n, s, a) {
    const o = this.planes;
    return (
      o[0].copy(e),
      o[1].copy(t),
      o[2].copy(i),
      o[3].copy(n),
      o[4].copy(s),
      o[5].copy(a),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes,
      i = e.elements,
      n = i[0],
      s = i[1],
      a = i[2],
      o = i[3],
      u = i[4],
      h = i[5],
      f = i[6],
      c = i[7],
      d = i[8],
      m = i[9],
      x = i[10],
      v = i[11],
      b = i[12],
      y = i[13],
      M = i[14],
      D = i[15];
    return (
      t[0].setComponents(o - n, c - u, v - d, D - b).normalize(),
      t[1].setComponents(o + n, c + u, v + d, D + b).normalize(),
      t[2].setComponents(o + s, c + h, v + m, D + y).normalize(),
      t[3].setComponents(o - s, c - h, v - m, D - y).normalize(),
      t[4].setComponents(o - a, c - f, v - x, D - M).normalize(),
      t[5].setComponents(o + a, c + f, v + x, D + M).normalize(),
      this
    );
  }
  intersectsObject(e) {
    const t = e.geometry;
    return (
      t.boundingSphere === null && t.computeBoundingSphere(),
      Fa.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Fa)
    );
  }
  intersectsSprite(e) {
    return (
      Fa.center.set(0, 0, 0),
      (Fa.radius = 0.7071067811865476),
      Fa.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Fa)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      n = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < n) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const n = t[i];
      if (
        ((ih.x = n.normal.x > 0 ? e.max.x : e.min.x),
        (ih.y = n.normal.y > 0 ? e.max.y : e.min.y),
        (ih.z = n.normal.z > 0 ? e.max.z : e.min.z),
        n.distanceToPoint(ih) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function gb() {
  let r = null,
    e = !1,
    t = null,
    i = null;
  function n(s, a) {
    t(s, a), (i = r.requestAnimationFrame(n));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((i = r.requestAnimationFrame(n)), (e = !0));
    },
    stop: function () {
      r.cancelAnimationFrame(i), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      r = s;
    },
  };
}
function hM(r, e) {
  const t = e.isWebGL2,
    i = new WeakMap();
  function n(h, f) {
    const c = h.array,
      d = h.usage,
      m = r.createBuffer();
    r.bindBuffer(f, m), r.bufferData(f, c, d), h.onUploadCallback();
    let x;
    if (c instanceof Float32Array) x = 5126;
    else if (c instanceof Uint16Array)
      if (h.isFloat16BufferAttribute)
        if (t) x = 5131;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else x = 5123;
    else if (c instanceof Int16Array) x = 5122;
    else if (c instanceof Uint32Array) x = 5125;
    else if (c instanceof Int32Array) x = 5124;
    else if (c instanceof Int8Array) x = 5120;
    else if (c instanceof Uint8Array) x = 5121;
    else if (c instanceof Uint8ClampedArray) x = 5121;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + c
      );
    return {
      buffer: m,
      type: x,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: h.version,
    };
  }
  function s(h, f, c) {
    const d = f.array,
      m = f.updateRange;
    r.bindBuffer(c, h),
      m.count === -1
        ? r.bufferSubData(c, 0, d)
        : (t
            ? r.bufferSubData(
                c,
                m.offset * d.BYTES_PER_ELEMENT,
                d,
                m.offset,
                m.count
              )
            : r.bufferSubData(
                c,
                m.offset * d.BYTES_PER_ELEMENT,
                d.subarray(m.offset, m.offset + m.count)
              ),
          (m.count = -1)),
      f.onUploadCallback();
  }
  function a(h) {
    return h.isInterleavedBufferAttribute && (h = h.data), i.get(h);
  }
  function o(h) {
    h.isInterleavedBufferAttribute && (h = h.data);
    const f = i.get(h);
    f && (r.deleteBuffer(f.buffer), i.delete(h));
  }
  function u(h, f) {
    if (h.isGLBufferAttribute) {
      const d = i.get(h);
      (!d || d.version < h.version) &&
        i.set(h, {
          buffer: h.buffer,
          type: h.type,
          bytesPerElement: h.elementSize,
          version: h.version,
        });
      return;
    }
    h.isInterleavedBufferAttribute && (h = h.data);
    const c = i.get(h);
    c === void 0
      ? i.set(h, n(h, f))
      : c.version < h.version && (s(c.buffer, h, f), (c.version = h.version));
  }
  return { get: a, remove: o, update: u };
}
class au extends cn {
  constructor(e = 1, t = 1, i = 1, n = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: n,
      });
    const s = e / 2,
      a = t / 2,
      o = Math.floor(i),
      u = Math.floor(n),
      h = o + 1,
      f = u + 1,
      c = e / o,
      d = t / u,
      m = [],
      x = [],
      v = [],
      b = [];
    for (let y = 0; y < f; y++) {
      const M = y * d - a;
      for (let D = 0; D < h; D++) {
        const C = D * c - s;
        x.push(C, -M, 0), v.push(0, 0, 1), b.push(D / o), b.push(1 - y / u);
      }
    }
    for (let y = 0; y < u; y++)
      for (let M = 0; M < o; M++) {
        const D = M + h * y,
          C = M + h * (y + 1),
          A = M + 1 + h * (y + 1),
          I = M + 1 + h * y;
        m.push(D, C, I), m.push(C, A, I);
      }
    this.setIndex(m),
      this.setAttribute("position", new xn(x, 3)),
      this.setAttribute("normal", new xn(v, 3)),
      this.setAttribute("uv", new xn(b, 2));
  }
  static fromJSON(e) {
    return new au(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var dM = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
  pM = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  fM = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  mM = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  gM = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  vM = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  _M = "vec3 transformed = vec3( position );",
  bM = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  xM = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
  wM = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  yM = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  SM = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  MM = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  TM = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  EM = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  CM = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  DM = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  PM = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  AM = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  LM = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
  RM = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  kM = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  IM = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  FM = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
  OM = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  NM = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  BM = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  VM = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  zM = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  UM = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  GM = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  HM = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  WM = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  jM = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  qM = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  XM = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  $M = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  YM = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  KM = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  ZM = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  JM = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  QM = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  eT = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  tT = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
  iT = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  nT = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  sT = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  rT = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  oT = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
  aT = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  lT = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  cT = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  uT = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  hT = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  dT = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  pT = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  fT = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  mT = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  gT = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  vT = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  _T = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  bT = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  xT = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  wT = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  yT = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  ST = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  MT = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  TT = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
  ET = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  CT = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  DT = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  PT = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  AT = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
  LT = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  RT = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
  kT = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
  IT = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  FT = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  OT = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
  NT = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  BT = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  VT = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  zT = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  UT = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  GT = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  HT = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  WT = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  jT = `#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
  qT = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  XT = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  $T = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  YT = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  KT = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  ZT = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  JT = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  QT = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  eE = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  tE = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
  iE = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
  nE = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
  sE = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
  rE = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
  oE = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
  aE = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
  lE = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
  cE = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const uE = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  hE = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  dE = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  pE = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  fE = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  mE = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  gE = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  vE = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  _E = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  bE = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  xE = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  wE = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  yE = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  SE = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  ME = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  TE = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  EE = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  CE = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  DE = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  PE = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  AE = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  LE = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  RE = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  kE = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  IE = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  FE = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  OE = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  NE = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  BE = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  VE = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  zE = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  UE = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  GE = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  HE = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  Tt = {
    alphamap_fragment: dM,
    alphamap_pars_fragment: pM,
    alphatest_fragment: fM,
    alphatest_pars_fragment: mM,
    aomap_fragment: gM,
    aomap_pars_fragment: vM,
    begin_vertex: _M,
    beginnormal_vertex: bM,
    bsdfs: xM,
    iridescence_fragment: wM,
    bumpmap_pars_fragment: yM,
    clipping_planes_fragment: SM,
    clipping_planes_pars_fragment: MM,
    clipping_planes_pars_vertex: TM,
    clipping_planes_vertex: EM,
    color_fragment: CM,
    color_pars_fragment: DM,
    color_pars_vertex: PM,
    color_vertex: AM,
    common: LM,
    cube_uv_reflection_fragment: RM,
    defaultnormal_vertex: kM,
    displacementmap_pars_vertex: IM,
    displacementmap_vertex: FM,
    emissivemap_fragment: OM,
    emissivemap_pars_fragment: NM,
    encodings_fragment: BM,
    encodings_pars_fragment: VM,
    envmap_fragment: zM,
    envmap_common_pars_fragment: UM,
    envmap_pars_fragment: GM,
    envmap_pars_vertex: HM,
    envmap_physical_pars_fragment: tT,
    envmap_vertex: WM,
    fog_vertex: jM,
    fog_pars_vertex: qM,
    fog_fragment: XM,
    fog_pars_fragment: $M,
    gradientmap_pars_fragment: YM,
    lightmap_fragment: KM,
    lightmap_pars_fragment: ZM,
    lights_lambert_fragment: JM,
    lights_lambert_pars_fragment: QM,
    lights_pars_begin: eT,
    lights_toon_fragment: iT,
    lights_toon_pars_fragment: nT,
    lights_phong_fragment: sT,
    lights_phong_pars_fragment: rT,
    lights_physical_fragment: oT,
    lights_physical_pars_fragment: aT,
    lights_fragment_begin: lT,
    lights_fragment_maps: cT,
    lights_fragment_end: uT,
    logdepthbuf_fragment: hT,
    logdepthbuf_pars_fragment: dT,
    logdepthbuf_pars_vertex: pT,
    logdepthbuf_vertex: fT,
    map_fragment: mT,
    map_pars_fragment: gT,
    map_particle_fragment: vT,
    map_particle_pars_fragment: _T,
    metalnessmap_fragment: bT,
    metalnessmap_pars_fragment: xT,
    morphcolor_vertex: wT,
    morphnormal_vertex: yT,
    morphtarget_pars_vertex: ST,
    morphtarget_vertex: MT,
    normal_fragment_begin: TT,
    normal_fragment_maps: ET,
    normal_pars_fragment: CT,
    normal_pars_vertex: DT,
    normal_vertex: PT,
    normalmap_pars_fragment: AT,
    clearcoat_normal_fragment_begin: LT,
    clearcoat_normal_fragment_maps: RT,
    clearcoat_pars_fragment: kT,
    iridescence_pars_fragment: IT,
    output_fragment: FT,
    packing: OT,
    premultiplied_alpha_fragment: NT,
    project_vertex: BT,
    dithering_fragment: VT,
    dithering_pars_fragment: zT,
    roughnessmap_fragment: UT,
    roughnessmap_pars_fragment: GT,
    shadowmap_pars_fragment: HT,
    shadowmap_pars_vertex: WT,
    shadowmap_vertex: jT,
    shadowmask_pars_fragment: qT,
    skinbase_vertex: XT,
    skinning_pars_vertex: $T,
    skinning_vertex: YT,
    skinnormal_vertex: KT,
    specularmap_fragment: ZT,
    specularmap_pars_fragment: JT,
    tonemapping_fragment: QT,
    tonemapping_pars_fragment: eE,
    transmission_fragment: tE,
    transmission_pars_fragment: iE,
    uv_pars_fragment: nE,
    uv_pars_vertex: sE,
    uv_vertex: rE,
    uv2_pars_fragment: oE,
    uv2_pars_vertex: aE,
    uv2_vertex: lE,
    worldpos_vertex: cE,
    background_vert: uE,
    background_frag: hE,
    backgroundCube_vert: dE,
    backgroundCube_frag: pE,
    cube_vert: fE,
    cube_frag: mE,
    depth_vert: gE,
    depth_frag: vE,
    distanceRGBA_vert: _E,
    distanceRGBA_frag: bE,
    equirect_vert: xE,
    equirect_frag: wE,
    linedashed_vert: yE,
    linedashed_frag: SE,
    meshbasic_vert: ME,
    meshbasic_frag: TE,
    meshlambert_vert: EE,
    meshlambert_frag: CE,
    meshmatcap_vert: DE,
    meshmatcap_frag: PE,
    meshnormal_vert: AE,
    meshnormal_frag: LE,
    meshphong_vert: RE,
    meshphong_frag: kE,
    meshphysical_vert: IE,
    meshphysical_frag: FE,
    meshtoon_vert: OE,
    meshtoon_frag: NE,
    points_vert: BE,
    points_frag: VE,
    shadow_vert: zE,
    shadow_frag: UE,
    sprite_vert: GE,
    sprite_frag: HE,
  },
  Be = {
    common: {
      diffuse: { value: new ct(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new Nn() },
      uv2Transform: { value: new Nn() },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new Ue(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new ct(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new ct(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Nn() },
    },
    sprite: {
      diffuse: { value: new ct(16777215) },
      opacity: { value: 1 },
      center: { value: new Ue(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Nn() },
    },
  },
  Ls = {
    basic: {
      uniforms: Qi([
        Be.common,
        Be.specularmap,
        Be.envmap,
        Be.aomap,
        Be.lightmap,
        Be.fog,
      ]),
      vertexShader: Tt.meshbasic_vert,
      fragmentShader: Tt.meshbasic_frag,
    },
    lambert: {
      uniforms: Qi([
        Be.common,
        Be.specularmap,
        Be.envmap,
        Be.aomap,
        Be.lightmap,
        Be.emissivemap,
        Be.bumpmap,
        Be.normalmap,
        Be.displacementmap,
        Be.fog,
        Be.lights,
        { emissive: { value: new ct(0) } },
      ]),
      vertexShader: Tt.meshlambert_vert,
      fragmentShader: Tt.meshlambert_frag,
    },
    phong: {
      uniforms: Qi([
        Be.common,
        Be.specularmap,
        Be.envmap,
        Be.aomap,
        Be.lightmap,
        Be.emissivemap,
        Be.bumpmap,
        Be.normalmap,
        Be.displacementmap,
        Be.fog,
        Be.lights,
        {
          emissive: { value: new ct(0) },
          specular: { value: new ct(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Tt.meshphong_vert,
      fragmentShader: Tt.meshphong_frag,
    },
    standard: {
      uniforms: Qi([
        Be.common,
        Be.envmap,
        Be.aomap,
        Be.lightmap,
        Be.emissivemap,
        Be.bumpmap,
        Be.normalmap,
        Be.displacementmap,
        Be.roughnessmap,
        Be.metalnessmap,
        Be.fog,
        Be.lights,
        {
          emissive: { value: new ct(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Tt.meshphysical_vert,
      fragmentShader: Tt.meshphysical_frag,
    },
    toon: {
      uniforms: Qi([
        Be.common,
        Be.aomap,
        Be.lightmap,
        Be.emissivemap,
        Be.bumpmap,
        Be.normalmap,
        Be.displacementmap,
        Be.gradientmap,
        Be.fog,
        Be.lights,
        { emissive: { value: new ct(0) } },
      ]),
      vertexShader: Tt.meshtoon_vert,
      fragmentShader: Tt.meshtoon_frag,
    },
    matcap: {
      uniforms: Qi([
        Be.common,
        Be.bumpmap,
        Be.normalmap,
        Be.displacementmap,
        Be.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Tt.meshmatcap_vert,
      fragmentShader: Tt.meshmatcap_frag,
    },
    points: {
      uniforms: Qi([Be.points, Be.fog]),
      vertexShader: Tt.points_vert,
      fragmentShader: Tt.points_frag,
    },
    dashed: {
      uniforms: Qi([
        Be.common,
        Be.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Tt.linedashed_vert,
      fragmentShader: Tt.linedashed_frag,
    },
    depth: {
      uniforms: Qi([Be.common, Be.displacementmap]),
      vertexShader: Tt.depth_vert,
      fragmentShader: Tt.depth_frag,
    },
    normal: {
      uniforms: Qi([
        Be.common,
        Be.bumpmap,
        Be.normalmap,
        Be.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Tt.meshnormal_vert,
      fragmentShader: Tt.meshnormal_frag,
    },
    sprite: {
      uniforms: Qi([Be.sprite, Be.fog]),
      vertexShader: Tt.sprite_vert,
      fragmentShader: Tt.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Nn() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Tt.background_vert,
      fragmentShader: Tt.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Tt.backgroundCube_vert,
      fragmentShader: Tt.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Tt.cube_vert,
      fragmentShader: Tt.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Tt.equirect_vert,
      fragmentShader: Tt.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Qi([
        Be.common,
        Be.displacementmap,
        {
          referencePosition: { value: new Z() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Tt.distanceRGBA_vert,
      fragmentShader: Tt.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Qi([
        Be.lights,
        Be.fog,
        { color: { value: new ct(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Tt.shadow_vert,
      fragmentShader: Tt.shadow_frag,
    },
  };
Ls.physical = {
  uniforms: Qi([
    Ls.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new Ue(1, 1) },
      clearcoatNormalMap: { value: null },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: new ct(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new Ue() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new ct(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: new ct(1, 1, 1) },
      specularColorMap: { value: null },
    },
  ]),
  vertexShader: Tt.meshphysical_vert,
  fragmentShader: Tt.meshphysical_frag,
};
const nh = { r: 0, b: 0, g: 0 };
function WE(r, e, t, i, n, s, a) {
  const o = new ct(0);
  let u = s === !0 ? 0 : 1,
    h,
    f,
    c = null,
    d = 0,
    m = null;
  function x(b, y) {
    let M = !1,
      D = y.isScene === !0 ? y.background : null;
    D && D.isTexture && (D = (y.backgroundBlurriness > 0 ? t : e).get(D));
    const C = r.xr,
      A = C.getSession && C.getSession();
    A && A.environmentBlendMode === "additive" && (D = null),
      D === null ? v(o, u) : D && D.isColor && (v(D, 1), (M = !0)),
      (r.autoClear || M) &&
        r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil),
      D && (D.isCubeTexture || D.mapping === ld)
        ? (f === void 0 &&
            ((f = new Wi(
              new ou(1, 1, 1),
              new vr({
                name: "BackgroundCubeMaterial",
                uniforms: hl(Ls.backgroundCube.uniforms),
                vertexShader: Ls.backgroundCube.vertexShader,
                fragmentShader: Ls.backgroundCube.fragmentShader,
                side: Bn,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            f.geometry.deleteAttribute("normal"),
            f.geometry.deleteAttribute("uv"),
            (f.onBeforeRender = function (I, F, P) {
              this.matrixWorld.copyPosition(P.matrixWorld);
            }),
            Object.defineProperty(f.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            n.update(f)),
          (f.material.uniforms.envMap.value = D),
          (f.material.uniforms.flipEnvMap.value =
            D.isCubeTexture && D.isRenderTargetTexture === !1 ? -1 : 1),
          (f.material.uniforms.backgroundBlurriness.value =
            y.backgroundBlurriness),
          (f.material.uniforms.backgroundIntensity.value =
            y.backgroundIntensity),
          (f.material.toneMapped = D.encoding !== Ht),
          (c !== D || d !== D.version || m !== r.toneMapping) &&
            ((f.material.needsUpdate = !0),
            (c = D),
            (d = D.version),
            (m = r.toneMapping)),
          f.layers.enableAll(),
          b.unshift(f, f.geometry, f.material, 0, 0, null))
        : D &&
          D.isTexture &&
          (h === void 0 &&
            ((h = new Wi(
              new au(2, 2),
              new vr({
                name: "BackgroundMaterial",
                uniforms: hl(Ls.background.uniforms),
                vertexShader: Ls.background.vertexShader,
                fragmentShader: Ls.background.fragmentShader,
                side: Bs,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            h.geometry.deleteAttribute("normal"),
            Object.defineProperty(h.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            n.update(h)),
          (h.material.uniforms.t2D.value = D),
          (h.material.uniforms.backgroundIntensity.value =
            y.backgroundIntensity),
          (h.material.toneMapped = D.encoding !== Ht),
          D.matrixAutoUpdate === !0 && D.updateMatrix(),
          h.material.uniforms.uvTransform.value.copy(D.matrix),
          (c !== D || d !== D.version || m !== r.toneMapping) &&
            ((h.material.needsUpdate = !0),
            (c = D),
            (d = D.version),
            (m = r.toneMapping)),
          h.layers.enableAll(),
          b.unshift(h, h.geometry, h.material, 0, 0, null));
  }
  function v(b, y) {
    b.getRGB(nh, fb(r)), i.buffers.color.setClear(nh.r, nh.g, nh.b, y, a);
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (b, y = 1) {
      o.set(b), (u = y), v(o, u);
    },
    getClearAlpha: function () {
      return u;
    },
    setClearAlpha: function (b) {
      (u = b), v(o, u);
    },
    render: x,
  };
}
function jE(r, e, t, i) {
  const n = r.getParameter(34921),
    s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    a = i.isWebGL2 || s !== null,
    o = {},
    u = b(null);
  let h = u,
    f = !1;
  function c(j, Y, ie, Q, V) {
    let ve = !1;
    if (a) {
      const U = v(Q, ie, Y);
      h !== U && ((h = U), m(h.object)),
        (ve = y(j, Q, ie, V)),
        ve && M(j, Q, ie, V);
    } else {
      const U = Y.wireframe === !0;
      (h.geometry !== Q.id || h.program !== ie.id || h.wireframe !== U) &&
        ((h.geometry = Q.id),
        (h.program = ie.id),
        (h.wireframe = U),
        (ve = !0));
    }
    V !== null && t.update(V, 34963),
      (ve || f) &&
        ((f = !1),
        P(j, Y, ie, Q),
        V !== null && r.bindBuffer(34963, t.get(V).buffer));
  }
  function d() {
    return i.isWebGL2 ? r.createVertexArray() : s.createVertexArrayOES();
  }
  function m(j) {
    return i.isWebGL2 ? r.bindVertexArray(j) : s.bindVertexArrayOES(j);
  }
  function x(j) {
    return i.isWebGL2 ? r.deleteVertexArray(j) : s.deleteVertexArrayOES(j);
  }
  function v(j, Y, ie) {
    const Q = ie.wireframe === !0;
    let V = o[j.id];
    V === void 0 && ((V = {}), (o[j.id] = V));
    let ve = V[Y.id];
    ve === void 0 && ((ve = {}), (V[Y.id] = ve));
    let U = ve[Q];
    return U === void 0 && ((U = b(d())), (ve[Q] = U)), U;
  }
  function b(j) {
    const Y = [],
      ie = [],
      Q = [];
    for (let V = 0; V < n; V++) (Y[V] = 0), (ie[V] = 0), (Q[V] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: Y,
      enabledAttributes: ie,
      attributeDivisors: Q,
      object: j,
      attributes: {},
      index: null,
    };
  }
  function y(j, Y, ie, Q) {
    const V = h.attributes,
      ve = Y.attributes;
    let U = 0;
    const oe = ie.getAttributes();
    for (const ue in oe)
      if (oe[ue].location >= 0) {
        const le = V[ue];
        let be = ve[ue];
        if (
          (be === void 0 &&
            (ue === "instanceMatrix" &&
              j.instanceMatrix &&
              (be = j.instanceMatrix),
            ue === "instanceColor" &&
              j.instanceColor &&
              (be = j.instanceColor)),
          le === void 0 || le.attribute !== be || (be && le.data !== be.data))
        )
          return !0;
        U++;
      }
    return h.attributesNum !== U || h.index !== Q;
  }
  function M(j, Y, ie, Q) {
    const V = {},
      ve = Y.attributes;
    let U = 0;
    const oe = ie.getAttributes();
    for (const ue in oe)
      if (oe[ue].location >= 0) {
        let le = ve[ue];
        le === void 0 &&
          (ue === "instanceMatrix" &&
            j.instanceMatrix &&
            (le = j.instanceMatrix),
          ue === "instanceColor" && j.instanceColor && (le = j.instanceColor));
        const be = {};
        (be.attribute = le),
          le && le.data && (be.data = le.data),
          (V[ue] = be),
          U++;
      }
    (h.attributes = V), (h.attributesNum = U), (h.index = Q);
  }
  function D() {
    const j = h.newAttributes;
    for (let Y = 0, ie = j.length; Y < ie; Y++) j[Y] = 0;
  }
  function C(j) {
    A(j, 0);
  }
  function A(j, Y) {
    const ie = h.newAttributes,
      Q = h.enabledAttributes,
      V = h.attributeDivisors;
    (ie[j] = 1),
      Q[j] === 0 && (r.enableVertexAttribArray(j), (Q[j] = 1)),
      V[j] !== Y &&
        ((i.isWebGL2 ? r : e.get("ANGLE_instanced_arrays"))[
          i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](j, Y),
        (V[j] = Y));
  }
  function I() {
    const j = h.newAttributes,
      Y = h.enabledAttributes;
    for (let ie = 0, Q = Y.length; ie < Q; ie++)
      Y[ie] !== j[ie] && (r.disableVertexAttribArray(ie), (Y[ie] = 0));
  }
  function F(j, Y, ie, Q, V, ve) {
    i.isWebGL2 === !0 && (ie === 5124 || ie === 5125)
      ? r.vertexAttribIPointer(j, Y, ie, V, ve)
      : r.vertexAttribPointer(j, Y, ie, Q, V, ve);
  }
  function P(j, Y, ie, Q) {
    if (
      i.isWebGL2 === !1 &&
      (j.isInstancedMesh || Q.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    D();
    const V = Q.attributes,
      ve = ie.getAttributes(),
      U = Y.defaultAttributeValues;
    for (const oe in ve) {
      const ue = ve[oe];
      if (ue.location >= 0) {
        let fe = V[oe];
        if (
          (fe === void 0 &&
            (oe === "instanceMatrix" &&
              j.instanceMatrix &&
              (fe = j.instanceMatrix),
            oe === "instanceColor" &&
              j.instanceColor &&
              (fe = j.instanceColor)),
          fe !== void 0)
        ) {
          const le = fe.normalized,
            be = fe.itemSize,
            ce = t.get(fe);
          if (ce === void 0) continue;
          const He = ce.buffer,
            Se = ce.type,
            Oe = ce.bytesPerElement;
          if (fe.isInterleavedBufferAttribute) {
            const Me = fe.data,
              Ke = Me.stride,
              Qe = fe.offset;
            if (Me.isInstancedInterleavedBuffer) {
              for (let Pe = 0; Pe < ue.locationSize; Pe++)
                A(ue.location + Pe, Me.meshPerAttribute);
              j.isInstancedMesh !== !0 &&
                Q._maxInstanceCount === void 0 &&
                (Q._maxInstanceCount = Me.meshPerAttribute * Me.count);
            } else
              for (let Pe = 0; Pe < ue.locationSize; Pe++) C(ue.location + Pe);
            r.bindBuffer(34962, He);
            for (let Pe = 0; Pe < ue.locationSize; Pe++)
              F(
                ue.location + Pe,
                be / ue.locationSize,
                Se,
                le,
                Ke * Oe,
                (Qe + (be / ue.locationSize) * Pe) * Oe
              );
          } else {
            if (fe.isInstancedBufferAttribute) {
              for (let Me = 0; Me < ue.locationSize; Me++)
                A(ue.location + Me, fe.meshPerAttribute);
              j.isInstancedMesh !== !0 &&
                Q._maxInstanceCount === void 0 &&
                (Q._maxInstanceCount = fe.meshPerAttribute * fe.count);
            } else
              for (let Me = 0; Me < ue.locationSize; Me++) C(ue.location + Me);
            r.bindBuffer(34962, He);
            for (let Me = 0; Me < ue.locationSize; Me++)
              F(
                ue.location + Me,
                be / ue.locationSize,
                Se,
                le,
                be * Oe,
                (be / ue.locationSize) * Me * Oe
              );
          }
        } else if (U !== void 0) {
          const le = U[oe];
          if (le !== void 0)
            switch (le.length) {
              case 2:
                r.vertexAttrib2fv(ue.location, le);
                break;
              case 3:
                r.vertexAttrib3fv(ue.location, le);
                break;
              case 4:
                r.vertexAttrib4fv(ue.location, le);
                break;
              default:
                r.vertexAttrib1fv(ue.location, le);
            }
        }
      }
    }
    I();
  }
  function k() {
    ee();
    for (const j in o) {
      const Y = o[j];
      for (const ie in Y) {
        const Q = Y[ie];
        for (const V in Q) x(Q[V].object), delete Q[V];
        delete Y[ie];
      }
      delete o[j];
    }
  }
  function O(j) {
    if (o[j.id] === void 0) return;
    const Y = o[j.id];
    for (const ie in Y) {
      const Q = Y[ie];
      for (const V in Q) x(Q[V].object), delete Q[V];
      delete Y[ie];
    }
    delete o[j.id];
  }
  function J(j) {
    for (const Y in o) {
      const ie = o[Y];
      if (ie[j.id] === void 0) continue;
      const Q = ie[j.id];
      for (const V in Q) x(Q[V].object), delete Q[V];
      delete ie[j.id];
    }
  }
  function ee() {
    X(), (f = !0), h !== u && ((h = u), m(h.object));
  }
  function X() {
    (u.geometry = null), (u.program = null), (u.wireframe = !1);
  }
  return {
    setup: c,
    reset: ee,
    resetDefaultState: X,
    dispose: k,
    releaseStatesOfGeometry: O,
    releaseStatesOfProgram: J,
    initAttributes: D,
    enableAttribute: C,
    disableUnusedAttributes: I,
  };
}
function qE(r, e, t, i) {
  const n = i.isWebGL2;
  let s;
  function a(h) {
    s = h;
  }
  function o(h, f) {
    r.drawArrays(s, h, f), t.update(f, s, 1);
  }
  function u(h, f, c) {
    if (c === 0) return;
    let d, m;
    if (n) (d = r), (m = "drawArraysInstanced");
    else if (
      ((d = e.get("ANGLE_instanced_arrays")),
      (m = "drawArraysInstancedANGLE"),
      d === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    d[m](s, h, f, c), t.update(f, s, c);
  }
  (this.setMode = a), (this.render = o), (this.renderInstances = u);
}
function XE(r, e, t) {
  let i;
  function n() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const F = e.get("EXT_texture_filter_anisotropic");
      i = r.getParameter(F.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function s(F) {
    if (F === "highp") {
      if (
        r.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        r.getShaderPrecisionFormat(35632, 36338).precision > 0
      )
        return "highp";
      F = "mediump";
    }
    return F === "mediump" &&
      r.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
      r.getShaderPrecisionFormat(35632, 36337).precision > 0
      ? "mediump"
      : "lowp";
  }
  const a =
    (typeof WebGL2RenderingContext < "u" &&
      r instanceof WebGL2RenderingContext) ||
    (typeof WebGL2ComputeRenderingContext < "u" &&
      r instanceof WebGL2ComputeRenderingContext);
  let o = t.precision !== void 0 ? t.precision : "highp";
  const u = s(o);
  u !== o &&
    (console.warn(
      "THREE.WebGLRenderer:",
      o,
      "not supported, using",
      u,
      "instead."
    ),
    (o = u));
  const h = a || e.has("WEBGL_draw_buffers"),
    f = t.logarithmicDepthBuffer === !0,
    c = r.getParameter(34930),
    d = r.getParameter(35660),
    m = r.getParameter(3379),
    x = r.getParameter(34076),
    v = r.getParameter(34921),
    b = r.getParameter(36347),
    y = r.getParameter(36348),
    M = r.getParameter(36349),
    D = d > 0,
    C = a || e.has("OES_texture_float"),
    A = D && C,
    I = a ? r.getParameter(36183) : 0;
  return {
    isWebGL2: a,
    drawBuffers: h,
    getMaxAnisotropy: n,
    getMaxPrecision: s,
    precision: o,
    logarithmicDepthBuffer: f,
    maxTextures: c,
    maxVertexTextures: d,
    maxTextureSize: m,
    maxCubemapSize: x,
    maxAttributes: v,
    maxVertexUniforms: b,
    maxVaryings: y,
    maxFragmentUniforms: M,
    vertexTextures: D,
    floatFragmentTextures: C,
    floatVertexTextures: A,
    maxSamples: I,
  };
}
function $E(r) {
  const e = this;
  let t = null,
    i = 0,
    n = !1,
    s = !1;
  const a = new Mo(),
    o = new Nn(),
    u = { value: null, needsUpdate: !1 };
  (this.uniform = u),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (c, d, m) {
      const x = c.length !== 0 || d || i !== 0 || n;
      return (n = d), (t = f(c, m, 0)), (i = c.length), x;
    }),
    (this.beginShadows = function () {
      (s = !0), f(null);
    }),
    (this.endShadows = function () {
      (s = !1), h();
    }),
    (this.setState = function (c, d, m) {
      const x = c.clippingPlanes,
        v = c.clipIntersection,
        b = c.clipShadows,
        y = r.get(c);
      if (!n || x === null || x.length === 0 || (s && !b)) s ? f(null) : h();
      else {
        const M = s ? 0 : i,
          D = M * 4;
        let C = y.clippingState || null;
        (u.value = C), (C = f(x, d, D, m));
        for (let A = 0; A !== D; ++A) C[A] = t[A];
        (y.clippingState = C),
          (this.numIntersection = v ? this.numPlanes : 0),
          (this.numPlanes += M);
      }
    });
  function h() {
    u.value !== t && ((u.value = t), (u.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0);
  }
  function f(c, d, m, x) {
    const v = c !== null ? c.length : 0;
    let b = null;
    if (v !== 0) {
      if (((b = u.value), x !== !0 || b === null)) {
        const y = m + v * 4,
          M = d.matrixWorldInverse;
        o.getNormalMatrix(M),
          (b === null || b.length < y) && (b = new Float32Array(y));
        for (let D = 0, C = m; D !== v; ++D, C += 4)
          a.copy(c[D]).applyMatrix4(M, o),
            a.normal.toArray(b, C),
            (b[C + 3] = a.constant);
      }
      (u.value = b), (u.needsUpdate = !0);
    }
    return (e.numPlanes = v), (e.numIntersection = 0), b;
  }
}
function YE(r) {
  let e = new WeakMap();
  function t(a, o) {
    return o === Sf ? (a.mapping = al) : o === Mf && (a.mapping = ll), a;
  }
  function i(a) {
    if (a && a.isTexture && a.isRenderTargetTexture === !1) {
      const o = a.mapping;
      if (o === Sf || o === Mf)
        if (e.has(a)) {
          const u = e.get(a).texture;
          return t(u, a.mapping);
        } else {
          const u = a.image;
          if (u && u.height > 0) {
            const h = new lM(u.height / 2);
            return (
              h.fromEquirectangularTexture(r, a),
              e.set(a, h),
              a.addEventListener("dispose", n),
              t(h.texture, a.mapping)
            );
          } else return null;
        }
    }
    return a;
  }
  function n(a) {
    const o = a.target;
    o.removeEventListener("dispose", n);
    const u = e.get(o);
    u !== void 0 && (e.delete(o), u.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: i, dispose: s };
}
class ym extends xm {
  constructor(e = -1, t = 1, i = 1, n = -1, s = 0.1, a = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = n),
      (this.near = s),
      (this.far = a),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, i, n, s, a) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = n),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      n = (this.top + this.bottom) / 2;
    let s = i - e,
      a = i + e,
      o = n + t,
      u = n - t;
    if (this.view !== null && this.view.enabled) {
      const h = (this.right - this.left) / this.view.fullWidth / this.zoom,
        f = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += h * this.view.offsetX),
        (a = s + h * this.view.width),
        (o -= f * this.view.offsetY),
        (u = o - f * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(s, a, o, u, this.near, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const Xa = 4,
  H0 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Po = 20,
  Op = new ym(),
  W0 = new ct();
let Np = null;
const To = (1 + Math.sqrt(5)) / 2,
  Oa = 1 / To,
  j0 = [
    new Z(1, 1, 1),
    new Z(-1, 1, 1),
    new Z(1, 1, -1),
    new Z(-1, 1, -1),
    new Z(0, To, Oa),
    new Z(0, To, -Oa),
    new Z(Oa, 0, To),
    new Z(-Oa, 0, To),
    new Z(To, Oa, 0),
    new Z(-To, Oa, 0),
  ];
class q0 {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, i = 0.1, n = 100) {
    (Np = this._renderer.getRenderTarget()), this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, i, n, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = Y0()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = $0()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Np),
      (e.scissorTest = !1),
      sh(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === al || e.mapping === ll
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (Np = this._renderer.getRenderTarget());
    const i = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: Ui,
        minFilter: Ui,
        generateMipmaps: !1,
        type: Vc,
        format: es,
        encoding: gr,
        depthBuffer: !1,
      },
      n = X0(e, t, i);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = X0(e, t, i));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = KE(s)),
        (this._blurMaterial = ZE(s, e, t));
    }
    return n;
  }
  _compileMaterial(e) {
    const t = new Wi(this._lodPlanes[0], e);
    this._renderer.compile(t, Op);
  }
  _sceneToCubeUV(e, t, i, n) {
    const o = new Gi(90, 1, t, i),
      u = [1, -1, 1, 1, 1, 1],
      h = [1, 1, 1, -1, -1, -1],
      f = this._renderer,
      c = f.autoClear,
      d = f.toneMapping;
    f.getClearColor(W0), (f.toneMapping = pr), (f.autoClear = !1);
    const m = new cr({
        name: "PMREM.Background",
        side: Bn,
        depthWrite: !1,
        depthTest: !1,
      }),
      x = new Wi(new ou(), m);
    let v = !1;
    const b = e.background;
    b
      ? b.isColor && (m.color.copy(b), (e.background = null), (v = !0))
      : (m.color.copy(W0), (v = !0));
    for (let y = 0; y < 6; y++) {
      const M = y % 3;
      M === 0
        ? (o.up.set(0, u[y], 0), o.lookAt(h[y], 0, 0))
        : M === 1
        ? (o.up.set(0, 0, u[y]), o.lookAt(0, h[y], 0))
        : (o.up.set(0, u[y], 0), o.lookAt(0, 0, h[y]));
      const D = this._cubeSize;
      sh(n, M * D, y > 2 ? D : 0, D, D),
        f.setRenderTarget(n),
        v && f.render(x, o),
        f.render(e, o);
    }
    x.geometry.dispose(),
      x.material.dispose(),
      (f.toneMapping = d),
      (f.autoClear = c),
      (e.background = b);
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      n = e.mapping === al || e.mapping === ll;
    n
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = Y0()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = $0());
    const s = n ? this._cubemapMaterial : this._equirectMaterial,
      a = new Wi(this._lodPlanes[0], s),
      o = s.uniforms;
    o.envMap.value = e;
    const u = this._cubeSize;
    sh(t, 0, 0, 3 * u, 2 * u), i.setRenderTarget(t), i.render(a, Op);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear;
    t.autoClear = !1;
    for (let n = 1; n < this._lodPlanes.length; n++) {
      const s = Math.sqrt(
          this._sigmas[n] * this._sigmas[n] -
            this._sigmas[n - 1] * this._sigmas[n - 1]
        ),
        a = j0[(n - 1) % j0.length];
      this._blur(e, n - 1, n, s, a);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, n, s) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(e, a, t, i, n, "latitudinal", s),
      this._halfBlur(a, e, i, i, n, "longitudinal", s);
  }
  _halfBlur(e, t, i, n, s, a, o) {
    const u = this._renderer,
      h = this._blurMaterial;
    a !== "latitudinal" &&
      a !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const f = 3,
      c = new Wi(this._lodPlanes[n], h),
      d = h.uniforms,
      m = this._sizeLods[i] - 1,
      x = isFinite(s) ? Math.PI / (2 * m) : (2 * Math.PI) / (2 * Po - 1),
      v = s / x,
      b = isFinite(s) ? 1 + Math.floor(f * v) : Po;
    b > Po &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${b} samples when the maximum is set to ${Po}`
      );
    const y = [];
    let M = 0;
    for (let F = 0; F < Po; ++F) {
      const P = F / v,
        k = Math.exp((-P * P) / 2);
      y.push(k), F === 0 ? (M += k) : F < b && (M += 2 * k);
    }
    for (let F = 0; F < y.length; F++) y[F] = y[F] / M;
    (d.envMap.value = e.texture),
      (d.samples.value = b),
      (d.weights.value = y),
      (d.latitudinal.value = a === "latitudinal"),
      o && (d.poleAxis.value = o);
    const { _lodMax: D } = this;
    (d.dTheta.value = x), (d.mipInt.value = D - i);
    const C = this._sizeLods[n],
      A = 3 * C * (n > D - Xa ? n - D + Xa : 0),
      I = 4 * (this._cubeSize - C);
    sh(t, A, I, 3 * C, 2 * C), u.setRenderTarget(t), u.render(c, Op);
  }
}
function KE(r) {
  const e = [],
    t = [],
    i = [];
  let n = r;
  const s = r - Xa + 1 + H0.length;
  for (let a = 0; a < s; a++) {
    const o = Math.pow(2, n);
    t.push(o);
    let u = 1 / o;
    a > r - Xa ? (u = H0[a - r + Xa - 1]) : a === 0 && (u = 0), i.push(u);
    const h = 1 / (o - 2),
      f = -h,
      c = 1 + h,
      d = [f, f, c, f, c, c, f, f, c, c, f, c],
      m = 6,
      x = 6,
      v = 3,
      b = 2,
      y = 1,
      M = new Float32Array(v * x * m),
      D = new Float32Array(b * x * m),
      C = new Float32Array(y * x * m);
    for (let I = 0; I < m; I++) {
      const F = ((I % 3) * 2) / 3 - 1,
        P = I > 2 ? 0 : -1,
        k = [
          F,
          P,
          0,
          F + 2 / 3,
          P,
          0,
          F + 2 / 3,
          P + 1,
          0,
          F,
          P,
          0,
          F + 2 / 3,
          P + 1,
          0,
          F,
          P + 1,
          0,
        ];
      M.set(k, v * x * I), D.set(d, b * x * I);
      const O = [I, I, I, I, I, I];
      C.set(O, y * x * I);
    }
    const A = new cn();
    A.setAttribute("position", new an(M, v)),
      A.setAttribute("uv", new an(D, b)),
      A.setAttribute("faceIndex", new an(C, y)),
      e.push(A),
      n > Xa && n--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function X0(r, e, t) {
  const i = new Zo(r, e, t);
  return (
    (i.texture.mapping = ld),
    (i.texture.name = "PMREM.cubeUv"),
    (i.scissorTest = !0),
    i
  );
}
function sh(r, e, t, i, n) {
  r.viewport.set(e, t, i, n), r.scissor.set(e, t, i, n);
}
function ZE(r, e, t) {
  const i = new Float32Array(Po),
    n = new Z(0, 1, 0);
  return new vr({
    name: "SphericalGaussianBlur",
    defines: {
      n: Po,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${r}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: n },
    },
    vertexShader: Sm(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: dr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function $0() {
  return new vr({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: Sm(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: dr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Y0() {
  return new vr({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: Sm(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: dr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Sm() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function JE(r) {
  let e = new WeakMap(),
    t = null;
  function i(o) {
    if (o && o.isTexture) {
      const u = o.mapping,
        h = u === Sf || u === Mf,
        f = u === al || u === ll;
      if (h || f)
        if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
          o.needsPMREMUpdate = !1;
          let c = e.get(o);
          return (
            t === null && (t = new q0(r)),
            (c = h ? t.fromEquirectangular(o, c) : t.fromCubemap(o, c)),
            e.set(o, c),
            c.texture
          );
        } else {
          if (e.has(o)) return e.get(o).texture;
          {
            const c = o.image;
            if ((h && c && c.height > 0) || (f && c && n(c))) {
              t === null && (t = new q0(r));
              const d = h ? t.fromEquirectangular(o) : t.fromCubemap(o);
              return e.set(o, d), o.addEventListener("dispose", s), d.texture;
            } else return null;
          }
        }
    }
    return o;
  }
  function n(o) {
    let u = 0;
    const h = 6;
    for (let f = 0; f < h; f++) o[f] !== void 0 && u++;
    return u === h;
  }
  function s(o) {
    const u = o.target;
    u.removeEventListener("dispose", s);
    const h = e.get(u);
    h !== void 0 && (e.delete(u), h.dispose());
  }
  function a() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: i, dispose: a };
}
function QE(r) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0) return e[i];
    let n;
    switch (i) {
      case "WEBGL_depth_texture":
        n =
          r.getExtension("WEBGL_depth_texture") ||
          r.getExtension("MOZ_WEBGL_depth_texture") ||
          r.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        n =
          r.getExtension("EXT_texture_filter_anisotropic") ||
          r.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        n =
          r.getExtension("WEBGL_compressed_texture_s3tc") ||
          r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        n =
          r.getExtension("WEBGL_compressed_texture_pvrtc") ||
          r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        n = r.getExtension(i);
    }
    return (e[i] = n), n;
  }
  return {
    has: function (i) {
      return t(i) !== null;
    },
    init: function (i) {
      i.isWebGL2
        ? t("EXT_color_buffer_float")
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture");
    },
    get: function (i) {
      const n = t(i);
      return (
        n === null &&
          console.warn(
            "THREE.WebGLRenderer: " + i + " extension not supported."
          ),
        n
      );
    },
  };
}
function e2(r, e, t, i) {
  const n = {},
    s = new WeakMap();
  function a(c) {
    const d = c.target;
    d.index !== null && e.remove(d.index);
    for (const x in d.attributes) e.remove(d.attributes[x]);
    d.removeEventListener("dispose", a), delete n[d.id];
    const m = s.get(d);
    m && (e.remove(m), s.delete(d)),
      i.releaseStatesOfGeometry(d),
      d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
      t.memory.geometries--;
  }
  function o(c, d) {
    return (
      n[d.id] === !0 ||
        (d.addEventListener("dispose", a),
        (n[d.id] = !0),
        t.memory.geometries++),
      d
    );
  }
  function u(c) {
    const d = c.attributes;
    for (const x in d) e.update(d[x], 34962);
    const m = c.morphAttributes;
    for (const x in m) {
      const v = m[x];
      for (let b = 0, y = v.length; b < y; b++) e.update(v[b], 34962);
    }
  }
  function h(c) {
    const d = [],
      m = c.index,
      x = c.attributes.position;
    let v = 0;
    if (m !== null) {
      const M = m.array;
      v = m.version;
      for (let D = 0, C = M.length; D < C; D += 3) {
        const A = M[D + 0],
          I = M[D + 1],
          F = M[D + 2];
        d.push(A, I, I, F, F, A);
      }
    } else {
      const M = x.array;
      v = x.version;
      for (let D = 0, C = M.length / 3 - 1; D < C; D += 3) {
        const A = D + 0,
          I = D + 1,
          F = D + 2;
        d.push(A, I, I, F, F, A);
      }
    }
    const b = new (ab(d) ? pb : db)(d, 1);
    b.version = v;
    const y = s.get(c);
    y && e.remove(y), s.set(c, b);
  }
  function f(c) {
    const d = s.get(c);
    if (d) {
      const m = c.index;
      m !== null && d.version < m.version && h(c);
    } else h(c);
    return s.get(c);
  }
  return { get: o, update: u, getWireframeAttribute: f };
}
function t2(r, e, t, i) {
  const n = i.isWebGL2;
  let s;
  function a(d) {
    s = d;
  }
  let o, u;
  function h(d) {
    (o = d.type), (u = d.bytesPerElement);
  }
  function f(d, m) {
    r.drawElements(s, m, o, d * u), t.update(m, s, 1);
  }
  function c(d, m, x) {
    if (x === 0) return;
    let v, b;
    if (n) (v = r), (b = "drawElementsInstanced");
    else if (
      ((v = e.get("ANGLE_instanced_arrays")),
      (b = "drawElementsInstancedANGLE"),
      v === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    v[b](s, m, o, d * u, x), t.update(m, s, x);
  }
  (this.setMode = a),
    (this.setIndex = h),
    (this.render = f),
    (this.renderInstances = c);
}
function i2(r) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(s, a, o) {
    switch ((t.calls++, a)) {
      case 4:
        t.triangles += o * (s / 3);
        break;
      case 1:
        t.lines += o * (s / 2);
        break;
      case 3:
        t.lines += o * (s - 1);
        break;
      case 2:
        t.lines += o * s;
        break;
      case 0:
        t.points += o * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function n() {
    t.frame++, (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: n,
    update: i,
  };
}
function n2(r, e) {
  return r[0] - e[0];
}
function s2(r, e) {
  return Math.abs(e[1]) - Math.abs(r[1]);
}
function r2(r, e, t) {
  const i = {},
    n = new Float32Array(8),
    s = new WeakMap(),
    a = new Kt(),
    o = [];
  for (let h = 0; h < 8; h++) o[h] = [h, 0];
  function u(h, f, c, d) {
    const m = h.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const v =
          f.morphAttributes.position ||
          f.morphAttributes.normal ||
          f.morphAttributes.color,
        b = v !== void 0 ? v.length : 0;
      let y = s.get(f);
      if (y === void 0 || y.count !== b) {
        let ie = function () {
          j.dispose(), s.delete(f), f.removeEventListener("dispose", ie);
        };
        var x = ie;
        y !== void 0 && y.texture.dispose();
        const C = f.morphAttributes.position !== void 0,
          A = f.morphAttributes.normal !== void 0,
          I = f.morphAttributes.color !== void 0,
          F = f.morphAttributes.position || [],
          P = f.morphAttributes.normal || [],
          k = f.morphAttributes.color || [];
        let O = 0;
        C === !0 && (O = 1), A === !0 && (O = 2), I === !0 && (O = 3);
        let J = f.attributes.position.count * O,
          ee = 1;
        J > e.maxTextureSize &&
          ((ee = Math.ceil(J / e.maxTextureSize)), (J = e.maxTextureSize));
        const X = new Float32Array(J * ee * 4 * b),
          j = new hb(X, J, ee, b);
        (j.type = Gr), (j.needsUpdate = !0);
        const Y = O * 4;
        for (let Q = 0; Q < b; Q++) {
          const V = F[Q],
            ve = P[Q],
            U = k[Q],
            oe = J * ee * 4 * Q;
          for (let ue = 0; ue < V.count; ue++) {
            const fe = ue * Y;
            C === !0 &&
              (a.fromBufferAttribute(V, ue),
              (X[oe + fe + 0] = a.x),
              (X[oe + fe + 1] = a.y),
              (X[oe + fe + 2] = a.z),
              (X[oe + fe + 3] = 0)),
              A === !0 &&
                (a.fromBufferAttribute(ve, ue),
                (X[oe + fe + 4] = a.x),
                (X[oe + fe + 5] = a.y),
                (X[oe + fe + 6] = a.z),
                (X[oe + fe + 7] = 0)),
              I === !0 &&
                (a.fromBufferAttribute(U, ue),
                (X[oe + fe + 8] = a.x),
                (X[oe + fe + 9] = a.y),
                (X[oe + fe + 10] = a.z),
                (X[oe + fe + 11] = U.itemSize === 4 ? a.w : 1));
          }
        }
        (y = { count: b, texture: j, size: new Ue(J, ee) }),
          s.set(f, y),
          f.addEventListener("dispose", ie);
      }
      let M = 0;
      for (let C = 0; C < m.length; C++) M += m[C];
      const D = f.morphTargetsRelative ? 1 : 1 - M;
      d.getUniforms().setValue(r, "morphTargetBaseInfluence", D),
        d.getUniforms().setValue(r, "morphTargetInfluences", m),
        d.getUniforms().setValue(r, "morphTargetsTexture", y.texture, t),
        d.getUniforms().setValue(r, "morphTargetsTextureSize", y.size);
    } else {
      const v = m === void 0 ? 0 : m.length;
      let b = i[f.id];
      if (b === void 0 || b.length !== v) {
        b = [];
        for (let A = 0; A < v; A++) b[A] = [A, 0];
        i[f.id] = b;
      }
      for (let A = 0; A < v; A++) {
        const I = b[A];
        (I[0] = A), (I[1] = m[A]);
      }
      b.sort(s2);
      for (let A = 0; A < 8; A++)
        A < v && b[A][1]
          ? ((o[A][0] = b[A][0]), (o[A][1] = b[A][1]))
          : ((o[A][0] = Number.MAX_SAFE_INTEGER), (o[A][1] = 0));
      o.sort(n2);
      const y = f.morphAttributes.position,
        M = f.morphAttributes.normal;
      let D = 0;
      for (let A = 0; A < 8; A++) {
        const I = o[A],
          F = I[0],
          P = I[1];
        F !== Number.MAX_SAFE_INTEGER && P
          ? (y &&
              f.getAttribute("morphTarget" + A) !== y[F] &&
              f.setAttribute("morphTarget" + A, y[F]),
            M &&
              f.getAttribute("morphNormal" + A) !== M[F] &&
              f.setAttribute("morphNormal" + A, M[F]),
            (n[A] = P),
            (D += P))
          : (y &&
              f.hasAttribute("morphTarget" + A) === !0 &&
              f.deleteAttribute("morphTarget" + A),
            M &&
              f.hasAttribute("morphNormal" + A) === !0 &&
              f.deleteAttribute("morphNormal" + A),
            (n[A] = 0));
      }
      const C = f.morphTargetsRelative ? 1 : 1 - D;
      d.getUniforms().setValue(r, "morphTargetBaseInfluence", C),
        d.getUniforms().setValue(r, "morphTargetInfluences", n);
    }
  }
  return { update: u };
}
function o2(r, e, t, i) {
  let n = new WeakMap();
  function s(u) {
    const h = i.render.frame,
      f = u.geometry,
      c = e.get(u, f);
    return (
      n.get(c) !== h && (e.update(c), n.set(c, h)),
      u.isInstancedMesh &&
        (u.hasEventListener("dispose", o) === !1 &&
          u.addEventListener("dispose", o),
        t.update(u.instanceMatrix, 34962),
        u.instanceColor !== null && t.update(u.instanceColor, 34962)),
      c
    );
  }
  function a() {
    n = new WeakMap();
  }
  function o(u) {
    const h = u.target;
    h.removeEventListener("dispose", o),
      t.remove(h.instanceMatrix),
      h.instanceColor !== null && t.remove(h.instanceColor);
  }
  return { update: s, dispose: a };
}
const vb = new xi(),
  _b = new hb(),
  bb = new qS(),
  xb = new mb(),
  K0 = [],
  Z0 = [],
  J0 = new Float32Array(16),
  Q0 = new Float32Array(9),
  ev = new Float32Array(4);
function Dl(r, e, t) {
  const i = r[0];
  if (i <= 0 || i > 0) return r;
  const n = e * t;
  let s = K0[n];
  if ((s === void 0 && ((s = new Float32Array(n)), (K0[n] = s)), e !== 0)) {
    i.toArray(s, 0);
    for (let a = 1, o = 0; a !== e; ++a) (o += t), r[a].toArray(s, o);
  }
  return s;
}
function Si(r, e) {
  if (r.length !== e.length) return !1;
  for (let t = 0, i = r.length; t < i; t++) if (r[t] !== e[t]) return !1;
  return !0;
}
function Mi(r, e) {
  for (let t = 0, i = e.length; t < i; t++) r[t] = e[t];
}
function ud(r, e) {
  let t = Z0[e];
  t === void 0 && ((t = new Int32Array(e)), (Z0[e] = t));
  for (let i = 0; i !== e; ++i) t[i] = r.allocateTextureUnit();
  return t;
}
function a2(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1f(this.addr, e), (t[0] = e));
}
function l2(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Si(t, e)) return;
    r.uniform2fv(this.addr, e), Mi(t, e);
  }
}
function c2(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (r.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Si(t, e)) return;
    r.uniform3fv(this.addr, e), Mi(t, e);
  }
}
function u2(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Si(t, e)) return;
    r.uniform4fv(this.addr, e), Mi(t, e);
  }
}
function h2(r, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Si(t, e)) return;
    r.uniformMatrix2fv(this.addr, !1, e), Mi(t, e);
  } else {
    if (Si(t, i)) return;
    ev.set(i), r.uniformMatrix2fv(this.addr, !1, ev), Mi(t, i);
  }
}
function d2(r, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Si(t, e)) return;
    r.uniformMatrix3fv(this.addr, !1, e), Mi(t, e);
  } else {
    if (Si(t, i)) return;
    Q0.set(i), r.uniformMatrix3fv(this.addr, !1, Q0), Mi(t, i);
  }
}
function p2(r, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Si(t, e)) return;
    r.uniformMatrix4fv(this.addr, !1, e), Mi(t, e);
  } else {
    if (Si(t, i)) return;
    J0.set(i), r.uniformMatrix4fv(this.addr, !1, J0), Mi(t, i);
  }
}
function f2(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1i(this.addr, e), (t[0] = e));
}
function m2(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Si(t, e)) return;
    r.uniform2iv(this.addr, e), Mi(t, e);
  }
}
function g2(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Si(t, e)) return;
    r.uniform3iv(this.addr, e), Mi(t, e);
  }
}
function v2(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Si(t, e)) return;
    r.uniform4iv(this.addr, e), Mi(t, e);
  }
}
function _2(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1ui(this.addr, e), (t[0] = e));
}
function b2(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Si(t, e)) return;
    r.uniform2uiv(this.addr, e), Mi(t, e);
  }
}
function x2(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Si(t, e)) return;
    r.uniform3uiv(this.addr, e), Mi(t, e);
  }
}
function w2(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Si(t, e)) return;
    r.uniform4uiv(this.addr, e), Mi(t, e);
  }
}
function y2(r, e, t) {
  const i = this.cache,
    n = t.allocateTextureUnit();
  i[0] !== n && (r.uniform1i(this.addr, n), (i[0] = n)),
    t.setTexture2D(e || vb, n);
}
function S2(r, e, t) {
  const i = this.cache,
    n = t.allocateTextureUnit();
  i[0] !== n && (r.uniform1i(this.addr, n), (i[0] = n)),
    t.setTexture3D(e || bb, n);
}
function M2(r, e, t) {
  const i = this.cache,
    n = t.allocateTextureUnit();
  i[0] !== n && (r.uniform1i(this.addr, n), (i[0] = n)),
    t.setTextureCube(e || xb, n);
}
function T2(r, e, t) {
  const i = this.cache,
    n = t.allocateTextureUnit();
  i[0] !== n && (r.uniform1i(this.addr, n), (i[0] = n)),
    t.setTexture2DArray(e || _b, n);
}
function E2(r) {
  switch (r) {
    case 5126:
      return a2;
    case 35664:
      return l2;
    case 35665:
      return c2;
    case 35666:
      return u2;
    case 35674:
      return h2;
    case 35675:
      return d2;
    case 35676:
      return p2;
    case 5124:
    case 35670:
      return f2;
    case 35667:
    case 35671:
      return m2;
    case 35668:
    case 35672:
      return g2;
    case 35669:
    case 35673:
      return v2;
    case 5125:
      return _2;
    case 36294:
      return b2;
    case 36295:
      return x2;
    case 36296:
      return w2;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return y2;
    case 35679:
    case 36299:
    case 36307:
      return S2;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return M2;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return T2;
  }
}
function C2(r, e) {
  r.uniform1fv(this.addr, e);
}
function D2(r, e) {
  const t = Dl(e, this.size, 2);
  r.uniform2fv(this.addr, t);
}
function P2(r, e) {
  const t = Dl(e, this.size, 3);
  r.uniform3fv(this.addr, t);
}
function A2(r, e) {
  const t = Dl(e, this.size, 4);
  r.uniform4fv(this.addr, t);
}
function L2(r, e) {
  const t = Dl(e, this.size, 4);
  r.uniformMatrix2fv(this.addr, !1, t);
}
function R2(r, e) {
  const t = Dl(e, this.size, 9);
  r.uniformMatrix3fv(this.addr, !1, t);
}
function k2(r, e) {
  const t = Dl(e, this.size, 16);
  r.uniformMatrix4fv(this.addr, !1, t);
}
function I2(r, e) {
  r.uniform1iv(this.addr, e);
}
function F2(r, e) {
  r.uniform2iv(this.addr, e);
}
function O2(r, e) {
  r.uniform3iv(this.addr, e);
}
function N2(r, e) {
  r.uniform4iv(this.addr, e);
}
function B2(r, e) {
  r.uniform1uiv(this.addr, e);
}
function V2(r, e) {
  r.uniform2uiv(this.addr, e);
}
function z2(r, e) {
  r.uniform3uiv(this.addr, e);
}
function U2(r, e) {
  r.uniform4uiv(this.addr, e);
}
function G2(r, e, t) {
  const i = this.cache,
    n = e.length,
    s = ud(t, n);
  Si(i, s) || (r.uniform1iv(this.addr, s), Mi(i, s));
  for (let a = 0; a !== n; ++a) t.setTexture2D(e[a] || vb, s[a]);
}
function H2(r, e, t) {
  const i = this.cache,
    n = e.length,
    s = ud(t, n);
  Si(i, s) || (r.uniform1iv(this.addr, s), Mi(i, s));
  for (let a = 0; a !== n; ++a) t.setTexture3D(e[a] || bb, s[a]);
}
function W2(r, e, t) {
  const i = this.cache,
    n = e.length,
    s = ud(t, n);
  Si(i, s) || (r.uniform1iv(this.addr, s), Mi(i, s));
  for (let a = 0; a !== n; ++a) t.setTextureCube(e[a] || xb, s[a]);
}
function j2(r, e, t) {
  const i = this.cache,
    n = e.length,
    s = ud(t, n);
  Si(i, s) || (r.uniform1iv(this.addr, s), Mi(i, s));
  for (let a = 0; a !== n; ++a) t.setTexture2DArray(e[a] || _b, s[a]);
}
function q2(r) {
  switch (r) {
    case 5126:
      return C2;
    case 35664:
      return D2;
    case 35665:
      return P2;
    case 35666:
      return A2;
    case 35674:
      return L2;
    case 35675:
      return R2;
    case 35676:
      return k2;
    case 5124:
    case 35670:
      return I2;
    case 35667:
    case 35671:
      return F2;
    case 35668:
    case 35672:
      return O2;
    case 35669:
    case 35673:
      return N2;
    case 5125:
      return B2;
    case 36294:
      return V2;
    case 36295:
      return z2;
    case 36296:
      return U2;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return G2;
    case 35679:
    case 36299:
    case 36307:
      return H2;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return W2;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return j2;
  }
}
class X2 {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.setValue = E2(t.type));
  }
}
class $2 {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = q2(t.type));
  }
}
class Y2 {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, i) {
    const n = this.seq;
    for (let s = 0, a = n.length; s !== a; ++s) {
      const o = n[s];
      o.setValue(e, t[o.id], i);
    }
  }
}
const Bp = /(\w+)(\])?(\[|\.)?/g;
function tv(r, e) {
  r.seq.push(e), (r.map[e.id] = e);
}
function K2(r, e, t) {
  const i = r.name,
    n = i.length;
  for (Bp.lastIndex = 0; ; ) {
    const s = Bp.exec(i),
      a = Bp.lastIndex;
    let o = s[1];
    const u = s[2] === "]",
      h = s[3];
    if ((u && (o = o | 0), h === void 0 || (h === "[" && a + 2 === n))) {
      tv(t, h === void 0 ? new X2(o, r, e) : new $2(o, r, e));
      break;
    } else {
      let c = t.map[o];
      c === void 0 && ((c = new Y2(o)), tv(t, c)), (t = c);
    }
  }
}
class Rh {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const i = e.getProgramParameter(t, 35718);
    for (let n = 0; n < i; ++n) {
      const s = e.getActiveUniform(t, n),
        a = e.getUniformLocation(t, s.name);
      K2(s, a, this);
    }
  }
  setValue(e, t, i, n) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, n);
  }
  setOptional(e, t, i) {
    const n = t[i];
    n !== void 0 && this.setValue(e, i, n);
  }
  static upload(e, t, i, n) {
    for (let s = 0, a = t.length; s !== a; ++s) {
      const o = t[s],
        u = i[o.id];
      u.needsUpdate !== !1 && o.setValue(e, u.value, n);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let n = 0, s = e.length; n !== s; ++n) {
      const a = e[n];
      a.id in t && i.push(a);
    }
    return i;
  }
}
function iv(r, e, t) {
  const i = r.createShader(e);
  return r.shaderSource(i, t), r.compileShader(i), i;
}
let Z2 = 0;
function J2(r, e) {
  const t = r.split(`
`),
    i = [],
    n = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let a = n; a < s; a++) {
    const o = a + 1;
    i.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
  }
  return i.join(`
`);
}
function Q2(r) {
  switch (r) {
    case gr:
      return ["Linear", "( value )"];
    case Ht:
      return ["sRGB", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported encoding:", r),
        ["Linear", "( value )"]
      );
  }
}
function nv(r, e, t) {
  const i = r.getShaderParameter(e, 35713),
    n = r.getShaderInfoLog(e).trim();
  if (i && n === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(n);
  if (s) {
    const a = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      n +
      `

` +
      J2(r.getShaderSource(e), a)
    );
  } else return n;
}
function eC(r, e) {
  const t = Q2(e);
  return "vec4 " + r + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function tC(r, e) {
  let t;
  switch (e) {
    case oS:
      t = "Linear";
      break;
    case aS:
      t = "Reinhard";
      break;
    case lS:
      t = "OptimizedCineon";
      break;
    case cS:
      t = "ACESFilmic";
      break;
    case uS:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function iC(r) {
  return [
    r.extensionDerivatives ||
    r.envMapCubeUVHeight ||
    r.bumpMap ||
    r.tangentSpaceNormalMap ||
    r.clearcoatNormalMap ||
    r.flatShading ||
    r.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (r.extensionFragDepth || r.logarithmicDepthBuffer) &&
    r.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    r.extensionDrawBuffers && r.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (r.extensionShaderTextureLOD || r.envMap || r.transmission) &&
    r.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(vc).join(`
`);
}
function nC(r) {
  const e = [];
  for (const t in r) {
    const i = r[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function sC(r, e) {
  const t = {},
    i = r.getProgramParameter(e, 35721);
  for (let n = 0; n < i; n++) {
    const s = r.getActiveAttrib(e, n),
      a = s.name;
    let o = 1;
    s.type === 35674 && (o = 2),
      s.type === 35675 && (o = 3),
      s.type === 35676 && (o = 4),
      (t[a] = {
        type: s.type,
        location: r.getAttribLocation(e, a),
        locationSize: o,
      });
  }
  return t;
}
function vc(r) {
  return r !== "";
}
function sv(r, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return r
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function rv(r, e) {
  return r
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const rC = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Pf(r) {
  return r.replace(rC, oC);
}
function oC(r, e) {
  const t = Tt[e];
  if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
  return Pf(t);
}
const aC =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function ov(r) {
  return r.replace(aC, lC);
}
function lC(r, e, t, i) {
  let n = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    n += i
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return n;
}
function av(r) {
  let e =
    "precision " +
    r.precision +
    ` float;
precision ` +
    r.precision +
    " int;";
  return (
    r.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : r.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : r.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function cC(r) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    r.shadowMapType === K_
      ? (e = "SHADOWMAP_TYPE_PCF")
      : r.shadowMapType === V1
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : r.shadowMapType === gc && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function uC(r) {
  let e = "ENVMAP_TYPE_CUBE";
  if (r.envMap)
    switch (r.envMapMode) {
      case al:
      case ll:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case ld:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function hC(r) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (r.envMap)
    switch (r.envMapMode) {
      case ll:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function dC(r) {
  let e = "ENVMAP_BLENDING_NONE";
  if (r.envMap)
    switch (r.combine) {
      case eb:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case sS:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case rS:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function pC(r) {
  const e = r.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    i = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: i,
    maxMip: t,
  };
}
function fC(r, e, t, i) {
  const n = r.getContext(),
    s = t.defines;
  let a = t.vertexShader,
    o = t.fragmentShader;
  const u = cC(t),
    h = uC(t),
    f = hC(t),
    c = dC(t),
    d = pC(t),
    m = t.isWebGL2 ? "" : iC(t),
    x = nC(s),
    v = n.createProgram();
  let b,
    y,
    M = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((b = [x].filter(vc).join(`
`)),
      b.length > 0 &&
        (b += `
`),
      (y = [m, x].filter(vc).join(`
`)),
      y.length > 0 &&
        (y += `
`))
    : ((b = [
        av(t),
        "#define SHADER_NAME " + t.shaderName,
        x,
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + f : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMap && t.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        t.normalMap && t.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.displacementMap && t.supportsVertexTextures
          ? "#define USE_DISPLACEMENTMAP"
          : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs ? "#define USE_UV" : "",
        t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + u : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(vc).join(`
`)),
      (y = [
        m,
        av(t),
        "#define SHADER_NAME " + t.shaderName,
        x,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + h : "",
        t.envMap ? "#define " + f : "",
        t.envMap ? "#define " + c : "",
        d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
        d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
        d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMap && t.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        t.normalMap && t.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs ? "#define USE_UV" : "",
        t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + u : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== pr ? "#define TONE_MAPPING" : "",
        t.toneMapping !== pr ? Tt.tonemapping_pars_fragment : "",
        t.toneMapping !== pr ? tC("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        Tt.encodings_pars_fragment,
        eC("linearToOutputTexel", t.outputEncoding),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(vc).join(`
`))),
    (a = Pf(a)),
    (a = sv(a, t)),
    (a = rv(a, t)),
    (o = Pf(o)),
    (o = sv(o, t)),
    (o = rv(o, t)),
    (a = ov(a)),
    (o = ov(o)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((M = `#version 300 es
`),
      (b =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        b),
      (y =
        [
          "#define varying in",
          t.glslVersion === L0
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === L0 ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        y));
  const D = M + b + a,
    C = M + y + o,
    A = iv(n, 35633, D),
    I = iv(n, 35632, C);
  if (
    (n.attachShader(v, A),
    n.attachShader(v, I),
    t.index0AttributeName !== void 0
      ? n.bindAttribLocation(v, 0, t.index0AttributeName)
      : t.morphTargets === !0 && n.bindAttribLocation(v, 0, "position"),
    n.linkProgram(v),
    r.debug.checkShaderErrors)
  ) {
    const k = n.getProgramInfoLog(v).trim(),
      O = n.getShaderInfoLog(A).trim(),
      J = n.getShaderInfoLog(I).trim();
    let ee = !0,
      X = !0;
    if (n.getProgramParameter(v, 35714) === !1) {
      ee = !1;
      const j = nv(n, A, "vertex"),
        Y = nv(n, I, "fragment");
      console.error(
        "THREE.WebGLProgram: Shader Error " +
          n.getError() +
          " - VALIDATE_STATUS " +
          n.getProgramParameter(v, 35715) +
          `

Program Info Log: ` +
          k +
          `
` +
          j +
          `
` +
          Y
      );
    } else
      k !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", k)
        : (O === "" || J === "") && (X = !1);
    X &&
      (this.diagnostics = {
        runnable: ee,
        programLog: k,
        vertexShader: { log: O, prefix: b },
        fragmentShader: { log: J, prefix: y },
      });
  }
  n.deleteShader(A), n.deleteShader(I);
  let F;
  this.getUniforms = function () {
    return F === void 0 && (F = new Rh(n, v)), F;
  };
  let P;
  return (
    (this.getAttributes = function () {
      return P === void 0 && (P = sC(n, v)), P;
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        n.deleteProgram(v),
        (this.program = void 0);
    }),
    (this.name = t.shaderName),
    (this.id = Z2++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = v),
    (this.vertexShader = A),
    (this.fragmentShader = I),
    this
  );
}
let mC = 0;
class gC {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      n = this._getShaderStage(t),
      s = this._getShaderStage(i),
      a = this._getShaderCacheForMaterial(e);
    return (
      a.has(n) === !1 && (a.add(n), n.usedTimes++),
      a.has(s) === !1 && (a.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && ((i = new Set()), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && ((i = new vC(e)), t.set(e, i)), i;
  }
}
class vC {
  constructor(e) {
    (this.id = mC++), (this.code = e), (this.usedTimes = 0);
  }
}
function _C(r, e, t, i, n, s, a) {
  const o = new bm(),
    u = new gC(),
    h = [],
    f = n.isWebGL2,
    c = n.logarithmicDepthBuffer,
    d = n.vertexTextures;
  let m = n.precision;
  const x = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function v(P, k, O, J, ee) {
    const X = J.fog,
      j = ee.geometry,
      Y = P.isMeshStandardMaterial ? J.environment : null,
      ie = (P.isMeshStandardMaterial ? t : e).get(P.envMap || Y),
      Q = ie && ie.mapping === ld ? ie.image.height : null,
      V = x[P.type];
    P.precision !== null &&
      ((m = n.getMaxPrecision(P.precision)),
      m !== P.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          P.precision,
          "not supported, using",
          m,
          "instead."
        ));
    const ve =
        j.morphAttributes.position ||
        j.morphAttributes.normal ||
        j.morphAttributes.color,
      U = ve !== void 0 ? ve.length : 0;
    let oe = 0;
    j.morphAttributes.position !== void 0 && (oe = 1),
      j.morphAttributes.normal !== void 0 && (oe = 2),
      j.morphAttributes.color !== void 0 && (oe = 3);
    let ue, fe, le, be;
    if (V) {
      const Ke = Ls[V];
      (ue = Ke.vertexShader), (fe = Ke.fragmentShader);
    } else
      (ue = P.vertexShader),
        (fe = P.fragmentShader),
        u.update(P),
        (le = u.getVertexShaderID(P)),
        (be = u.getFragmentShaderID(P));
    const ce = r.getRenderTarget(),
      He = P.alphaTest > 0,
      Se = P.clearcoat > 0,
      Oe = P.iridescence > 0;
    return {
      isWebGL2: f,
      shaderID: V,
      shaderName: P.type,
      vertexShader: ue,
      fragmentShader: fe,
      defines: P.defines,
      customVertexShaderID: le,
      customFragmentShaderID: be,
      isRawShaderMaterial: P.isRawShaderMaterial === !0,
      glslVersion: P.glslVersion,
      precision: m,
      instancing: ee.isInstancedMesh === !0,
      instancingColor: ee.isInstancedMesh === !0 && ee.instanceColor !== null,
      supportsVertexTextures: d,
      outputEncoding:
        ce === null
          ? r.outputEncoding
          : ce.isXRRenderTarget === !0
          ? ce.texture.encoding
          : gr,
      map: !!P.map,
      matcap: !!P.matcap,
      envMap: !!ie,
      envMapMode: ie && ie.mapping,
      envMapCubeUVHeight: Q,
      lightMap: !!P.lightMap,
      aoMap: !!P.aoMap,
      emissiveMap: !!P.emissiveMap,
      bumpMap: !!P.bumpMap,
      normalMap: !!P.normalMap,
      objectSpaceNormalMap: P.normalMapType === AS,
      tangentSpaceNormalMap: P.normalMapType === rb,
      decodeVideoTexture:
        !!P.map && P.map.isVideoTexture === !0 && P.map.encoding === Ht,
      clearcoat: Se,
      clearcoatMap: Se && !!P.clearcoatMap,
      clearcoatRoughnessMap: Se && !!P.clearcoatRoughnessMap,
      clearcoatNormalMap: Se && !!P.clearcoatNormalMap,
      iridescence: Oe,
      iridescenceMap: Oe && !!P.iridescenceMap,
      iridescenceThicknessMap: Oe && !!P.iridescenceThicknessMap,
      displacementMap: !!P.displacementMap,
      roughnessMap: !!P.roughnessMap,
      metalnessMap: !!P.metalnessMap,
      specularMap: !!P.specularMap,
      specularIntensityMap: !!P.specularIntensityMap,
      specularColorMap: !!P.specularColorMap,
      opaque: P.transparent === !1 && P.blending === Oo,
      alphaMap: !!P.alphaMap,
      alphaTest: He,
      gradientMap: !!P.gradientMap,
      sheen: P.sheen > 0,
      sheenColorMap: !!P.sheenColorMap,
      sheenRoughnessMap: !!P.sheenRoughnessMap,
      transmission: P.transmission > 0,
      transmissionMap: !!P.transmissionMap,
      thicknessMap: !!P.thicknessMap,
      combine: P.combine,
      vertexTangents: !!P.normalMap && !!j.attributes.tangent,
      vertexColors: P.vertexColors,
      vertexAlphas:
        P.vertexColors === !0 &&
        !!j.attributes.color &&
        j.attributes.color.itemSize === 4,
      vertexUvs:
        !!P.map ||
        !!P.bumpMap ||
        !!P.normalMap ||
        !!P.specularMap ||
        !!P.alphaMap ||
        !!P.emissiveMap ||
        !!P.roughnessMap ||
        !!P.metalnessMap ||
        !!P.clearcoatMap ||
        !!P.clearcoatRoughnessMap ||
        !!P.clearcoatNormalMap ||
        !!P.iridescenceMap ||
        !!P.iridescenceThicknessMap ||
        !!P.displacementMap ||
        !!P.transmissionMap ||
        !!P.thicknessMap ||
        !!P.specularIntensityMap ||
        !!P.specularColorMap ||
        !!P.sheenColorMap ||
        !!P.sheenRoughnessMap,
      uvsVertexOnly:
        !(
          P.map ||
          P.bumpMap ||
          P.normalMap ||
          P.specularMap ||
          P.alphaMap ||
          P.emissiveMap ||
          P.roughnessMap ||
          P.metalnessMap ||
          P.clearcoatNormalMap ||
          P.iridescenceMap ||
          P.iridescenceThicknessMap ||
          P.transmission > 0 ||
          P.transmissionMap ||
          P.thicknessMap ||
          P.specularIntensityMap ||
          P.specularColorMap ||
          P.sheen > 0 ||
          P.sheenColorMap ||
          P.sheenRoughnessMap
        ) && !!P.displacementMap,
      fog: !!X,
      useFog: P.fog === !0,
      fogExp2: X && X.isFogExp2,
      flatShading: !!P.flatShading,
      sizeAttenuation: P.sizeAttenuation,
      logarithmicDepthBuffer: c,
      skinning: ee.isSkinnedMesh === !0,
      morphTargets: j.morphAttributes.position !== void 0,
      morphNormals: j.morphAttributes.normal !== void 0,
      morphColors: j.morphAttributes.color !== void 0,
      morphTargetsCount: U,
      morphTextureStride: oe,
      numDirLights: k.directional.length,
      numPointLights: k.point.length,
      numSpotLights: k.spot.length,
      numSpotLightMaps: k.spotLightMap.length,
      numRectAreaLights: k.rectArea.length,
      numHemiLights: k.hemi.length,
      numDirLightShadows: k.directionalShadowMap.length,
      numPointLightShadows: k.pointShadowMap.length,
      numSpotLightShadows: k.spotShadowMap.length,
      numSpotLightShadowsWithMaps: k.numSpotLightShadowsWithMaps,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: P.dithering,
      shadowMapEnabled: r.shadowMap.enabled && O.length > 0,
      shadowMapType: r.shadowMap.type,
      toneMapping: P.toneMapped ? r.toneMapping : pr,
      physicallyCorrectLights: r.physicallyCorrectLights,
      premultipliedAlpha: P.premultipliedAlpha,
      doubleSided: P.side === ru,
      flipSided: P.side === Bn,
      useDepthPacking: !!P.depthPacking,
      depthPacking: P.depthPacking || 0,
      index0AttributeName: P.index0AttributeName,
      extensionDerivatives: P.extensions && P.extensions.derivatives,
      extensionFragDepth: P.extensions && P.extensions.fragDepth,
      extensionDrawBuffers: P.extensions && P.extensions.drawBuffers,
      extensionShaderTextureLOD: P.extensions && P.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: f || i.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: f || i.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: f || i.has("EXT_shader_texture_lod"),
      customProgramCacheKey: P.customProgramCacheKey(),
    };
  }
  function b(P) {
    const k = [];
    if (
      (P.shaderID
        ? k.push(P.shaderID)
        : (k.push(P.customVertexShaderID), k.push(P.customFragmentShaderID)),
      P.defines !== void 0)
    )
      for (const O in P.defines) k.push(O), k.push(P.defines[O]);
    return (
      P.isRawShaderMaterial === !1 &&
        (y(k, P), M(k, P), k.push(r.outputEncoding)),
      k.push(P.customProgramCacheKey),
      k.join()
    );
  }
  function y(P, k) {
    P.push(k.precision),
      P.push(k.outputEncoding),
      P.push(k.envMapMode),
      P.push(k.envMapCubeUVHeight),
      P.push(k.combine),
      P.push(k.vertexUvs),
      P.push(k.fogExp2),
      P.push(k.sizeAttenuation),
      P.push(k.morphTargetsCount),
      P.push(k.morphAttributeCount),
      P.push(k.numDirLights),
      P.push(k.numPointLights),
      P.push(k.numSpotLights),
      P.push(k.numSpotLightMaps),
      P.push(k.numHemiLights),
      P.push(k.numRectAreaLights),
      P.push(k.numDirLightShadows),
      P.push(k.numPointLightShadows),
      P.push(k.numSpotLightShadows),
      P.push(k.numSpotLightShadowsWithMaps),
      P.push(k.shadowMapType),
      P.push(k.toneMapping),
      P.push(k.numClippingPlanes),
      P.push(k.numClipIntersection),
      P.push(k.depthPacking);
  }
  function M(P, k) {
    o.disableAll(),
      k.isWebGL2 && o.enable(0),
      k.supportsVertexTextures && o.enable(1),
      k.instancing && o.enable(2),
      k.instancingColor && o.enable(3),
      k.map && o.enable(4),
      k.matcap && o.enable(5),
      k.envMap && o.enable(6),
      k.lightMap && o.enable(7),
      k.aoMap && o.enable(8),
      k.emissiveMap && o.enable(9),
      k.bumpMap && o.enable(10),
      k.normalMap && o.enable(11),
      k.objectSpaceNormalMap && o.enable(12),
      k.tangentSpaceNormalMap && o.enable(13),
      k.clearcoat && o.enable(14),
      k.clearcoatMap && o.enable(15),
      k.clearcoatRoughnessMap && o.enable(16),
      k.clearcoatNormalMap && o.enable(17),
      k.iridescence && o.enable(18),
      k.iridescenceMap && o.enable(19),
      k.iridescenceThicknessMap && o.enable(20),
      k.displacementMap && o.enable(21),
      k.specularMap && o.enable(22),
      k.roughnessMap && o.enable(23),
      k.metalnessMap && o.enable(24),
      k.gradientMap && o.enable(25),
      k.alphaMap && o.enable(26),
      k.alphaTest && o.enable(27),
      k.vertexColors && o.enable(28),
      k.vertexAlphas && o.enable(29),
      k.vertexUvs && o.enable(30),
      k.vertexTangents && o.enable(31),
      k.uvsVertexOnly && o.enable(32),
      P.push(o.mask),
      o.disableAll(),
      k.fog && o.enable(0),
      k.useFog && o.enable(1),
      k.flatShading && o.enable(2),
      k.logarithmicDepthBuffer && o.enable(3),
      k.skinning && o.enable(4),
      k.morphTargets && o.enable(5),
      k.morphNormals && o.enable(6),
      k.morphColors && o.enable(7),
      k.premultipliedAlpha && o.enable(8),
      k.shadowMapEnabled && o.enable(9),
      k.physicallyCorrectLights && o.enable(10),
      k.doubleSided && o.enable(11),
      k.flipSided && o.enable(12),
      k.useDepthPacking && o.enable(13),
      k.dithering && o.enable(14),
      k.specularIntensityMap && o.enable(15),
      k.specularColorMap && o.enable(16),
      k.transmission && o.enable(17),
      k.transmissionMap && o.enable(18),
      k.thicknessMap && o.enable(19),
      k.sheen && o.enable(20),
      k.sheenColorMap && o.enable(21),
      k.sheenRoughnessMap && o.enable(22),
      k.decodeVideoTexture && o.enable(23),
      k.opaque && o.enable(24),
      P.push(o.mask);
  }
  function D(P) {
    const k = x[P.type];
    let O;
    if (k) {
      const J = Ls[k];
      O = sM.clone(J.uniforms);
    } else O = P.uniforms;
    return O;
  }
  function C(P, k) {
    let O;
    for (let J = 0, ee = h.length; J < ee; J++) {
      const X = h[J];
      if (X.cacheKey === k) {
        (O = X), ++O.usedTimes;
        break;
      }
    }
    return O === void 0 && ((O = new fC(r, k, P, s)), h.push(O)), O;
  }
  function A(P) {
    if (--P.usedTimes === 0) {
      const k = h.indexOf(P);
      (h[k] = h[h.length - 1]), h.pop(), P.destroy();
    }
  }
  function I(P) {
    u.remove(P);
  }
  function F() {
    u.dispose();
  }
  return {
    getParameters: v,
    getProgramCacheKey: b,
    getUniforms: D,
    acquireProgram: C,
    releaseProgram: A,
    releaseShaderCache: I,
    programs: h,
    dispose: F,
  };
}
function bC() {
  let r = new WeakMap();
  function e(s) {
    let a = r.get(s);
    return a === void 0 && ((a = {}), r.set(s, a)), a;
  }
  function t(s) {
    r.delete(s);
  }
  function i(s, a, o) {
    r.get(s)[a] = o;
  }
  function n() {
    r = new WeakMap();
  }
  return { get: e, remove: t, update: i, dispose: n };
}
function xC(r, e) {
  return r.groupOrder !== e.groupOrder
    ? r.groupOrder - e.groupOrder
    : r.renderOrder !== e.renderOrder
    ? r.renderOrder - e.renderOrder
    : r.material.id !== e.material.id
    ? r.material.id - e.material.id
    : r.z !== e.z
    ? r.z - e.z
    : r.id - e.id;
}
function lv(r, e) {
  return r.groupOrder !== e.groupOrder
    ? r.groupOrder - e.groupOrder
    : r.renderOrder !== e.renderOrder
    ? r.renderOrder - e.renderOrder
    : r.z !== e.z
    ? e.z - r.z
    : r.id - e.id;
}
function cv() {
  const r = [];
  let e = 0;
  const t = [],
    i = [],
    n = [];
  function s() {
    (e = 0), (t.length = 0), (i.length = 0), (n.length = 0);
  }
  function a(c, d, m, x, v, b) {
    let y = r[e];
    return (
      y === void 0
        ? ((y = {
            id: c.id,
            object: c,
            geometry: d,
            material: m,
            groupOrder: x,
            renderOrder: c.renderOrder,
            z: v,
            group: b,
          }),
          (r[e] = y))
        : ((y.id = c.id),
          (y.object = c),
          (y.geometry = d),
          (y.material = m),
          (y.groupOrder = x),
          (y.renderOrder = c.renderOrder),
          (y.z = v),
          (y.group = b)),
      e++,
      y
    );
  }
  function o(c, d, m, x, v, b) {
    const y = a(c, d, m, x, v, b);
    m.transmission > 0
      ? i.push(y)
      : m.transparent === !0
      ? n.push(y)
      : t.push(y);
  }
  function u(c, d, m, x, v, b) {
    const y = a(c, d, m, x, v, b);
    m.transmission > 0
      ? i.unshift(y)
      : m.transparent === !0
      ? n.unshift(y)
      : t.unshift(y);
  }
  function h(c, d) {
    t.length > 1 && t.sort(c || xC),
      i.length > 1 && i.sort(d || lv),
      n.length > 1 && n.sort(d || lv);
  }
  function f() {
    for (let c = e, d = r.length; c < d; c++) {
      const m = r[c];
      if (m.id === null) break;
      (m.id = null),
        (m.object = null),
        (m.geometry = null),
        (m.material = null),
        (m.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: n,
    init: s,
    push: o,
    unshift: u,
    finish: f,
    sort: h,
  };
}
function wC() {
  let r = new WeakMap();
  function e(i, n) {
    const s = r.get(i);
    let a;
    return (
      s === void 0
        ? ((a = new cv()), r.set(i, [a]))
        : n >= s.length
        ? ((a = new cv()), s.push(a))
        : (a = s[n]),
      a
    );
  }
  function t() {
    r = new WeakMap();
  }
  return { get: e, dispose: t };
}
function yC() {
  const r = {};
  return {
    get: function (e) {
      if (r[e.id] !== void 0) return r[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new Z(), color: new ct() };
          break;
        case "SpotLight":
          t = {
            position: new Z(),
            direction: new Z(),
            color: new ct(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new Z(), color: new ct(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new Z(), skyColor: new ct(), groundColor: new ct() };
          break;
        case "RectAreaLight":
          t = {
            color: new ct(),
            position: new Z(),
            halfWidth: new Z(),
            halfHeight: new Z(),
          };
          break;
      }
      return (r[e.id] = t), t;
    },
  };
}
function SC() {
  const r = {};
  return {
    get: function (e) {
      if (r[e.id] !== void 0) return r[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ue(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ue(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ue(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (r[e.id] = t), t;
    },
  };
}
let MC = 0;
function TC(r, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (r.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (r.map ? 1 : 0)
  );
}
function EC(r, e) {
  const t = new yC(),
    i = SC(),
    n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
    };
  for (let f = 0; f < 9; f++) n.probe.push(new Z());
  const s = new Z(),
    a = new At(),
    o = new At();
  function u(f, c) {
    let d = 0,
      m = 0,
      x = 0;
    for (let J = 0; J < 9; J++) n.probe[J].set(0, 0, 0);
    let v = 0,
      b = 0,
      y = 0,
      M = 0,
      D = 0,
      C = 0,
      A = 0,
      I = 0,
      F = 0,
      P = 0;
    f.sort(TC);
    const k = c !== !0 ? Math.PI : 1;
    for (let J = 0, ee = f.length; J < ee; J++) {
      const X = f[J],
        j = X.color,
        Y = X.intensity,
        ie = X.distance,
        Q = X.shadow && X.shadow.map ? X.shadow.map.texture : null;
      if (X.isAmbientLight)
        (d += j.r * Y * k), (m += j.g * Y * k), (x += j.b * Y * k);
      else if (X.isLightProbe)
        for (let V = 0; V < 9; V++)
          n.probe[V].addScaledVector(X.sh.coefficients[V], Y);
      else if (X.isDirectionalLight) {
        const V = t.get(X);
        if (
          (V.color.copy(X.color).multiplyScalar(X.intensity * k), X.castShadow)
        ) {
          const ve = X.shadow,
            U = i.get(X);
          (U.shadowBias = ve.bias),
            (U.shadowNormalBias = ve.normalBias),
            (U.shadowRadius = ve.radius),
            (U.shadowMapSize = ve.mapSize),
            (n.directionalShadow[v] = U),
            (n.directionalShadowMap[v] = Q),
            (n.directionalShadowMatrix[v] = X.shadow.matrix),
            C++;
        }
        (n.directional[v] = V), v++;
      } else if (X.isSpotLight) {
        const V = t.get(X);
        V.position.setFromMatrixPosition(X.matrixWorld),
          V.color.copy(j).multiplyScalar(Y * k),
          (V.distance = ie),
          (V.coneCos = Math.cos(X.angle)),
          (V.penumbraCos = Math.cos(X.angle * (1 - X.penumbra))),
          (V.decay = X.decay),
          (n.spot[y] = V);
        const ve = X.shadow;
        if (
          (X.map &&
            ((n.spotLightMap[F] = X.map),
            F++,
            ve.updateMatrices(X),
            X.castShadow && P++),
          (n.spotLightMatrix[y] = ve.matrix),
          X.castShadow)
        ) {
          const U = i.get(X);
          (U.shadowBias = ve.bias),
            (U.shadowNormalBias = ve.normalBias),
            (U.shadowRadius = ve.radius),
            (U.shadowMapSize = ve.mapSize),
            (n.spotShadow[y] = U),
            (n.spotShadowMap[y] = Q),
            I++;
        }
        y++;
      } else if (X.isRectAreaLight) {
        const V = t.get(X);
        V.color.copy(j).multiplyScalar(Y),
          V.halfWidth.set(X.width * 0.5, 0, 0),
          V.halfHeight.set(0, X.height * 0.5, 0),
          (n.rectArea[M] = V),
          M++;
      } else if (X.isPointLight) {
        const V = t.get(X);
        if (
          (V.color.copy(X.color).multiplyScalar(X.intensity * k),
          (V.distance = X.distance),
          (V.decay = X.decay),
          X.castShadow)
        ) {
          const ve = X.shadow,
            U = i.get(X);
          (U.shadowBias = ve.bias),
            (U.shadowNormalBias = ve.normalBias),
            (U.shadowRadius = ve.radius),
            (U.shadowMapSize = ve.mapSize),
            (U.shadowCameraNear = ve.camera.near),
            (U.shadowCameraFar = ve.camera.far),
            (n.pointShadow[b] = U),
            (n.pointShadowMap[b] = Q),
            (n.pointShadowMatrix[b] = X.shadow.matrix),
            A++;
        }
        (n.point[b] = V), b++;
      } else if (X.isHemisphereLight) {
        const V = t.get(X);
        V.skyColor.copy(X.color).multiplyScalar(Y * k),
          V.groundColor.copy(X.groundColor).multiplyScalar(Y * k),
          (n.hemi[D] = V),
          D++;
      }
    }
    M > 0 &&
      (e.isWebGL2 || r.has("OES_texture_float_linear") === !0
        ? ((n.rectAreaLTC1 = Be.LTC_FLOAT_1), (n.rectAreaLTC2 = Be.LTC_FLOAT_2))
        : r.has("OES_texture_half_float_linear") === !0
        ? ((n.rectAreaLTC1 = Be.LTC_HALF_1), (n.rectAreaLTC2 = Be.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (n.ambient[0] = d),
      (n.ambient[1] = m),
      (n.ambient[2] = x);
    const O = n.hash;
    (O.directionalLength !== v ||
      O.pointLength !== b ||
      O.spotLength !== y ||
      O.rectAreaLength !== M ||
      O.hemiLength !== D ||
      O.numDirectionalShadows !== C ||
      O.numPointShadows !== A ||
      O.numSpotShadows !== I ||
      O.numSpotMaps !== F) &&
      ((n.directional.length = v),
      (n.spot.length = y),
      (n.rectArea.length = M),
      (n.point.length = b),
      (n.hemi.length = D),
      (n.directionalShadow.length = C),
      (n.directionalShadowMap.length = C),
      (n.pointShadow.length = A),
      (n.pointShadowMap.length = A),
      (n.spotShadow.length = I),
      (n.spotShadowMap.length = I),
      (n.directionalShadowMatrix.length = C),
      (n.pointShadowMatrix.length = A),
      (n.spotLightMatrix.length = I + F - P),
      (n.spotLightMap.length = F),
      (n.numSpotLightShadowsWithMaps = P),
      (O.directionalLength = v),
      (O.pointLength = b),
      (O.spotLength = y),
      (O.rectAreaLength = M),
      (O.hemiLength = D),
      (O.numDirectionalShadows = C),
      (O.numPointShadows = A),
      (O.numSpotShadows = I),
      (O.numSpotMaps = F),
      (n.version = MC++));
  }
  function h(f, c) {
    let d = 0,
      m = 0,
      x = 0,
      v = 0,
      b = 0;
    const y = c.matrixWorldInverse;
    for (let M = 0, D = f.length; M < D; M++) {
      const C = f[M];
      if (C.isDirectionalLight) {
        const A = n.directional[d];
        A.direction.setFromMatrixPosition(C.matrixWorld),
          s.setFromMatrixPosition(C.target.matrixWorld),
          A.direction.sub(s),
          A.direction.transformDirection(y),
          d++;
      } else if (C.isSpotLight) {
        const A = n.spot[x];
        A.position.setFromMatrixPosition(C.matrixWorld),
          A.position.applyMatrix4(y),
          A.direction.setFromMatrixPosition(C.matrixWorld),
          s.setFromMatrixPosition(C.target.matrixWorld),
          A.direction.sub(s),
          A.direction.transformDirection(y),
          x++;
      } else if (C.isRectAreaLight) {
        const A = n.rectArea[v];
        A.position.setFromMatrixPosition(C.matrixWorld),
          A.position.applyMatrix4(y),
          o.identity(),
          a.copy(C.matrixWorld),
          a.premultiply(y),
          o.extractRotation(a),
          A.halfWidth.set(C.width * 0.5, 0, 0),
          A.halfHeight.set(0, C.height * 0.5, 0),
          A.halfWidth.applyMatrix4(o),
          A.halfHeight.applyMatrix4(o),
          v++;
      } else if (C.isPointLight) {
        const A = n.point[m];
        A.position.setFromMatrixPosition(C.matrixWorld),
          A.position.applyMatrix4(y),
          m++;
      } else if (C.isHemisphereLight) {
        const A = n.hemi[b];
        A.direction.setFromMatrixPosition(C.matrixWorld),
          A.direction.transformDirection(y),
          b++;
      }
    }
  }
  return { setup: u, setupView: h, state: n };
}
function uv(r, e) {
  const t = new EC(r, e),
    i = [],
    n = [];
  function s() {
    (i.length = 0), (n.length = 0);
  }
  function a(c) {
    i.push(c);
  }
  function o(c) {
    n.push(c);
  }
  function u(c) {
    t.setup(i, c);
  }
  function h(c) {
    t.setupView(i, c);
  }
  return {
    init: s,
    state: { lightsArray: i, shadowsArray: n, lights: t },
    setupLights: u,
    setupLightsView: h,
    pushLight: a,
    pushShadow: o,
  };
}
function CC(r, e) {
  let t = new WeakMap();
  function i(s, a = 0) {
    const o = t.get(s);
    let u;
    return (
      o === void 0
        ? ((u = new uv(r, e)), t.set(s, [u]))
        : a >= o.length
        ? ((u = new uv(r, e)), o.push(u))
        : (u = o[a]),
      u
    );
  }
  function n() {
    t = new WeakMap();
  }
  return { get: i, dispose: n };
}
class DC extends Is {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = DS),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class PC extends Is {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.referencePosition = new Z()),
      (this.nearDistance = 1),
      (this.farDistance = 1e3),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.referencePosition.copy(e.referencePosition),
      (this.nearDistance = e.nearDistance),
      (this.farDistance = e.farDistance),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const AC = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  LC = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function RC(r, e, t) {
  let i = new wm();
  const n = new Ue(),
    s = new Ue(),
    a = new Kt(),
    o = new DC({ depthPacking: PS }),
    u = new PC(),
    h = {},
    f = t.maxTextureSize,
    c = { 0: Bn, 1: Bs, 2: ru },
    d = new vr({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Ue() },
        radius: { value: 4 },
      },
      vertexShader: AC,
      fragmentShader: LC,
    }),
    m = d.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const x = new cn();
  x.setAttribute(
    "position",
    new an(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const v = new Wi(x, d),
    b = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = K_),
    (this.render = function (C, A, I) {
      if (
        b.enabled === !1 ||
        (b.autoUpdate === !1 && b.needsUpdate === !1) ||
        C.length === 0
      )
        return;
      const F = r.getRenderTarget(),
        P = r.getActiveCubeFace(),
        k = r.getActiveMipmapLevel(),
        O = r.state;
      O.setBlending(dr),
        O.buffers.color.setClear(1, 1, 1, 1),
        O.buffers.depth.setTest(!0),
        O.setScissorTest(!1);
      for (let J = 0, ee = C.length; J < ee; J++) {
        const X = C[J],
          j = X.shadow;
        if (j === void 0) {
          console.warn("THREE.WebGLShadowMap:", X, "has no shadow.");
          continue;
        }
        if (j.autoUpdate === !1 && j.needsUpdate === !1) continue;
        n.copy(j.mapSize);
        const Y = j.getFrameExtents();
        if (
          (n.multiply(Y),
          s.copy(j.mapSize),
          (n.x > f || n.y > f) &&
            (n.x > f &&
              ((s.x = Math.floor(f / Y.x)),
              (n.x = s.x * Y.x),
              (j.mapSize.x = s.x)),
            n.y > f &&
              ((s.y = Math.floor(f / Y.y)),
              (n.y = s.y * Y.y),
              (j.mapSize.y = s.y))),
          j.map === null)
        ) {
          const Q = this.type !== gc ? { minFilter: Ai, magFilter: Ai } : {};
          (j.map = new Zo(n.x, n.y, Q)),
            (j.map.texture.name = X.name + ".shadowMap"),
            j.camera.updateProjectionMatrix();
        }
        r.setRenderTarget(j.map), r.clear();
        const ie = j.getViewportCount();
        for (let Q = 0; Q < ie; Q++) {
          const V = j.getViewport(Q);
          a.set(s.x * V.x, s.y * V.y, s.x * V.z, s.y * V.w),
            O.viewport(a),
            j.updateMatrices(X, Q),
            (i = j.getFrustum()),
            D(A, I, j.camera, X, this.type);
        }
        j.isPointLightShadow !== !0 && this.type === gc && y(j, I),
          (j.needsUpdate = !1);
      }
      (b.needsUpdate = !1), r.setRenderTarget(F, P, k);
    });
  function y(C, A) {
    const I = e.update(v);
    d.defines.VSM_SAMPLES !== C.blurSamples &&
      ((d.defines.VSM_SAMPLES = C.blurSamples),
      (m.defines.VSM_SAMPLES = C.blurSamples),
      (d.needsUpdate = !0),
      (m.needsUpdate = !0)),
      C.mapPass === null && (C.mapPass = new Zo(n.x, n.y)),
      (d.uniforms.shadow_pass.value = C.map.texture),
      (d.uniforms.resolution.value = C.mapSize),
      (d.uniforms.radius.value = C.radius),
      r.setRenderTarget(C.mapPass),
      r.clear(),
      r.renderBufferDirect(A, null, I, d, v, null),
      (m.uniforms.shadow_pass.value = C.mapPass.texture),
      (m.uniforms.resolution.value = C.mapSize),
      (m.uniforms.radius.value = C.radius),
      r.setRenderTarget(C.map),
      r.clear(),
      r.renderBufferDirect(A, null, I, m, v, null);
  }
  function M(C, A, I, F, P, k) {
    let O = null;
    const J =
      I.isPointLight === !0 ? C.customDistanceMaterial : C.customDepthMaterial;
    if (J !== void 0) O = J;
    else if (
      ((O = I.isPointLight === !0 ? u : o),
      (r.localClippingEnabled &&
        A.clipShadows === !0 &&
        Array.isArray(A.clippingPlanes) &&
        A.clippingPlanes.length !== 0) ||
        (A.displacementMap && A.displacementScale !== 0) ||
        (A.alphaMap && A.alphaTest > 0) ||
        (A.map && A.alphaTest > 0))
    ) {
      const ee = O.uuid,
        X = A.uuid;
      let j = h[ee];
      j === void 0 && ((j = {}), (h[ee] = j));
      let Y = j[X];
      Y === void 0 && ((Y = O.clone()), (j[X] = Y)), (O = Y);
    }
    return (
      (O.visible = A.visible),
      (O.wireframe = A.wireframe),
      k === gc
        ? (O.side = A.shadowSide !== null ? A.shadowSide : A.side)
        : (O.side = A.shadowSide !== null ? A.shadowSide : c[A.side]),
      (O.alphaMap = A.alphaMap),
      (O.alphaTest = A.alphaTest),
      (O.map = A.map),
      (O.clipShadows = A.clipShadows),
      (O.clippingPlanes = A.clippingPlanes),
      (O.clipIntersection = A.clipIntersection),
      (O.displacementMap = A.displacementMap),
      (O.displacementScale = A.displacementScale),
      (O.displacementBias = A.displacementBias),
      (O.wireframeLinewidth = A.wireframeLinewidth),
      (O.linewidth = A.linewidth),
      I.isPointLight === !0 &&
        O.isMeshDistanceMaterial === !0 &&
        (O.referencePosition.setFromMatrixPosition(I.matrixWorld),
        (O.nearDistance = F),
        (O.farDistance = P)),
      O
    );
  }
  function D(C, A, I, F, P) {
    if (C.visible === !1) return;
    if (
      C.layers.test(A.layers) &&
      (C.isMesh || C.isLine || C.isPoints) &&
      (C.castShadow || (C.receiveShadow && P === gc)) &&
      (!C.frustumCulled || i.intersectsObject(C))
    ) {
      C.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse, C.matrixWorld);
      const J = e.update(C),
        ee = C.material;
      if (Array.isArray(ee)) {
        const X = J.groups;
        for (let j = 0, Y = X.length; j < Y; j++) {
          const ie = X[j],
            Q = ee[ie.materialIndex];
          if (Q && Q.visible) {
            const V = M(C, Q, F, I.near, I.far, P);
            r.renderBufferDirect(I, null, J, V, C, ie);
          }
        }
      } else if (ee.visible) {
        const X = M(C, ee, F, I.near, I.far, P);
        r.renderBufferDirect(I, null, J, X, C, null);
      }
    }
    const O = C.children;
    for (let J = 0, ee = O.length; J < ee; J++) D(O[J], A, I, F, P);
  }
}
function kC(r, e, t) {
  const i = t.isWebGL2;
  function n() {
    let $ = !1;
    const ge = new Kt();
    let ye = null;
    const Ie = new Kt(0, 0, 0, 0);
    return {
      setMask: function (Ge) {
        ye !== Ge && !$ && (r.colorMask(Ge, Ge, Ge, Ge), (ye = Ge));
      },
      setLocked: function (Ge) {
        $ = Ge;
      },
      setClear: function (Ge, Mt, zt, Rt, tt) {
        tt === !0 && ((Ge *= Rt), (Mt *= Rt), (zt *= Rt)),
          ge.set(Ge, Mt, zt, Rt),
          Ie.equals(ge) === !1 && (r.clearColor(Ge, Mt, zt, Rt), Ie.copy(ge));
      },
      reset: function () {
        ($ = !1), (ye = null), Ie.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let $ = !1,
      ge = null,
      ye = null,
      Ie = null;
    return {
      setTest: function (Ge) {
        Ge ? He(2929) : Se(2929);
      },
      setMask: function (Ge) {
        ge !== Ge && !$ && (r.depthMask(Ge), (ge = Ge));
      },
      setFunc: function (Ge) {
        if (ye !== Ge) {
          switch (Ge) {
            case Z1:
              r.depthFunc(512);
              break;
            case J1:
              r.depthFunc(519);
              break;
            case Q1:
              r.depthFunc(513);
              break;
            case yf:
              r.depthFunc(515);
              break;
            case eS:
              r.depthFunc(514);
              break;
            case tS:
              r.depthFunc(518);
              break;
            case iS:
              r.depthFunc(516);
              break;
            case nS:
              r.depthFunc(517);
              break;
            default:
              r.depthFunc(515);
          }
          ye = Ge;
        }
      },
      setLocked: function (Ge) {
        $ = Ge;
      },
      setClear: function (Ge) {
        Ie !== Ge && (r.clearDepth(Ge), (Ie = Ge));
      },
      reset: function () {
        ($ = !1), (ge = null), (ye = null), (Ie = null);
      },
    };
  }
  function a() {
    let $ = !1,
      ge = null,
      ye = null,
      Ie = null,
      Ge = null,
      Mt = null,
      zt = null,
      Rt = null,
      tt = null;
    return {
      setTest: function (Te) {
        $ || (Te ? He(2960) : Se(2960));
      },
      setMask: function (Te) {
        ge !== Te && !$ && (r.stencilMask(Te), (ge = Te));
      },
      setFunc: function (Te, gt, mt) {
        (ye !== Te || Ie !== gt || Ge !== mt) &&
          (r.stencilFunc(Te, gt, mt), (ye = Te), (Ie = gt), (Ge = mt));
      },
      setOp: function (Te, gt, mt) {
        (Mt !== Te || zt !== gt || Rt !== mt) &&
          (r.stencilOp(Te, gt, mt), (Mt = Te), (zt = gt), (Rt = mt));
      },
      setLocked: function (Te) {
        $ = Te;
      },
      setClear: function (Te) {
        tt !== Te && (r.clearStencil(Te), (tt = Te));
      },
      reset: function () {
        ($ = !1),
          (ge = null),
          (ye = null),
          (Ie = null),
          (Ge = null),
          (Mt = null),
          (zt = null),
          (Rt = null),
          (tt = null);
      },
    };
  }
  const o = new n(),
    u = new s(),
    h = new a(),
    f = new WeakMap(),
    c = new WeakMap();
  let d = {},
    m = {},
    x = new WeakMap(),
    v = [],
    b = null,
    y = !1,
    M = null,
    D = null,
    C = null,
    A = null,
    I = null,
    F = null,
    P = null,
    k = !1,
    O = null,
    J = null,
    ee = null,
    X = null,
    j = null;
  const Y = r.getParameter(35661);
  let ie = !1,
    Q = 0;
  const V = r.getParameter(7938);
  V.indexOf("WebGL") !== -1
    ? ((Q = parseFloat(/^WebGL (\d)/.exec(V)[1])), (ie = Q >= 1))
    : V.indexOf("OpenGL ES") !== -1 &&
      ((Q = parseFloat(/^OpenGL ES (\d)/.exec(V)[1])), (ie = Q >= 2));
  let ve = null,
    U = {};
  const oe = r.getParameter(3088),
    ue = r.getParameter(2978),
    fe = new Kt().fromArray(oe),
    le = new Kt().fromArray(ue);
  function be($, ge, ye) {
    const Ie = new Uint8Array(4),
      Ge = r.createTexture();
    r.bindTexture($, Ge),
      r.texParameteri($, 10241, 9728),
      r.texParameteri($, 10240, 9728);
    for (let Mt = 0; Mt < ye; Mt++)
      r.texImage2D(ge + Mt, 0, 6408, 1, 1, 0, 6408, 5121, Ie);
    return Ge;
  }
  const ce = {};
  (ce[3553] = be(3553, 3553, 1)),
    (ce[34067] = be(34067, 34069, 6)),
    o.setClear(0, 0, 0, 1),
    u.setClear(1),
    h.setClear(0),
    He(2929),
    u.setFunc(yf),
    dt(!1),
    he(s0),
    He(2884),
    ht(dr);
  function He($) {
    d[$] !== !0 && (r.enable($), (d[$] = !0));
  }
  function Se($) {
    d[$] !== !1 && (r.disable($), (d[$] = !1));
  }
  function Oe($, ge) {
    return m[$] !== ge
      ? (r.bindFramebuffer($, ge),
        (m[$] = ge),
        i && ($ === 36009 && (m[36160] = ge), $ === 36160 && (m[36009] = ge)),
        !0)
      : !1;
  }
  function Me($, ge) {
    let ye = v,
      Ie = !1;
    if ($)
      if (
        ((ye = x.get(ge)),
        ye === void 0 && ((ye = []), x.set(ge, ye)),
        $.isWebGLMultipleRenderTargets)
      ) {
        const Ge = $.texture;
        if (ye.length !== Ge.length || ye[0] !== 36064) {
          for (let Mt = 0, zt = Ge.length; Mt < zt; Mt++) ye[Mt] = 36064 + Mt;
          (ye.length = Ge.length), (Ie = !0);
        }
      } else ye[0] !== 36064 && ((ye[0] = 36064), (Ie = !0));
    else ye[0] !== 1029 && ((ye[0] = 1029), (Ie = !0));
    Ie &&
      (t.isWebGL2
        ? r.drawBuffers(ye)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(ye));
  }
  function Ke($) {
    return b !== $ ? (r.useProgram($), (b = $), !0) : !1;
  }
  const Qe = { [Ga]: 32774, [z1]: 32778, [U1]: 32779 };
  if (i) (Qe[r0] = 32775), (Qe[o0] = 32776);
  else {
    const $ = e.get("EXT_blend_minmax");
    $ !== null && ((Qe[r0] = $.MIN_EXT), (Qe[o0] = $.MAX_EXT));
  }
  const Pe = {
    [G1]: 0,
    [H1]: 1,
    [W1]: 768,
    [J_]: 770,
    [K1]: 776,
    [$1]: 774,
    [q1]: 772,
    [j1]: 769,
    [Q_]: 771,
    [Y1]: 775,
    [X1]: 773,
  };
  function ht($, ge, ye, Ie, Ge, Mt, zt, Rt) {
    if ($ === dr) {
      y === !0 && (Se(3042), (y = !1));
      return;
    }
    if ((y === !1 && (He(3042), (y = !0)), $ !== Z_)) {
      if ($ !== M || Rt !== k) {
        if (
          ((D !== Ga || I !== Ga) &&
            (r.blendEquation(32774), (D = Ga), (I = Ga)),
          Rt)
        )
          switch ($) {
            case Oo:
              r.blendFuncSeparate(1, 771, 1, 771);
              break;
            case bf:
              r.blendFunc(1, 1);
              break;
            case xf:
              r.blendFuncSeparate(0, 769, 0, 1);
              break;
            case wf:
              r.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", $);
              break;
          }
        else
          switch ($) {
            case Oo:
              r.blendFuncSeparate(770, 771, 1, 771);
              break;
            case bf:
              r.blendFunc(770, 1);
              break;
            case xf:
              r.blendFuncSeparate(0, 769, 0, 1);
              break;
            case wf:
              r.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", $);
              break;
          }
        (C = null), (A = null), (F = null), (P = null), (M = $), (k = Rt);
      }
      return;
    }
    (Ge = Ge || ge),
      (Mt = Mt || ye),
      (zt = zt || Ie),
      (ge !== D || Ge !== I) &&
        (r.blendEquationSeparate(Qe[ge], Qe[Ge]), (D = ge), (I = Ge)),
      (ye !== C || Ie !== A || Mt !== F || zt !== P) &&
        (r.blendFuncSeparate(Pe[ye], Pe[Ie], Pe[Mt], Pe[zt]),
        (C = ye),
        (A = Ie),
        (F = Mt),
        (P = zt)),
      (M = $),
      (k = !1);
  }
  function wt($, ge) {
    $.side === ru ? Se(2884) : He(2884);
    let ye = $.side === Bn;
    ge && (ye = !ye),
      dt(ye),
      $.blending === Oo && $.transparent === !1
        ? ht(dr)
        : ht(
            $.blending,
            $.blendEquation,
            $.blendSrc,
            $.blendDst,
            $.blendEquationAlpha,
            $.blendSrcAlpha,
            $.blendDstAlpha,
            $.premultipliedAlpha
          ),
      u.setFunc($.depthFunc),
      u.setTest($.depthTest),
      u.setMask($.depthWrite),
      o.setMask($.colorWrite);
    const Ie = $.stencilWrite;
    h.setTest(Ie),
      Ie &&
        (h.setMask($.stencilWriteMask),
        h.setFunc($.stencilFunc, $.stencilRef, $.stencilFuncMask),
        h.setOp($.stencilFail, $.stencilZFail, $.stencilZPass)),
      ft($.polygonOffset, $.polygonOffsetFactor, $.polygonOffsetUnits),
      $.alphaToCoverage === !0 ? He(32926) : Se(32926);
  }
  function dt($) {
    O !== $ && ($ ? r.frontFace(2304) : r.frontFace(2305), (O = $));
  }
  function he($) {
    $ !== N1
      ? (He(2884),
        $ !== J &&
          ($ === s0
            ? r.cullFace(1029)
            : $ === B1
            ? r.cullFace(1028)
            : r.cullFace(1032)))
      : Se(2884),
      (J = $);
  }
  function Et($) {
    $ !== ee && (ie && r.lineWidth($), (ee = $));
  }
  function ft($, ge, ye) {
    $
      ? (He(32823),
        (X !== ge || j !== ye) && (r.polygonOffset(ge, ye), (X = ge), (j = ye)))
      : Se(32823);
  }
  function Bt($) {
    $ ? He(3089) : Se(3089);
  }
  function bt($) {
    $ === void 0 && ($ = 33984 + Y - 1),
      ve !== $ && (r.activeTexture($), (ve = $));
  }
  function G($, ge, ye) {
    ye === void 0 && (ve === null ? (ye = 33984 + Y - 1) : (ye = ve));
    let Ie = U[ye];
    Ie === void 0 && ((Ie = { type: void 0, texture: void 0 }), (U[ye] = Ie)),
      (Ie.type !== $ || Ie.texture !== ge) &&
        (ve !== ye && (r.activeTexture(ye), (ve = ye)),
        r.bindTexture($, ge || ce[$]),
        (Ie.type = $),
        (Ie.texture = ge));
  }
  function N() {
    const $ = U[ve];
    $ !== void 0 &&
      $.type !== void 0 &&
      (r.bindTexture($.type, null), ($.type = void 0), ($.texture = void 0));
  }
  function pe() {
    try {
      r.compressedTexImage2D.apply(r, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function xe() {
    try {
      r.compressedTexImage3D.apply(r, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function we() {
    try {
      r.texSubImage2D.apply(r, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function Ce() {
    try {
      r.texSubImage3D.apply(r, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function We() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function H() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function ne() {
    try {
      r.texStorage2D.apply(r, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function Re() {
    try {
      r.texStorage3D.apply(r, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function Ae() {
    try {
      r.texImage2D.apply(r, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function ke() {
    try {
      r.texImage3D.apply(r, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function je($) {
    fe.equals($) === !1 && (r.scissor($.x, $.y, $.z, $.w), fe.copy($));
  }
  function Ve($) {
    le.equals($) === !1 && (r.viewport($.x, $.y, $.z, $.w), le.copy($));
  }
  function rt($, ge) {
    let ye = c.get(ge);
    ye === void 0 && ((ye = new WeakMap()), c.set(ge, ye));
    let Ie = ye.get($);
    Ie === void 0 && ((Ie = r.getUniformBlockIndex(ge, $.name)), ye.set($, Ie));
  }
  function lt($, ge) {
    const Ie = c.get(ge).get($);
    f.get(ge) !== Ie &&
      (r.uniformBlockBinding(ge, Ie, $.__bindingPointIndex), f.set(ge, Ie));
  }
  function Ct() {
    r.disable(3042),
      r.disable(2884),
      r.disable(2929),
      r.disable(32823),
      r.disable(3089),
      r.disable(2960),
      r.disable(32926),
      r.blendEquation(32774),
      r.blendFunc(1, 0),
      r.blendFuncSeparate(1, 0, 1, 0),
      r.colorMask(!0, !0, !0, !0),
      r.clearColor(0, 0, 0, 0),
      r.depthMask(!0),
      r.depthFunc(513),
      r.clearDepth(1),
      r.stencilMask(4294967295),
      r.stencilFunc(519, 0, 4294967295),
      r.stencilOp(7680, 7680, 7680),
      r.clearStencil(0),
      r.cullFace(1029),
      r.frontFace(2305),
      r.polygonOffset(0, 0),
      r.activeTexture(33984),
      r.bindFramebuffer(36160, null),
      i === !0 &&
        (r.bindFramebuffer(36009, null), r.bindFramebuffer(36008, null)),
      r.useProgram(null),
      r.lineWidth(1),
      r.scissor(0, 0, r.canvas.width, r.canvas.height),
      r.viewport(0, 0, r.canvas.width, r.canvas.height),
      (d = {}),
      (ve = null),
      (U = {}),
      (m = {}),
      (x = new WeakMap()),
      (v = []),
      (b = null),
      (y = !1),
      (M = null),
      (D = null),
      (C = null),
      (A = null),
      (I = null),
      (F = null),
      (P = null),
      (k = !1),
      (O = null),
      (J = null),
      (ee = null),
      (X = null),
      (j = null),
      fe.set(0, 0, r.canvas.width, r.canvas.height),
      le.set(0, 0, r.canvas.width, r.canvas.height),
      o.reset(),
      u.reset(),
      h.reset();
  }
  return {
    buffers: { color: o, depth: u, stencil: h },
    enable: He,
    disable: Se,
    bindFramebuffer: Oe,
    drawBuffers: Me,
    useProgram: Ke,
    setBlending: ht,
    setMaterial: wt,
    setFlipSided: dt,
    setCullFace: he,
    setLineWidth: Et,
    setPolygonOffset: ft,
    setScissorTest: Bt,
    activeTexture: bt,
    bindTexture: G,
    unbindTexture: N,
    compressedTexImage2D: pe,
    compressedTexImage3D: xe,
    texImage2D: Ae,
    texImage3D: ke,
    updateUBOMapping: rt,
    uniformBlockBinding: lt,
    texStorage2D: ne,
    texStorage3D: Re,
    texSubImage2D: we,
    texSubImage3D: Ce,
    compressedTexSubImage2D: We,
    compressedTexSubImage3D: H,
    scissor: je,
    viewport: Ve,
    reset: Ct,
  };
}
function IC(r, e, t, i, n, s, a) {
  const o = n.isWebGL2,
    u = n.maxTextures,
    h = n.maxCubemapSize,
    f = n.maxTextureSize,
    c = n.maxSamples,
    d = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    m =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    x = new WeakMap();
  let v;
  const b = new WeakMap();
  let y = !1;
  try {
    y =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function M(G, N) {
    return y ? new OffscreenCanvas(G, N) : Hc("canvas");
  }
  function D(G, N, pe, xe) {
    let we = 1;
    if (
      ((G.width > xe || G.height > xe) &&
        (we = xe / Math.max(G.width, G.height)),
      we < 1 || N === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && G instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && G instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && G instanceof ImageBitmap)
      ) {
        const Ce = N ? jh : Math.floor,
          We = Ce(we * G.width),
          H = Ce(we * G.height);
        v === void 0 && (v = M(We, H));
        const ne = pe ? M(We, H) : v;
        return (
          (ne.width = We),
          (ne.height = H),
          ne.getContext("2d").drawImage(G, 0, 0, We, H),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              G.width +
              "x" +
              G.height +
              ") to (" +
              We +
              "x" +
              H +
              ")."
          ),
          ne
        );
      } else
        return (
          "data" in G &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                G.width +
                "x" +
                G.height +
                ")."
            ),
          G
        );
    return G;
  }
  function C(G) {
    return Df(G.width) && Df(G.height);
  }
  function A(G) {
    return o
      ? !1
      : G.wrapS !== bn ||
          G.wrapT !== bn ||
          (G.minFilter !== Ai && G.minFilter !== Ui);
  }
  function I(G, N) {
    return G.generateMipmaps && N && G.minFilter !== Ai && G.minFilter !== Ui;
  }
  function F(G) {
    r.generateMipmap(G);
  }
  function P(G, N, pe, xe, we = !1) {
    if (o === !1) return N;
    if (G !== null) {
      if (r[G] !== void 0) return r[G];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          G +
          "'"
      );
    }
    let Ce = N;
    return (
      N === 6403 &&
        (pe === 5126 && (Ce = 33326),
        pe === 5131 && (Ce = 33325),
        pe === 5121 && (Ce = 33321)),
      N === 33319 &&
        (pe === 5126 && (Ce = 33328),
        pe === 5131 && (Ce = 33327),
        pe === 5121 && (Ce = 33323)),
      N === 6408 &&
        (pe === 5126 && (Ce = 34836),
        pe === 5131 && (Ce = 34842),
        pe === 5121 && (Ce = xe === Ht && we === !1 ? 35907 : 32856),
        pe === 32819 && (Ce = 32854),
        pe === 32820 && (Ce = 32855)),
      (Ce === 33325 ||
        Ce === 33326 ||
        Ce === 33327 ||
        Ce === 33328 ||
        Ce === 34842 ||
        Ce === 34836) &&
        e.get("EXT_color_buffer_float"),
      Ce
    );
  }
  function k(G, N, pe) {
    return I(G, pe) === !0 ||
      (G.isFramebufferTexture && G.minFilter !== Ai && G.minFilter !== Ui)
      ? Math.log2(Math.max(N.width, N.height)) + 1
      : G.mipmaps !== void 0 && G.mipmaps.length > 0
      ? G.mipmaps.length
      : G.isCompressedTexture && Array.isArray(G.image)
      ? N.mipmaps.length
      : 1;
  }
  function O(G) {
    return G === Ai || G === Tf || G === Ah ? 9728 : 9729;
  }
  function J(G) {
    const N = G.target;
    N.removeEventListener("dispose", J), X(N), N.isVideoTexture && x.delete(N);
  }
  function ee(G) {
    const N = G.target;
    N.removeEventListener("dispose", ee), Y(N);
  }
  function X(G) {
    const N = i.get(G);
    if (N.__webglInit === void 0) return;
    const pe = G.source,
      xe = b.get(pe);
    if (xe) {
      const we = xe[N.__cacheKey];
      we.usedTimes--,
        we.usedTimes === 0 && j(G),
        Object.keys(xe).length === 0 && b.delete(pe);
    }
    i.remove(G);
  }
  function j(G) {
    const N = i.get(G);
    r.deleteTexture(N.__webglTexture);
    const pe = G.source,
      xe = b.get(pe);
    delete xe[N.__cacheKey], a.memory.textures--;
  }
  function Y(G) {
    const N = G.texture,
      pe = i.get(G),
      xe = i.get(N);
    if (
      (xe.__webglTexture !== void 0 &&
        (r.deleteTexture(xe.__webglTexture), a.memory.textures--),
      G.depthTexture && G.depthTexture.dispose(),
      G.isWebGLCubeRenderTarget)
    )
      for (let we = 0; we < 6; we++)
        r.deleteFramebuffer(pe.__webglFramebuffer[we]),
          pe.__webglDepthbuffer &&
            r.deleteRenderbuffer(pe.__webglDepthbuffer[we]);
    else {
      if (
        (r.deleteFramebuffer(pe.__webglFramebuffer),
        pe.__webglDepthbuffer && r.deleteRenderbuffer(pe.__webglDepthbuffer),
        pe.__webglMultisampledFramebuffer &&
          r.deleteFramebuffer(pe.__webglMultisampledFramebuffer),
        pe.__webglColorRenderbuffer)
      )
        for (let we = 0; we < pe.__webglColorRenderbuffer.length; we++)
          pe.__webglColorRenderbuffer[we] &&
            r.deleteRenderbuffer(pe.__webglColorRenderbuffer[we]);
      pe.__webglDepthRenderbuffer &&
        r.deleteRenderbuffer(pe.__webglDepthRenderbuffer);
    }
    if (G.isWebGLMultipleRenderTargets)
      for (let we = 0, Ce = N.length; we < Ce; we++) {
        const We = i.get(N[we]);
        We.__webglTexture &&
          (r.deleteTexture(We.__webglTexture), a.memory.textures--),
          i.remove(N[we]);
      }
    i.remove(N), i.remove(G);
  }
  let ie = 0;
  function Q() {
    ie = 0;
  }
  function V() {
    const G = ie;
    return (
      G >= u &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            G +
            " texture units while this GPU supports only " +
            u
        ),
      (ie += 1),
      G
    );
  }
  function ve(G) {
    const N = [];
    return (
      N.push(G.wrapS),
      N.push(G.wrapT),
      N.push(G.wrapR || 0),
      N.push(G.magFilter),
      N.push(G.minFilter),
      N.push(G.anisotropy),
      N.push(G.internalFormat),
      N.push(G.format),
      N.push(G.type),
      N.push(G.generateMipmaps),
      N.push(G.premultiplyAlpha),
      N.push(G.flipY),
      N.push(G.unpackAlignment),
      N.push(G.encoding),
      N.join()
    );
  }
  function U(G, N) {
    const pe = i.get(G);
    if (
      (G.isVideoTexture && Bt(G),
      G.isRenderTargetTexture === !1 &&
        G.version > 0 &&
        pe.__version !== G.version)
    ) {
      const xe = G.image;
      if (xe === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (xe.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        Se(pe, G, N);
        return;
      }
    }
    t.bindTexture(3553, pe.__webglTexture, 33984 + N);
  }
  function oe(G, N) {
    const pe = i.get(G);
    if (G.version > 0 && pe.__version !== G.version) {
      Se(pe, G, N);
      return;
    }
    t.bindTexture(35866, pe.__webglTexture, 33984 + N);
  }
  function ue(G, N) {
    const pe = i.get(G);
    if (G.version > 0 && pe.__version !== G.version) {
      Se(pe, G, N);
      return;
    }
    t.bindTexture(32879, pe.__webglTexture, 33984 + N);
  }
  function fe(G, N) {
    const pe = i.get(G);
    if (G.version > 0 && pe.__version !== G.version) {
      Oe(pe, G, N);
      return;
    }
    t.bindTexture(34067, pe.__webglTexture, 33984 + N);
  }
  const le = { [Zr]: 10497, [bn]: 33071, [Wh]: 33648 },
    be = {
      [Ai]: 9728,
      [Tf]: 9984,
      [Ah]: 9986,
      [Ui]: 9729,
      [ib]: 9985,
      [mr]: 9987,
    };
  function ce(G, N, pe) {
    if (
      (pe
        ? (r.texParameteri(G, 10242, le[N.wrapS]),
          r.texParameteri(G, 10243, le[N.wrapT]),
          (G === 32879 || G === 35866) &&
            r.texParameteri(G, 32882, le[N.wrapR]),
          r.texParameteri(G, 10240, be[N.magFilter]),
          r.texParameteri(G, 10241, be[N.minFilter]))
        : (r.texParameteri(G, 10242, 33071),
          r.texParameteri(G, 10243, 33071),
          (G === 32879 || G === 35866) && r.texParameteri(G, 32882, 33071),
          (N.wrapS !== bn || N.wrapT !== bn) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          r.texParameteri(G, 10240, O(N.magFilter)),
          r.texParameteri(G, 10241, O(N.minFilter)),
          N.minFilter !== Ai &&
            N.minFilter !== Ui &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const xe = e.get("EXT_texture_filter_anisotropic");
      if (
        N.magFilter === Ai ||
        (N.minFilter !== Ah && N.minFilter !== mr) ||
        (N.type === Gr && e.has("OES_texture_float_linear") === !1) ||
        (o === !1 &&
          N.type === Vc &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (N.anisotropy > 1 || i.get(N).__currentAnisotropy) &&
        (r.texParameterf(
          G,
          xe.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(N.anisotropy, n.getMaxAnisotropy())
        ),
        (i.get(N).__currentAnisotropy = N.anisotropy));
    }
  }
  function He(G, N) {
    let pe = !1;
    G.__webglInit === void 0 &&
      ((G.__webglInit = !0), N.addEventListener("dispose", J));
    const xe = N.source;
    let we = b.get(xe);
    we === void 0 && ((we = {}), b.set(xe, we));
    const Ce = ve(N);
    if (Ce !== G.__cacheKey) {
      we[Ce] === void 0 &&
        ((we[Ce] = { texture: r.createTexture(), usedTimes: 0 }),
        a.memory.textures++,
        (pe = !0)),
        we[Ce].usedTimes++;
      const We = we[G.__cacheKey];
      We !== void 0 &&
        (we[G.__cacheKey].usedTimes--, We.usedTimes === 0 && j(N)),
        (G.__cacheKey = Ce),
        (G.__webglTexture = we[Ce].texture);
    }
    return pe;
  }
  function Se(G, N, pe) {
    let xe = 3553;
    (N.isDataArrayTexture || N.isCompressedArrayTexture) && (xe = 35866),
      N.isData3DTexture && (xe = 32879);
    const we = He(G, N),
      Ce = N.source;
    t.bindTexture(xe, G.__webglTexture, 33984 + pe);
    const We = i.get(Ce);
    if (Ce.version !== We.__version || we === !0) {
      t.activeTexture(33984 + pe),
        r.pixelStorei(37440, N.flipY),
        r.pixelStorei(37441, N.premultiplyAlpha),
        r.pixelStorei(3317, N.unpackAlignment),
        r.pixelStorei(37443, 0);
      const H = A(N) && C(N.image) === !1;
      let ne = D(N.image, H, !1, f);
      ne = bt(N, ne);
      const Re = C(ne) || o,
        Ae = s.convert(N.format, N.encoding);
      let ke = s.convert(N.type),
        je = P(N.internalFormat, Ae, ke, N.encoding, N.isVideoTexture);
      ce(xe, N, Re);
      let Ve;
      const rt = N.mipmaps,
        lt = o && N.isVideoTexture !== !0,
        Ct = We.__version === void 0 || we === !0,
        $ = k(N, ne, Re);
      if (N.isDepthTexture)
        (je = 6402),
          o
            ? N.type === Gr
              ? (je = 36012)
              : N.type === Ro
              ? (je = 33190)
              : N.type === el
              ? (je = 35056)
              : (je = 33189)
            : N.type === Gr &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          N.format === No &&
            je === 6402 &&
            N.type !== nb &&
            N.type !== Ro &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (N.type = Ro),
            (ke = s.convert(N.type))),
          N.format === cl &&
            je === 6402 &&
            ((je = 34041),
            N.type !== el &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (N.type = el),
              (ke = s.convert(N.type)))),
          Ct &&
            (lt
              ? t.texStorage2D(3553, 1, je, ne.width, ne.height)
              : t.texImage2D(
                  3553,
                  0,
                  je,
                  ne.width,
                  ne.height,
                  0,
                  Ae,
                  ke,
                  null
                ));
      else if (N.isDataTexture)
        if (rt.length > 0 && Re) {
          lt && Ct && t.texStorage2D(3553, $, je, rt[0].width, rt[0].height);
          for (let ge = 0, ye = rt.length; ge < ye; ge++)
            (Ve = rt[ge]),
              lt
                ? t.texSubImage2D(
                    3553,
                    ge,
                    0,
                    0,
                    Ve.width,
                    Ve.height,
                    Ae,
                    ke,
                    Ve.data
                  )
                : t.texImage2D(
                    3553,
                    ge,
                    je,
                    Ve.width,
                    Ve.height,
                    0,
                    Ae,
                    ke,
                    Ve.data
                  );
          N.generateMipmaps = !1;
        } else
          lt
            ? (Ct && t.texStorage2D(3553, $, je, ne.width, ne.height),
              t.texSubImage2D(
                3553,
                0,
                0,
                0,
                ne.width,
                ne.height,
                Ae,
                ke,
                ne.data
              ))
            : t.texImage2D(
                3553,
                0,
                je,
                ne.width,
                ne.height,
                0,
                Ae,
                ke,
                ne.data
              );
      else if (N.isCompressedTexture)
        if (N.isCompressedArrayTexture) {
          lt &&
            Ct &&
            t.texStorage3D(35866, $, je, rt[0].width, rt[0].height, ne.depth);
          for (let ge = 0, ye = rt.length; ge < ye; ge++)
            (Ve = rt[ge]),
              N.format !== es
                ? Ae !== null
                  ? lt
                    ? t.compressedTexSubImage3D(
                        35866,
                        ge,
                        0,
                        0,
                        0,
                        Ve.width,
                        Ve.height,
                        ne.depth,
                        Ae,
                        Ve.data,
                        0,
                        0
                      )
                    : t.compressedTexImage3D(
                        35866,
                        ge,
                        je,
                        Ve.width,
                        Ve.height,
                        ne.depth,
                        0,
                        Ve.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : lt
                ? t.texSubImage3D(
                    35866,
                    ge,
                    0,
                    0,
                    0,
                    Ve.width,
                    Ve.height,
                    ne.depth,
                    Ae,
                    ke,
                    Ve.data
                  )
                : t.texImage3D(
                    35866,
                    ge,
                    je,
                    Ve.width,
                    Ve.height,
                    ne.depth,
                    0,
                    Ae,
                    ke,
                    Ve.data
                  );
        } else {
          lt && Ct && t.texStorage2D(3553, $, je, rt[0].width, rt[0].height);
          for (let ge = 0, ye = rt.length; ge < ye; ge++)
            (Ve = rt[ge]),
              N.format !== es
                ? Ae !== null
                  ? lt
                    ? t.compressedTexSubImage2D(
                        3553,
                        ge,
                        0,
                        0,
                        Ve.width,
                        Ve.height,
                        Ae,
                        Ve.data
                      )
                    : t.compressedTexImage2D(
                        3553,
                        ge,
                        je,
                        Ve.width,
                        Ve.height,
                        0,
                        Ve.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : lt
                ? t.texSubImage2D(
                    3553,
                    ge,
                    0,
                    0,
                    Ve.width,
                    Ve.height,
                    Ae,
                    ke,
                    Ve.data
                  )
                : t.texImage2D(
                    3553,
                    ge,
                    je,
                    Ve.width,
                    Ve.height,
                    0,
                    Ae,
                    ke,
                    Ve.data
                  );
        }
      else if (N.isDataArrayTexture)
        lt
          ? (Ct && t.texStorage3D(35866, $, je, ne.width, ne.height, ne.depth),
            t.texSubImage3D(
              35866,
              0,
              0,
              0,
              0,
              ne.width,
              ne.height,
              ne.depth,
              Ae,
              ke,
              ne.data
            ))
          : t.texImage3D(
              35866,
              0,
              je,
              ne.width,
              ne.height,
              ne.depth,
              0,
              Ae,
              ke,
              ne.data
            );
      else if (N.isData3DTexture)
        lt
          ? (Ct && t.texStorage3D(32879, $, je, ne.width, ne.height, ne.depth),
            t.texSubImage3D(
              32879,
              0,
              0,
              0,
              0,
              ne.width,
              ne.height,
              ne.depth,
              Ae,
              ke,
              ne.data
            ))
          : t.texImage3D(
              32879,
              0,
              je,
              ne.width,
              ne.height,
              ne.depth,
              0,
              Ae,
              ke,
              ne.data
            );
      else if (N.isFramebufferTexture) {
        if (Ct)
          if (lt) t.texStorage2D(3553, $, je, ne.width, ne.height);
          else {
            let ge = ne.width,
              ye = ne.height;
            for (let Ie = 0; Ie < $; Ie++)
              t.texImage2D(3553, Ie, je, ge, ye, 0, Ae, ke, null),
                (ge >>= 1),
                (ye >>= 1);
          }
      } else if (rt.length > 0 && Re) {
        lt && Ct && t.texStorage2D(3553, $, je, rt[0].width, rt[0].height);
        for (let ge = 0, ye = rt.length; ge < ye; ge++)
          (Ve = rt[ge]),
            lt
              ? t.texSubImage2D(3553, ge, 0, 0, Ae, ke, Ve)
              : t.texImage2D(3553, ge, je, Ae, ke, Ve);
        N.generateMipmaps = !1;
      } else
        lt
          ? (Ct && t.texStorage2D(3553, $, je, ne.width, ne.height),
            t.texSubImage2D(3553, 0, 0, 0, Ae, ke, ne))
          : t.texImage2D(3553, 0, je, Ae, ke, ne);
      I(N, Re) && F(xe),
        (We.__version = Ce.version),
        N.onUpdate && N.onUpdate(N);
    }
    G.__version = N.version;
  }
  function Oe(G, N, pe) {
    if (N.image.length !== 6) return;
    const xe = He(G, N),
      we = N.source;
    t.bindTexture(34067, G.__webglTexture, 33984 + pe);
    const Ce = i.get(we);
    if (we.version !== Ce.__version || xe === !0) {
      t.activeTexture(33984 + pe),
        r.pixelStorei(37440, N.flipY),
        r.pixelStorei(37441, N.premultiplyAlpha),
        r.pixelStorei(3317, N.unpackAlignment),
        r.pixelStorei(37443, 0);
      const We = N.isCompressedTexture || N.image[0].isCompressedTexture,
        H = N.image[0] && N.image[0].isDataTexture,
        ne = [];
      for (let ge = 0; ge < 6; ge++)
        !We && !H
          ? (ne[ge] = D(N.image[ge], !1, !0, h))
          : (ne[ge] = H ? N.image[ge].image : N.image[ge]),
          (ne[ge] = bt(N, ne[ge]));
      const Re = ne[0],
        Ae = C(Re) || o,
        ke = s.convert(N.format, N.encoding),
        je = s.convert(N.type),
        Ve = P(N.internalFormat, ke, je, N.encoding),
        rt = o && N.isVideoTexture !== !0,
        lt = Ce.__version === void 0 || xe === !0;
      let Ct = k(N, Re, Ae);
      ce(34067, N, Ae);
      let $;
      if (We) {
        rt && lt && t.texStorage2D(34067, Ct, Ve, Re.width, Re.height);
        for (let ge = 0; ge < 6; ge++) {
          $ = ne[ge].mipmaps;
          for (let ye = 0; ye < $.length; ye++) {
            const Ie = $[ye];
            N.format !== es
              ? ke !== null
                ? rt
                  ? t.compressedTexSubImage2D(
                      34069 + ge,
                      ye,
                      0,
                      0,
                      Ie.width,
                      Ie.height,
                      ke,
                      Ie.data
                    )
                  : t.compressedTexImage2D(
                      34069 + ge,
                      ye,
                      Ve,
                      Ie.width,
                      Ie.height,
                      0,
                      Ie.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : rt
              ? t.texSubImage2D(
                  34069 + ge,
                  ye,
                  0,
                  0,
                  Ie.width,
                  Ie.height,
                  ke,
                  je,
                  Ie.data
                )
              : t.texImage2D(
                  34069 + ge,
                  ye,
                  Ve,
                  Ie.width,
                  Ie.height,
                  0,
                  ke,
                  je,
                  Ie.data
                );
          }
        }
      } else {
        ($ = N.mipmaps),
          rt &&
            lt &&
            ($.length > 0 && Ct++,
            t.texStorage2D(34067, Ct, Ve, ne[0].width, ne[0].height));
        for (let ge = 0; ge < 6; ge++)
          if (H) {
            rt
              ? t.texSubImage2D(
                  34069 + ge,
                  0,
                  0,
                  0,
                  ne[ge].width,
                  ne[ge].height,
                  ke,
                  je,
                  ne[ge].data
                )
              : t.texImage2D(
                  34069 + ge,
                  0,
                  Ve,
                  ne[ge].width,
                  ne[ge].height,
                  0,
                  ke,
                  je,
                  ne[ge].data
                );
            for (let ye = 0; ye < $.length; ye++) {
              const Ge = $[ye].image[ge].image;
              rt
                ? t.texSubImage2D(
                    34069 + ge,
                    ye + 1,
                    0,
                    0,
                    Ge.width,
                    Ge.height,
                    ke,
                    je,
                    Ge.data
                  )
                : t.texImage2D(
                    34069 + ge,
                    ye + 1,
                    Ve,
                    Ge.width,
                    Ge.height,
                    0,
                    ke,
                    je,
                    Ge.data
                  );
            }
          } else {
            rt
              ? t.texSubImage2D(34069 + ge, 0, 0, 0, ke, je, ne[ge])
              : t.texImage2D(34069 + ge, 0, Ve, ke, je, ne[ge]);
            for (let ye = 0; ye < $.length; ye++) {
              const Ie = $[ye];
              rt
                ? t.texSubImage2D(
                    34069 + ge,
                    ye + 1,
                    0,
                    0,
                    ke,
                    je,
                    Ie.image[ge]
                  )
                : t.texImage2D(34069 + ge, ye + 1, Ve, ke, je, Ie.image[ge]);
            }
          }
      }
      I(N, Ae) && F(34067),
        (Ce.__version = we.version),
        N.onUpdate && N.onUpdate(N);
    }
    G.__version = N.version;
  }
  function Me(G, N, pe, xe, we) {
    const Ce = s.convert(pe.format, pe.encoding),
      We = s.convert(pe.type),
      H = P(pe.internalFormat, Ce, We, pe.encoding);
    i.get(N).__hasExternalTextures ||
      (we === 32879 || we === 35866
        ? t.texImage3D(we, 0, H, N.width, N.height, N.depth, 0, Ce, We, null)
        : t.texImage2D(we, 0, H, N.width, N.height, 0, Ce, We, null)),
      t.bindFramebuffer(36160, G),
      ft(N)
        ? d.framebufferTexture2DMultisampleEXT(
            36160,
            xe,
            we,
            i.get(pe).__webglTexture,
            0,
            Et(N)
          )
        : (we === 3553 || (we >= 34069 && we <= 34074)) &&
          r.framebufferTexture2D(36160, xe, we, i.get(pe).__webglTexture, 0),
      t.bindFramebuffer(36160, null);
  }
  function Ke(G, N, pe) {
    if ((r.bindRenderbuffer(36161, G), N.depthBuffer && !N.stencilBuffer)) {
      let xe = 33189;
      if (pe || ft(N)) {
        const we = N.depthTexture;
        we &&
          we.isDepthTexture &&
          (we.type === Gr ? (xe = 36012) : we.type === Ro && (xe = 33190));
        const Ce = Et(N);
        ft(N)
          ? d.renderbufferStorageMultisampleEXT(
              36161,
              Ce,
              xe,
              N.width,
              N.height
            )
          : r.renderbufferStorageMultisample(36161, Ce, xe, N.width, N.height);
      } else r.renderbufferStorage(36161, xe, N.width, N.height);
      r.framebufferRenderbuffer(36160, 36096, 36161, G);
    } else if (N.depthBuffer && N.stencilBuffer) {
      const xe = Et(N);
      pe && ft(N) === !1
        ? r.renderbufferStorageMultisample(36161, xe, 35056, N.width, N.height)
        : ft(N)
        ? d.renderbufferStorageMultisampleEXT(
            36161,
            xe,
            35056,
            N.width,
            N.height
          )
        : r.renderbufferStorage(36161, 34041, N.width, N.height),
        r.framebufferRenderbuffer(36160, 33306, 36161, G);
    } else {
      const xe =
        N.isWebGLMultipleRenderTargets === !0 ? N.texture : [N.texture];
      for (let we = 0; we < xe.length; we++) {
        const Ce = xe[we],
          We = s.convert(Ce.format, Ce.encoding),
          H = s.convert(Ce.type),
          ne = P(Ce.internalFormat, We, H, Ce.encoding),
          Re = Et(N);
        pe && ft(N) === !1
          ? r.renderbufferStorageMultisample(36161, Re, ne, N.width, N.height)
          : ft(N)
          ? d.renderbufferStorageMultisampleEXT(
              36161,
              Re,
              ne,
              N.width,
              N.height
            )
          : r.renderbufferStorage(36161, ne, N.width, N.height);
      }
    }
    r.bindRenderbuffer(36161, null);
  }
  function Qe(G, N) {
    if (N && N.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(36160, G),
      !(N.depthTexture && N.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!i.get(N.depthTexture).__webglTexture ||
      N.depthTexture.image.width !== N.width ||
      N.depthTexture.image.height !== N.height) &&
      ((N.depthTexture.image.width = N.width),
      (N.depthTexture.image.height = N.height),
      (N.depthTexture.needsUpdate = !0)),
      U(N.depthTexture, 0);
    const xe = i.get(N.depthTexture).__webglTexture,
      we = Et(N);
    if (N.depthTexture.format === No)
      ft(N)
        ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, xe, 0, we)
        : r.framebufferTexture2D(36160, 36096, 3553, xe, 0);
    else if (N.depthTexture.format === cl)
      ft(N)
        ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, xe, 0, we)
        : r.framebufferTexture2D(36160, 33306, 3553, xe, 0);
    else throw new Error("Unknown depthTexture format");
  }
  function Pe(G) {
    const N = i.get(G),
      pe = G.isWebGLCubeRenderTarget === !0;
    if (G.depthTexture && !N.__autoAllocateDepthBuffer) {
      if (pe)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      Qe(N.__webglFramebuffer, G);
    } else if (pe) {
      N.__webglDepthbuffer = [];
      for (let xe = 0; xe < 6; xe++)
        t.bindFramebuffer(36160, N.__webglFramebuffer[xe]),
          (N.__webglDepthbuffer[xe] = r.createRenderbuffer()),
          Ke(N.__webglDepthbuffer[xe], G, !1);
    } else
      t.bindFramebuffer(36160, N.__webglFramebuffer),
        (N.__webglDepthbuffer = r.createRenderbuffer()),
        Ke(N.__webglDepthbuffer, G, !1);
    t.bindFramebuffer(36160, null);
  }
  function ht(G, N, pe) {
    const xe = i.get(G);
    N !== void 0 && Me(xe.__webglFramebuffer, G, G.texture, 36064, 3553),
      pe !== void 0 && Pe(G);
  }
  function wt(G) {
    const N = G.texture,
      pe = i.get(G),
      xe = i.get(N);
    G.addEventListener("dispose", ee),
      G.isWebGLMultipleRenderTargets !== !0 &&
        (xe.__webglTexture === void 0 &&
          (xe.__webglTexture = r.createTexture()),
        (xe.__version = N.version),
        a.memory.textures++);
    const we = G.isWebGLCubeRenderTarget === !0,
      Ce = G.isWebGLMultipleRenderTargets === !0,
      We = C(G) || o;
    if (we) {
      pe.__webglFramebuffer = [];
      for (let H = 0; H < 6; H++)
        pe.__webglFramebuffer[H] = r.createFramebuffer();
    } else {
      if (((pe.__webglFramebuffer = r.createFramebuffer()), Ce))
        if (n.drawBuffers) {
          const H = G.texture;
          for (let ne = 0, Re = H.length; ne < Re; ne++) {
            const Ae = i.get(H[ne]);
            Ae.__webglTexture === void 0 &&
              ((Ae.__webglTexture = r.createTexture()), a.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (o && G.samples > 0 && ft(G) === !1) {
        const H = Ce ? N : [N];
        (pe.__webglMultisampledFramebuffer = r.createFramebuffer()),
          (pe.__webglColorRenderbuffer = []),
          t.bindFramebuffer(36160, pe.__webglMultisampledFramebuffer);
        for (let ne = 0; ne < H.length; ne++) {
          const Re = H[ne];
          (pe.__webglColorRenderbuffer[ne] = r.createRenderbuffer()),
            r.bindRenderbuffer(36161, pe.__webglColorRenderbuffer[ne]);
          const Ae = s.convert(Re.format, Re.encoding),
            ke = s.convert(Re.type),
            je = P(
              Re.internalFormat,
              Ae,
              ke,
              Re.encoding,
              G.isXRRenderTarget === !0
            ),
            Ve = Et(G);
          r.renderbufferStorageMultisample(36161, Ve, je, G.width, G.height),
            r.framebufferRenderbuffer(
              36160,
              36064 + ne,
              36161,
              pe.__webglColorRenderbuffer[ne]
            );
        }
        r.bindRenderbuffer(36161, null),
          G.depthBuffer &&
            ((pe.__webglDepthRenderbuffer = r.createRenderbuffer()),
            Ke(pe.__webglDepthRenderbuffer, G, !0)),
          t.bindFramebuffer(36160, null);
      }
    }
    if (we) {
      t.bindTexture(34067, xe.__webglTexture), ce(34067, N, We);
      for (let H = 0; H < 6; H++)
        Me(pe.__webglFramebuffer[H], G, N, 36064, 34069 + H);
      I(N, We) && F(34067), t.unbindTexture();
    } else if (Ce) {
      const H = G.texture;
      for (let ne = 0, Re = H.length; ne < Re; ne++) {
        const Ae = H[ne],
          ke = i.get(Ae);
        t.bindTexture(3553, ke.__webglTexture),
          ce(3553, Ae, We),
          Me(pe.__webglFramebuffer, G, Ae, 36064 + ne, 3553),
          I(Ae, We) && F(3553);
      }
      t.unbindTexture();
    } else {
      let H = 3553;
      (G.isWebGL3DRenderTarget || G.isWebGLArrayRenderTarget) &&
        (o
          ? (H = G.isWebGL3DRenderTarget ? 32879 : 35866)
          : console.error(
              "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
            )),
        t.bindTexture(H, xe.__webglTexture),
        ce(H, N, We),
        Me(pe.__webglFramebuffer, G, N, 36064, H),
        I(N, We) && F(H),
        t.unbindTexture();
    }
    G.depthBuffer && Pe(G);
  }
  function dt(G) {
    const N = C(G) || o,
      pe = G.isWebGLMultipleRenderTargets === !0 ? G.texture : [G.texture];
    for (let xe = 0, we = pe.length; xe < we; xe++) {
      const Ce = pe[xe];
      if (I(Ce, N)) {
        const We = G.isWebGLCubeRenderTarget ? 34067 : 3553,
          H = i.get(Ce).__webglTexture;
        t.bindTexture(We, H), F(We), t.unbindTexture();
      }
    }
  }
  function he(G) {
    if (o && G.samples > 0 && ft(G) === !1) {
      const N = G.isWebGLMultipleRenderTargets ? G.texture : [G.texture],
        pe = G.width,
        xe = G.height;
      let we = 16384;
      const Ce = [],
        We = G.stencilBuffer ? 33306 : 36096,
        H = i.get(G),
        ne = G.isWebGLMultipleRenderTargets === !0;
      if (ne)
        for (let Re = 0; Re < N.length; Re++)
          t.bindFramebuffer(36160, H.__webglMultisampledFramebuffer),
            r.framebufferRenderbuffer(36160, 36064 + Re, 36161, null),
            t.bindFramebuffer(36160, H.__webglFramebuffer),
            r.framebufferTexture2D(36009, 36064 + Re, 3553, null, 0);
      t.bindFramebuffer(36008, H.__webglMultisampledFramebuffer),
        t.bindFramebuffer(36009, H.__webglFramebuffer);
      for (let Re = 0; Re < N.length; Re++) {
        Ce.push(36064 + Re), G.depthBuffer && Ce.push(We);
        const Ae =
          H.__ignoreDepthValues !== void 0 ? H.__ignoreDepthValues : !1;
        if (
          (Ae === !1 &&
            (G.depthBuffer && (we |= 256), G.stencilBuffer && (we |= 1024)),
          ne &&
            r.framebufferRenderbuffer(
              36008,
              36064,
              36161,
              H.__webglColorRenderbuffer[Re]
            ),
          Ae === !0 &&
            (r.invalidateFramebuffer(36008, [We]),
            r.invalidateFramebuffer(36009, [We])),
          ne)
        ) {
          const ke = i.get(N[Re]).__webglTexture;
          r.framebufferTexture2D(36009, 36064, 3553, ke, 0);
        }
        r.blitFramebuffer(0, 0, pe, xe, 0, 0, pe, xe, we, 9728),
          m && r.invalidateFramebuffer(36008, Ce);
      }
      if ((t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), ne))
        for (let Re = 0; Re < N.length; Re++) {
          t.bindFramebuffer(36160, H.__webglMultisampledFramebuffer),
            r.framebufferRenderbuffer(
              36160,
              36064 + Re,
              36161,
              H.__webglColorRenderbuffer[Re]
            );
          const Ae = i.get(N[Re]).__webglTexture;
          t.bindFramebuffer(36160, H.__webglFramebuffer),
            r.framebufferTexture2D(36009, 36064 + Re, 3553, Ae, 0);
        }
      t.bindFramebuffer(36009, H.__webglMultisampledFramebuffer);
    }
  }
  function Et(G) {
    return Math.min(c, G.samples);
  }
  function ft(G) {
    const N = i.get(G);
    return (
      o &&
      G.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      N.__useRenderToTexture !== !1
    );
  }
  function Bt(G) {
    const N = a.render.frame;
    x.get(G) !== N && (x.set(G, N), G.update());
  }
  function bt(G, N) {
    const pe = G.encoding,
      xe = G.format,
      we = G.type;
    return (
      G.isCompressedTexture === !0 ||
        G.isVideoTexture === !0 ||
        G.format === Cf ||
        (pe !== gr &&
          (pe === Ht
            ? o === !1
              ? e.has("EXT_sRGB") === !0 && xe === es
                ? ((G.format = Cf),
                  (G.minFilter = Ui),
                  (G.generateMipmaps = !1))
                : (N = cb.sRGBToLinear(N))
              : (xe !== es || we !== Ko) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture encoding:",
                pe
              ))),
      N
    );
  }
  (this.allocateTextureUnit = V),
    (this.resetTextureUnits = Q),
    (this.setTexture2D = U),
    (this.setTexture2DArray = oe),
    (this.setTexture3D = ue),
    (this.setTextureCube = fe),
    (this.rebindTextures = ht),
    (this.setupRenderTarget = wt),
    (this.updateRenderTargetMipmap = dt),
    (this.updateMultisampleRenderTarget = he),
    (this.setupDepthRenderbuffer = Pe),
    (this.setupFrameBufferTexture = Me),
    (this.useMultisampledRTT = ft);
}
function FC(r, e, t) {
  const i = t.isWebGL2;
  function n(s, a = null) {
    let o;
    if (s === Ko) return 5121;
    if (s === fS) return 32819;
    if (s === mS) return 32820;
    if (s === hS) return 5120;
    if (s === dS) return 5122;
    if (s === nb) return 5123;
    if (s === pS) return 5124;
    if (s === Ro) return 5125;
    if (s === Gr) return 5126;
    if (s === Vc)
      return i
        ? 5131
        : ((o = e.get("OES_texture_half_float")),
          o !== null ? o.HALF_FLOAT_OES : null);
    if (s === gS) return 6406;
    if (s === es) return 6408;
    if (s === _S) return 6409;
    if (s === bS) return 6410;
    if (s === No) return 6402;
    if (s === cl) return 34041;
    if (s === vS)
      return (
        console.warn(
          "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"
        ),
        6408
      );
    if (s === Cf)
      return (o = e.get("EXT_sRGB")), o !== null ? o.SRGB_ALPHA_EXT : null;
    if (s === xS) return 6403;
    if (s === wS) return 36244;
    if (s === yS) return 33319;
    if (s === SS) return 33320;
    if (s === MS) return 36249;
    if (s === up || s === hp || s === dp || s === pp)
      if (a === Ht)
        if (((o = e.get("WEBGL_compressed_texture_s3tc_srgb")), o !== null)) {
          if (s === up) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === hp) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === dp) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === pp) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (s === up) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === hp) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === dp) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === pp) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === a0 || s === l0 || s === c0 || s === u0)
      if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (s === a0) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === l0) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === c0) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === u0) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === TS)
      return (
        (o = e.get("WEBGL_compressed_texture_etc1")),
        o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (s === h0 || s === d0)
      if (((o = e.get("WEBGL_compressed_texture_etc")), o !== null)) {
        if (s === h0)
          return a === Ht ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (s === d0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === p0 ||
      s === f0 ||
      s === m0 ||
      s === g0 ||
      s === v0 ||
      s === _0 ||
      s === b0 ||
      s === x0 ||
      s === w0 ||
      s === y0 ||
      s === S0 ||
      s === M0 ||
      s === T0 ||
      s === E0
    )
      if (((o = e.get("WEBGL_compressed_texture_astc")), o !== null)) {
        if (s === p0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === f0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === m0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === g0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === v0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === _0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === b0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === x0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === w0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === y0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === S0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === M0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === T0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === E0)
          return a === Ht
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === C0)
      if (((o = e.get("EXT_texture_compression_bptc")), o !== null)) {
        if (s === C0)
          return a === Ht
            ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else return null;
    return s === el
      ? i
        ? 34042
        : ((o = e.get("WEBGL_depth_texture")),
          o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null)
      : r[s] !== void 0
      ? r[s]
      : null;
  }
  return { convert: n };
}
class OC extends Gi {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class ts extends ei {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const NC = { type: "move" };
class Vp {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new ts()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new ts()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new Z()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new Z())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new ts()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new Z()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new Z())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, i) {
    let n = null,
      s = null,
      a = null;
    const o = this._targetRay,
      u = this._grip,
      h = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (h && e.hand) {
        a = !0;
        for (const v of e.hand.values()) {
          const b = t.getJointPose(v, i),
            y = this._getHandJoint(h, v);
          b !== null &&
            (y.matrix.fromArray(b.transform.matrix),
            y.matrix.decompose(y.position, y.rotation, y.scale),
            (y.jointRadius = b.radius)),
            (y.visible = b !== null);
        }
        const f = h.joints["index-finger-tip"],
          c = h.joints["thumb-tip"],
          d = f.position.distanceTo(c.position),
          m = 0.02,
          x = 0.005;
        h.inputState.pinching && d > m + x
          ? ((h.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !h.inputState.pinching &&
            d <= m - x &&
            ((h.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        u !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, i)),
          s !== null &&
            (u.matrix.fromArray(s.transform.matrix),
            u.matrix.decompose(u.position, u.rotation, u.scale),
            s.linearVelocity
              ? ((u.hasLinearVelocity = !0),
                u.linearVelocity.copy(s.linearVelocity))
              : (u.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((u.hasAngularVelocity = !0),
                u.angularVelocity.copy(s.angularVelocity))
              : (u.hasAngularVelocity = !1)));
      o !== null &&
        ((n = t.getPose(e.targetRaySpace, i)),
        n === null && s !== null && (n = s),
        n !== null &&
          (o.matrix.fromArray(n.transform.matrix),
          o.matrix.decompose(o.position, o.rotation, o.scale),
          n.linearVelocity
            ? ((o.hasLinearVelocity = !0),
              o.linearVelocity.copy(n.linearVelocity))
            : (o.hasLinearVelocity = !1),
          n.angularVelocity
            ? ((o.hasAngularVelocity = !0),
              o.angularVelocity.copy(n.angularVelocity))
            : (o.hasAngularVelocity = !1),
          this.dispatchEvent(NC)));
    }
    return (
      o !== null && (o.visible = n !== null),
      u !== null && (u.visible = s !== null),
      h !== null && (h.visible = a !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new ts();
      (i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[t.jointName] = i),
        e.add(i);
    }
    return e.joints[t.jointName];
  }
}
class BC extends xi {
  constructor(e, t, i, n, s, a, o, u, h, f) {
    if (((f = f !== void 0 ? f : No), f !== No && f !== cl))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    i === void 0 && f === No && (i = Ro),
      i === void 0 && f === cl && (i = el),
      super(null, n, s, a, o, u, f, i, h),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = o !== void 0 ? o : Ai),
      (this.minFilter = u !== void 0 ? u : Ai),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class VC extends ra {
  constructor(e, t) {
    super();
    const i = this;
    let n = null,
      s = 1,
      a = null,
      o = "local-floor",
      u = null,
      h = null,
      f = null,
      c = null,
      d = null,
      m = null;
    const x = t.getContextAttributes();
    let v = null,
      b = null;
    const y = [],
      M = [],
      D = new Set(),
      C = new Map(),
      A = new Gi();
    A.layers.enable(1), (A.viewport = new Kt());
    const I = new Gi();
    I.layers.enable(2), (I.viewport = new Kt());
    const F = [A, I],
      P = new OC();
    P.layers.enable(1), P.layers.enable(2);
    let k = null,
      O = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (oe) {
        let ue = y[oe];
        return (
          ue === void 0 && ((ue = new Vp()), (y[oe] = ue)),
          ue.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (oe) {
        let ue = y[oe];
        return (
          ue === void 0 && ((ue = new Vp()), (y[oe] = ue)), ue.getGripSpace()
        );
      }),
      (this.getHand = function (oe) {
        let ue = y[oe];
        return (
          ue === void 0 && ((ue = new Vp()), (y[oe] = ue)), ue.getHandSpace()
        );
      });
    function J(oe) {
      const ue = M.indexOf(oe.inputSource);
      if (ue === -1) return;
      const fe = y[ue];
      fe !== void 0 &&
        fe.dispatchEvent({ type: oe.type, data: oe.inputSource });
    }
    function ee() {
      n.removeEventListener("select", J),
        n.removeEventListener("selectstart", J),
        n.removeEventListener("selectend", J),
        n.removeEventListener("squeeze", J),
        n.removeEventListener("squeezestart", J),
        n.removeEventListener("squeezeend", J),
        n.removeEventListener("end", ee),
        n.removeEventListener("inputsourceschange", X);
      for (let oe = 0; oe < y.length; oe++) {
        const ue = M[oe];
        ue !== null && ((M[oe] = null), y[oe].disconnect(ue));
      }
      (k = null),
        (O = null),
        e.setRenderTarget(v),
        (d = null),
        (c = null),
        (f = null),
        (n = null),
        (b = null),
        U.stop(),
        (i.isPresenting = !1),
        i.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (oe) {
      (s = oe),
        i.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (oe) {
        (o = oe),
          i.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return u || a;
      }),
      (this.setReferenceSpace = function (oe) {
        u = oe;
      }),
      (this.getBaseLayer = function () {
        return c !== null ? c : d;
      }),
      (this.getBinding = function () {
        return f;
      }),
      (this.getFrame = function () {
        return m;
      }),
      (this.getSession = function () {
        return n;
      }),
      (this.setSession = async function (oe) {
        if (((n = oe), n !== null)) {
          if (
            ((v = e.getRenderTarget()),
            n.addEventListener("select", J),
            n.addEventListener("selectstart", J),
            n.addEventListener("selectend", J),
            n.addEventListener("squeeze", J),
            n.addEventListener("squeezestart", J),
            n.addEventListener("squeezeend", J),
            n.addEventListener("end", ee),
            n.addEventListener("inputsourceschange", X),
            x.xrCompatible !== !0 && (await t.makeXRCompatible()),
            n.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const ue = {
              antialias: n.renderState.layers === void 0 ? x.antialias : !0,
              alpha: x.alpha,
              depth: x.depth,
              stencil: x.stencil,
              framebufferScaleFactor: s,
            };
            (d = new XRWebGLLayer(n, t, ue)),
              n.updateRenderState({ baseLayer: d }),
              (b = new Zo(d.framebufferWidth, d.framebufferHeight, {
                format: es,
                type: Ko,
                encoding: e.outputEncoding,
                stencilBuffer: x.stencil,
              }));
          } else {
            let ue = null,
              fe = null,
              le = null;
            x.depth &&
              ((le = x.stencil ? 35056 : 33190),
              (ue = x.stencil ? cl : No),
              (fe = x.stencil ? el : Ro));
            const be = { colorFormat: 32856, depthFormat: le, scaleFactor: s };
            (f = new XRWebGLBinding(n, t)),
              (c = f.createProjectionLayer(be)),
              n.updateRenderState({ layers: [c] }),
              (b = new Zo(c.textureWidth, c.textureHeight, {
                format: es,
                type: Ko,
                depthTexture: new BC(
                  c.textureWidth,
                  c.textureHeight,
                  fe,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  ue
                ),
                stencilBuffer: x.stencil,
                encoding: e.outputEncoding,
                samples: x.antialias ? 4 : 0,
              }));
            const ce = e.properties.get(b);
            ce.__ignoreDepthValues = c.ignoreDepthValues;
          }
          (b.isXRRenderTarget = !0),
            this.setFoveation(1),
            (u = null),
            (a = await n.requestReferenceSpace(o)),
            U.setContext(n),
            U.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: "sessionstart" });
        }
      });
    function X(oe) {
      for (let ue = 0; ue < oe.removed.length; ue++) {
        const fe = oe.removed[ue],
          le = M.indexOf(fe);
        le >= 0 && ((M[le] = null), y[le].disconnect(fe));
      }
      for (let ue = 0; ue < oe.added.length; ue++) {
        const fe = oe.added[ue];
        let le = M.indexOf(fe);
        if (le === -1) {
          for (let ce = 0; ce < y.length; ce++)
            if (ce >= M.length) {
              M.push(fe), (le = ce);
              break;
            } else if (M[ce] === null) {
              (M[ce] = fe), (le = ce);
              break;
            }
          if (le === -1) break;
        }
        const be = y[le];
        be && be.connect(fe);
      }
    }
    const j = new Z(),
      Y = new Z();
    function ie(oe, ue, fe) {
      j.setFromMatrixPosition(ue.matrixWorld),
        Y.setFromMatrixPosition(fe.matrixWorld);
      const le = j.distanceTo(Y),
        be = ue.projectionMatrix.elements,
        ce = fe.projectionMatrix.elements,
        He = be[14] / (be[10] - 1),
        Se = be[14] / (be[10] + 1),
        Oe = (be[9] + 1) / be[5],
        Me = (be[9] - 1) / be[5],
        Ke = (be[8] - 1) / be[0],
        Qe = (ce[8] + 1) / ce[0],
        Pe = He * Ke,
        ht = He * Qe,
        wt = le / (-Ke + Qe),
        dt = wt * -Ke;
      ue.matrixWorld.decompose(oe.position, oe.quaternion, oe.scale),
        oe.translateX(dt),
        oe.translateZ(wt),
        oe.matrixWorld.compose(oe.position, oe.quaternion, oe.scale),
        oe.matrixWorldInverse.copy(oe.matrixWorld).invert();
      const he = He + wt,
        Et = Se + wt,
        ft = Pe - dt,
        Bt = ht + (le - dt),
        bt = ((Oe * Se) / Et) * he,
        G = ((Me * Se) / Et) * he;
      oe.projectionMatrix.makePerspective(ft, Bt, bt, G, he, Et);
    }
    function Q(oe, ue) {
      ue === null
        ? oe.matrixWorld.copy(oe.matrix)
        : oe.matrixWorld.multiplyMatrices(ue.matrixWorld, oe.matrix),
        oe.matrixWorldInverse.copy(oe.matrixWorld).invert();
    }
    (this.updateCamera = function (oe) {
      if (n === null) return;
      (P.near = I.near = A.near = oe.near),
        (P.far = I.far = A.far = oe.far),
        (k !== P.near || O !== P.far) &&
          (n.updateRenderState({ depthNear: P.near, depthFar: P.far }),
          (k = P.near),
          (O = P.far));
      const ue = oe.parent,
        fe = P.cameras;
      Q(P, ue);
      for (let be = 0; be < fe.length; be++) Q(fe[be], ue);
      P.matrixWorld.decompose(P.position, P.quaternion, P.scale),
        oe.matrix.copy(P.matrix),
        oe.matrix.decompose(oe.position, oe.quaternion, oe.scale);
      const le = oe.children;
      for (let be = 0, ce = le.length; be < ce; be++)
        le[be].updateMatrixWorld(!0);
      fe.length === 2
        ? ie(P, A, I)
        : P.projectionMatrix.copy(A.projectionMatrix);
    }),
      (this.getCamera = function () {
        return P;
      }),
      (this.getFoveation = function () {
        if (c !== null) return c.fixedFoveation;
        if (d !== null) return d.fixedFoveation;
      }),
      (this.setFoveation = function (oe) {
        c !== null && (c.fixedFoveation = oe),
          d !== null && d.fixedFoveation !== void 0 && (d.fixedFoveation = oe);
      }),
      (this.getPlanes = function () {
        return D;
      });
    let V = null;
    function ve(oe, ue) {
      if (((h = ue.getViewerPose(u || a)), (m = ue), h !== null)) {
        const fe = h.views;
        d !== null &&
          (e.setRenderTargetFramebuffer(b, d.framebuffer),
          e.setRenderTarget(b));
        let le = !1;
        fe.length !== P.cameras.length && ((P.cameras.length = 0), (le = !0));
        for (let be = 0; be < fe.length; be++) {
          const ce = fe[be];
          let He = null;
          if (d !== null) He = d.getViewport(ce);
          else {
            const Oe = f.getViewSubImage(c, ce);
            (He = Oe.viewport),
              be === 0 &&
                (e.setRenderTargetTextures(
                  b,
                  Oe.colorTexture,
                  c.ignoreDepthValues ? void 0 : Oe.depthStencilTexture
                ),
                e.setRenderTarget(b));
          }
          let Se = F[be];
          Se === void 0 &&
            ((Se = new Gi()),
            Se.layers.enable(be),
            (Se.viewport = new Kt()),
            (F[be] = Se)),
            Se.matrix.fromArray(ce.transform.matrix),
            Se.projectionMatrix.fromArray(ce.projectionMatrix),
            Se.viewport.set(He.x, He.y, He.width, He.height),
            be === 0 && P.matrix.copy(Se.matrix),
            le === !0 && P.cameras.push(Se);
        }
      }
      for (let fe = 0; fe < y.length; fe++) {
        const le = M[fe],
          be = y[fe];
        le !== null && be !== void 0 && be.update(le, ue, u || a);
      }
      if ((V && V(oe, ue), ue.detectedPlanes)) {
        i.dispatchEvent({ type: "planesdetected", data: ue.detectedPlanes });
        let fe = null;
        for (const le of D)
          ue.detectedPlanes.has(le) || (fe === null && (fe = []), fe.push(le));
        if (fe !== null)
          for (const le of fe)
            D.delete(le),
              C.delete(le),
              i.dispatchEvent({ type: "planeremoved", data: le });
        for (const le of ue.detectedPlanes)
          if (!D.has(le))
            D.add(le),
              C.set(le, ue.lastChangedTime),
              i.dispatchEvent({ type: "planeadded", data: le });
          else {
            const be = C.get(le);
            le.lastChangedTime > be &&
              (C.set(le, le.lastChangedTime),
              i.dispatchEvent({ type: "planechanged", data: le }));
          }
      }
      m = null;
    }
    const U = new gb();
    U.setAnimationLoop(ve),
      (this.setAnimationLoop = function (oe) {
        V = oe;
      }),
      (this.dispose = function () {});
  }
}
function zC(r, e) {
  function t(v, b) {
    b.color.getRGB(v.fogColor.value, fb(r)),
      b.isFog
        ? ((v.fogNear.value = b.near), (v.fogFar.value = b.far))
        : b.isFogExp2 && (v.fogDensity.value = b.density);
  }
  function i(v, b, y, M, D) {
    b.isMeshBasicMaterial || b.isMeshLambertMaterial
      ? n(v, b)
      : b.isMeshToonMaterial
      ? (n(v, b), f(v, b))
      : b.isMeshPhongMaterial
      ? (n(v, b), h(v, b))
      : b.isMeshStandardMaterial
      ? (n(v, b), c(v, b), b.isMeshPhysicalMaterial && d(v, b, D))
      : b.isMeshMatcapMaterial
      ? (n(v, b), m(v, b))
      : b.isMeshDepthMaterial
      ? n(v, b)
      : b.isMeshDistanceMaterial
      ? (n(v, b), x(v, b))
      : b.isMeshNormalMaterial
      ? n(v, b)
      : b.isLineBasicMaterial
      ? (s(v, b), b.isLineDashedMaterial && a(v, b))
      : b.isPointsMaterial
      ? o(v, b, y, M)
      : b.isSpriteMaterial
      ? u(v, b)
      : b.isShadowMaterial
      ? (v.color.value.copy(b.color), (v.opacity.value = b.opacity))
      : b.isShaderMaterial && (b.uniformsNeedUpdate = !1);
  }
  function n(v, b) {
    (v.opacity.value = b.opacity),
      b.color && v.diffuse.value.copy(b.color),
      b.emissive &&
        v.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity),
      b.map && (v.map.value = b.map),
      b.alphaMap && (v.alphaMap.value = b.alphaMap),
      b.bumpMap &&
        ((v.bumpMap.value = b.bumpMap),
        (v.bumpScale.value = b.bumpScale),
        b.side === Bn && (v.bumpScale.value *= -1)),
      b.displacementMap &&
        ((v.displacementMap.value = b.displacementMap),
        (v.displacementScale.value = b.displacementScale),
        (v.displacementBias.value = b.displacementBias)),
      b.emissiveMap && (v.emissiveMap.value = b.emissiveMap),
      b.normalMap &&
        ((v.normalMap.value = b.normalMap),
        v.normalScale.value.copy(b.normalScale),
        b.side === Bn && v.normalScale.value.negate()),
      b.specularMap && (v.specularMap.value = b.specularMap),
      b.alphaTest > 0 && (v.alphaTest.value = b.alphaTest);
    const y = e.get(b).envMap;
    if (
      (y &&
        ((v.envMap.value = y),
        (v.flipEnvMap.value =
          y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1),
        (v.reflectivity.value = b.reflectivity),
        (v.ior.value = b.ior),
        (v.refractionRatio.value = b.refractionRatio)),
      b.lightMap)
    ) {
      v.lightMap.value = b.lightMap;
      const C = r.physicallyCorrectLights !== !0 ? Math.PI : 1;
      v.lightMapIntensity.value = b.lightMapIntensity * C;
    }
    b.aoMap &&
      ((v.aoMap.value = b.aoMap), (v.aoMapIntensity.value = b.aoMapIntensity));
    let M;
    b.map
      ? (M = b.map)
      : b.specularMap
      ? (M = b.specularMap)
      : b.displacementMap
      ? (M = b.displacementMap)
      : b.normalMap
      ? (M = b.normalMap)
      : b.bumpMap
      ? (M = b.bumpMap)
      : b.roughnessMap
      ? (M = b.roughnessMap)
      : b.metalnessMap
      ? (M = b.metalnessMap)
      : b.alphaMap
      ? (M = b.alphaMap)
      : b.emissiveMap
      ? (M = b.emissiveMap)
      : b.clearcoatMap
      ? (M = b.clearcoatMap)
      : b.clearcoatNormalMap
      ? (M = b.clearcoatNormalMap)
      : b.clearcoatRoughnessMap
      ? (M = b.clearcoatRoughnessMap)
      : b.iridescenceMap
      ? (M = b.iridescenceMap)
      : b.iridescenceThicknessMap
      ? (M = b.iridescenceThicknessMap)
      : b.specularIntensityMap
      ? (M = b.specularIntensityMap)
      : b.specularColorMap
      ? (M = b.specularColorMap)
      : b.transmissionMap
      ? (M = b.transmissionMap)
      : b.thicknessMap
      ? (M = b.thicknessMap)
      : b.sheenColorMap
      ? (M = b.sheenColorMap)
      : b.sheenRoughnessMap && (M = b.sheenRoughnessMap),
      M !== void 0 &&
        (M.isWebGLRenderTarget && (M = M.texture),
        M.matrixAutoUpdate === !0 && M.updateMatrix(),
        v.uvTransform.value.copy(M.matrix));
    let D;
    b.aoMap ? (D = b.aoMap) : b.lightMap && (D = b.lightMap),
      D !== void 0 &&
        (D.isWebGLRenderTarget && (D = D.texture),
        D.matrixAutoUpdate === !0 && D.updateMatrix(),
        v.uv2Transform.value.copy(D.matrix));
  }
  function s(v, b) {
    v.diffuse.value.copy(b.color), (v.opacity.value = b.opacity);
  }
  function a(v, b) {
    (v.dashSize.value = b.dashSize),
      (v.totalSize.value = b.dashSize + b.gapSize),
      (v.scale.value = b.scale);
  }
  function o(v, b, y, M) {
    v.diffuse.value.copy(b.color),
      (v.opacity.value = b.opacity),
      (v.size.value = b.size * y),
      (v.scale.value = M * 0.5),
      b.map && (v.map.value = b.map),
      b.alphaMap && (v.alphaMap.value = b.alphaMap),
      b.alphaTest > 0 && (v.alphaTest.value = b.alphaTest);
    let D;
    b.map ? (D = b.map) : b.alphaMap && (D = b.alphaMap),
      D !== void 0 &&
        (D.matrixAutoUpdate === !0 && D.updateMatrix(),
        v.uvTransform.value.copy(D.matrix));
  }
  function u(v, b) {
    v.diffuse.value.copy(b.color),
      (v.opacity.value = b.opacity),
      (v.rotation.value = b.rotation),
      b.map && (v.map.value = b.map),
      b.alphaMap && (v.alphaMap.value = b.alphaMap),
      b.alphaTest > 0 && (v.alphaTest.value = b.alphaTest);
    let y;
    b.map ? (y = b.map) : b.alphaMap && (y = b.alphaMap),
      y !== void 0 &&
        (y.matrixAutoUpdate === !0 && y.updateMatrix(),
        v.uvTransform.value.copy(y.matrix));
  }
  function h(v, b) {
    v.specular.value.copy(b.specular),
      (v.shininess.value = Math.max(b.shininess, 1e-4));
  }
  function f(v, b) {
    b.gradientMap && (v.gradientMap.value = b.gradientMap);
  }
  function c(v, b) {
    (v.roughness.value = b.roughness),
      (v.metalness.value = b.metalness),
      b.roughnessMap && (v.roughnessMap.value = b.roughnessMap),
      b.metalnessMap && (v.metalnessMap.value = b.metalnessMap),
      e.get(b).envMap && (v.envMapIntensity.value = b.envMapIntensity);
  }
  function d(v, b, y) {
    (v.ior.value = b.ior),
      b.sheen > 0 &&
        (v.sheenColor.value.copy(b.sheenColor).multiplyScalar(b.sheen),
        (v.sheenRoughness.value = b.sheenRoughness),
        b.sheenColorMap && (v.sheenColorMap.value = b.sheenColorMap),
        b.sheenRoughnessMap &&
          (v.sheenRoughnessMap.value = b.sheenRoughnessMap)),
      b.clearcoat > 0 &&
        ((v.clearcoat.value = b.clearcoat),
        (v.clearcoatRoughness.value = b.clearcoatRoughness),
        b.clearcoatMap && (v.clearcoatMap.value = b.clearcoatMap),
        b.clearcoatRoughnessMap &&
          (v.clearcoatRoughnessMap.value = b.clearcoatRoughnessMap),
        b.clearcoatNormalMap &&
          (v.clearcoatNormalScale.value.copy(b.clearcoatNormalScale),
          (v.clearcoatNormalMap.value = b.clearcoatNormalMap),
          b.side === Bn && v.clearcoatNormalScale.value.negate())),
      b.iridescence > 0 &&
        ((v.iridescence.value = b.iridescence),
        (v.iridescenceIOR.value = b.iridescenceIOR),
        (v.iridescenceThicknessMinimum.value = b.iridescenceThicknessRange[0]),
        (v.iridescenceThicknessMaximum.value = b.iridescenceThicknessRange[1]),
        b.iridescenceMap && (v.iridescenceMap.value = b.iridescenceMap),
        b.iridescenceThicknessMap &&
          (v.iridescenceThicknessMap.value = b.iridescenceThicknessMap)),
      b.transmission > 0 &&
        ((v.transmission.value = b.transmission),
        (v.transmissionSamplerMap.value = y.texture),
        v.transmissionSamplerSize.value.set(y.width, y.height),
        b.transmissionMap && (v.transmissionMap.value = b.transmissionMap),
        (v.thickness.value = b.thickness),
        b.thicknessMap && (v.thicknessMap.value = b.thicknessMap),
        (v.attenuationDistance.value = b.attenuationDistance),
        v.attenuationColor.value.copy(b.attenuationColor)),
      (v.specularIntensity.value = b.specularIntensity),
      v.specularColor.value.copy(b.specularColor),
      b.specularIntensityMap &&
        (v.specularIntensityMap.value = b.specularIntensityMap),
      b.specularColorMap && (v.specularColorMap.value = b.specularColorMap);
  }
  function m(v, b) {
    b.matcap && (v.matcap.value = b.matcap);
  }
  function x(v, b) {
    v.referencePosition.value.copy(b.referencePosition),
      (v.nearDistance.value = b.nearDistance),
      (v.farDistance.value = b.farDistance);
  }
  return { refreshFogUniforms: t, refreshMaterialUniforms: i };
}
function UC(r, e, t, i) {
  let n = {},
    s = {},
    a = [];
  const o = t.isWebGL2 ? r.getParameter(35375) : 0;
  function u(M, D) {
    const C = D.program;
    i.uniformBlockBinding(M, C);
  }
  function h(M, D) {
    let C = n[M.id];
    C === void 0 &&
      (x(M), (C = f(M)), (n[M.id] = C), M.addEventListener("dispose", b));
    const A = D.program;
    i.updateUBOMapping(M, A);
    const I = e.render.frame;
    s[M.id] !== I && (d(M), (s[M.id] = I));
  }
  function f(M) {
    const D = c();
    M.__bindingPointIndex = D;
    const C = r.createBuffer(),
      A = M.__size,
      I = M.usage;
    return (
      r.bindBuffer(35345, C),
      r.bufferData(35345, A, I),
      r.bindBuffer(35345, null),
      r.bindBufferBase(35345, D, C),
      C
    );
  }
  function c() {
    for (let M = 0; M < o; M++) if (a.indexOf(M) === -1) return a.push(M), M;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function d(M) {
    const D = n[M.id],
      C = M.uniforms,
      A = M.__cache;
    r.bindBuffer(35345, D);
    for (let I = 0, F = C.length; I < F; I++) {
      const P = C[I];
      if (m(P, I, A) === !0) {
        const k = P.__offset,
          O = Array.isArray(P.value) ? P.value : [P.value];
        let J = 0;
        for (let ee = 0; ee < O.length; ee++) {
          const X = O[ee],
            j = v(X);
          typeof X == "number"
            ? ((P.__data[0] = X), r.bufferSubData(35345, k + J, P.__data))
            : X.isMatrix3
            ? ((P.__data[0] = X.elements[0]),
              (P.__data[1] = X.elements[1]),
              (P.__data[2] = X.elements[2]),
              (P.__data[3] = X.elements[0]),
              (P.__data[4] = X.elements[3]),
              (P.__data[5] = X.elements[4]),
              (P.__data[6] = X.elements[5]),
              (P.__data[7] = X.elements[0]),
              (P.__data[8] = X.elements[6]),
              (P.__data[9] = X.elements[7]),
              (P.__data[10] = X.elements[8]),
              (P.__data[11] = X.elements[0]))
            : (X.toArray(P.__data, J),
              (J += j.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        r.bufferSubData(35345, k, P.__data);
      }
    }
    r.bindBuffer(35345, null);
  }
  function m(M, D, C) {
    const A = M.value;
    if (C[D] === void 0) {
      if (typeof A == "number") C[D] = A;
      else {
        const I = Array.isArray(A) ? A : [A],
          F = [];
        for (let P = 0; P < I.length; P++) F.push(I[P].clone());
        C[D] = F;
      }
      return !0;
    } else if (typeof A == "number") {
      if (C[D] !== A) return (C[D] = A), !0;
    } else {
      const I = Array.isArray(C[D]) ? C[D] : [C[D]],
        F = Array.isArray(A) ? A : [A];
      for (let P = 0; P < I.length; P++) {
        const k = I[P];
        if (k.equals(F[P]) === !1) return k.copy(F[P]), !0;
      }
    }
    return !1;
  }
  function x(M) {
    const D = M.uniforms;
    let C = 0;
    const A = 16;
    let I = 0;
    for (let F = 0, P = D.length; F < P; F++) {
      const k = D[F],
        O = { boundary: 0, storage: 0 },
        J = Array.isArray(k.value) ? k.value : [k.value];
      for (let ee = 0, X = J.length; ee < X; ee++) {
        const j = J[ee],
          Y = v(j);
        (O.boundary += Y.boundary), (O.storage += Y.storage);
      }
      if (
        ((k.__data = new Float32Array(
          O.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (k.__offset = C),
        F > 0)
      ) {
        I = C % A;
        const ee = A - I;
        I !== 0 && ee - O.boundary < 0 && ((C += A - I), (k.__offset = C));
      }
      C += O.storage;
    }
    return (
      (I = C % A), I > 0 && (C += A - I), (M.__size = C), (M.__cache = {}), this
    );
  }
  function v(M) {
    const D = { boundary: 0, storage: 0 };
    return (
      typeof M == "number"
        ? ((D.boundary = 4), (D.storage = 4))
        : M.isVector2
        ? ((D.boundary = 8), (D.storage = 8))
        : M.isVector3 || M.isColor
        ? ((D.boundary = 16), (D.storage = 12))
        : M.isVector4
        ? ((D.boundary = 16), (D.storage = 16))
        : M.isMatrix3
        ? ((D.boundary = 48), (D.storage = 48))
        : M.isMatrix4
        ? ((D.boundary = 64), (D.storage = 64))
        : M.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            M
          ),
      D
    );
  }
  function b(M) {
    const D = M.target;
    D.removeEventListener("dispose", b);
    const C = a.indexOf(D.__bindingPointIndex);
    a.splice(C, 1), r.deleteBuffer(n[D.id]), delete n[D.id], delete s[D.id];
  }
  function y() {
    for (const M in n) r.deleteBuffer(n[M]);
    (a = []), (n = {}), (s = {});
  }
  return { bind: u, update: h, dispose: y };
}
function GC() {
  const r = Hc("canvas");
  return (r.style.display = "block"), r;
}
function Mm(r = {}) {
  this.isWebGLRenderer = !0;
  const e = r.canvas !== void 0 ? r.canvas : GC(),
    t = r.context !== void 0 ? r.context : null,
    i = r.depth !== void 0 ? r.depth : !0,
    n = r.stencil !== void 0 ? r.stencil : !0,
    s = r.antialias !== void 0 ? r.antialias : !1,
    a = r.premultipliedAlpha !== void 0 ? r.premultipliedAlpha : !0,
    o = r.preserveDrawingBuffer !== void 0 ? r.preserveDrawingBuffer : !1,
    u = r.powerPreference !== void 0 ? r.powerPreference : "default",
    h =
      r.failIfMajorPerformanceCaveat !== void 0
        ? r.failIfMajorPerformanceCaveat
        : !1;
  let f;
  t !== null
    ? (f = t.getContextAttributes().alpha)
    : (f = r.alpha !== void 0 ? r.alpha : !1);
  let c = null,
    d = null;
  const m = [],
    x = [];
  (this.domElement = e),
    (this.debug = { checkShaderErrors: !0 }),
    (this.autoClear = !0),
    (this.autoClearColor = !0),
    (this.autoClearDepth = !0),
    (this.autoClearStencil = !0),
    (this.sortObjects = !0),
    (this.clippingPlanes = []),
    (this.localClippingEnabled = !1),
    (this.outputEncoding = gr),
    (this.physicallyCorrectLights = !1),
    (this.toneMapping = pr),
    (this.toneMappingExposure = 1);
  const v = this;
  let b = !1,
    y = 0,
    M = 0,
    D = null,
    C = -1,
    A = null;
  const I = new Kt(),
    F = new Kt();
  let P = null,
    k = e.width,
    O = e.height,
    J = 1,
    ee = null,
    X = null;
  const j = new Kt(0, 0, k, O),
    Y = new Kt(0, 0, k, O);
  let ie = !1;
  const Q = new wm();
  let V = !1,
    ve = !1,
    U = null;
  const oe = new At(),
    ue = new Ue(),
    fe = new Z(),
    le = {
      background: null,
      fog: null,
      environment: null,
      overrideMaterial: null,
      isScene: !0,
    };
  function be() {
    return D === null ? J : 1;
  }
  let ce = t;
  function He(B, te) {
    for (let de = 0; de < B.length; de++) {
      const se = B[de],
        me = e.getContext(se, te);
      if (me !== null) return me;
    }
    return null;
  }
  try {
    const B = {
      alpha: !0,
      depth: i,
      stencil: n,
      antialias: s,
      premultipliedAlpha: a,
      preserveDrawingBuffer: o,
      powerPreference: u,
      failIfMajorPerformanceCaveat: h,
    };
    if (
      ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${vm}`),
      e.addEventListener("webglcontextlost", je, !1),
      e.addEventListener("webglcontextrestored", Ve, !1),
      e.addEventListener("webglcontextcreationerror", rt, !1),
      ce === null)
    ) {
      const te = ["webgl2", "webgl", "experimental-webgl"];
      if (
        (v.isWebGL1Renderer === !0 && te.shift(), (ce = He(te, B)), ce === null)
      )
        throw He(te)
          ? new Error(
              "Error creating WebGL context with your selected attributes."
            )
          : new Error("Error creating WebGL context.");
    }
    ce.getShaderPrecisionFormat === void 0 &&
      (ce.getShaderPrecisionFormat = function () {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
  } catch (B) {
    throw (console.error("THREE.WebGLRenderer: " + B.message), B);
  }
  let Se,
    Oe,
    Me,
    Ke,
    Qe,
    Pe,
    ht,
    wt,
    dt,
    he,
    Et,
    ft,
    Bt,
    bt,
    G,
    N,
    pe,
    xe,
    we,
    Ce,
    We,
    H,
    ne,
    Re;
  function Ae() {
    (Se = new QE(ce)),
      (Oe = new XE(ce, Se, r)),
      Se.init(Oe),
      (H = new FC(ce, Se, Oe)),
      (Me = new kC(ce, Se, Oe)),
      (Ke = new i2()),
      (Qe = new bC()),
      (Pe = new IC(ce, Se, Me, Qe, Oe, H, Ke)),
      (ht = new YE(v)),
      (wt = new JE(v)),
      (dt = new hM(ce, Oe)),
      (ne = new jE(ce, Se, dt, Oe)),
      (he = new e2(ce, dt, Ke, ne)),
      (Et = new o2(ce, he, dt, Ke)),
      (we = new r2(ce, Oe, Pe)),
      (N = new $E(Qe)),
      (ft = new _C(v, ht, wt, Se, Oe, ne, N)),
      (Bt = new zC(v, Qe)),
      (bt = new wC()),
      (G = new CC(Se, Oe)),
      (xe = new WE(v, ht, wt, Me, Et, f, a)),
      (pe = new RC(v, Et, Oe)),
      (Re = new UC(ce, Ke, Oe, Me)),
      (Ce = new qE(ce, Se, Ke, Oe)),
      (We = new t2(ce, Se, Ke, Oe)),
      (Ke.programs = ft.programs),
      (v.capabilities = Oe),
      (v.extensions = Se),
      (v.properties = Qe),
      (v.renderLists = bt),
      (v.shadowMap = pe),
      (v.state = Me),
      (v.info = Ke);
  }
  Ae();
  const ke = new VC(v, ce);
  (this.xr = ke),
    (this.getContext = function () {
      return ce;
    }),
    (this.getContextAttributes = function () {
      return ce.getContextAttributes();
    }),
    (this.forceContextLoss = function () {
      const B = Se.get("WEBGL_lose_context");
      B && B.loseContext();
    }),
    (this.forceContextRestore = function () {
      const B = Se.get("WEBGL_lose_context");
      B && B.restoreContext();
    }),
    (this.getPixelRatio = function () {
      return J;
    }),
    (this.setPixelRatio = function (B) {
      B !== void 0 && ((J = B), this.setSize(k, O, !1));
    }),
    (this.getSize = function (B) {
      return B.set(k, O);
    }),
    (this.setSize = function (B, te, de) {
      if (ke.isPresenting) {
        console.warn(
          "THREE.WebGLRenderer: Can't change size while VR device is presenting."
        );
        return;
      }
      (k = B),
        (O = te),
        (e.width = Math.floor(B * J)),
        (e.height = Math.floor(te * J)),
        de !== !1 && ((e.style.width = B + "px"), (e.style.height = te + "px")),
        this.setViewport(0, 0, B, te);
    }),
    (this.getDrawingBufferSize = function (B) {
      return B.set(k * J, O * J).floor();
    }),
    (this.setDrawingBufferSize = function (B, te, de) {
      (k = B),
        (O = te),
        (J = de),
        (e.width = Math.floor(B * de)),
        (e.height = Math.floor(te * de)),
        this.setViewport(0, 0, B, te);
    }),
    (this.getCurrentViewport = function (B) {
      return B.copy(I);
    }),
    (this.getViewport = function (B) {
      return B.copy(j);
    }),
    (this.setViewport = function (B, te, de, se) {
      B.isVector4 ? j.set(B.x, B.y, B.z, B.w) : j.set(B, te, de, se),
        Me.viewport(I.copy(j).multiplyScalar(J).floor());
    }),
    (this.getScissor = function (B) {
      return B.copy(Y);
    }),
    (this.setScissor = function (B, te, de, se) {
      B.isVector4 ? Y.set(B.x, B.y, B.z, B.w) : Y.set(B, te, de, se),
        Me.scissor(F.copy(Y).multiplyScalar(J).floor());
    }),
    (this.getScissorTest = function () {
      return ie;
    }),
    (this.setScissorTest = function (B) {
      Me.setScissorTest((ie = B));
    }),
    (this.setOpaqueSort = function (B) {
      ee = B;
    }),
    (this.setTransparentSort = function (B) {
      X = B;
    }),
    (this.getClearColor = function (B) {
      return B.copy(xe.getClearColor());
    }),
    (this.setClearColor = function () {
      xe.setClearColor.apply(xe, arguments);
    }),
    (this.getClearAlpha = function () {
      return xe.getClearAlpha();
    }),
    (this.setClearAlpha = function () {
      xe.setClearAlpha.apply(xe, arguments);
    }),
    (this.clear = function (B = !0, te = !0, de = !0) {
      let se = 0;
      B && (se |= 16384), te && (se |= 256), de && (se |= 1024), ce.clear(se);
    }),
    (this.clearColor = function () {
      this.clear(!0, !1, !1);
    }),
    (this.clearDepth = function () {
      this.clear(!1, !0, !1);
    }),
    (this.clearStencil = function () {
      this.clear(!1, !1, !0);
    }),
    (this.dispose = function () {
      e.removeEventListener("webglcontextlost", je, !1),
        e.removeEventListener("webglcontextrestored", Ve, !1),
        e.removeEventListener("webglcontextcreationerror", rt, !1),
        bt.dispose(),
        G.dispose(),
        Qe.dispose(),
        ht.dispose(),
        wt.dispose(),
        Et.dispose(),
        ne.dispose(),
        Re.dispose(),
        ft.dispose(),
        ke.dispose(),
        ke.removeEventListener("sessionstart", Ie),
        ke.removeEventListener("sessionend", Ge),
        U && (U.dispose(), (U = null)),
        Mt.stop();
    });
  function je(B) {
    B.preventDefault(),
      console.log("THREE.WebGLRenderer: Context Lost."),
      (b = !0);
  }
  function Ve() {
    console.log("THREE.WebGLRenderer: Context Restored."), (b = !1);
    const B = Ke.autoReset,
      te = pe.enabled,
      de = pe.autoUpdate,
      se = pe.needsUpdate,
      me = pe.type;
    Ae(),
      (Ke.autoReset = B),
      (pe.enabled = te),
      (pe.autoUpdate = de),
      (pe.needsUpdate = se),
      (pe.type = me);
  }
  function rt(B) {
    console.error(
      "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
      B.statusMessage
    );
  }
  function lt(B) {
    const te = B.target;
    te.removeEventListener("dispose", lt), Ct(te);
  }
  function Ct(B) {
    $(B), Qe.remove(B);
  }
  function $(B) {
    const te = Qe.get(B).programs;
    te !== void 0 &&
      (te.forEach(function (de) {
        ft.releaseProgram(de);
      }),
      B.isShaderMaterial && ft.releaseShaderCache(B));
  }
  (this.renderBufferDirect = function (B, te, de, se, me, Fe) {
    te === null && (te = le);
    const Ne = me.isMesh && me.matrixWorld.determinant() < 0,
      it = yt(B, te, de, se, me);
    Me.setMaterial(se, Ne);
    let $e = de.index,
      nt = 1;
    se.wireframe === !0 && (($e = he.getWireframeAttribute(de)), (nt = 2));
    const pt = de.drawRange,
      ot = de.attributes.position;
    let xt = pt.start * nt,
      Ot = (pt.start + pt.count) * nt;
    Fe !== null &&
      ((xt = Math.max(xt, Fe.start * nt)),
      (Ot = Math.min(Ot, (Fe.start + Fe.count) * nt))),
      $e !== null
        ? ((xt = Math.max(xt, 0)), (Ot = Math.min(Ot, $e.count)))
        : ot != null && ((xt = Math.max(xt, 0)), (Ot = Math.min(Ot, ot.count)));
    const Zt = Ot - xt;
    if (Zt < 0 || Zt === 1 / 0) return;
    ne.setup(me, se, it, de, $e);
    let ki,
      St = Ce;
    if (
      ($e !== null && ((ki = dt.get($e)), (St = We), St.setIndex(ki)),
      me.isMesh)
    )
      se.wireframe === !0
        ? (Me.setLineWidth(se.wireframeLinewidth * be()), St.setMode(1))
        : St.setMode(4);
    else if (me.isLine) {
      let Je = se.linewidth;
      Je === void 0 && (Je = 1),
        Me.setLineWidth(Je * be()),
        me.isLineSegments
          ? St.setMode(1)
          : me.isLineLoop
          ? St.setMode(2)
          : St.setMode(3);
    } else me.isPoints ? St.setMode(0) : me.isSprite && St.setMode(4);
    if (me.isInstancedMesh) St.renderInstances(xt, Zt, me.count);
    else if (de.isInstancedBufferGeometry) {
      const Je = de._maxInstanceCount !== void 0 ? de._maxInstanceCount : 1 / 0,
        ai = Math.min(de.instanceCount, Je);
      St.renderInstances(xt, Zt, ai);
    } else St.render(xt, Zt);
  }),
    (this.compile = function (B, te) {
      function de(se, me, Fe) {
        se.transparent === !0 && se.side === zu
          ? ((se.side = Bn),
            (se.needsUpdate = !0),
            mt(se, me, Fe),
            (se.side = Bs),
            (se.needsUpdate = !0),
            mt(se, me, Fe),
            (se.side = zu))
          : mt(se, me, Fe);
      }
      (d = G.get(B)),
        d.init(),
        x.push(d),
        B.traverseVisible(function (se) {
          se.isLight &&
            se.layers.test(te.layers) &&
            (d.pushLight(se), se.castShadow && d.pushShadow(se));
        }),
        d.setupLights(v.physicallyCorrectLights),
        B.traverse(function (se) {
          const me = se.material;
          if (me)
            if (Array.isArray(me))
              for (let Fe = 0; Fe < me.length; Fe++) {
                const Ne = me[Fe];
                de(Ne, B, se);
              }
            else de(me, B, se);
        }),
        x.pop(),
        (d = null);
    });
  let ge = null;
  function ye(B) {
    ge && ge(B);
  }
  function Ie() {
    Mt.stop();
  }
  function Ge() {
    Mt.start();
  }
  const Mt = new gb();
  Mt.setAnimationLoop(ye),
    typeof self < "u" && Mt.setContext(self),
    (this.setAnimationLoop = function (B) {
      (ge = B), ke.setAnimationLoop(B), B === null ? Mt.stop() : Mt.start();
    }),
    ke.addEventListener("sessionstart", Ie),
    ke.addEventListener("sessionend", Ge),
    (this.render = function (B, te) {
      if (te !== void 0 && te.isCamera !== !0) {
        console.error(
          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
        );
        return;
      }
      if (b === !0) return;
      B.matrixWorldAutoUpdate === !0 && B.updateMatrixWorld(),
        te.parent === null &&
          te.matrixWorldAutoUpdate === !0 &&
          te.updateMatrixWorld(),
        ke.enabled === !0 &&
          ke.isPresenting === !0 &&
          (ke.cameraAutoUpdate === !0 && ke.updateCamera(te),
          (te = ke.getCamera())),
        B.isScene === !0 && B.onBeforeRender(v, B, te, D),
        (d = G.get(B, x.length)),
        d.init(),
        x.push(d),
        oe.multiplyMatrices(te.projectionMatrix, te.matrixWorldInverse),
        Q.setFromProjectionMatrix(oe),
        (ve = this.localClippingEnabled),
        (V = N.init(this.clippingPlanes, ve, te)),
        (c = bt.get(B, m.length)),
        c.init(),
        m.push(c),
        zt(B, te, 0, v.sortObjects),
        c.finish(),
        v.sortObjects === !0 && c.sort(ee, X),
        V === !0 && N.beginShadows();
      const de = d.state.shadowsArray;
      if (
        (pe.render(de, B, te),
        V === !0 && N.endShadows(),
        this.info.autoReset === !0 && this.info.reset(),
        xe.render(c, B),
        d.setupLights(v.physicallyCorrectLights),
        te.isArrayCamera)
      ) {
        const se = te.cameras;
        for (let me = 0, Fe = se.length; me < Fe; me++) {
          const Ne = se[me];
          Rt(c, B, Ne, Ne.viewport);
        }
      } else Rt(c, B, te);
      D !== null &&
        (Pe.updateMultisampleRenderTarget(D), Pe.updateRenderTargetMipmap(D)),
        B.isScene === !0 && B.onAfterRender(v, B, te),
        ne.resetDefaultState(),
        (C = -1),
        (A = null),
        x.pop(),
        x.length > 0 ? (d = x[x.length - 1]) : (d = null),
        m.pop(),
        m.length > 0 ? (c = m[m.length - 1]) : (c = null);
    });
  function zt(B, te, de, se) {
    if (B.visible === !1) return;
    if (B.layers.test(te.layers)) {
      if (B.isGroup) de = B.renderOrder;
      else if (B.isLOD) B.autoUpdate === !0 && B.update(te);
      else if (B.isLight) d.pushLight(B), B.castShadow && d.pushShadow(B);
      else if (B.isSprite) {
        if (!B.frustumCulled || Q.intersectsSprite(B)) {
          se && fe.setFromMatrixPosition(B.matrixWorld).applyMatrix4(oe);
          const Ne = Et.update(B),
            it = B.material;
          it.visible && c.push(B, Ne, it, de, fe.z, null);
        }
      } else if (
        (B.isMesh || B.isLine || B.isPoints) &&
        (B.isSkinnedMesh &&
          B.skeleton.frame !== Ke.render.frame &&
          (B.skeleton.update(), (B.skeleton.frame = Ke.render.frame)),
        !B.frustumCulled || Q.intersectsObject(B))
      ) {
        se && fe.setFromMatrixPosition(B.matrixWorld).applyMatrix4(oe);
        const Ne = Et.update(B),
          it = B.material;
        if (Array.isArray(it)) {
          const $e = Ne.groups;
          for (let nt = 0, pt = $e.length; nt < pt; nt++) {
            const ot = $e[nt],
              xt = it[ot.materialIndex];
            xt && xt.visible && c.push(B, Ne, xt, de, fe.z, ot);
          }
        } else it.visible && c.push(B, Ne, it, de, fe.z, null);
      }
    }
    const Fe = B.children;
    for (let Ne = 0, it = Fe.length; Ne < it; Ne++) zt(Fe[Ne], te, de, se);
  }
  function Rt(B, te, de, se) {
    const me = B.opaque,
      Fe = B.transmissive,
      Ne = B.transparent;
    d.setupLightsView(de),
      Fe.length > 0 && tt(me, te, de),
      se && Me.viewport(I.copy(se)),
      me.length > 0 && Te(me, te, de),
      Fe.length > 0 && Te(Fe, te, de),
      Ne.length > 0 && Te(Ne, te, de),
      Me.buffers.depth.setTest(!0),
      Me.buffers.depth.setMask(!0),
      Me.buffers.color.setMask(!0),
      Me.setPolygonOffset(!1);
  }
  function tt(B, te, de) {
    const se = Oe.isWebGL2;
    U === null &&
      (U = new Zo(1, 1, {
        generateMipmaps: !0,
        type: Se.has("EXT_color_buffer_half_float") ? Vc : Ko,
        minFilter: mr,
        samples: se && s === !0 ? 4 : 0,
      })),
      v.getDrawingBufferSize(ue),
      se ? U.setSize(ue.x, ue.y) : U.setSize(jh(ue.x), jh(ue.y));
    const me = v.getRenderTarget();
    v.setRenderTarget(U), v.clear();
    const Fe = v.toneMapping;
    (v.toneMapping = pr),
      Te(B, te, de),
      (v.toneMapping = Fe),
      Pe.updateMultisampleRenderTarget(U),
      Pe.updateRenderTargetMipmap(U),
      v.setRenderTarget(me);
  }
  function Te(B, te, de) {
    const se = te.isScene === !0 ? te.overrideMaterial : null;
    for (let me = 0, Fe = B.length; me < Fe; me++) {
      const Ne = B[me],
        it = Ne.object,
        $e = Ne.geometry,
        nt = se === null ? Ne.material : se,
        pt = Ne.group;
      it.layers.test(de.layers) && gt(it, te, de, $e, nt, pt);
    }
  }
  function gt(B, te, de, se, me, Fe) {
    B.onBeforeRender(v, te, de, se, me, Fe),
      B.modelViewMatrix.multiplyMatrices(de.matrixWorldInverse, B.matrixWorld),
      B.normalMatrix.getNormalMatrix(B.modelViewMatrix),
      me.onBeforeRender(v, te, de, se, B, Fe),
      me.transparent === !0 && me.side === zu
        ? ((me.side = Bn),
          (me.needsUpdate = !0),
          v.renderBufferDirect(de, te, se, me, B, Fe),
          (me.side = Bs),
          (me.needsUpdate = !0),
          v.renderBufferDirect(de, te, se, me, B, Fe),
          (me.side = zu))
        : v.renderBufferDirect(de, te, se, me, B, Fe),
      B.onAfterRender(v, te, de, se, me, Fe);
  }
  function mt(B, te, de) {
    te.isScene !== !0 && (te = le);
    const se = Qe.get(B),
      me = d.state.lights,
      Fe = d.state.shadowsArray,
      Ne = me.state.version,
      it = ft.getParameters(B, me.state, Fe, te, de),
      $e = ft.getProgramCacheKey(it);
    let nt = se.programs;
    (se.environment = B.isMeshStandardMaterial ? te.environment : null),
      (se.fog = te.fog),
      (se.envMap = (B.isMeshStandardMaterial ? wt : ht).get(
        B.envMap || se.environment
      )),
      nt === void 0 &&
        (B.addEventListener("dispose", lt),
        (nt = new Map()),
        (se.programs = nt));
    let pt = nt.get($e);
    if (pt !== void 0) {
      if (se.currentProgram === pt && se.lightsStateVersion === Ne)
        return ze(B, it), pt;
    } else
      (it.uniforms = ft.getUniforms(B)),
        B.onBuild(de, it, v),
        B.onBeforeCompile(it, v),
        (pt = ft.acquireProgram(it, $e)),
        nt.set($e, pt),
        (se.uniforms = it.uniforms);
    const ot = se.uniforms;
    ((!B.isShaderMaterial && !B.isRawShaderMaterial) || B.clipping === !0) &&
      (ot.clippingPlanes = N.uniform),
      ze(B, it),
      (se.needsLights = _t(B)),
      (se.lightsStateVersion = Ne),
      se.needsLights &&
        ((ot.ambientLightColor.value = me.state.ambient),
        (ot.lightProbe.value = me.state.probe),
        (ot.directionalLights.value = me.state.directional),
        (ot.directionalLightShadows.value = me.state.directionalShadow),
        (ot.spotLights.value = me.state.spot),
        (ot.spotLightShadows.value = me.state.spotShadow),
        (ot.rectAreaLights.value = me.state.rectArea),
        (ot.ltc_1.value = me.state.rectAreaLTC1),
        (ot.ltc_2.value = me.state.rectAreaLTC2),
        (ot.pointLights.value = me.state.point),
        (ot.pointLightShadows.value = me.state.pointShadow),
        (ot.hemisphereLights.value = me.state.hemi),
        (ot.directionalShadowMap.value = me.state.directionalShadowMap),
        (ot.directionalShadowMatrix.value = me.state.directionalShadowMatrix),
        (ot.spotShadowMap.value = me.state.spotShadowMap),
        (ot.spotLightMatrix.value = me.state.spotLightMatrix),
        (ot.spotLightMap.value = me.state.spotLightMap),
        (ot.pointShadowMap.value = me.state.pointShadowMap),
        (ot.pointShadowMatrix.value = me.state.pointShadowMatrix));
    const xt = pt.getUniforms(),
      Ot = Rh.seqWithValue(xt.seq, ot);
    return (se.currentProgram = pt), (se.uniformsList = Ot), pt;
  }
  function ze(B, te) {
    const de = Qe.get(B);
    (de.outputEncoding = te.outputEncoding),
      (de.instancing = te.instancing),
      (de.skinning = te.skinning),
      (de.morphTargets = te.morphTargets),
      (de.morphNormals = te.morphNormals),
      (de.morphColors = te.morphColors),
      (de.morphTargetsCount = te.morphTargetsCount),
      (de.numClippingPlanes = te.numClippingPlanes),
      (de.numIntersection = te.numClipIntersection),
      (de.vertexAlphas = te.vertexAlphas),
      (de.vertexTangents = te.vertexTangents),
      (de.toneMapping = te.toneMapping);
  }
  function yt(B, te, de, se, me) {
    te.isScene !== !0 && (te = le), Pe.resetTextureUnits();
    const Fe = te.fog,
      Ne = se.isMeshStandardMaterial ? te.environment : null,
      it =
        D === null
          ? v.outputEncoding
          : D.isXRRenderTarget === !0
          ? D.texture.encoding
          : gr,
      $e = (se.isMeshStandardMaterial ? wt : ht).get(se.envMap || Ne),
      nt =
        se.vertexColors === !0 &&
        !!de.attributes.color &&
        de.attributes.color.itemSize === 4,
      pt = !!se.normalMap && !!de.attributes.tangent,
      ot = !!de.morphAttributes.position,
      xt = !!de.morphAttributes.normal,
      Ot = !!de.morphAttributes.color,
      Zt = se.toneMapped ? v.toneMapping : pr,
      ki =
        de.morphAttributes.position ||
        de.morphAttributes.normal ||
        de.morphAttributes.color,
      St = ki !== void 0 ? ki.length : 0,
      Je = Qe.get(se),
      ai = d.state.lights;
    if (V === !0 && (ve === !0 || B !== A)) {
      const Ii = B === A && se.id === C;
      N.setState(se, B, Ii);
    }
    let Jt = !1;
    se.version === Je.__version
      ? ((Je.needsLights && Je.lightsStateVersion !== ai.state.version) ||
          Je.outputEncoding !== it ||
          (me.isInstancedMesh && Je.instancing === !1) ||
          (!me.isInstancedMesh && Je.instancing === !0) ||
          (me.isSkinnedMesh && Je.skinning === !1) ||
          (!me.isSkinnedMesh && Je.skinning === !0) ||
          Je.envMap !== $e ||
          (se.fog === !0 && Je.fog !== Fe) ||
          (Je.numClippingPlanes !== void 0 &&
            (Je.numClippingPlanes !== N.numPlanes ||
              Je.numIntersection !== N.numIntersection)) ||
          Je.vertexAlphas !== nt ||
          Je.vertexTangents !== pt ||
          Je.morphTargets !== ot ||
          Je.morphNormals !== xt ||
          Je.morphColors !== Ot ||
          Je.toneMapping !== Zt ||
          (Oe.isWebGL2 === !0 && Je.morphTargetsCount !== St)) &&
        (Jt = !0)
      : ((Jt = !0), (Je.__version = se.version));
    let Ut = Je.currentProgram;
    Jt === !0 && (Ut = mt(se, te, me));
    let Gn = !1,
      ni = !1,
      un = !1;
    const Qt = Ut.getUniforms(),
      Ti = Je.uniforms;
    if (
      (Me.useProgram(Ut.program) && ((Gn = !0), (ni = !0), (un = !0)),
      se.id !== C && ((C = se.id), (ni = !0)),
      Gn || A !== B)
    ) {
      if (
        (Qt.setValue(ce, "projectionMatrix", B.projectionMatrix),
        Oe.logarithmicDepthBuffer &&
          Qt.setValue(
            ce,
            "logDepthBufFC",
            2 / (Math.log(B.far + 1) / Math.LN2)
          ),
        A !== B && ((A = B), (ni = !0), (un = !0)),
        se.isShaderMaterial ||
          se.isMeshPhongMaterial ||
          se.isMeshToonMaterial ||
          se.isMeshStandardMaterial ||
          se.envMap)
      ) {
        const Ii = Qt.map.cameraPosition;
        Ii !== void 0 &&
          Ii.setValue(ce, fe.setFromMatrixPosition(B.matrixWorld));
      }
      (se.isMeshPhongMaterial ||
        se.isMeshToonMaterial ||
        se.isMeshLambertMaterial ||
        se.isMeshBasicMaterial ||
        se.isMeshStandardMaterial ||
        se.isShaderMaterial) &&
        Qt.setValue(ce, "isOrthographic", B.isOrthographicCamera === !0),
        (se.isMeshPhongMaterial ||
          se.isMeshToonMaterial ||
          se.isMeshLambertMaterial ||
          se.isMeshBasicMaterial ||
          se.isMeshStandardMaterial ||
          se.isShaderMaterial ||
          se.isShadowMaterial ||
          me.isSkinnedMesh) &&
          Qt.setValue(ce, "viewMatrix", B.matrixWorldInverse);
    }
    if (me.isSkinnedMesh) {
      Qt.setOptional(ce, me, "bindMatrix"),
        Qt.setOptional(ce, me, "bindMatrixInverse");
      const Ii = me.skeleton;
      Ii &&
        (Oe.floatVertexTextures
          ? (Ii.boneTexture === null && Ii.computeBoneTexture(),
            Qt.setValue(ce, "boneTexture", Ii.boneTexture, Pe),
            Qt.setValue(ce, "boneTextureSize", Ii.boneTextureSize))
          : console.warn(
              "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
            ));
    }
    const yr = de.morphAttributes;
    if (
      ((yr.position !== void 0 ||
        yr.normal !== void 0 ||
        (yr.color !== void 0 && Oe.isWebGL2 === !0)) &&
        we.update(me, de, se, Ut),
      (ni || Je.receiveShadow !== me.receiveShadow) &&
        ((Je.receiveShadow = me.receiveShadow),
        Qt.setValue(ce, "receiveShadow", me.receiveShadow)),
      se.isMeshGouraudMaterial &&
        se.envMap !== null &&
        ((Ti.envMap.value = $e),
        (Ti.flipEnvMap.value =
          $e.isCubeTexture && $e.isRenderTargetTexture === !1 ? -1 : 1)),
      ni &&
        (Qt.setValue(ce, "toneMappingExposure", v.toneMappingExposure),
        Je.needsLights && st(Ti, un),
        Fe && se.fog === !0 && Bt.refreshFogUniforms(Ti, Fe),
        Bt.refreshMaterialUniforms(Ti, se, J, O, U),
        Rh.upload(ce, Je.uniformsList, Ti, Pe)),
      se.isShaderMaterial &&
        se.uniformsNeedUpdate === !0 &&
        (Rh.upload(ce, Je.uniformsList, Ti, Pe), (se.uniformsNeedUpdate = !1)),
      se.isSpriteMaterial && Qt.setValue(ce, "center", me.center),
      Qt.setValue(ce, "modelViewMatrix", me.modelViewMatrix),
      Qt.setValue(ce, "normalMatrix", me.normalMatrix),
      Qt.setValue(ce, "modelMatrix", me.matrixWorld),
      se.isShaderMaterial || se.isRawShaderMaterial)
    ) {
      const Ii = se.uniformsGroups;
      for (let Hn = 0, ys = Ii.length; Hn < ys; Hn++)
        if (Oe.isWebGL2) {
          const Ss = Ii[Hn];
          Re.update(Ss, Ut), Re.bind(Ss, Ut);
        } else
          console.warn(
            "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
          );
    }
    return Ut;
  }
  function st(B, te) {
    (B.ambientLightColor.needsUpdate = te),
      (B.lightProbe.needsUpdate = te),
      (B.directionalLights.needsUpdate = te),
      (B.directionalLightShadows.needsUpdate = te),
      (B.pointLights.needsUpdate = te),
      (B.pointLightShadows.needsUpdate = te),
      (B.spotLights.needsUpdate = te),
      (B.spotLightShadows.needsUpdate = te),
      (B.rectAreaLights.needsUpdate = te),
      (B.hemisphereLights.needsUpdate = te);
  }
  function _t(B) {
    return (
      B.isMeshLambertMaterial ||
      B.isMeshToonMaterial ||
      B.isMeshPhongMaterial ||
      B.isMeshStandardMaterial ||
      B.isShadowMaterial ||
      (B.isShaderMaterial && B.lights === !0)
    );
  }
  (this.getActiveCubeFace = function () {
    return y;
  }),
    (this.getActiveMipmapLevel = function () {
      return M;
    }),
    (this.getRenderTarget = function () {
      return D;
    }),
    (this.setRenderTargetTextures = function (B, te, de) {
      (Qe.get(B.texture).__webglTexture = te),
        (Qe.get(B.depthTexture).__webglTexture = de);
      const se = Qe.get(B);
      (se.__hasExternalTextures = !0),
        se.__hasExternalTextures &&
          ((se.__autoAllocateDepthBuffer = de === void 0),
          se.__autoAllocateDepthBuffer ||
            (Se.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (se.__useRenderToTexture = !1))));
    }),
    (this.setRenderTargetFramebuffer = function (B, te) {
      const de = Qe.get(B);
      (de.__webglFramebuffer = te),
        (de.__useDefaultFramebuffer = te === void 0);
    }),
    (this.setRenderTarget = function (B, te = 0, de = 0) {
      (D = B), (y = te), (M = de);
      let se = !0,
        me = null,
        Fe = !1,
        Ne = !1;
      if (B) {
        const $e = Qe.get(B);
        $e.__useDefaultFramebuffer !== void 0
          ? (Me.bindFramebuffer(36160, null), (se = !1))
          : $e.__webglFramebuffer === void 0
          ? Pe.setupRenderTarget(B)
          : $e.__hasExternalTextures &&
            Pe.rebindTextures(
              B,
              Qe.get(B.texture).__webglTexture,
              Qe.get(B.depthTexture).__webglTexture
            );
        const nt = B.texture;
        (nt.isData3DTexture ||
          nt.isDataArrayTexture ||
          nt.isCompressedArrayTexture) &&
          (Ne = !0);
        const pt = Qe.get(B).__webglFramebuffer;
        B.isWebGLCubeRenderTarget
          ? ((me = pt[te]), (Fe = !0))
          : Oe.isWebGL2 && B.samples > 0 && Pe.useMultisampledRTT(B) === !1
          ? (me = Qe.get(B).__webglMultisampledFramebuffer)
          : (me = pt),
          I.copy(B.viewport),
          F.copy(B.scissor),
          (P = B.scissorTest);
      } else
        I.copy(j).multiplyScalar(J).floor(),
          F.copy(Y).multiplyScalar(J).floor(),
          (P = ie);
      if (
        (Me.bindFramebuffer(36160, me) &&
          Oe.drawBuffers &&
          se &&
          Me.drawBuffers(B, me),
        Me.viewport(I),
        Me.scissor(F),
        Me.setScissorTest(P),
        Fe)
      ) {
        const $e = Qe.get(B.texture);
        ce.framebufferTexture2D(
          36160,
          36064,
          34069 + te,
          $e.__webglTexture,
          de
        );
      } else if (Ne) {
        const $e = Qe.get(B.texture),
          nt = te || 0;
        ce.framebufferTextureLayer(
          36160,
          36064,
          $e.__webglTexture,
          de || 0,
          nt
        );
      }
      C = -1;
    }),
    (this.readRenderTargetPixels = function (B, te, de, se, me, Fe, Ne) {
      if (!(B && B.isWebGLRenderTarget)) {
        console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
        );
        return;
      }
      let it = Qe.get(B).__webglFramebuffer;
      if ((B.isWebGLCubeRenderTarget && Ne !== void 0 && (it = it[Ne]), it)) {
        Me.bindFramebuffer(36160, it);
        try {
          const $e = B.texture,
            nt = $e.format,
            pt = $e.type;
          if (nt !== es && H.convert(nt) !== ce.getParameter(35739)) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
            );
            return;
          }
          const ot =
            pt === Vc &&
            (Se.has("EXT_color_buffer_half_float") ||
              (Oe.isWebGL2 && Se.has("EXT_color_buffer_float")));
          if (
            pt !== Ko &&
            H.convert(pt) !== ce.getParameter(35738) &&
            !(
              pt === Gr &&
              (Oe.isWebGL2 ||
                Se.has("OES_texture_float") ||
                Se.has("WEBGL_color_buffer_float"))
            ) &&
            !ot
          ) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
            );
            return;
          }
          te >= 0 &&
            te <= B.width - se &&
            de >= 0 &&
            de <= B.height - me &&
            ce.readPixels(te, de, se, me, H.convert(nt), H.convert(pt), Fe);
        } finally {
          const $e = D !== null ? Qe.get(D).__webglFramebuffer : null;
          Me.bindFramebuffer(36160, $e);
        }
      }
    }),
    (this.copyFramebufferToTexture = function (B, te, de = 0) {
      const se = Math.pow(2, -de),
        me = Math.floor(te.image.width * se),
        Fe = Math.floor(te.image.height * se);
      Pe.setTexture2D(te, 0),
        ce.copyTexSubImage2D(3553, de, 0, 0, B.x, B.y, me, Fe),
        Me.unbindTexture();
    }),
    (this.copyTextureToTexture = function (B, te, de, se = 0) {
      const me = te.image.width,
        Fe = te.image.height,
        Ne = H.convert(de.format),
        it = H.convert(de.type);
      Pe.setTexture2D(de, 0),
        ce.pixelStorei(37440, de.flipY),
        ce.pixelStorei(37441, de.premultiplyAlpha),
        ce.pixelStorei(3317, de.unpackAlignment),
        te.isDataTexture
          ? ce.texSubImage2D(3553, se, B.x, B.y, me, Fe, Ne, it, te.image.data)
          : te.isCompressedTexture
          ? ce.compressedTexSubImage2D(
              3553,
              se,
              B.x,
              B.y,
              te.mipmaps[0].width,
              te.mipmaps[0].height,
              Ne,
              te.mipmaps[0].data
            )
          : ce.texSubImage2D(3553, se, B.x, B.y, Ne, it, te.image),
        se === 0 && de.generateMipmaps && ce.generateMipmap(3553),
        Me.unbindTexture();
    }),
    (this.copyTextureToTexture3D = function (B, te, de, se, me = 0) {
      if (v.isWebGL1Renderer) {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
        );
        return;
      }
      const Fe = B.max.x - B.min.x + 1,
        Ne = B.max.y - B.min.y + 1,
        it = B.max.z - B.min.z + 1,
        $e = H.convert(se.format),
        nt = H.convert(se.type);
      let pt;
      if (se.isData3DTexture) Pe.setTexture3D(se, 0), (pt = 32879);
      else if (se.isDataArrayTexture) Pe.setTexture2DArray(se, 0), (pt = 35866);
      else {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
        );
        return;
      }
      ce.pixelStorei(37440, se.flipY),
        ce.pixelStorei(37441, se.premultiplyAlpha),
        ce.pixelStorei(3317, se.unpackAlignment);
      const ot = ce.getParameter(3314),
        xt = ce.getParameter(32878),
        Ot = ce.getParameter(3316),
        Zt = ce.getParameter(3315),
        ki = ce.getParameter(32877),
        St = de.isCompressedTexture ? de.mipmaps[0] : de.image;
      ce.pixelStorei(3314, St.width),
        ce.pixelStorei(32878, St.height),
        ce.pixelStorei(3316, B.min.x),
        ce.pixelStorei(3315, B.min.y),
        ce.pixelStorei(32877, B.min.z),
        de.isDataTexture || de.isData3DTexture
          ? ce.texSubImage3D(
              pt,
              me,
              te.x,
              te.y,
              te.z,
              Fe,
              Ne,
              it,
              $e,
              nt,
              St.data
            )
          : de.isCompressedArrayTexture
          ? (console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
            ),
            ce.compressedTexSubImage3D(
              pt,
              me,
              te.x,
              te.y,
              te.z,
              Fe,
              Ne,
              it,
              $e,
              St.data
            ))
          : ce.texSubImage3D(pt, me, te.x, te.y, te.z, Fe, Ne, it, $e, nt, St),
        ce.pixelStorei(3314, ot),
        ce.pixelStorei(32878, xt),
        ce.pixelStorei(3316, Ot),
        ce.pixelStorei(3315, Zt),
        ce.pixelStorei(32877, ki),
        me === 0 && se.generateMipmaps && ce.generateMipmap(pt),
        Me.unbindTexture();
    }),
    (this.initTexture = function (B) {
      B.isCubeTexture
        ? Pe.setTextureCube(B, 0)
        : B.isData3DTexture
        ? Pe.setTexture3D(B, 0)
        : B.isDataArrayTexture || B.isCompressedArrayTexture
        ? Pe.setTexture2DArray(B, 0)
        : Pe.setTexture2D(B, 0),
        Me.unbindTexture();
    }),
    (this.resetState = function () {
      (y = 0), (M = 0), (D = null), Me.reset(), ne.reset();
    }),
    typeof __THREE_DEVTOOLS__ < "u" &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this })
      );
}
class HC extends Mm {}
HC.prototype.isWebGL1Renderer = !0;
class hd {
  constructor(e, t = 1, i = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new ct(e)),
      (this.near = t),
      (this.far = i);
  }
  clone() {
    return new hd(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class WC extends ei {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
  get autoUpdate() {
    return (
      console.warn(
        "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
      ),
      this.matrixWorldAutoUpdate
    );
  }
  set autoUpdate(e) {
    console.warn(
      "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
    ),
      (this.matrixWorldAutoUpdate = e);
  }
}
class jC {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = Ef),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = bs());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.stride), (i *= t.stride);
    for (let n = 0, s = this.stride; n < s; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = bs()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = bs()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const Zi = new Z();
class Tm {
  constructor(e, t, i, n = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = n);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      Zi.fromBufferAttribute(this, t),
        Zi.applyMatrix4(e),
        this.setXYZ(t, Zi.x, Zi.y, Zi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Zi.fromBufferAttribute(this, t),
        Zi.applyNormalMatrix(e),
        this.setXYZ(t, Zi.x, Zi.y, Zi.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Zi.fromBufferAttribute(this, t),
        Zi.transformDirection(e),
        this.setXYZ(t, Zi.x, Zi.y, Zi.z);
    return this;
  }
  setX(e, t) {
    return (
      this.normalized && (t = $t(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = $t(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = $t(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = $t(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = lr(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = lr(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = lr(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = lr(t, this.array)), t;
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = $t(t, this.array)), (i = $t(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, n) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = $t(t, this.array)),
        (i = $t(i, this.array)),
        (n = $t(n, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = n),
      this
    );
  }
  setXYZW(e, t, i, n, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = $t(t, this.array)),
        (i = $t(i, this.array)),
        (n = $t(n, this.array)),
        (s = $t(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = n),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const n = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[n + s]);
      }
      return new an(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Tm(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const n = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[n + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
const hv = new Z(),
  dv = new Kt(),
  pv = new Kt(),
  qC = new Z(),
  fv = new At();
class XC extends Wi {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new At()),
      (this.bindMatrixInverse = new At());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      this
    );
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Kt(),
      t = this.geometry.attributes.skinWeight;
    for (let i = 0, n = t.count; i < n; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === "detached"
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  boneTransform(e, t) {
    const i = this.skeleton,
      n = this.geometry;
    dv.fromBufferAttribute(n.attributes.skinIndex, e),
      pv.fromBufferAttribute(n.attributes.skinWeight, e),
      hv.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const a = pv.getComponent(s);
      if (a !== 0) {
        const o = dv.getComponent(s);
        fv.multiplyMatrices(i.bones[o].matrixWorld, i.boneInverses[o]),
          t.addScaledVector(qC.copy(hv).applyMatrix4(fv), a);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class wb extends ei {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class $C extends xi {
  constructor(e = null, t = 1, i = 1, n, s, a, o, u, h = Ai, f = Ai, c, d) {
    super(null, a, o, u, h, f, n, s, c, d),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const mv = new At(),
  YC = new At();
class Em {
  constructor(e = [], t = []) {
    (this.uuid = bs()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      (this.frame = -1),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let i = 0, n = this.bones.length; i < n; i++)
        this.boneInverses.push(new At());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new At();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      n = this.boneTexture;
    for (let s = 0, a = e.length; s < a; s++) {
      const o = e[s] ? e[s].matrixWorld : YC;
      mv.multiplyMatrices(o, t[s]), mv.toArray(i, s * 16);
    }
    n !== null && (n.needsUpdate = !0);
  }
  clone() {
    return new Em(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = ob(e)), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new $C(t, e, e, es, Gr);
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const n = this.bones[t];
      if (n.name === e) return n;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, n = e.bones.length; i < n; i++) {
      const s = e.bones[i];
      let a = t[s];
      a === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (a = new wb())),
        this.bones.push(a),
        this.boneInverses.push(new At().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      i = this.boneInverses;
    for (let n = 0, s = t.length; n < s; n++) {
      const a = t[n];
      e.bones.push(a.uuid);
      const o = i[n];
      e.boneInverses.push(o.toArray());
    }
    return e;
  }
}
class zo extends an {
  constructor(e, t, i, n = 1) {
    super(e, t, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = n);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const gv = new At(),
  vv = new At(),
  rh = [],
  KC = new At(),
  oc = new Wi();
class yb extends Wi {
  constructor(e, t, i) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new zo(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.count = i),
      (this.frustumCulled = !1);
    for (let n = 0; n < i; n++) this.setMatrixAt(n, KC);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      n = this.count;
    if (
      ((oc.geometry = this.geometry),
      (oc.material = this.material),
      oc.material !== void 0)
    )
      for (let s = 0; s < n; s++) {
        this.getMatrixAt(s, gv),
          vv.multiplyMatrices(i, gv),
          (oc.matrixWorld = vv),
          oc.raycast(e, rh);
        for (let a = 0, o = rh.length; a < o; a++) {
          const u = rh[a];
          (u.instanceId = s), (u.object = this), t.push(u);
        }
        rh.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new zo(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class lu extends Is {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new ct(16777215)),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const _v = new Z(),
  bv = new Z(),
  xv = new At(),
  zp = new cd(),
  oh = new El();
class cu extends ei {
  constructor(e = new cn(), t = new lu()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [0];
      for (let n = 1, s = t.count; n < s; n++)
        _v.fromBufferAttribute(t, n - 1),
          bv.fromBufferAttribute(t, n),
          (i[n] = i[n - 1]),
          (i[n] += _v.distanceTo(bv));
      e.setAttribute("lineDistance", new xn(i, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const i = this.geometry,
      n = this.matrixWorld,
      s = e.params.Line.threshold,
      a = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      oh.copy(i.boundingSphere),
      oh.applyMatrix4(n),
      (oh.radius += s),
      e.ray.intersectsSphere(oh) === !1)
    )
      return;
    xv.copy(n).invert(), zp.copy(e.ray).applyMatrix4(xv);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      u = o * o,
      h = new Z(),
      f = new Z(),
      c = new Z(),
      d = new Z(),
      m = this.isLineSegments ? 2 : 1,
      x = i.index,
      b = i.attributes.position;
    if (x !== null) {
      const y = Math.max(0, a.start),
        M = Math.min(x.count, a.start + a.count);
      for (let D = y, C = M - 1; D < C; D += m) {
        const A = x.getX(D),
          I = x.getX(D + 1);
        if (
          (h.fromBufferAttribute(b, A),
          f.fromBufferAttribute(b, I),
          zp.distanceSqToSegment(h, f, d, c) > u)
        )
          continue;
        d.applyMatrix4(this.matrixWorld);
        const P = e.ray.origin.distanceTo(d);
        P < e.near ||
          P > e.far ||
          t.push({
            distance: P,
            point: c.clone().applyMatrix4(this.matrixWorld),
            index: D,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const y = Math.max(0, a.start),
        M = Math.min(b.count, a.start + a.count);
      for (let D = y, C = M - 1; D < C; D += m) {
        if (
          (h.fromBufferAttribute(b, D),
          f.fromBufferAttribute(b, D + 1),
          zp.distanceSqToSegment(h, f, d, c) > u)
        )
          continue;
        d.applyMatrix4(this.matrixWorld);
        const I = e.ray.origin.distanceTo(d);
        I < e.near ||
          I > e.far ||
          t.push({
            distance: I,
            point: c.clone().applyMatrix4(this.matrixWorld),
            index: D,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = n.length; s < a; s++) {
          const o = n[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
}
const wv = new Z(),
  yv = new Z();
class Sb extends cu {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [];
      for (let n = 0, s = t.count; n < s; n += 2)
        wv.fromBufferAttribute(t, n),
          yv.fromBufferAttribute(t, n + 1),
          (i[n] = n === 0 ? 0 : i[n - 1]),
          (i[n + 1] = i[n] + wv.distanceTo(yv));
      e.setAttribute("lineDistance", new xn(i, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class ZC extends cu {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class Mb extends Is {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new ct(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const Sv = new At(),
  Af = new cd(),
  ah = new El(),
  lh = new Z();
class JC extends ei {
  constructor(e = new cn(), t = new Mb()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const i = this.geometry,
      n = this.matrixWorld,
      s = e.params.Points.threshold,
      a = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      ah.copy(i.boundingSphere),
      ah.applyMatrix4(n),
      (ah.radius += s),
      e.ray.intersectsSphere(ah) === !1)
    )
      return;
    Sv.copy(n).invert(), Af.copy(e.ray).applyMatrix4(Sv);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      u = o * o,
      h = i.index,
      c = i.attributes.position;
    if (h !== null) {
      const d = Math.max(0, a.start),
        m = Math.min(h.count, a.start + a.count);
      for (let x = d, v = m; x < v; x++) {
        const b = h.getX(x);
        lh.fromBufferAttribute(c, b), Mv(lh, b, u, n, e, t, this);
      }
    } else {
      const d = Math.max(0, a.start),
        m = Math.min(c.count, a.start + a.count);
      for (let x = d, v = m; x < v; x++)
        lh.fromBufferAttribute(c, x), Mv(lh, x, u, n, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = n.length; s < a; s++) {
          const o = n[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
}
function Mv(r, e, t, i, n, s, a) {
  const o = Af.distanceSqToPoint(r);
  if (o < t) {
    const u = new Z();
    Af.closestPointToPoint(r, u), u.applyMatrix4(i);
    const h = n.ray.origin.distanceTo(u);
    if (h < n.near || h > n.far) return;
    s.push({
      distance: h,
      distanceToRay: Math.sqrt(o),
      point: u,
      index: e,
      face: null,
      object: a,
    });
  }
}
class Cm {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i,
      n = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let a = 1; a <= e; a++)
      (i = this.getPoint(a / e)), (s += i.distanceTo(n)), t.push(s), (n = i);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let n = 0;
    const s = i.length;
    let a;
    t ? (a = t) : (a = e * i[s - 1]);
    let o = 0,
      u = s - 1,
      h;
    for (; o <= u; )
      if (((n = Math.floor(o + (u - o) / 2)), (h = i[n] - a), h < 0)) o = n + 1;
      else if (h > 0) u = n - 1;
      else {
        u = n;
        break;
      }
    if (((n = u), i[n] === a)) return n / (s - 1);
    const f = i[n],
      d = i[n + 1] - f,
      m = (a - f) / d;
    return (n + m) / (s - 1);
  }
  getTangent(e, t) {
    let n = e - 1e-4,
      s = e + 1e-4;
    n < 0 && (n = 0), s > 1 && (s = 1);
    const a = this.getPoint(n),
      o = this.getPoint(s),
      u = t || (a.isVector2 ? new Ue() : new Z());
    return u.copy(o).sub(a).normalize(), u;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new Z(),
      n = [],
      s = [],
      a = [],
      o = new Z(),
      u = new At();
    for (let m = 0; m <= e; m++) {
      const x = m / e;
      n[m] = this.getTangentAt(x, new Z());
    }
    (s[0] = new Z()), (a[0] = new Z());
    let h = Number.MAX_VALUE;
    const f = Math.abs(n[0].x),
      c = Math.abs(n[0].y),
      d = Math.abs(n[0].z);
    f <= h && ((h = f), i.set(1, 0, 0)),
      c <= h && ((h = c), i.set(0, 1, 0)),
      d <= h && i.set(0, 0, 1),
      o.crossVectors(n[0], i).normalize(),
      s[0].crossVectors(n[0], o),
      a[0].crossVectors(n[0], s[0]);
    for (let m = 1; m <= e; m++) {
      if (
        ((s[m] = s[m - 1].clone()),
        (a[m] = a[m - 1].clone()),
        o.crossVectors(n[m - 1], n[m]),
        o.length() > Number.EPSILON)
      ) {
        o.normalize();
        const x = Math.acos(Li(n[m - 1].dot(n[m]), -1, 1));
        s[m].applyMatrix4(u.makeRotationAxis(o, x));
      }
      a[m].crossVectors(n[m], s[m]);
    }
    if (t === !0) {
      let m = Math.acos(Li(s[0].dot(s[e]), -1, 1));
      (m /= e), n[0].dot(o.crossVectors(s[0], s[e])) > 0 && (m = -m);
      for (let x = 1; x <= e; x++)
        s[x].applyMatrix4(u.makeRotationAxis(n[x], m * x)),
          a[x].crossVectors(n[x], s[x]);
    }
    return { tangents: n, normals: s, binormals: a };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
function Dm() {
  let r = 0,
    e = 0,
    t = 0,
    i = 0;
  function n(s, a, o, u) {
    (r = s),
      (e = o),
      (t = -3 * s + 3 * a - 2 * o - u),
      (i = 2 * s - 2 * a + o + u);
  }
  return {
    initCatmullRom: function (s, a, o, u, h) {
      n(a, o, h * (o - s), h * (u - a));
    },
    initNonuniformCatmullRom: function (s, a, o, u, h, f, c) {
      let d = (a - s) / h - (o - s) / (h + f) + (o - a) / f,
        m = (o - a) / f - (u - a) / (f + c) + (u - o) / c;
      (d *= f), (m *= f), n(a, o, d, m);
    },
    calc: function (s) {
      const a = s * s,
        o = a * s;
      return r + e * s + t * a + i * o;
    },
  };
}
const ch = new Z(),
  Up = new Dm(),
  Gp = new Dm(),
  Hp = new Dm();
class Tb extends Cm {
  constructor(e = [], t = !1, i = "centripetal", n = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = i),
      (this.tension = n);
  }
  getPoint(e, t = new Z()) {
    const i = t,
      n = this.points,
      s = n.length,
      a = (s - (this.closed ? 0 : 1)) * e;
    let o = Math.floor(a),
      u = a - o;
    this.closed
      ? (o += o > 0 ? 0 : (Math.floor(Math.abs(o) / s) + 1) * s)
      : u === 0 && o === s - 1 && ((o = s - 2), (u = 1));
    let h, f;
    this.closed || o > 0
      ? (h = n[(o - 1) % s])
      : (ch.subVectors(n[0], n[1]).add(n[0]), (h = ch));
    const c = n[o % s],
      d = n[(o + 1) % s];
    if (
      (this.closed || o + 2 < s
        ? (f = n[(o + 2) % s])
        : (ch.subVectors(n[s - 1], n[s - 2]).add(n[s - 1]), (f = ch)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const m = this.curveType === "chordal" ? 0.5 : 0.25;
      let x = Math.pow(h.distanceToSquared(c), m),
        v = Math.pow(c.distanceToSquared(d), m),
        b = Math.pow(d.distanceToSquared(f), m);
      v < 1e-4 && (v = 1),
        x < 1e-4 && (x = v),
        b < 1e-4 && (b = v),
        Up.initNonuniformCatmullRom(h.x, c.x, d.x, f.x, x, v, b),
        Gp.initNonuniformCatmullRom(h.y, c.y, d.y, f.y, x, v, b),
        Hp.initNonuniformCatmullRom(h.z, c.z, d.z, f.z, x, v, b);
    } else
      this.curveType === "catmullrom" &&
        (Up.initCatmullRom(h.x, c.x, d.x, f.x, this.tension),
        Gp.initCatmullRom(h.y, c.y, d.y, f.y, this.tension),
        Hp.initCatmullRom(h.z, c.z, d.z, f.z, this.tension));
    return i.set(Up.calc(u), Gp.calc(u), Hp.calc(u)), i;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(new Z().fromArray(n));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function Tv(r, e, t, i, n) {
  const s = (i - e) * 0.5,
    a = (n - t) * 0.5,
    o = r * r,
    u = r * o;
  return (
    (2 * t - 2 * i + s + a) * u + (-3 * t + 3 * i - 2 * s - a) * o + s * r + t
  );
}
function QC(r, e) {
  const t = 1 - r;
  return t * t * t * e;
}
function eD(r, e) {
  const t = 1 - r;
  return 3 * t * t * r * e;
}
function tD(r, e) {
  return 3 * (1 - r) * r * r * e;
}
function iD(r, e) {
  return r * r * r * e;
}
function Ev(r, e, t, i, n) {
  return QC(r, e) + eD(r, t) + tD(r, i) + iD(r, n);
}
class nD extends Cm {
  constructor(e = new Ue(), t = new Ue(), i = new Ue(), n = new Ue()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = n);
  }
  getPoint(e, t = new Ue()) {
    const i = t,
      n = this.v0,
      s = this.v1,
      a = this.v2,
      o = this.v3;
    return i.set(Ev(e, n.x, s.x, a.x, o.x), Ev(e, n.y, s.y, a.y, o.y)), i;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class sD extends Cm {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new Ue()) {
    const i = t,
      n = this.points,
      s = (n.length - 1) * e,
      a = Math.floor(s),
      o = s - a,
      u = n[a === 0 ? a : a - 1],
      h = n[a],
      f = n[a > n.length - 2 ? n.length - 1 : a + 1],
      c = n[a > n.length - 3 ? n.length - 1 : a + 2];
    return i.set(Tv(o, u.x, h.x, f.x, c.x), Tv(o, u.y, h.y, f.y, c.y)), i;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(new Ue().fromArray(n));
    }
    return this;
  }
}
class dd extends cn {
  constructor(
    e = 1,
    t = 32,
    i = 16,
    n = 0,
    s = Math.PI * 2,
    a = 0,
    o = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: i,
        phiStart: n,
        phiLength: s,
        thetaStart: a,
        thetaLength: o,
      }),
      (t = Math.max(3, Math.floor(t))),
      (i = Math.max(2, Math.floor(i)));
    const u = Math.min(a + o, Math.PI);
    let h = 0;
    const f = [],
      c = new Z(),
      d = new Z(),
      m = [],
      x = [],
      v = [],
      b = [];
    for (let y = 0; y <= i; y++) {
      const M = [],
        D = y / i;
      let C = 0;
      y == 0 && a == 0
        ? (C = 0.5 / t)
        : y == i && u == Math.PI && (C = -0.5 / t);
      for (let A = 0; A <= t; A++) {
        const I = A / t;
        (c.x = -e * Math.cos(n + I * s) * Math.sin(a + D * o)),
          (c.y = e * Math.cos(a + D * o)),
          (c.z = e * Math.sin(n + I * s) * Math.sin(a + D * o)),
          x.push(c.x, c.y, c.z),
          d.copy(c).normalize(),
          v.push(d.x, d.y, d.z),
          b.push(I + C, 1 - D),
          M.push(h++);
      }
      f.push(M);
    }
    for (let y = 0; y < i; y++)
      for (let M = 0; M < t; M++) {
        const D = f[y][M + 1],
          C = f[y][M],
          A = f[y + 1][M],
          I = f[y + 1][M + 1];
        (y !== 0 || a > 0) && m.push(D, C, I),
          (y !== i - 1 || u < Math.PI) && m.push(C, A, I);
      }
    this.setIndex(m),
      this.setAttribute("position", new xn(x, 3)),
      this.setAttribute("normal", new xn(v, 3)),
      this.setAttribute("uv", new xn(b, 2));
  }
  static fromJSON(e) {
    return new dd(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class rD extends vr {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class pd extends Is {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new ct(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new ct(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = rb),
      (this.normalScale = new Ue(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class oa extends pd {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Ue(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return Li((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new ct(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new ct(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new ct(1, 1, 1)),
      (this.specularColorMap = null),
      (this._sheen = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
function Or(r, e, t) {
  return Eb(r)
    ? new r.constructor(r.subarray(e, t !== void 0 ? t : r.length))
    : r.slice(e, t);
}
function uh(r, e, t) {
  return !r || (!t && r.constructor === e)
    ? r
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(r)
    : Array.prototype.slice.call(r);
}
function Eb(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function oD(r) {
  function e(n, s) {
    return r[n] - r[s];
  }
  const t = r.length,
    i = new Array(t);
  for (let n = 0; n !== t; ++n) i[n] = n;
  return i.sort(e), i;
}
function Cv(r, e, t) {
  const i = r.length,
    n = new r.constructor(i);
  for (let s = 0, a = 0; a !== i; ++s) {
    const o = t[s] * e;
    for (let u = 0; u !== e; ++u) n[a++] = r[o + u];
  }
  return n;
}
function Cb(r, e, t, i) {
  let n = 1,
    s = r[0];
  for (; s !== void 0 && s[i] === void 0; ) s = r[n++];
  if (s === void 0) return;
  let a = s[i];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        (a = s[i]),
          a !== void 0 && (e.push(s.time), t.push.apply(t, a)),
          (s = r[n++]);
      while (s !== void 0);
    else if (a.toArray !== void 0)
      do
        (a = s[i]),
          a !== void 0 && (e.push(s.time), a.toArray(t, t.length)),
          (s = r[n++]);
      while (s !== void 0);
    else
      do (a = s[i]), a !== void 0 && (e.push(s.time), t.push(a)), (s = r[n++]);
      while (s !== void 0);
}
class uu {
  constructor(e, t, i, n) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = n !== void 0 ? n : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex,
      n = t[i],
      s = t[i - 1];
    i: {
      e: {
        let a;
        t: {
          n: if (!(e < n)) {
            for (let o = i + 2; ; ) {
              if (n === void 0) {
                if (e < s) break n;
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
              }
              if (i === o) break;
              if (((s = n), (n = t[++i]), e < n)) break e;
            }
            a = t.length;
            break t;
          }
          if (!(e >= s)) {
            const o = t[1];
            e < o && ((i = 2), (s = o));
            for (let u = i - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (i === u) break;
              if (((n = s), (s = t[--i - 1]), e >= s)) break e;
            }
            (a = i), (i = 0);
            break t;
          }
          break i;
        }
        for (; i < a; ) {
          const o = (i + a) >>> 1;
          e < t[o] ? (a = o) : (i = o + 1);
        }
        if (((n = t[i]), (s = t[i - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (n === void 0)
          return (
            (i = t.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          );
      }
      (this._cachedIndex = i), this.intervalChanged_(i, s, n);
    }
    return this.interpolate_(i, s, e, n);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      n = this.valueSize,
      s = e * n;
    for (let a = 0; a !== n; ++a) t[a] = i[s + a];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class aD extends uu {
  constructor(e, t, i, n) {
    super(e, t, i, n),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: D0, endingEnd: D0 });
  }
  intervalChanged_(e, t, i) {
    const n = this.parameterPositions;
    let s = e - 2,
      a = e + 1,
      o = n[s],
      u = n[a];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case P0:
          (s = e), (o = 2 * t - i);
          break;
        case A0:
          (s = n.length - 2), (o = t + n[s] - n[s + 1]);
          break;
        default:
          (s = e), (o = i);
      }
    if (u === void 0)
      switch (this.getSettings_().endingEnd) {
        case P0:
          (a = e), (u = 2 * i - t);
          break;
        case A0:
          (a = 1), (u = i + n[1] - n[0]);
          break;
        default:
          (a = e - 1), (u = t);
      }
    const h = (i - t) * 0.5,
      f = this.valueSize;
    (this._weightPrev = h / (t - o)),
      (this._weightNext = h / (u - i)),
      (this._offsetPrev = s * f),
      (this._offsetNext = a * f);
  }
  interpolate_(e, t, i, n) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      u = e * o,
      h = u - o,
      f = this._offsetPrev,
      c = this._offsetNext,
      d = this._weightPrev,
      m = this._weightNext,
      x = (i - t) / (n - t),
      v = x * x,
      b = v * x,
      y = -d * b + 2 * d * v - d * x,
      M = (1 + d) * b + (-1.5 - 2 * d) * v + (-0.5 + d) * x + 1,
      D = (-1 - m) * b + (1.5 + m) * v + 0.5 * x,
      C = m * b - m * v;
    for (let A = 0; A !== o; ++A)
      s[A] = y * a[f + A] + M * a[h + A] + D * a[u + A] + C * a[c + A];
    return s;
  }
}
class lD extends uu {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e, t, i, n) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      u = e * o,
      h = u - o,
      f = (i - t) / (n - t),
      c = 1 - f;
    for (let d = 0; d !== o; ++d) s[d] = a[h + d] * c + a[u + d] * f;
    return s;
  }
}
class cD extends uu {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Us {
  constructor(e, t, i, n) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = uh(t, this.TimeBufferType)),
      (this.values = uh(i, this.ValueBufferType)),
      this.setInterpolation(n || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: uh(e.times, Array),
        values: uh(e.values, Array),
      };
      const n = e.getInterpolation();
      n !== e.DefaultInterpolation && (i.interpolation = n);
    }
    return (i.type = e.ValueTypeName), i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new cD(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new lD(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new aD(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case zc:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case ul:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case fp:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return zc;
      case this.InterpolantFactoryMethodLinear:
        return ul;
      case this.InterpolantFactoryMethodSmooth:
        return fp;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, n = t.length; i !== n; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, n = t.length; i !== n; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times,
      n = i.length;
    let s = 0,
      a = n - 1;
    for (; s !== n && i[s] < e; ) ++s;
    for (; a !== -1 && i[a] > t; ) --a;
    if ((++a, s !== 0 || a !== n)) {
      s >= a && ((a = Math.max(a, 1)), (s = a - 1));
      const o = this.getValueSize();
      (this.times = Or(i, s, a)), (this.values = Or(this.values, s * o, a * o));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const i = this.times,
      n = this.values,
      s = i.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let a = null;
    for (let o = 0; o !== s; o++) {
      const u = i[o];
      if (typeof u == "number" && isNaN(u)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          o,
          u
        ),
          (e = !1);
        break;
      }
      if (a !== null && a > u) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, u, a),
          (e = !1);
        break;
      }
      a = u;
    }
    if (n !== void 0 && Eb(n))
      for (let o = 0, u = n.length; o !== u; ++o) {
        const h = n[o];
        if (isNaN(h)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            o,
            h
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = Or(this.times),
      t = Or(this.values),
      i = this.getValueSize(),
      n = this.getInterpolation() === fp,
      s = e.length - 1;
    let a = 1;
    for (let o = 1; o < s; ++o) {
      let u = !1;
      const h = e[o],
        f = e[o + 1];
      if (h !== f && (o !== 1 || h !== e[0]))
        if (n) u = !0;
        else {
          const c = o * i,
            d = c - i,
            m = c + i;
          for (let x = 0; x !== i; ++x) {
            const v = t[c + x];
            if (v !== t[d + x] || v !== t[m + x]) {
              u = !0;
              break;
            }
          }
        }
      if (u) {
        if (o !== a) {
          e[a] = e[o];
          const c = o * i,
            d = a * i;
          for (let m = 0; m !== i; ++m) t[d + m] = t[c + m];
        }
        ++a;
      }
    }
    if (s > 0) {
      e[a] = e[s];
      for (let o = s * i, u = a * i, h = 0; h !== i; ++h) t[u + h] = t[o + h];
      ++a;
    }
    return (
      a !== e.length
        ? ((this.times = Or(e, 0, a)), (this.values = Or(t, 0, a * i)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = Or(this.times, 0),
      t = Or(this.values, 0),
      i = this.constructor,
      n = new i(this.name, e, t);
    return (n.createInterpolant = this.createInterpolant), n;
  }
}
Us.prototype.TimeBufferType = Float32Array;
Us.prototype.ValueBufferType = Float32Array;
Us.prototype.DefaultInterpolation = ul;
class Pl extends Us {}
Pl.prototype.ValueTypeName = "bool";
Pl.prototype.ValueBufferType = Array;
Pl.prototype.DefaultInterpolation = zc;
Pl.prototype.InterpolantFactoryMethodLinear = void 0;
Pl.prototype.InterpolantFactoryMethodSmooth = void 0;
class Db extends Us {}
Db.prototype.ValueTypeName = "color";
class Wc extends Us {}
Wc.prototype.ValueTypeName = "number";
class uD extends uu {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e, t, i, n) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      u = (i - t) / (n - t);
    let h = e * o;
    for (let f = h + o; h !== f; h += 4) ws.slerpFlat(s, 0, a, h - o, a, h, u);
    return s;
  }
}
class Jo extends Us {
  InterpolantFactoryMethodLinear(e) {
    return new uD(this.times, this.values, this.getValueSize(), e);
  }
}
Jo.prototype.ValueTypeName = "quaternion";
Jo.prototype.DefaultInterpolation = ul;
Jo.prototype.InterpolantFactoryMethodSmooth = void 0;
class Al extends Us {}
Al.prototype.ValueTypeName = "string";
Al.prototype.ValueBufferType = Array;
Al.prototype.DefaultInterpolation = zc;
Al.prototype.InterpolantFactoryMethodLinear = void 0;
Al.prototype.InterpolantFactoryMethodSmooth = void 0;
class jc extends Us {}
jc.prototype.ValueTypeName = "vector";
class hD {
  constructor(e, t = -1, i, n = ES) {
    (this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = n),
      (this.uuid = bs()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      n = 1 / (e.fps || 1);
    for (let a = 0, o = i.length; a !== o; ++a) t.push(pD(i[a]).scale(n));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      n = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, a = i.length; s !== a; ++s) t.push(Us.toJSON(i[s]));
    return n;
  }
  static CreateFromMorphTargetSequence(e, t, i, n) {
    const s = t.length,
      a = [];
    for (let o = 0; o < s; o++) {
      let u = [],
        h = [];
      u.push((o + s - 1) % s, o, (o + 1) % s), h.push(0, 1, 0);
      const f = oD(u);
      (u = Cv(u, 1, f)),
        (h = Cv(h, 1, f)),
        !n && u[0] === 0 && (u.push(s), h.push(h[0])),
        a.push(
          new Wc(".morphTargetInfluences[" + t[o].name + "]", u, h).scale(1 / i)
        );
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const n = e;
      i = (n.geometry && n.geometry.animations) || n.animations;
    }
    for (let n = 0; n < i.length; n++) if (i[n].name === t) return i[n];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const n = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, u = e.length; o < u; o++) {
      const h = e[o],
        f = h.name.match(s);
      if (f && f.length > 1) {
        const c = f[1];
        let d = n[c];
        d || (n[c] = d = []), d.push(h);
      }
    }
    const a = [];
    for (const o in n)
      a.push(this.CreateFromMorphTargetSequence(o, n[o], t, i));
    return a;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const i = function (c, d, m, x, v) {
        if (m.length !== 0) {
          const b = [],
            y = [];
          Cb(m, b, y, x), b.length !== 0 && v.push(new c(d, b, y));
        }
      },
      n = [],
      s = e.name || "default",
      a = e.fps || 30,
      o = e.blendMode;
    let u = e.length || -1;
    const h = e.hierarchy || [];
    for (let c = 0; c < h.length; c++) {
      const d = h[c].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const m = {};
          let x;
          for (x = 0; x < d.length; x++)
            if (d[x].morphTargets)
              for (let v = 0; v < d[x].morphTargets.length; v++)
                m[d[x].morphTargets[v]] = -1;
          for (const v in m) {
            const b = [],
              y = [];
            for (let M = 0; M !== d[x].morphTargets.length; ++M) {
              const D = d[x];
              b.push(D.time), y.push(D.morphTarget === v ? 1 : 0);
            }
            n.push(new Wc(".morphTargetInfluence[" + v + "]", b, y));
          }
          u = m.length * a;
        } else {
          const m = ".bones[" + t[c].name + "]";
          i(jc, m + ".position", d, "pos", n),
            i(Jo, m + ".quaternion", d, "rot", n),
            i(jc, m + ".scale", d, "scl", n);
        }
    }
    return n.length === 0 ? null : new this(s, u, n, o);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, n = e.length; i !== n; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function dD(r) {
  switch (r.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Wc;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return jc;
    case "color":
      return Db;
    case "quaternion":
      return Jo;
    case "bool":
    case "boolean":
      return Pl;
    case "string":
      return Al;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r);
}
function pD(r) {
  if (r.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = dD(r.type);
  if (r.times === void 0) {
    const t = [],
      i = [];
    Cb(r.keys, t, i, "value"), (r.times = t), (r.values = i);
  }
  return e.parse !== void 0
    ? e.parse(r)
    : new e(r.name, r.times, r.values, r.interpolation);
}
const dl = {
  enabled: !1,
  files: {},
  add: function (r, e) {
    this.enabled !== !1 && (this.files[r] = e);
  },
  get: function (r) {
    if (this.enabled !== !1) return this.files[r];
  },
  remove: function (r) {
    delete this.files[r];
  },
  clear: function () {
    this.files = {};
  },
};
class fD {
  constructor(e, t, i) {
    const n = this;
    let s = !1,
      a = 0,
      o = 0,
      u;
    const h = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (f) {
        o++, s === !1 && n.onStart !== void 0 && n.onStart(f, a, o), (s = !0);
      }),
      (this.itemEnd = function (f) {
        a++,
          n.onProgress !== void 0 && n.onProgress(f, a, o),
          a === o && ((s = !1), n.onLoad !== void 0 && n.onLoad());
      }),
      (this.itemError = function (f) {
        n.onError !== void 0 && n.onError(f);
      }),
      (this.resolveURL = function (f) {
        return u ? u(f) : f;
      }),
      (this.setURLModifier = function (f) {
        return (u = f), this;
      }),
      (this.addHandler = function (f, c) {
        return h.push(f, c), this;
      }),
      (this.removeHandler = function (f) {
        const c = h.indexOf(f);
        return c !== -1 && h.splice(c, 2), this;
      }),
      (this.getHandler = function (f) {
        for (let c = 0, d = h.length; c < d; c += 2) {
          const m = h[c],
            x = h[c + 1];
          if ((m.global && (m.lastIndex = 0), m.test(f))) return x;
        }
        return null;
      });
  }
}
const mD = new fD();
class hu {
  constructor(e) {
    (this.manager = e !== void 0 ? e : mD),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const i = this;
    return new Promise(function (n, s) {
      i.load(e, n, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
const tr = {};
class gD extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class Pb extends hu {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = dl.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (tr[e] !== void 0) {
      tr[e].push({ onLoad: t, onProgress: i, onError: n });
      return;
    }
    (tr[e] = []), tr[e].push({ onLoad: t, onProgress: i, onError: n });
    const a = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      o = this.mimeType,
      u = this.responseType;
    fetch(a)
      .then((h) => {
        if (h.status === 200 || h.status === 0) {
          if (
            (h.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              h.body === void 0 ||
              h.body.getReader === void 0)
          )
            return h;
          const f = tr[e],
            c = h.body.getReader(),
            d = h.headers.get("Content-Length") || h.headers.get("X-File-Size"),
            m = d ? parseInt(d) : 0,
            x = m !== 0;
          let v = 0;
          const b = new ReadableStream({
            start(y) {
              M();
              function M() {
                c.read().then(({ done: D, value: C }) => {
                  if (D) y.close();
                  else {
                    v += C.byteLength;
                    const A = new ProgressEvent("progress", {
                      lengthComputable: x,
                      loaded: v,
                      total: m,
                    });
                    for (let I = 0, F = f.length; I < F; I++) {
                      const P = f[I];
                      P.onProgress && P.onProgress(A);
                    }
                    y.enqueue(C), M();
                  }
                });
              }
            },
          });
          return new Response(b);
        } else
          throw new gD(
            `fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`,
            h
          );
      })
      .then((h) => {
        switch (u) {
          case "arraybuffer":
            return h.arrayBuffer();
          case "blob":
            return h.blob();
          case "document":
            return h.text().then((f) => new DOMParser().parseFromString(f, o));
          case "json":
            return h.json();
          default:
            if (o === void 0) return h.text();
            {
              const c = /charset="?([^;"\s]*)"?/i.exec(o),
                d = c && c[1] ? c[1].toLowerCase() : void 0,
                m = new TextDecoder(d);
              return h.arrayBuffer().then((x) => m.decode(x));
            }
        }
      })
      .then((h) => {
        dl.add(e, h);
        const f = tr[e];
        delete tr[e];
        for (let c = 0, d = f.length; c < d; c++) {
          const m = f[c];
          m.onLoad && m.onLoad(h);
        }
      })
      .catch((h) => {
        const f = tr[e];
        if (f === void 0) throw (this.manager.itemError(e), h);
        delete tr[e];
        for (let c = 0, d = f.length; c < d; c++) {
          const m = f[c];
          m.onError && m.onError(h);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class vD extends hu {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      a = dl.get(e);
    if (a !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(a), s.manager.itemEnd(e);
        }, 0),
        a
      );
    const o = Hc("img");
    function u() {
      f(), dl.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function h(c) {
      f(), n && n(c), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function f() {
      o.removeEventListener("load", u, !1),
        o.removeEventListener("error", h, !1);
    }
    return (
      o.addEventListener("load", u, !1),
      o.addEventListener("error", h, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (o.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (o.src = e),
      o
    );
  }
}
class Ab extends hu {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const s = new xi(),
      a = new vD(this.manager);
    return (
      a.setCrossOrigin(this.crossOrigin),
      a.setPath(this.path),
      a.load(
        e,
        function (o) {
          (s.image = o), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        i,
        n
      ),
      s
    );
  }
}
class fd extends ei {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new ct(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
const Wp = new At(),
  Dv = new Z(),
  Pv = new Z();
class Pm {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Ue(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new At()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new wm()),
      (this._frameExtents = new Ue(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Kt(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix;
    Dv.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(Dv),
      Pv.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(Pv),
      t.updateMatrixWorld(),
      Wp.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Wp),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(Wp);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class _D extends Pm {
  constructor() {
    super(new Gi(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      i = Gc * 2 * e.angle * this.focus,
      n = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    (i !== t.fov || n !== t.aspect || s !== t.far) &&
      ((t.fov = i), (t.aspect = n), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class Lb extends fd {
  constructor(e, t, i = 0, n = Math.PI / 3, s = 0, a = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(ei.DefaultUp),
      this.updateMatrix(),
      (this.target = new ei()),
      (this.distance = i),
      (this.angle = n),
      (this.penumbra = s),
      (this.decay = a),
      (this.map = null),
      (this.shadow = new _D());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const Av = new At(),
  ac = new Z(),
  jp = new Z();
class bD extends Pm {
  constructor() {
    super(new Gi(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Ue(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Kt(2, 1, 1, 1),
        new Kt(0, 1, 1, 1),
        new Kt(3, 1, 1, 1),
        new Kt(1, 1, 1, 1),
        new Kt(3, 0, 1, 1),
        new Kt(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new Z(1, 0, 0),
        new Z(-1, 0, 0),
        new Z(0, 0, 1),
        new Z(0, 0, -1),
        new Z(0, 1, 0),
        new Z(0, -1, 0),
      ]),
      (this._cubeUps = [
        new Z(0, 1, 0),
        new Z(0, 1, 0),
        new Z(0, 1, 0),
        new Z(0, 1, 0),
        new Z(0, 0, 1),
        new Z(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      n = this.matrix,
      s = e.distance || i.far;
    s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      ac.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(ac),
      jp.copy(i.position),
      jp.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(jp),
      i.updateMatrixWorld(),
      n.makeTranslation(-ac.x, -ac.y, -ac.z),
      Av.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Av);
  }
}
class xD extends fd {
  constructor(e, t, i = 0, n = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = i),
      (this.decay = n),
      (this.shadow = new bD());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class wD extends Pm {
  constructor() {
    super(new ym(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class Rb extends fd {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(ei.DefaultUp),
      this.updateMatrix(),
      (this.target = new ei()),
      (this.shadow = new wD());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class yD extends fd {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class Uo {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, n = e.length; i < n; i++) t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class SD extends cn {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class MD extends hu {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, i, n) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      a = dl.get(e);
    if (a !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(a), s.manager.itemEnd(e);
        }, 0),
        a
      );
    const o = {};
    (o.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (o.headers = this.requestHeader),
      fetch(e, o)
        .then(function (u) {
          return u.blob();
        })
        .then(function (u) {
          return createImageBitmap(
            u,
            Object.assign(s.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (u) {
          dl.add(e, u), t && t(u), s.manager.itemEnd(e);
        })
        .catch(function (u) {
          n && n(u), s.manager.itemError(e), s.manager.itemEnd(e);
        }),
      s.manager.itemStart(e);
  }
}
class TD {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = Lv()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = Lv();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function Lv() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Am = "\\[\\]\\.:\\/",
  ED = new RegExp("[" + Am + "]", "g"),
  Lm = "[^" + Am + "]",
  CD = "[^" + Am.replace("\\.", "") + "]",
  DD = /((?:WC+[\/:])*)/.source.replace("WC", Lm),
  PD = /(WCOD+)?/.source.replace("WCOD", CD),
  AD = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Lm),
  LD = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Lm),
  RD = new RegExp("^" + DD + PD + AD + LD + "$"),
  kD = ["material", "materials", "bones", "map"];
class ID {
  constructor(e, t, i) {
    const n = i || Wt.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, n));
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_,
      n = this._bindings[i];
    n !== void 0 && n.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, s = i.length; n !== s; ++n)
      i[n].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class Wt {
  constructor(e, t, i) {
    (this.path = t),
      (this.parsedPath = i || Wt.parseTrackName(t)),
      (this.node = Wt.findNode(e, this.parsedPath.nodeName) || e),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new Wt.Composite(e, t, i)
      : new Wt(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(ED, "");
  }
  static parseTrackName(e) {
    const t = RD.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      n = i.nodeName && i.nodeName.lastIndexOf(".");
    if (n !== void 0 && n !== -1) {
      const s = i.nodeName.substring(n + 1);
      kD.indexOf(s) !== -1 &&
        ((i.nodeName = i.nodeName.substring(0, n)), (i.objectName = s));
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return i;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0) return i;
    }
    if (e.children) {
      const i = function (s) {
          for (let a = 0; a < s.length; a++) {
            const o = s[a];
            if (o.name === t || o.uuid === t) return o;
            const u = i(o.children);
            if (u) return u;
          }
          return null;
        },
        n = i(e.children);
      if (n) return n;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, s = i.length; n !== s; ++n) e[t++] = i[n];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, s = i.length; n !== s; ++n) i[n] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, s = i.length; n !== s; ++n) i[n] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, s = i.length; n !== s; ++n) i[n] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      i = t.objectName,
      n = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e ||
        ((e = Wt.findNode(this.rootNode, t.nodeName) || this.rootNode),
        (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.error(
        "THREE.PropertyBinding: Trying to update node for track: " +
          this.path +
          " but it wasn't found."
      );
      return;
    }
    if (i) {
      let h = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let f = 0; f < e.length; f++)
            if (e[f].name === h) {
              h = f;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[i];
      }
      if (h !== void 0) {
        if (e[h] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[h];
      }
    }
    const a = e[n];
    if (a === void 0) {
      const h = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          h +
          "." +
          n +
          " but it wasn't found.",
        e
      );
      return;
    }
    let o = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (o = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (o = this.Versioning.MatrixWorldNeedsUpdate);
    let u = this.BindingType.Direct;
    if (s !== void 0) {
      if (n === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (u = this.BindingType.ArrayElement),
        (this.resolvedProperty = a),
        (this.propertyIndex = s);
    } else
      a.fromArray !== void 0 && a.toArray !== void 0
        ? ((u = this.BindingType.HasFromToArray), (this.resolvedProperty = a))
        : Array.isArray(a)
        ? ((u = this.BindingType.EntireArray), (this.resolvedProperty = a))
        : (this.propertyName = n);
    (this.getValue = this.GetterByBindingType[u]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[u][o]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
Wt.Composite = ID;
Wt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Wt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Wt.prototype.GetterByBindingType = [
  Wt.prototype._getValue_direct,
  Wt.prototype._getValue_array,
  Wt.prototype._getValue_arrayElement,
  Wt.prototype._getValue_toArray,
];
Wt.prototype.SetterByBindingTypeAndVersioning = [
  [
    Wt.prototype._setValue_direct,
    Wt.prototype._setValue_direct_setNeedsUpdate,
    Wt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Wt.prototype._setValue_array,
    Wt.prototype._setValue_array_setNeedsUpdate,
    Wt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Wt.prototype._setValue_arrayElement,
    Wt.prototype._setValue_arrayElement_setNeedsUpdate,
    Wt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Wt.prototype._setValue_fromArray,
    Wt.prototype._setValue_fromArray_setNeedsUpdate,
    Wt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class FD {
  constructor(e, t, i = 0, n = 1 / 0) {
    (this.ray = new cd(e, t)),
      (this.near = i),
      (this.far = n),
      (this.camera = null),
      (this.layers = new bm()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, i = []) {
    return Lf(e, this, i, t), i.sort(Rv), i;
  }
  intersectObjects(e, t = !0, i = []) {
    for (let n = 0, s = e.length; n < s; n++) Lf(e[n], this, i, t);
    return i.sort(Rv), i;
  }
}
function Rv(r, e) {
  return r.distance - e.distance;
}
function Lf(r, e, t, i) {
  if ((r.layers.test(e.layers) && r.raycast(e, t), i === !0)) {
    const n = r.children;
    for (let s = 0, a = n.length; s < a; s++) Lf(n[s], e, t, !0);
  }
}
class kv {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  set(e, t, i) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + i * i)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)),
          (this.phi = Math.acos(Li(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const hh = new Z(),
  ui = new xm();
class OD extends Sb {
  constructor(e) {
    const t = new cn(),
      i = new lu({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      n = [],
      s = [],
      a = {};
    o("n1", "n2"),
      o("n2", "n4"),
      o("n4", "n3"),
      o("n3", "n1"),
      o("f1", "f2"),
      o("f2", "f4"),
      o("f4", "f3"),
      o("f3", "f1"),
      o("n1", "f1"),
      o("n2", "f2"),
      o("n3", "f3"),
      o("n4", "f4"),
      o("p", "n1"),
      o("p", "n2"),
      o("p", "n3"),
      o("p", "n4"),
      o("u1", "u2"),
      o("u2", "u3"),
      o("u3", "u1"),
      o("c", "t"),
      o("p", "c"),
      o("cn1", "cn2"),
      o("cn3", "cn4"),
      o("cf1", "cf2"),
      o("cf3", "cf4");
    function o(x, v) {
      u(x), u(v);
    }
    function u(x) {
      n.push(0, 0, 0),
        s.push(0, 0, 0),
        a[x] === void 0 && (a[x] = []),
        a[x].push(n.length / 3 - 1);
    }
    t.setAttribute("position", new xn(n, 3)),
      t.setAttribute("color", new xn(s, 3)),
      super(t, i),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = a),
      this.update();
    const h = new ct(16755200),
      f = new ct(16711680),
      c = new ct(43775),
      d = new ct(16777215),
      m = new ct(3355443);
    this.setColors(h, f, c, d, m);
  }
  setColors(e, t, i, n, s) {
    const o = this.geometry.getAttribute("color");
    o.setXYZ(0, e.r, e.g, e.b),
      o.setXYZ(1, e.r, e.g, e.b),
      o.setXYZ(2, e.r, e.g, e.b),
      o.setXYZ(3, e.r, e.g, e.b),
      o.setXYZ(4, e.r, e.g, e.b),
      o.setXYZ(5, e.r, e.g, e.b),
      o.setXYZ(6, e.r, e.g, e.b),
      o.setXYZ(7, e.r, e.g, e.b),
      o.setXYZ(8, e.r, e.g, e.b),
      o.setXYZ(9, e.r, e.g, e.b),
      o.setXYZ(10, e.r, e.g, e.b),
      o.setXYZ(11, e.r, e.g, e.b),
      o.setXYZ(12, e.r, e.g, e.b),
      o.setXYZ(13, e.r, e.g, e.b),
      o.setXYZ(14, e.r, e.g, e.b),
      o.setXYZ(15, e.r, e.g, e.b),
      o.setXYZ(16, e.r, e.g, e.b),
      o.setXYZ(17, e.r, e.g, e.b),
      o.setXYZ(18, e.r, e.g, e.b),
      o.setXYZ(19, e.r, e.g, e.b),
      o.setXYZ(20, e.r, e.g, e.b),
      o.setXYZ(21, e.r, e.g, e.b),
      o.setXYZ(22, e.r, e.g, e.b),
      o.setXYZ(23, e.r, e.g, e.b),
      o.setXYZ(24, t.r, t.g, t.b),
      o.setXYZ(25, t.r, t.g, t.b),
      o.setXYZ(26, t.r, t.g, t.b),
      o.setXYZ(27, t.r, t.g, t.b),
      o.setXYZ(28, t.r, t.g, t.b),
      o.setXYZ(29, t.r, t.g, t.b),
      o.setXYZ(30, t.r, t.g, t.b),
      o.setXYZ(31, t.r, t.g, t.b),
      o.setXYZ(32, i.r, i.g, i.b),
      o.setXYZ(33, i.r, i.g, i.b),
      o.setXYZ(34, i.r, i.g, i.b),
      o.setXYZ(35, i.r, i.g, i.b),
      o.setXYZ(36, i.r, i.g, i.b),
      o.setXYZ(37, i.r, i.g, i.b),
      o.setXYZ(38, n.r, n.g, n.b),
      o.setXYZ(39, n.r, n.g, n.b),
      o.setXYZ(40, s.r, s.g, s.b),
      o.setXYZ(41, s.r, s.g, s.b),
      o.setXYZ(42, s.r, s.g, s.b),
      o.setXYZ(43, s.r, s.g, s.b),
      o.setXYZ(44, s.r, s.g, s.b),
      o.setXYZ(45, s.r, s.g, s.b),
      o.setXYZ(46, s.r, s.g, s.b),
      o.setXYZ(47, s.r, s.g, s.b),
      o.setXYZ(48, s.r, s.g, s.b),
      o.setXYZ(49, s.r, s.g, s.b),
      (o.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      i = 1,
      n = 1;
    ui.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      fi("c", t, e, ui, 0, 0, -1),
      fi("t", t, e, ui, 0, 0, 1),
      fi("n1", t, e, ui, -i, -n, -1),
      fi("n2", t, e, ui, i, -n, -1),
      fi("n3", t, e, ui, -i, n, -1),
      fi("n4", t, e, ui, i, n, -1),
      fi("f1", t, e, ui, -i, -n, 1),
      fi("f2", t, e, ui, i, -n, 1),
      fi("f3", t, e, ui, -i, n, 1),
      fi("f4", t, e, ui, i, n, 1),
      fi("u1", t, e, ui, i * 0.7, n * 1.1, -1),
      fi("u2", t, e, ui, -i * 0.7, n * 1.1, -1),
      fi("u3", t, e, ui, 0, n * 2, -1),
      fi("cf1", t, e, ui, -i, 0, 1),
      fi("cf2", t, e, ui, i, 0, 1),
      fi("cf3", t, e, ui, 0, -n, 1),
      fi("cf4", t, e, ui, 0, n, 1),
      fi("cn1", t, e, ui, -i, 0, -1),
      fi("cn2", t, e, ui, i, 0, -1),
      fi("cn3", t, e, ui, 0, -n, -1),
      fi("cn4", t, e, ui, 0, n, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function fi(r, e, t, i, n, s, a) {
  hh.set(n, s, a).unproject(i);
  const o = e[r];
  if (o !== void 0) {
    const u = t.getAttribute("position");
    for (let h = 0, f = o.length; h < f; h++) u.setXYZ(o[h], hh.x, hh.y, hh.z);
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: vm } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = vm));
const E = {
  html: document.documentElement,
  body: document.body,
  window: {
    w: window.innerWidth,
    h: window.innerHeight,
    dpr: window.devicePixelRatio,
  },
  keys: { UP: 38, DOWN: 40, ENTER: 13, ESC: 27, HOME: 36, END: 35 },
  isTouch: !1,
  isIOS:
    [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod",
    ].includes(navigator.platform) ||
    (navigator.userAgent.includes("Mac") && "ontouchend" in document),
  isAndroid: /(android)/i.test(navigator.userAgent),
  isDarkMode: !0,
  isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
  pointer: { x: 0, y: 0, isDragging: !1, gl: new Ue(), glNormalized: new Ue() },
  cookieNoticeAccepted: !1,
  staticComponents: null,
  components: null,
  ASS: null,
  Taxi: null,
  AssetLoader: null,
  RAFCollection: null,
  SmoothScroll: null,
  WebGL: null,
  urlParams: null,
  mq: {},
  pinType: "transform",
  isShyHeaderActive: !1,
  scrollToActive: !1,
  isHeaderHidden: !1,
};
function ln() {
  if (!(this instanceof ln)) return new ln();
  (this.size = 0),
    (this.uid = 0),
    (this.selectors = []),
    (this.selectorObjects = {}),
    (this.indexes = Object.create(this.indexes)),
    (this.activeIndexes = []);
}
var lc = window.document.documentElement,
  ND =
    lc.matches ||
    lc.webkitMatchesSelector ||
    lc.mozMatchesSelector ||
    lc.oMatchesSelector ||
    lc.msMatchesSelector;
ln.prototype.matchesSelector = function (r, e) {
  return ND.call(r, e);
};
ln.prototype.querySelectorAll = function (r, e) {
  return e.querySelectorAll(r);
};
ln.prototype.indexes = [];
var BD = /^#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
ln.prototype.indexes.push({
  name: "ID",
  selector: function (e) {
    var t;
    if ((t = e.match(BD))) return t[0].slice(1);
  },
  element: function (e) {
    if (e.id) return [e.id];
  },
});
var VD = /^\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
ln.prototype.indexes.push({
  name: "CLASS",
  selector: function (e) {
    var t;
    if ((t = e.match(VD))) return t[0].slice(1);
  },
  element: function (e) {
    var t = e.className;
    if (t) {
      if (typeof t == "string") return t.split(/\s/);
      if (typeof t == "object" && "baseVal" in t) return t.baseVal.split(/\s/);
    }
  },
});
var zD = /^((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
ln.prototype.indexes.push({
  name: "TAG",
  selector: function (e) {
    var t;
    if ((t = e.match(zD))) return t[0].toUpperCase();
  },
  element: function (e) {
    return [e.nodeName.toUpperCase()];
  },
});
ln.prototype.indexes.default = {
  name: "UNIVERSAL",
  selector: function () {
    return !0;
  },
  element: function () {
    return [!0];
  },
};
var Rf;
typeof window.Map == "function"
  ? (Rf = window.Map)
  : (Rf = (function () {
      function r() {
        this.map = {};
      }
      return (
        (r.prototype.get = function (e) {
          return this.map[e + " "];
        }),
        (r.prototype.set = function (e, t) {
          this.map[e + " "] = t;
        }),
        r
      );
    })());
var Iv =
  /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g;
function kb(r, e) {
  r = r.slice(0).concat(r.default);
  var t = r.length,
    i,
    n,
    s,
    a,
    o = e,
    u,
    h,
    f = [];
  do
    if ((Iv.exec(""), (s = Iv.exec(o)) && ((o = s[3]), s[2] || !o))) {
      for (i = 0; i < t; i++)
        if (((h = r[i]), (u = h.selector(s[1])))) {
          for (n = f.length, a = !1; n--; )
            if (f[n].index === h && f[n].key === u) {
              a = !0;
              break;
            }
          a || f.push({ index: h, key: u });
          break;
        }
    }
  while (s);
  return f;
}
function UD(r, e) {
  var t, i, n;
  for (t = 0, i = r.length; t < i; t++)
    if (((n = r[t]), e.isPrototypeOf(n))) return n;
}
ln.prototype.logDefaultIndexUsed = function () {};
ln.prototype.add = function (r, e) {
  var t,
    i,
    n,
    s,
    a,
    o,
    u,
    h,
    f = this.activeIndexes,
    c = this.selectors,
    d = this.selectorObjects;
  if (typeof r == "string") {
    for (
      t = { id: this.uid++, selector: r, data: e },
        d[t.id] = t,
        u = kb(this.indexes, r),
        i = 0;
      i < u.length;
      i++
    )
      (h = u[i]),
        (s = h.key),
        (n = h.index),
        (a = UD(f, n)),
        a || ((a = Object.create(n)), (a.map = new Rf()), f.push(a)),
        n === this.indexes.default && this.logDefaultIndexUsed(t),
        (o = a.map.get(s)),
        o || ((o = []), a.map.set(s, o)),
        o.push(t);
    this.size++, c.push(r);
  }
};
ln.prototype.remove = function (r, e) {
  if (typeof r == "string") {
    var t,
      i,
      n,
      s,
      a,
      o,
      u,
      h,
      f = this.activeIndexes,
      c = (this.selectors = []),
      d = this.selectorObjects,
      m = {},
      x = arguments.length === 1;
    for (t = kb(this.indexes, r), n = 0; n < t.length; n++)
      for (i = t[n], s = f.length; s--; )
        if (((o = f[s]), i.index.isPrototypeOf(o))) {
          if (((u = o.map.get(i.key)), u))
            for (a = u.length; a--; )
              (h = u[a]),
                h.selector === r &&
                  (x || h.data === e) &&
                  (u.splice(a, 1), (m[h.id] = !0));
          break;
        }
    for (n in m) delete d[n], this.size--;
    for (n in d) c.push(d[n].selector);
  }
};
function Ib(r, e) {
  return r.id - e.id;
}
ln.prototype.queryAll = function (r) {
  if (!this.selectors.length) return [];
  var e = {},
    t = [],
    i = this.querySelectorAll(this.selectors.join(", "), r),
    n,
    s,
    a,
    o,
    u,
    h,
    f,
    c;
  for (n = 0, a = i.length; n < a; n++)
    for (u = i[n], h = this.matches(u), s = 0, o = h.length; s < o; s++)
      (c = h[s]),
        e[c.id]
          ? (f = e[c.id])
          : ((f = {
              id: c.id,
              selector: c.selector,
              data: c.data,
              elements: [],
            }),
            (e[c.id] = f),
            t.push(f)),
        f.elements.push(u);
  return t.sort(Ib);
};
ln.prototype.matches = function (r) {
  if (!r) return [];
  var e,
    t,
    i,
    n,
    s,
    a,
    o,
    u,
    h,
    f,
    c,
    d = this.activeIndexes,
    m = {},
    x = [];
  for (e = 0, n = d.length; e < n; e++)
    if (((o = d[e]), (u = o.element(r)), u)) {
      for (t = 0, s = u.length; t < s; t++)
        if ((h = o.map.get(u[t])))
          for (i = 0, a = h.length; i < a; i++)
            (f = h[i]),
              (c = f.id),
              !m[c] &&
                this.matchesSelector(r, f.selector) &&
                ((m[c] = !0), x.push(f));
    }
  return x.sort(Ib);
};
const Ha = {},
  vs = {},
  kf = [
    "mouseenter",
    "mouseleave",
    "pointerenter",
    "pointerleave",
    "blur",
    "focus",
  ];
function Fv(r) {
  vs[r] === void 0 && (vs[r] = []);
}
function GD(r, e) {
  if (vs[r]) for (let t = 0; t < vs[r].length; t++) vs[r][t](...e);
}
function Ov(r) {
  return typeof r == "string" ? document.querySelectorAll(r) : r;
}
function dh(r) {
  let e = HD(Ha[r.type], r.target);
  if (e.length)
    for (let t = 0; t < e.length; t++)
      for (let i = 0; i < e[t].stack.length; i++)
        kf.indexOf(r.type) !== -1
          ? (Nv(r, e[t].delegatedTarget),
            r.target === e[t].delegatedTarget && e[t].stack[i].data(r))
          : (Nv(r, e[t].delegatedTarget), e[t].stack[i].data(r));
}
function HD(r, e) {
  const t = [];
  let i = e;
  do {
    if (i.nodeType !== 1) break;
    const n = r.matches(i);
    n.length && t.push({ delegatedTarget: i, stack: n });
  } while ((i = i.parentElement));
  return t;
}
function Nv(r, e) {
  Object.defineProperty(r, "currentTarget", {
    configurable: !0,
    enumerable: !0,
    get: () => e,
  });
}
function WD(r) {
  const e = {};
  for (const t in r) e[t] = [...r[t]];
  return e;
}
class jD {
  bindAll(e, t) {
    t || (t = Object.getOwnPropertyNames(Object.getPrototypeOf(e)));
    for (let i = 0; i < t.length; i++) e[t[i]] = e[t[i]].bind(e);
  }
  on(e, t, i, n) {
    const s = e.split(" ");
    for (let a = 0; a < s.length; a++) {
      if (typeof t == "function" && i === void 0) {
        Fv(s[a]), vs[s[a]].push(t);
        continue;
      }
      if ((t.nodeType && t.nodeType === 1) || t === window || t === document) {
        t.addEventListener(s[a], i, n);
        continue;
      }
      t = Ov(t);
      for (let o = 0; o < t.length; o++) t[o].addEventListener(s[a], i, n);
    }
  }
  delegate(e, t, i) {
    const n = e.split(" ");
    for (let s = 0; s < n.length; s++) {
      let a = Ha[n[s]];
      a === void 0 &&
        ((a = new ln()),
        (Ha[n[s]] = a),
        kf.indexOf(n[s]) !== -1
          ? document.addEventListener(n[s], dh, !0)
          : document.addEventListener(n[s], dh)),
        a.add(t, i);
    }
  }
  off(e, t, i, n) {
    const s = e.split(" ");
    for (let a = 0; a < s.length; a++) {
      if (t === void 0) {
        vs[s[a]] = [];
        continue;
      }
      if (typeof t == "function") {
        Fv(s[a]);
        for (let u = 0; u < vs[s[a]].length; u++)
          vs[s[a]][u] === t && vs[s[a]].splice(u, 1);
        continue;
      }
      const o = Ha[s[a]];
      if (o !== void 0 && (o.remove(t, i), o.size === 0)) {
        delete Ha[s[a]],
          kf.indexOf(s[a]) !== -1
            ? document.removeEventListener(s[a], dh, !0)
            : document.removeEventListener(s[a], dh);
        continue;
      }
      if (t.removeEventListener !== void 0) {
        t.removeEventListener(s[a], i, n);
        continue;
      }
      t = Ov(t);
      for (let u = 0; u < t.length; u++) t[u].removeEventListener(s[a], i, n);
    }
  }
  emit(e, ...t) {
    GD(e, t);
  }
  debugDelegated() {
    return JSON.parse(JSON.stringify(Ha));
  }
  debugBus() {
    return WD(vs);
  }
  hasBus(e) {
    return this.debugBus().hasOwnProperty(e);
  }
}
const De = new jD(),
  qe = class qe {
    static enablePointerEvents() {
      typeof qe.enabled.pointerEvents > "u" &&
        ((qe.enabled.pointerEvents = !0),
        De.on(
          "mousemove touchmove",
          window,
          MA((e) => qe.handleMousemove(e), 16),
          { passive: !0 }
        ),
        De.on("mousedown touchstart", window, qe.handleMousedown),
        De.on("mouseup touchend", window, qe.handleMouseup));
    }
    static enableResize(e = !1) {
      (this.newHeight = E.window.h),
        (this.newWidth = E.window.w),
        typeof qe.enabled.resize > "u" &&
          ((qe.enabled.resize = !0),
          (this.isFullscreen =
            window.outerWidth === window.screen.availWidth &&
            window.outerHeight === window.screen.availHeight),
          e
            ? De.on(
                "resize",
                window,
                SA((t) => qe.handleResize(t), e)
              )
            : De.on("resize", window, qe.handleResize));
    }
    static enableRAF(e = null) {
      typeof qe.enabled.raf > "u" &&
        ((qe.enabled.raf = !0),
        (E.RAFCollection = new T3()),
        e
          ? ((qe.currentRafId = null), e.ticker.add(qe.handleRaf))
          : (qe.currentRafId = window.requestAnimationFrame(qe.handleRaf)));
    }
    static enableDrag() {
      typeof qe.enabled.drag > "u" && (qe.enabled.drag = !0);
    }
    static handleMousemove(e) {
      if (
        ((E.pointer.x = e.changedTouches
          ? e.changedTouches[0].clientX
          : e.clientX),
        (E.pointer.y = e.changedTouches
          ? e.changedTouches[0].clientY
          : e.clientY),
        E.pointer.gl.set(
          E.pointer.x - E.window.w / 2,
          -E.pointer.y + E.window.h / 2
        ),
        E.pointer.glNormalized.set(
          (E.pointer.x / E.window.w) * 2 - 1,
          -(E.pointer.y / E.window.h) * 2 + 1
        ),
        e.changedTouches ? De.emit(qe.TOUCHMOVE, e) : De.emit(qe.MOUSEMOVE, e),
        E.pointer.isDragging)
      ) {
        const t = {
          deltaX: E.pointer.x - qe.dragInfo.px,
          deltaY: E.pointer.y - qe.dragInfo.py,
          startX: qe.dragInfo.x,
          startY: qe.dragInfo.y,
          totalX: E.pointer.x - qe.dragInfo.x,
          totalY: E.pointer.y - qe.dragInfo.y,
        };
        De.emit(e.changedTouches ? qe.TOUCHDRAG : qe.MOUSEDRAG, e, t),
          (qe.dragInfo.px = E.pointer.x),
          (qe.dragInfo.py = E.pointer.y);
      }
    }
    static handleMousedown(e) {
      if (e.type === "touchstart") this.stopMouseDown = !0;
      else {
        if (this.stopMouseDown) {
          this.stopMouseDown = !1;
          return;
        }
        this.stopMouseDown = !1;
      }
      qe.handleMousemove(e),
        qe.enabled.drag &&
          ((E.pointer.isDragging = !0),
          (qe.dragInfo.x = qe.dragInfo.px = E.pointer.x),
          (qe.dragInfo.y = qe.dragInfo.py = E.pointer.y)),
        De.emit(qe.POINTERDOWN, e);
    }
    static handleMouseup(e) {
      if (((E.pointer.isDragging = !1), e.type === "touchend"))
        this.stopMouseUp = !0;
      else {
        if (this.stopMouseUp) {
          this.stopMouseUp = !1;
          return;
        }
        this.stopMouseUp = !1;
      }
      (this.stopMouseDown = !1),
        qe.handleMousemove(e),
        (qe.dragInfo = { x: 0, y: 0, px: 0, py: 0 }),
        De.emit(qe.POINTERUP, e);
    }
    static handleResize(e) {
      (this.oldHeight = this.newHeight),
        (this.oldWidth = this.newWidth),
        (this.newHeight = window.innerHeight),
        (this.newWidth = window.innerWidth);
      const t = this.oldHeight - this.newHeight;
      (this.isFullscreen =
        window.outerWidth === window.screen.availWidth &&
        window.outerHeight === window.screen.availHeight),
        !(this.isFullscreen && E.window.w === window.innerWidth) &&
          ((E.isTouch && E.window.w === window.innerWidth) ||
            (t < 50 && t > -50 && this.oldWidth === this.newWidth) ||
            ((E.window.w = window.innerWidth),
            (E.window.h = window.innerHeight),
            document.documentElement.style.setProperty(
              "--vh",
              `${window.innerHeight * 0.01}px`
            ),
            (E.window.fullHeight =
              document.querySelector(".height-div").clientHeight),
            E.isIOS &&
              E.window.fullHeight === E.window.h &&
              (E.window.fullHeight *= 1.2),
            De.emit(qe.RESIZE, e)));
    }
    static handleRaf(e) {
      var t, i;
      (t = E.Gui) == null || t.perfBegin(),
        De.emit(qe.RAF, e),
        qe.currentRafId !== null &&
          (qe.currentRafId = window.requestAnimationFrame(qe.handleRaf)),
        (i = E.Gui) == null ||
          i.perfEnd(qe.currentRafId === null ? e * 1e3 : e);
    }
    static detectTouchDevice() {
      "ontouchstart" in document.documentElement &&
        ((E.isTouch = !0), E.html.classList.add("is-touch"));
    }
  };
q(qe, "MOUSEMOVE", "global:mousemove"),
  q(qe, "TOUCHMOVE", "global:touchmove"),
  q(qe, "MOUSEDRAG", "global:mousedrag"),
  q(qe, "TOUCHDRAG", "global:touchdrag"),
  q(qe, "POINTERMOVE", `${qe.MOUSEMOVE} ${qe.TOUCHMOVE}`),
  q(qe, "POINTERDRAG", `${qe.TOUCHDRAG} ${qe.MOUSEDRAG}`),
  q(qe, "POINTERDOWN", "global:pointerdown"),
  q(qe, "POINTERUP", "global:pointerup"),
  q(qe, "RAF", "global:raf"),
  q(qe, "RESIZE", "global:resize"),
  q(qe, "currentRafId", null),
  q(qe, "enabled", {}),
  q(qe, "dragInfo", { x: 0, y: 0, px: 0, py: 0 }),
  q(qe, "stopMouseDown", !1),
  q(qe, "stopMouseUp", !1),
  q(qe, "isFullscreen", !1);
let Ze = qe;
class qh {
  constructor(e) {
    q(this, "components", []);
    q(this, "args", []);
    q(this, "negationSelector", null);
    if (e.selector === void 0)
      throw new Error(
        `The component "${e.name}" does not implement the selector property, or it is not available statically`
      );
    (this.Component = e), (this.inited = !1);
  }
  init(e = document) {
    if (this.inited) return this;
    if (((this.inited = !0), this.Component.isSingleton)) {
      const i = at(this.Component.selector, e);
      return (
        i && (this.components = [new this.Component(i, ...this.args)]), this
      );
    }
    const t = od(this.Component.selector, e);
    this.components = [];
    for (let i = 0; i < t.length; i++)
      (this.negationSelector === null ||
        t[i].matches(this.negationSelector) === !1) &&
        this.components.push(new this.Component(t[i], ...this.args));
    return this;
  }
  with(...e) {
    return (this.args = [...e]), this;
  }
  not(e) {
    return (this.negationSelector = e), this;
  }
  make(e, ...t) {
    const i = new this.Component(e, ...t);
    return this.components.push(i), i;
  }
  get(e = null) {
    return e !== null ? this.components[e] || null : this.components;
  }
  first() {
    return this.get(0);
  }
  forEach(e) {
    for (let t = 0; t < this.components.length; t++) e(this.components[t]);
    return this;
  }
  callAll(e, ...t) {
    for (let i = 0; i < this.components.length; i++)
      this.components[i][e](...t);
    return this;
  }
  destroy() {
    return this.callAll("destroy"), this;
  }
  reInit() {
    this.destroy(), (this.inited = !1), this.init();
  }
  [Symbol.iterator]() {
    return this.components.values();
  }
}
class An {
  static init() {
    document.location.hash &&
      An.focus(
        document.getElementById(window.location.hash.replace("#", "")),
        !0
      ),
      De.on("hashchange", window, () => {
        An.focus(
          document.getElementById(window.location.hash.replace("#", "")),
          !0
        );
      });
  }
  static isFocusable(e) {
    return (
      Element.prototype.matches ||
        (Element.prototype.matches = Element.prototype.msMatchesSelector),
      e.matches(
        "input:not([disabled]), a, button, textarea, select, iframe, object, [tabindex]"
      )
    );
  }
  static focusTrapElement(e) {
    const t = e.parentNode,
      i = document.createElement("div");
    i.setAttribute("data-focus-trap", "pre"), i.setAttribute("tabindex", "0");
    const n = document.createElement("div");
    n.setAttribute("data-focus-trap", "post"),
      n.setAttribute("tabindex", "0"),
      De.on("focus", n, () => this.focusFirstChild(e)),
      De.on("focus", i, () => this.focusLastChild(e)),
      t.insertBefore(i, e),
      t.insertBefore(n, e.nextSibling);
  }
  static focusFirstChild(e) {
    for (let t = 0; t < e.children.length; t++) {
      const i = e.children[t];
      if (An.focus(i) || An.focusFirstChild(i)) return !0;
    }
    return !1;
  }
  static focusLastChild(e) {
    for (let t = e.children.length - 1; t >= 0; t--) {
      const i = e.children[t];
      if (An.focus(i) || An.focusLastChild(i)) return !0;
    }
    return !1;
  }
  static focus(e, t = !1) {
    if (e == null) return !1;
    t === !0 &&
      An.isFocusable(e) === !1 &&
      (e.setAttribute("tabindex", "-1"),
      De.on("blur", e, An.removeTabIndex),
      De.on("focusout", e, An.removeTabIndex));
    try {
      e.focus();
    } catch {}
    return document.activeElement === e;
  }
  static removeTabIndex() {
    this.removeAttribute("tabindex"),
      De.off("blur", this, An.removeTabIndex),
      De.off("focusout", this, An.removeTabIndex);
  }
}
class Bv {
  constructor() {
    q(this, "_store", {});
  }
  add(...e) {
    for (let t = 0; t < e.length; t++) {
      if (e[t].negationSelector !== void 0) {
        this._store[e[t].Component.name] = e[t].init();
        continue;
      }
      if (e[t].selector) {
        this._store[e[t].name] = new qh(e[t]).init();
        continue;
      }
      this._store[e[t].constructor.name || e[t].name] = e[t];
    }
  }
  get(e) {
    return typeof e == "string"
      ? this._store[e] ?? null
      : this._store[e.name] ?? null;
  }
  [Symbol.iterator]() {
    return Object.values(this._store).values();
  }
}
class qD {
  constructor(e = "AssetsProgress") {
    q(this, "progressCallback", (e) => {
      De.emit(this.progressEventName, { percent: Math.floor(e) });
    });
    q(this, "retry", async (e, t = 2) => {
      try {
        return await e();
      } catch (i) {
        if (t <= 0) throw i;
        return this.retry(e, t - 1);
      }
    });
    q(
      this,
      "loadJson",
      (e) => (
        this.jsons[e] ||
          (this.jsons[e] = this.add(
            new Promise((t, i) => {
              fetch(e, {
                headers: { "Content-Type": "application/json" },
              }).then((n) => {
                n.ok
                  ? t(n.json())
                  : i(
                      new Error("Network response was not ok for request", {
                        cause: { url: e, response: n },
                      })
                    );
              }, i);
            })
          )),
        this.jsons[e]
      )
    );
    (this.promisesToLoad = []),
      (this.fontsLoaded = !1),
      (this.loaded = !1),
      (this.progressEventName = e),
      (this.jsons = {});
  }
  load({ element: e = document.body, progress: t = !0 } = {}) {
    e && ((this.element = e), this.addFonts(), this.addMedia());
    let i = 0;
    if (t)
      for (let n = 0; n < this.promisesToLoad.length; n++)
        this.promisesToLoad[n]
          .then(() => {
            i++, this.progressCallback((i * 100) / this.promisesToLoad.length);
          })
          .catch((s) => {
            s instanceof Error
              ? console.error(s.message, s.cause)
              : console.error(s);
          });
    return (
      (this.loaded = new Promise((n) => {
        Promise.all(this.promisesToLoad)
          .then(() => {
            this.reset(), n();
          })
          .catch((s) => {
            s instanceof Error
              ? console.error(s.message, s.cause)
              : console.error(s);
          });
      })),
      this.loaded
    );
  }
  add(e) {
    return this.promisesToLoad.push(e), e;
  }
  addMedia() {
    const e = this.element.querySelectorAll('img:not([lazy="full"])');
    for (let i = 0; i < e.length; i++)
      (e[i].getAttribute("src") || e[i].dataset.src) && this.addImage(e[i]);
    const t = this.element.querySelectorAll("video");
    for (let i = 0; i < t.length; i++)
      (t[i].getAttribute("src") || t[i].dataset.src) && this.addVideo(t[i]);
  }
  addImage(e) {
    return this.add(
      new Promise((t, i) => {
        e.complete
          ? e.naturalWidth !== 0 || e.currentSrc.includes("svg")
            ? t(e)
            : i(
                new Error("Image not loaded: element has no dimensions", {
                  cause: e,
                })
              )
          : (e.addEventListener(
              "load",
              () => {
                t(e);
              },
              { once: !0 }
            ),
            e.addEventListener(
              "error",
              (n) => {
                i(new Error("Image not loaded", { cause: n }));
              },
              { once: !0 }
            ));
      })
    );
  }
  addVideo(e) {
    const t = new Promise((i, n) => {
      e.addEventListener(
        "canplaythrough",
        () => {
          e.addEventListener(
            "timeupdate",
            () => {
              e.pause(), (e.currentTime = 0.05), i(e);
            },
            { once: !0 }
          );
        },
        { once: !0 }
      ),
        e.addEventListener(
          "error",
          (s) => {
            n(new Error("Video not loaded", { cause: s }));
          },
          { once: !0 }
        ),
        E.isSafari &&
          e.addEventListener("suspend", () => {
            window.addEventListener(
              "click",
              () => {
                e.currentTime < 0.01 && (e.currentTime = 0.05);
              },
              { once: !0 }
            ),
              i();
          }),
        e.src === "" && e.dataset.src && (e.src = e.dataset.src),
        e.load(),
        e
          .play()
          .then(() => i)
          .catch(() => i);
    });
    return this.add(t);
  }
  addFonts() {
    document.fonts && this.add(document.fonts.ready),
      !this.fontsLoaded &&
        window.Typekit &&
        this.add(
          new Promise((e) => {
            window.Typekit.load({
              active: () => {
                (this.fontsLoaded = !0), e();
              },
            });
          })
        );
  }
  reset() {
    this.promisesToLoad = [];
  }
}
class XD extends hu {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new JD(t);
      }),
      this.register(function (t) {
        return new r3(t);
      }),
      this.register(function (t) {
        return new o3(t);
      }),
      this.register(function (t) {
        return new e3(t);
      }),
      this.register(function (t) {
        return new t3(t);
      }),
      this.register(function (t) {
        return new i3(t);
      }),
      this.register(function (t) {
        return new n3(t);
      }),
      this.register(function (t) {
        return new ZD(t);
      }),
      this.register(function (t) {
        return new s3(t);
      }),
      this.register(function (t) {
        return new QD(t);
      }),
      this.register(function (t) {
        return new YD(t);
      }),
      this.register(function (t) {
        return new a3(t);
      }),
      this.register(function (t) {
        return new l3(t);
      });
  }
  load(e, t, i, n) {
    const s = this;
    let a;
    this.resourcePath !== ""
      ? (a = this.resourcePath)
      : this.path !== ""
      ? (a = this.path)
      : (a = Uo.extractUrlBase(e)),
      this.manager.itemStart(e);
    const o = function (h) {
        n ? n(h) : console.error(h),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      u = new Pb(this.manager);
    u.setPath(this.path),
      u.setResponseType("arraybuffer"),
      u.setRequestHeader(this.requestHeader),
      u.setWithCredentials(this.withCredentials),
      u.load(
        e,
        function (h) {
          try {
            s.parse(
              h,
              a,
              function (f) {
                t(f), s.manager.itemEnd(e);
              },
              o
            );
          } catch (f) {
            o(f);
          }
        },
        i,
        o
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, i, n) {
    let s;
    const a = {},
      o = {};
    if (typeof e == "string") s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (Uo.decodeText(new Uint8Array(e, 0, 4)) === Fb) {
        try {
          a[Nt.KHR_BINARY_GLTF] = new c3(e);
        } catch (f) {
          n && n(f);
          return;
        }
        s = JSON.parse(a[Nt.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(Uo.decodeText(new Uint8Array(e)));
    else s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      n &&
        n(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const u = new y3(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    u.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const f = this.pluginCallbacks[h](u);
      (o[f.name] = f), (a[f.name] = !0);
    }
    if (s.extensionsUsed)
      for (let h = 0; h < s.extensionsUsed.length; ++h) {
        const f = s.extensionsUsed[h],
          c = s.extensionsRequired || [];
        switch (f) {
          case Nt.KHR_MATERIALS_UNLIT:
            a[f] = new KD();
            break;
          case Nt.KHR_DRACO_MESH_COMPRESSION:
            a[f] = new u3(s, this.dracoLoader);
            break;
          case Nt.KHR_TEXTURE_TRANSFORM:
            a[f] = new h3();
            break;
          case Nt.KHR_MESH_QUANTIZATION:
            a[f] = new d3();
            break;
          default:
            c.indexOf(f) >= 0 &&
              o[f] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + f + '".');
        }
      }
    u.setExtensions(a), u.setPlugins(o), u.parse(i, n);
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function (n, s) {
      i.parse(e, t, n, s);
    });
  }
}
function $D() {
  let r = {};
  return {
    get: function (e) {
      return r[e];
    },
    add: function (e, t) {
      r[e] = t;
    },
    remove: function (e) {
      delete r[e];
    },
    removeAll: function () {
      r = {};
    },
  };
}
const Nt = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class YD {
  constructor(e) {
    (this.parser = e),
      (this.name = Nt.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let i = 0, n = t.length; i < n; i++) {
      const s = t[i];
      s.extensions &&
        s.extensions[this.name] &&
        s.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      i = "light:" + e;
    let n = t.cache.get(i);
    if (n) return n;
    const s = t.json,
      u = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let h;
    const f = new ct(16777215);
    u.color !== void 0 && f.fromArray(u.color);
    const c = u.range !== void 0 ? u.range : 0;
    switch (u.type) {
      case "directional":
        (h = new Rb(f)), h.target.position.set(0, 0, -1), h.add(h.target);
        break;
      case "point":
        (h = new xD(f)), (h.distance = c);
        break;
      case "spot":
        (h = new Lb(f)),
          (h.distance = c),
          (u.spot = u.spot || {}),
          (u.spot.innerConeAngle =
            u.spot.innerConeAngle !== void 0 ? u.spot.innerConeAngle : 0),
          (u.spot.outerConeAngle =
            u.spot.outerConeAngle !== void 0
              ? u.spot.outerConeAngle
              : Math.PI / 4),
          (h.angle = u.spot.outerConeAngle),
          (h.penumbra = 1 - u.spot.innerConeAngle / u.spot.outerConeAngle),
          h.target.position.set(0, 0, -1),
          h.add(h.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + u.type);
    }
    return (
      h.position.set(0, 0, 0),
      (h.decay = 2),
      Ur(h, u),
      u.intensity !== void 0 && (h.intensity = u.intensity),
      (h.name = t.createUniqueName(u.name || "light_" + e)),
      (n = Promise.resolve(h)),
      t.cache.add(i, n),
      n
    );
  }
  getDependency(e, t) {
    if (e === "light") return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      i = this.parser,
      s = i.json.nodes[e],
      o = ((s.extensions && s.extensions[this.name]) || {}).light;
    return o === void 0
      ? null
      : this._loadLight(o).then(function (u) {
          return i._getNodeRef(t.cache, o, u);
        });
  }
}
class KD {
  constructor() {
    this.name = Nt.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return cr;
  }
  extendParams(e, t, i) {
    const n = [];
    (e.color = new ct(1, 1, 1)), (e.opacity = 1);
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const a = s.baseColorFactor;
        e.color.fromArray(a), (e.opacity = a[3]);
      }
      s.baseColorTexture !== void 0 &&
        n.push(i.assignTexture(e, "map", s.baseColorTexture, Ht));
    }
    return Promise.all(n);
  }
}
class ZD {
  constructor(e) {
    (this.parser = e), (this.name = Nt.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = n.extensions[this.name].emissiveStrength;
    return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
  }
}
class JD {
  constructor(e) {
    (this.parser = e), (this.name = Nt.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oa;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = n.extensions[this.name];
    if (
      (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor),
      a.clearcoatTexture !== void 0 &&
        s.push(i.assignTexture(t, "clearcoatMap", a.clearcoatTexture)),
      a.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
      a.clearcoatRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            t,
            "clearcoatRoughnessMap",
            a.clearcoatRoughnessTexture
          )
        ),
      a.clearcoatNormalTexture !== void 0 &&
        (s.push(
          i.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)
        ),
        a.clearcoatNormalTexture.scale !== void 0))
    ) {
      const o = a.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Ue(o, o);
    }
    return Promise.all(s);
  }
}
class QD {
  constructor(e) {
    (this.parser = e), (this.name = Nt.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oa;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = n.extensions[this.name];
    return (
      a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor),
      a.iridescenceTexture !== void 0 &&
        s.push(i.assignTexture(t, "iridescenceMap", a.iridescenceTexture)),
      a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      a.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum),
      a.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum),
      a.iridescenceThicknessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            t,
            "iridescenceThicknessMap",
            a.iridescenceThicknessTexture
          )
        ),
      Promise.all(s)
    );
  }
}
class e3 {
  constructor(e) {
    (this.parser = e), (this.name = Nt.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oa;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [];
    (t.sheenColor = new ct(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const a = n.extensions[this.name];
    return (
      a.sheenColorFactor !== void 0 &&
        t.sheenColor.fromArray(a.sheenColorFactor),
      a.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = a.sheenRoughnessFactor),
      a.sheenColorTexture !== void 0 &&
        s.push(i.assignTexture(t, "sheenColorMap", a.sheenColorTexture, Ht)),
      a.sheenRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)
        ),
      Promise.all(s)
    );
  }
}
class t3 {
  constructor(e) {
    (this.parser = e), (this.name = Nt.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oa;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = n.extensions[this.name];
    return (
      a.transmissionFactor !== void 0 &&
        (t.transmission = a.transmissionFactor),
      a.transmissionTexture !== void 0 &&
        s.push(i.assignTexture(t, "transmissionMap", a.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class i3 {
  constructor(e) {
    (this.parser = e), (this.name = Nt.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oa;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = n.extensions[this.name];
    (t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0),
      a.thicknessTexture !== void 0 &&
        s.push(i.assignTexture(t, "thicknessMap", a.thicknessTexture)),
      (t.attenuationDistance = a.attenuationDistance || 1 / 0);
    const o = a.attenuationColor || [1, 1, 1];
    return (t.attenuationColor = new ct(o[0], o[1], o[2])), Promise.all(s);
  }
}
class n3 {
  constructor(e) {
    (this.parser = e), (this.name = Nt.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oa;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = n.extensions[this.name];
    return (t.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve();
  }
}
class s3 {
  constructor(e) {
    (this.parser = e), (this.name = Nt.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : oa;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = n.extensions[this.name];
    (t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1),
      a.specularTexture !== void 0 &&
        s.push(i.assignTexture(t, "specularIntensityMap", a.specularTexture));
    const o = a.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new ct(o[0], o[1], o[2])),
      a.specularColorTexture !== void 0 &&
        s.push(
          i.assignTexture(t, "specularColorMap", a.specularColorTexture, Ht)
        ),
      Promise.all(s)
    );
  }
}
class r3 {
  constructor(e) {
    (this.parser = e), (this.name = Nt.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      i = t.json,
      n = i.textures[e];
    if (!n.extensions || !n.extensions[this.name]) return null;
    const s = n.extensions[this.name],
      a = t.options.ktx2Loader;
    if (!a) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, s.source, a);
  }
}
class o3 {
  constructor(e) {
    (this.parser = e),
      (this.name = Nt.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      n = i.json,
      s = n.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const a = s.extensions[t],
      o = n.images[a.source];
    let u = i.textureLoader;
    if (o.uri) {
      const h = i.options.manager.getHandler(o.uri);
      h !== null && (u = h);
    }
    return this.detectSupport().then(function (h) {
      if (h) return i.loadTextureImage(e, a.source, u);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class a3 {
  constructor(e) {
    (this.name = Nt.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const n = i.extensions[this.name],
        s = this.parser.getDependency("buffer", n.buffer),
        a = this.parser.options.meshoptDecoder;
      if (!a || !a.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return s.then(function (o) {
        const u = n.byteOffset || 0,
          h = n.byteLength || 0,
          f = n.count,
          c = n.byteStride,
          d = new Uint8Array(o, u, h);
        return a.decodeGltfBufferAsync
          ? a
              .decodeGltfBufferAsync(f, c, d, n.mode, n.filter)
              .then(function (m) {
                return m.buffer;
              })
          : a.ready.then(function () {
              const m = new ArrayBuffer(f * c);
              return (
                a.decodeGltfBuffer(
                  new Uint8Array(m),
                  f,
                  c,
                  d,
                  n.mode,
                  n.filter
                ),
                m
              );
            });
      });
    } else return null;
  }
}
class l3 {
  constructor(e) {
    (this.name = Nt.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      i = t.nodes[e];
    if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
      return null;
    const n = t.meshes[i.mesh];
    for (const h of n.primitives)
      if (
        h.mode !== Kn.TRIANGLES &&
        h.mode !== Kn.TRIANGLE_STRIP &&
        h.mode !== Kn.TRIANGLE_FAN &&
        h.mode !== void 0
      )
        return null;
    const a = i.extensions[this.name].attributes,
      o = [],
      u = {};
    for (const h in a)
      o.push(
        this.parser
          .getDependency("accessor", a[h])
          .then((f) => ((u[h] = f), u[h]))
      );
    return o.length < 1
      ? null
      : (o.push(this.parser.createNodeMesh(e)),
        Promise.all(o).then((h) => {
          const f = h.pop(),
            c = f.isGroup ? f.children : [f],
            d = h[0].count,
            m = [];
          for (const x of c) {
            const v = new At(),
              b = new Z(),
              y = new ws(),
              M = new Z(1, 1, 1),
              D = new yb(x.geometry, x.material, d);
            for (let C = 0; C < d; C++)
              u.TRANSLATION && b.fromBufferAttribute(u.TRANSLATION, C),
                u.ROTATION && y.fromBufferAttribute(u.ROTATION, C),
                u.SCALE && M.fromBufferAttribute(u.SCALE, C),
                D.setMatrixAt(C, v.compose(b, y, M));
            for (const C in u)
              C !== "TRANSLATION" &&
                C !== "ROTATION" &&
                C !== "SCALE" &&
                x.geometry.setAttribute(C, u[C]);
            ei.prototype.copy.call(D, x),
              (D.frustumCulled = !1),
              this.parser.assignFinalMaterial(D),
              m.push(D);
          }
          return f.isGroup ? (f.clear(), f.add(...m), f) : m[0];
        }));
  }
}
const Fb = "glTF",
  cc = 12,
  Vv = { JSON: 1313821514, BIN: 5130562 };
class c3 {
  constructor(e) {
    (this.name = Nt.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, cc);
    if (
      ((this.header = {
        magic: Uo.decodeText(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== Fb)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - cc,
      n = new DataView(e, cc);
    let s = 0;
    for (; s < i; ) {
      const a = n.getUint32(s, !0);
      s += 4;
      const o = n.getUint32(s, !0);
      if (((s += 4), o === Vv.JSON)) {
        const u = new Uint8Array(e, cc + s, a);
        this.content = Uo.decodeText(u);
      } else if (o === Vv.BIN) {
        const u = cc + s;
        this.body = e.slice(u, u + a);
      }
      s += a;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class u3 {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = Nt.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const i = this.json,
      n = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      a = e.extensions[this.name].attributes,
      o = {},
      u = {},
      h = {};
    for (const f in a) {
      const c = If[f] || f.toLowerCase();
      o[c] = a[f];
    }
    for (const f in e.attributes) {
      const c = If[f] || f.toLowerCase();
      if (a[f] !== void 0) {
        const d = i.accessors[e.attributes[f]],
          m = tl[d.componentType];
        (h[c] = m.name), (u[c] = d.normalized === !0);
      }
    }
    return t.getDependency("bufferView", s).then(function (f) {
      return new Promise(function (c) {
        n.decodeDracoFile(
          f,
          function (d) {
            for (const m in d.attributes) {
              const x = d.attributes[m],
                v = u[m];
              v !== void 0 && (x.normalized = v);
            }
            c(d);
          },
          o,
          h
        );
      });
    });
  }
}
class h3 {
  constructor() {
    this.name = Nt.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      t.texCoord !== void 0 &&
        console.warn(
          'THREE.GLTFLoader: Custom UV sets in "' +
            this.name +
            '" extension not yet supported.'
        ),
      (t.offset === void 0 && t.rotation === void 0 && t.scale === void 0) ||
        ((e = e.clone()),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class d3 {
  constructor() {
    this.name = Nt.KHR_MESH_QUANTIZATION;
  }
}
class Ob extends uu {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      n = this.valueSize,
      s = e * n * 3 + n;
    for (let a = 0; a !== n; a++) t[a] = i[s + a];
    return t;
  }
  interpolate_(e, t, i, n) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      u = o * 2,
      h = o * 3,
      f = n - t,
      c = (i - t) / f,
      d = c * c,
      m = d * c,
      x = e * h,
      v = x - h,
      b = -2 * m + 3 * d,
      y = m - d,
      M = 1 - b,
      D = y - d + c;
    for (let C = 0; C !== o; C++) {
      const A = a[v + C + o],
        I = a[v + C + u] * f,
        F = a[x + C + o],
        P = a[x + C] * f;
      s[C] = M * A + D * I + b * F + y * P;
    }
    return s;
  }
}
const p3 = new ws();
class f3 extends Ob {
  interpolate_(e, t, i, n) {
    const s = super.interpolate_(e, t, i, n);
    return p3.fromArray(s).normalize().toArray(s), s;
  }
}
const Kn = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  tl = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  zv = { 9728: Ai, 9729: Ui, 9984: Tf, 9985: ib, 9986: Ah, 9987: mr },
  Uv = { 33071: bn, 33648: Wh, 10497: Zr },
  qp = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  If = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  Nr = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  m3 = { CUBICSPLINE: void 0, LINEAR: ul, STEP: zc },
  Xp = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function g3(r) {
  return (
    r.DefaultMaterial === void 0 &&
      (r.DefaultMaterial = new pd({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Bs,
      })),
    r.DefaultMaterial
  );
}
function uc(r, e, t) {
  for (const i in t.extensions)
    r[i] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[i] = t.extensions[i]));
}
function Ur(r, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(r.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function v3(r, e, t) {
  let i = !1,
    n = !1,
    s = !1;
  for (let h = 0, f = e.length; h < f; h++) {
    const c = e[h];
    if (
      (c.POSITION !== void 0 && (i = !0),
      c.NORMAL !== void 0 && (n = !0),
      c.COLOR_0 !== void 0 && (s = !0),
      i && n && s)
    )
      break;
  }
  if (!i && !n && !s) return Promise.resolve(r);
  const a = [],
    o = [],
    u = [];
  for (let h = 0, f = e.length; h < f; h++) {
    const c = e[h];
    if (i) {
      const d =
        c.POSITION !== void 0
          ? t.getDependency("accessor", c.POSITION)
          : r.attributes.position;
      a.push(d);
    }
    if (n) {
      const d =
        c.NORMAL !== void 0
          ? t.getDependency("accessor", c.NORMAL)
          : r.attributes.normal;
      o.push(d);
    }
    if (s) {
      const d =
        c.COLOR_0 !== void 0
          ? t.getDependency("accessor", c.COLOR_0)
          : r.attributes.color;
      u.push(d);
    }
  }
  return Promise.all([Promise.all(a), Promise.all(o), Promise.all(u)]).then(
    function (h) {
      const f = h[0],
        c = h[1],
        d = h[2];
      return (
        i && (r.morphAttributes.position = f),
        n && (r.morphAttributes.normal = c),
        s && (r.morphAttributes.color = d),
        (r.morphTargetsRelative = !0),
        r
      );
    }
  );
}
function _3(r, e) {
  if ((r.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, i = e.weights.length; t < i; t++)
      r.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (r.morphTargetInfluences.length === t.length) {
      r.morphTargetDictionary = {};
      for (let i = 0, n = t.length; i < n; i++)
        r.morphTargetDictionary[t[i]] = i;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function b3(r) {
  const e = r.extensions && r.extensions[Nt.KHR_DRACO_MESH_COMPRESSION];
  let t;
  return (
    e
      ? (t = "draco:" + e.bufferView + ":" + e.indices + ":" + Gv(e.attributes))
      : (t = r.indices + ":" + Gv(r.attributes) + ":" + r.mode),
    t
  );
}
function Gv(r) {
  let e = "";
  const t = Object.keys(r).sort();
  for (let i = 0, n = t.length; i < n; i++) e += t[i] + ":" + r[t[i]] + ";";
  return e;
}
function Ff(r) {
  switch (r) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function x3(r) {
  return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
const w3 = new At();
class y3 {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new $D()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let i = !1,
      n = !1,
      s = -1;
    typeof navigator < "u" &&
      ((i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (n = navigator.userAgent.indexOf("Firefox") > -1),
      (s = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > "u" || i || (n && s < 98)
        ? (this.textureLoader = new Ab(this.options.manager))
        : (this.textureLoader = new MD(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new Pb(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this,
      n = this.json,
      s = this.extensions;
    this.cache.removeAll(),
      this._invokeAll(function (a) {
        return a._markDefs && a._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (a) {
          return a.beforeRoot && a.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            i.getDependencies("scene"),
            i.getDependencies("animation"),
            i.getDependencies("camera"),
          ]);
        })
        .then(function (a) {
          const o = {
            scene: a[0][n.scene || 0],
            scenes: a[0],
            animations: a[1],
            cameras: a[2],
            asset: n.asset,
            parser: i,
            userData: {},
          };
          uc(s, o, n),
            Ur(o, n),
            Promise.all(
              i._invokeAll(function (u) {
                return u.afterRoot && u.afterRoot(o);
              })
            ).then(function () {
              e(o);
            });
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      i = this.json.meshes || [];
    for (let n = 0, s = t.length; n < s; n++) {
      const a = t[n].joints;
      for (let o = 0, u = a.length; o < u; o++) e[a[o]].isBone = !0;
    }
    for (let n = 0, s = e.length; n < s; n++) {
      const a = e[n];
      a.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, a.mesh),
        a.skin !== void 0 && (i[a.mesh].isSkinnedMesh = !0)),
        a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    const n = i.clone(),
      s = (a, o) => {
        const u = this.associations.get(a);
        u != null && this.associations.set(o, u);
        for (const [h, f] of a.children.entries()) s(f, o.children[h]);
      };
    return s(i, n), (n.name += "_instance_" + e.uses[t]++), n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const n = e(t[i]);
      if (n) return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let n = 0; n < t.length; n++) {
      const s = e(t[n]);
      s && i.push(s);
    }
    return i;
  }
  getDependency(e, t) {
    const i = e + ":" + t;
    let n = this.cache.get(i);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function (s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (
            ((n = this._invokeOne(function (s) {
              return s != this && s.getDependency && s.getDependency(e, t);
            })),
            !n)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(i, n);
    }
    return n;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this,
        n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        n.map(function (s, a) {
          return i.getDependency(e, a);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      i = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Nt.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function (s, a) {
      i.load(Uo.resolveURL(t.uri, n.path), s, void 0, function () {
        a(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (i) {
      const n = t.byteLength || 0,
        s = t.byteOffset || 0;
      return i.slice(s, s + n);
    });
  }
  loadAccessor(e) {
    const t = this,
      i = this.json,
      n = this.json.accessors[e];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      const a = qp[n.type],
        o = tl[n.componentType],
        u = n.normalized === !0,
        h = new o(n.count * a);
      return Promise.resolve(new an(h, a, u));
    }
    const s = [];
    return (
      n.bufferView !== void 0
        ? s.push(this.getDependency("bufferView", n.bufferView))
        : s.push(null),
      n.sparse !== void 0 &&
        (s.push(this.getDependency("bufferView", n.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", n.sparse.values.bufferView))),
      Promise.all(s).then(function (a) {
        const o = a[0],
          u = qp[n.type],
          h = tl[n.componentType],
          f = h.BYTES_PER_ELEMENT,
          c = f * u,
          d = n.byteOffset || 0,
          m =
            n.bufferView !== void 0
              ? i.bufferViews[n.bufferView].byteStride
              : void 0,
          x = n.normalized === !0;
        let v, b;
        if (m && m !== c) {
          const y = Math.floor(d / m),
            M =
              "InterleavedBuffer:" +
              n.bufferView +
              ":" +
              n.componentType +
              ":" +
              y +
              ":" +
              n.count;
          let D = t.cache.get(M);
          D ||
            ((v = new h(o, y * m, (n.count * m) / f)),
            (D = new jC(v, m / f)),
            t.cache.add(M, D)),
            (b = new Tm(D, u, (d % m) / f, x));
        } else o === null ? (v = new h(n.count * u)) : (v = new h(o, d, n.count * u)), (b = new an(v, u, x));
        if (n.sparse !== void 0) {
          const y = qp.SCALAR,
            M = tl[n.sparse.indices.componentType],
            D = n.sparse.indices.byteOffset || 0,
            C = n.sparse.values.byteOffset || 0,
            A = new M(a[1], D, n.sparse.count * y),
            I = new h(a[2], C, n.sparse.count * u);
          o !== null && (b = new an(b.array.slice(), b.itemSize, b.normalized));
          for (let F = 0, P = A.length; F < P; F++) {
            const k = A[F];
            if (
              (b.setX(k, I[F * u]),
              u >= 2 && b.setY(k, I[F * u + 1]),
              u >= 3 && b.setZ(k, I[F * u + 2]),
              u >= 4 && b.setW(k, I[F * u + 3]),
              u >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return b;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      i = this.options,
      s = t.textures[e].source,
      a = t.images[s];
    let o = this.textureLoader;
    if (a.uri) {
      const u = i.manager.getHandler(a.uri);
      u !== null && (o = u);
    }
    return this.loadTextureImage(e, s, o);
  }
  loadTextureImage(e, t, i) {
    const n = this,
      s = this.json,
      a = s.textures[e],
      o = s.images[t],
      u = (o.uri || o.bufferView) + ":" + a.sampler;
    if (this.textureCache[u]) return this.textureCache[u];
    const h = this.loadImageSource(t, i)
      .then(function (f) {
        (f.flipY = !1), (f.name = a.name || o.name || "");
        const d = (s.samplers || {})[a.sampler] || {};
        return (
          (f.magFilter = zv[d.magFilter] || Ui),
          (f.minFilter = zv[d.minFilter] || mr),
          (f.wrapS = Uv[d.wrapS] || Zr),
          (f.wrapT = Uv[d.wrapT] || Zr),
          n.associations.set(f, { textures: e }),
          f
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[u] = h), h;
  }
  loadImageSource(e, t) {
    const i = this,
      n = this.json,
      s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((c) => c.clone());
    const a = n.images[e],
      o = self.URL || self.webkitURL;
    let u = a.uri || "",
      h = !1;
    if (a.bufferView !== void 0)
      u = i.getDependency("bufferView", a.bufferView).then(function (c) {
        h = !0;
        const d = new Blob([c], { type: a.mimeType });
        return (u = o.createObjectURL(d)), u;
      });
    else if (a.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const f = Promise.resolve(u)
      .then(function (c) {
        return new Promise(function (d, m) {
          let x = d;
          t.isImageBitmapLoader === !0 &&
            (x = function (v) {
              const b = new xi(v);
              (b.needsUpdate = !0), d(b);
            }),
            t.load(Uo.resolveURL(c, s.path), x, void 0, m);
        });
      })
      .then(function (c) {
        return (
          h === !0 && o.revokeObjectURL(u),
          (c.userData.mimeType = a.mimeType || x3(a.uri)),
          c
        );
      })
      .catch(function (c) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", u), c);
      });
    return (this.sourceCache[e] = f), f;
  }
  assignTexture(e, t, i, n) {
    const s = this;
    return this.getDependency("texture", i.index).then(function (a) {
      if (!a) return null;
      if (
        (i.texCoord !== void 0 &&
          i.texCoord != 0 &&
          !(t === "aoMap" && i.texCoord == 1) &&
          console.warn(
            "THREE.GLTFLoader: Custom UV set " +
              i.texCoord +
              " for texture " +
              t +
              " not yet supported."
          ),
        s.extensions[Nt.KHR_TEXTURE_TRANSFORM])
      ) {
        const o =
          i.extensions !== void 0
            ? i.extensions[Nt.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (o) {
          const u = s.associations.get(a);
          (a = s.extensions[Nt.KHR_TEXTURE_TRANSFORM].extendTexture(a, o)),
            s.associations.set(a, u);
        }
      }
      return n !== void 0 && (a.encoding = n), (e[t] = a), a;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const n = t.attributes.tangent === void 0,
      s = t.attributes.color !== void 0,
      a = t.attributes.normal === void 0;
    if (e.isPoints) {
      const o = "PointsMaterial:" + i.uuid;
      let u = this.cache.get(o);
      u ||
        ((u = new Mb()),
        Is.prototype.copy.call(u, i),
        u.color.copy(i.color),
        (u.map = i.map),
        (u.sizeAttenuation = !1),
        this.cache.add(o, u)),
        (i = u);
    } else if (e.isLine) {
      const o = "LineBasicMaterial:" + i.uuid;
      let u = this.cache.get(o);
      u ||
        ((u = new lu()),
        Is.prototype.copy.call(u, i),
        u.color.copy(i.color),
        this.cache.add(o, u)),
        (i = u);
    }
    if (n || s || a) {
      let o = "ClonedMaterial:" + i.uuid + ":";
      n && (o += "derivative-tangents:"),
        s && (o += "vertex-colors:"),
        a && (o += "flat-shading:");
      let u = this.cache.get(o);
      u ||
        ((u = i.clone()),
        s && (u.vertexColors = !0),
        a && (u.flatShading = !0),
        n &&
          (u.normalScale && (u.normalScale.y *= -1),
          u.clearcoatNormalScale && (u.clearcoatNormalScale.y *= -1)),
        this.cache.add(o, u),
        this.associations.set(u, this.associations.get(i))),
        (i = u);
    }
    i.aoMap &&
      t.attributes.uv2 === void 0 &&
      t.attributes.uv !== void 0 &&
      t.setAttribute("uv2", t.attributes.uv),
      (e.material = i);
  }
  getMaterialType() {
    return pd;
  }
  loadMaterial(e) {
    const t = this,
      i = this.json,
      n = this.extensions,
      s = i.materials[e];
    let a;
    const o = {},
      u = s.extensions || {},
      h = [];
    if (u[Nt.KHR_MATERIALS_UNLIT]) {
      const c = n[Nt.KHR_MATERIALS_UNLIT];
      (a = c.getMaterialType()), h.push(c.extendParams(o, s, t));
    } else {
      const c = s.pbrMetallicRoughness || {};
      if (
        ((o.color = new ct(1, 1, 1)),
        (o.opacity = 1),
        Array.isArray(c.baseColorFactor))
      ) {
        const d = c.baseColorFactor;
        o.color.fromArray(d), (o.opacity = d[3]);
      }
      c.baseColorTexture !== void 0 &&
        h.push(t.assignTexture(o, "map", c.baseColorTexture, Ht)),
        (o.metalness = c.metallicFactor !== void 0 ? c.metallicFactor : 1),
        (o.roughness = c.roughnessFactor !== void 0 ? c.roughnessFactor : 1),
        c.metallicRoughnessTexture !== void 0 &&
          (h.push(
            t.assignTexture(o, "metalnessMap", c.metallicRoughnessTexture)
          ),
          h.push(
            t.assignTexture(o, "roughnessMap", c.metallicRoughnessTexture)
          )),
        (a = this._invokeOne(function (d) {
          return d.getMaterialType && d.getMaterialType(e);
        })),
        h.push(
          Promise.all(
            this._invokeAll(function (d) {
              return d.extendMaterialParams && d.extendMaterialParams(e, o);
            })
          )
        );
    }
    s.doubleSided === !0 && (o.side = ru);
    const f = s.alphaMode || Xp.OPAQUE;
    if (
      (f === Xp.BLEND
        ? ((o.transparent = !0), (o.depthWrite = !1))
        : ((o.transparent = !1),
          f === Xp.MASK &&
            (o.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
      s.normalTexture !== void 0 &&
        a !== cr &&
        (h.push(t.assignTexture(o, "normalMap", s.normalTexture)),
        (o.normalScale = new Ue(1, 1)),
        s.normalTexture.scale !== void 0))
    ) {
      const c = s.normalTexture.scale;
      o.normalScale.set(c, c);
    }
    return (
      s.occlusionTexture !== void 0 &&
        a !== cr &&
        (h.push(t.assignTexture(o, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 &&
          (o.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 &&
        a !== cr &&
        (o.emissive = new ct().fromArray(s.emissiveFactor)),
      s.emissiveTexture !== void 0 &&
        a !== cr &&
        h.push(t.assignTexture(o, "emissiveMap", s.emissiveTexture, Ht)),
      Promise.all(h).then(function () {
        const c = new a(o);
        return (
          s.name && (c.name = s.name),
          Ur(c, s),
          t.associations.set(c, { materials: e }),
          s.extensions && uc(n, c, s),
          c
        );
      })
    );
  }
  createUniqueName(e) {
    const t = Wt.sanitizeNodeName(e || "");
    let i = t;
    for (let n = 1; this.nodeNamesUsed[i]; ++n) i = t + "_" + n;
    return (this.nodeNamesUsed[i] = !0), i;
  }
  loadGeometries(e) {
    const t = this,
      i = this.extensions,
      n = this.primitiveCache;
    function s(o) {
      return i[Nt.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(o, t)
        .then(function (u) {
          return Hv(u, o, t);
        });
    }
    const a = [];
    for (let o = 0, u = e.length; o < u; o++) {
      const h = e[o],
        f = b3(h),
        c = n[f];
      if (c) a.push(c.promise);
      else {
        let d;
        h.extensions && h.extensions[Nt.KHR_DRACO_MESH_COMPRESSION]
          ? (d = s(h))
          : (d = Hv(new cn(), h, t)),
          (n[f] = { primitive: h, promise: d }),
          a.push(d);
      }
    }
    return Promise.all(a);
  }
  loadMesh(e) {
    const t = this,
      i = this.json,
      n = this.extensions,
      s = i.meshes[e],
      a = s.primitives,
      o = [];
    for (let u = 0, h = a.length; u < h; u++) {
      const f =
        a[u].material === void 0
          ? g3(this.cache)
          : this.getDependency("material", a[u].material);
      o.push(f);
    }
    return (
      o.push(t.loadGeometries(a)),
      Promise.all(o).then(function (u) {
        const h = u.slice(0, u.length - 1),
          f = u[u.length - 1],
          c = [];
        for (let m = 0, x = f.length; m < x; m++) {
          const v = f[m],
            b = a[m];
          let y;
          const M = h[m];
          if (
            b.mode === Kn.TRIANGLES ||
            b.mode === Kn.TRIANGLE_STRIP ||
            b.mode === Kn.TRIANGLE_FAN ||
            b.mode === void 0
          )
            (y = s.isSkinnedMesh === !0 ? new XC(v, M) : new Wi(v, M)),
              y.isSkinnedMesh === !0 &&
                !y.geometry.attributes.skinWeight.normalized &&
                y.normalizeSkinWeights(),
              b.mode === Kn.TRIANGLE_STRIP
                ? (y.geometry = Wv(y.geometry, CS))
                : b.mode === Kn.TRIANGLE_FAN &&
                  (y.geometry = Wv(y.geometry, sb));
          else if (b.mode === Kn.LINES) y = new Sb(v, M);
          else if (b.mode === Kn.LINE_STRIP) y = new cu(v, M);
          else if (b.mode === Kn.LINE_LOOP) y = new ZC(v, M);
          else if (b.mode === Kn.POINTS) y = new JC(v, M);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + b.mode
            );
          Object.keys(y.geometry.morphAttributes).length > 0 && _3(y, s),
            (y.name = t.createUniqueName(s.name || "mesh_" + e)),
            Ur(y, s),
            b.extensions && uc(n, y, b),
            t.assignFinalMaterial(y),
            c.push(y);
        }
        for (let m = 0, x = c.length; m < x; m++)
          t.associations.set(c[m], { meshes: e, primitives: m });
        if (c.length === 1) return c[0];
        const d = new ts();
        t.associations.set(d, { meshes: e });
        for (let m = 0, x = c.length; m < x; m++) d.add(c[m]);
        return d;
      })
    );
  }
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e],
      n = i[i.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      i.type === "perspective"
        ? (t = new Gi(
            Bo.radToDeg(n.yfov),
            n.aspectRatio || 1,
            n.znear || 1,
            n.zfar || 2e6
          ))
        : i.type === "orthographic" &&
          (t = new ym(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)),
      i.name && (t.name = this.createUniqueName(i.name)),
      Ur(t, i),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      i = [];
    for (let n = 0, s = t.joints.length; n < s; n++)
      i.push(this.getDependency("node", t.joints[n]));
    return (
      t.inverseBindMatrices !== void 0
        ? i.push(this.getDependency("accessor", t.inverseBindMatrices))
        : i.push(null),
      Promise.all(i).then(function (n) {
        const s = n.pop(),
          a = n,
          o = [],
          u = [];
        for (let h = 0, f = a.length; h < f; h++) {
          const c = a[h];
          if (c) {
            o.push(c);
            const d = new At();
            s !== null && d.fromArray(s.array, h * 16), u.push(d);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[h]
            );
        }
        return new Em(o, u);
      })
    );
  }
  loadAnimation(e) {
    const i = this.json.animations[e],
      n = [],
      s = [],
      a = [],
      o = [],
      u = [];
    for (let h = 0, f = i.channels.length; h < f; h++) {
      const c = i.channels[h],
        d = i.samplers[c.sampler],
        m = c.target,
        x = m.node,
        v = i.parameters !== void 0 ? i.parameters[d.input] : d.input,
        b = i.parameters !== void 0 ? i.parameters[d.output] : d.output;
      n.push(this.getDependency("node", x)),
        s.push(this.getDependency("accessor", v)),
        a.push(this.getDependency("accessor", b)),
        o.push(d),
        u.push(m);
    }
    return Promise.all([
      Promise.all(n),
      Promise.all(s),
      Promise.all(a),
      Promise.all(o),
      Promise.all(u),
    ]).then(function (h) {
      const f = h[0],
        c = h[1],
        d = h[2],
        m = h[3],
        x = h[4],
        v = [];
      for (let y = 0, M = f.length; y < M; y++) {
        const D = f[y],
          C = c[y],
          A = d[y],
          I = m[y],
          F = x[y];
        if (D === void 0) continue;
        D.updateMatrix();
        let P;
        switch (Nr[F.path]) {
          case Nr.weights:
            P = Wc;
            break;
          case Nr.rotation:
            P = Jo;
            break;
          case Nr.position:
          case Nr.scale:
          default:
            P = jc;
            break;
        }
        const k = D.name ? D.name : D.uuid,
          O = I.interpolation !== void 0 ? m3[I.interpolation] : ul,
          J = [];
        Nr[F.path] === Nr.weights
          ? D.traverse(function (X) {
              X.morphTargetInfluences && J.push(X.name ? X.name : X.uuid);
            })
          : J.push(k);
        let ee = A.array;
        if (A.normalized) {
          const X = Ff(ee.constructor),
            j = new Float32Array(ee.length);
          for (let Y = 0, ie = ee.length; Y < ie; Y++) j[Y] = ee[Y] * X;
          ee = j;
        }
        for (let X = 0, j = J.length; X < j; X++) {
          const Y = new P(J[X] + "." + Nr[F.path], C.array, ee, O);
          I.interpolation === "CUBICSPLINE" &&
            ((Y.createInterpolant = function (Q) {
              const V = this instanceof Jo ? f3 : Ob;
              return new V(this.times, this.values, this.getValueSize() / 3, Q);
            }),
            (Y.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0)),
            v.push(Y);
        }
      }
      const b = i.name ? i.name : "animation_" + e;
      return new hD(b, void 0, v);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      i = this,
      n = t.nodes[e];
    return n.mesh === void 0
      ? null
      : i.getDependency("mesh", n.mesh).then(function (s) {
          const a = i._getNodeRef(i.meshCache, n.mesh, s);
          return (
            n.weights !== void 0 &&
              a.traverse(function (o) {
                if (o.isMesh)
                  for (let u = 0, h = n.weights.length; u < h; u++)
                    o.morphTargetInfluences[u] = n.weights[u];
              }),
            a
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      i = this.extensions,
      n = this,
      s = t.nodes[e],
      a = s.name ? n.createUniqueName(s.name) : "";
    return (function () {
      const o = [],
        u = n._invokeOne(function (d) {
          return d.createNodeMesh && d.createNodeMesh(e);
        });
      u && o.push(u),
        s.camera !== void 0 &&
          o.push(
            n.getDependency("camera", s.camera).then(function (d) {
              return n._getNodeRef(n.cameraCache, s.camera, d);
            })
          ),
        n
          ._invokeAll(function (d) {
            return d.createNodeAttachment && d.createNodeAttachment(e);
          })
          .forEach(function (d) {
            o.push(d);
          });
      const h = [],
        f = s.children || [];
      for (let d = 0, m = f.length; d < m; d++)
        h.push(n.getDependency("node", f[d]));
      const c =
        s.skin === void 0
          ? Promise.resolve(null)
          : n.getDependency("skin", s.skin);
      return Promise.all([Promise.all(o), Promise.all(h), c]);
    })().then(function (o) {
      const u = o[0],
        h = o[1],
        f = o[2];
      let c;
      if (
        (s.isBone === !0
          ? (c = new wb())
          : u.length > 1
          ? (c = new ts())
          : u.length === 1
          ? (c = u[0])
          : (c = new ei()),
        c !== u[0])
      )
        for (let d = 0, m = u.length; d < m; d++) c.add(u[d]);
      if (
        (s.name && ((c.userData.name = s.name), (c.name = a)),
        Ur(c, s),
        s.extensions && uc(i, c, s),
        s.matrix !== void 0)
      ) {
        const d = new At();
        d.fromArray(s.matrix), c.applyMatrix4(d);
      } else s.translation !== void 0 && c.position.fromArray(s.translation), s.rotation !== void 0 && c.quaternion.fromArray(s.rotation), s.scale !== void 0 && c.scale.fromArray(s.scale);
      n.associations.has(c) || n.associations.set(c, {}),
        (n.associations.get(c).nodes = e),
        f !== null &&
          c.traverse(function (d) {
            d.isSkinnedMesh && d.bind(f, w3);
          });
      for (let d = 0, m = h.length; d < m; d++) c.add(h[d]);
      return c;
    });
  }
  loadScene(e) {
    const t = this.extensions,
      i = this.json.scenes[e],
      n = this,
      s = new ts();
    i.name && (s.name = n.createUniqueName(i.name)),
      Ur(s, i),
      i.extensions && uc(t, s, i);
    const a = i.nodes || [],
      o = [];
    for (let u = 0, h = a.length; u < h; u++)
      o.push(n.getDependency("node", a[u]));
    return Promise.all(o).then(function (u) {
      for (let f = 0, c = u.length; f < c; f++) s.add(u[f]);
      const h = (f) => {
        const c = new Map();
        for (const [d, m] of n.associations)
          (d instanceof Is || d instanceof xi) && c.set(d, m);
        return (
          f.traverse((d) => {
            const m = n.associations.get(d);
            m != null && c.set(d, m);
          }),
          c
        );
      };
      return (n.associations = h(s)), s;
    });
  }
}
function S3(r, e, t) {
  const i = e.attributes,
    n = new Tl();
  if (i.POSITION !== void 0) {
    const o = t.json.accessors[i.POSITION],
      u = o.min,
      h = o.max;
    if (u !== void 0 && h !== void 0) {
      if (
        (n.set(new Z(u[0], u[1], u[2]), new Z(h[0], h[1], h[2])), o.normalized)
      ) {
        const f = Ff(tl[o.componentType]);
        n.min.multiplyScalar(f), n.max.multiplyScalar(f);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const s = e.targets;
  if (s !== void 0) {
    const o = new Z(),
      u = new Z();
    for (let h = 0, f = s.length; h < f; h++) {
      const c = s[h];
      if (c.POSITION !== void 0) {
        const d = t.json.accessors[c.POSITION],
          m = d.min,
          x = d.max;
        if (m !== void 0 && x !== void 0) {
          if (
            (u.setX(Math.max(Math.abs(m[0]), Math.abs(x[0]))),
            u.setY(Math.max(Math.abs(m[1]), Math.abs(x[1]))),
            u.setZ(Math.max(Math.abs(m[2]), Math.abs(x[2]))),
            d.normalized)
          ) {
            const v = Ff(tl[d.componentType]);
            u.multiplyScalar(v);
          }
          o.max(u);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    n.expandByVector(o);
  }
  r.boundingBox = n;
  const a = new El();
  n.getCenter(a.center),
    (a.radius = n.min.distanceTo(n.max) / 2),
    (r.boundingSphere = a);
}
function Hv(r, e, t) {
  const i = e.attributes,
    n = [];
  function s(a, o) {
    return t.getDependency("accessor", a).then(function (u) {
      r.setAttribute(o, u);
    });
  }
  for (const a in i) {
    const o = If[a] || a.toLowerCase();
    o in r.attributes || n.push(s(i[a], o));
  }
  if (e.indices !== void 0 && !r.index) {
    const a = t.getDependency("accessor", e.indices).then(function (o) {
      r.setIndex(o);
    });
    n.push(a);
  }
  return (
    Ur(r, e),
    S3(r, e, t),
    Promise.all(n).then(function () {
      return e.targets !== void 0 ? v3(r, e.targets, t) : r;
    })
  );
}
function Wv(r, e) {
  let t = r.getIndex();
  if (t === null) {
    const a = [],
      o = r.getAttribute("position");
    if (o !== void 0) {
      for (let u = 0; u < o.count; u++) a.push(u);
      r.setIndex(a), (t = r.getIndex());
    } else
      return (
        console.error(
          "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
        ),
        r
      );
  }
  const i = t.count - 2,
    n = [];
  if (e === sb)
    for (let a = 1; a <= i; a++)
      n.push(t.getX(0)), n.push(t.getX(a)), n.push(t.getX(a + 1));
  else
    for (let a = 0; a < i; a++)
      a % 2 === 0
        ? (n.push(t.getX(a)), n.push(t.getX(a + 1)), n.push(t.getX(a + 2)))
        : (n.push(t.getX(a + 2)), n.push(t.getX(a + 1)), n.push(t.getX(a)));
  n.length / 3 !== i &&
    console.error(
      "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
    );
  const s = r.clone();
  return s.setIndex(n), s;
}
class M3 extends qD {
  constructor(t) {
    super(t);
    q(
      this,
      "loadGltf",
      (t) => (
        this.gltfs[t] ||
          (this.gltfs[t] = this.add(
            new Promise((i, n) => {
              this.gltfLoader.load(
                t,
                (s) => {
                  i(s);
                },
                void 0,
                (s) => {
                  n(
                    new Error("glTF not loaded", {
                      cause: { error: s, url: t },
                    })
                  );
                }
              );
            })
          )),
        this.gltfs[t]
      )
    );
    q(
      this,
      "loadTexture",
      (t, i) => (
        this.textures[t] ||
          (this.textures[t] = this.add(
            new Promise((n, s) => {
              this.textureLoader.load(
                t,
                (a) => {
                  n(E.WebGL.generateTexture(a, i));
                },
                void 0,
                (a) => {
                  s(
                    new Error("Texture not loaded", {
                      cause: { error: a, url: t },
                    })
                  );
                }
              );
            })
          )),
        this.textures[t]
      )
    );
    (this.gltfs = {}),
      (this.textures = {}),
      (this.ktxTextures = {}),
      (this.textureLoader = new Ab()),
      (this.gltfLoader = new XD());
  }
  reset() {
    this.promisesToLoad = [];
  }
}
class T3 {
  constructor() {
    q(this, "fire", (e) => {
      let t = 0;
      const i = this.callbacks.length;
      for (t; t < i; t++) this.callbacks[t] && this.callbacks[t].cb(e);
    });
    (this.callbacks = []), De.on(Ze.RAF, this.fire);
  }
  add(e, t) {
    for (let i = 0; i < this.callbacks.length; i++)
      this.callbacks[i].cb === e &&
        console.warn("Duplicate RAFCollection callback detected");
    this.callbacks.push({ index: t || 0, cb: e }),
      this.callbacks.sort(this.sort);
  }
  remove(e) {
    for (let t = 0; t < this.callbacks.length; t++)
      this.callbacks[t].cb === e && this.callbacks.splice(t, 1);
  }
  sort(e, t) {
    return e.index > t.index ? 1 : -1;
  }
}
function Of() {
  return (
    (Of = Object.assign
      ? Object.assign.bind()
      : function (r) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (r[i] = t[i]);
          }
          return r;
        }),
    Of.apply(this, arguments)
  );
}
function Xh(r, e, t) {
  return Math.max(r, Math.min(e, t));
}
class E3 {
  advance(e) {
    var t;
    if (!this.isRunning) return;
    let i = !1;
    if (this.lerp)
      (this.value = (1 - (n = this.lerp)) * this.value + n * this.to),
        Math.round(this.value) === this.to &&
          ((this.value = this.to), (i = !0));
    else {
      this.currentTime += e;
      const s = Xh(0, this.currentTime / this.duration, 1);
      i = s >= 1;
      const a = i ? 1 : this.easing(s);
      this.value = this.from + (this.to - this.from) * a;
    }
    var n;
    (t = this.onUpdate) == null || t.call(this, this.value, { completed: i }),
      i && this.stop();
  }
  stop() {
    this.isRunning = !1;
  }
  fromTo(
    e,
    t,
    { lerp: i = 0.1, duration: n = 1, easing: s = (o) => o, onUpdate: a }
  ) {
    (this.from = this.value = e),
      (this.to = t),
      (this.lerp = i),
      (this.duration = n),
      (this.easing = s),
      (this.currentTime = 0),
      (this.isRunning = !0),
      (this.onUpdate = a);
  }
}
function jv(r, e) {
  let t;
  return function () {
    let i = arguments,
      n = this;
    clearTimeout(t),
      (t = setTimeout(function () {
        r.apply(n, i);
      }, e));
  };
}
class C3 {
  constructor(e, t) {
    (this.onWindowResize = () => {
      (this.width = window.innerWidth), (this.height = window.innerHeight);
    }),
      (this.onWrapperResize = () => {
        (this.width = this.wrapper.clientWidth),
          (this.height = this.wrapper.clientHeight);
      }),
      (this.onContentResize = () => {
        const i =
          this.wrapper === window ? document.documentElement : this.wrapper;
        (this.scrollHeight = i.scrollHeight),
          (this.scrollWidth = i.scrollWidth);
      }),
      (this.wrapper = e),
      (this.content = t),
      this.wrapper === window
        ? (window.addEventListener("resize", this.onWindowResize, !1),
          this.onWindowResize())
        : ((this.wrapperResizeObserver = new ResizeObserver(
            jv(this.onWrapperResize, 100)
          )),
          this.wrapperResizeObserver.observe(this.wrapper),
          this.onWrapperResize()),
      (this.contentResizeObserver = new ResizeObserver(
        jv(this.onContentResize, 100)
      )),
      this.contentResizeObserver.observe(this.content),
      this.onContentResize();
  }
  destroy() {
    var e, t;
    window.removeEventListener("resize", this.onWindowResize, !1),
      (e = this.wrapperResizeObserver) == null || e.disconnect(),
      (t = this.contentResizeObserver) == null || t.disconnect();
  }
  get limit() {
    return {
      x: this.scrollWidth - this.width,
      y: this.scrollHeight - this.height,
    };
  }
}
let Nb = () => ({
  events: {},
  emit(r, ...e) {
    let t = this.events[r] || [];
    for (let i = 0, n = t.length; i < n; i++) t[i](...e);
  },
  on(r, e) {
    var t;
    return (
      ((t = this.events[r]) != null && t.push(e)) || (this.events[r] = [e]),
      () => {
        var i;
        this.events[r] =
          (i = this.events[r]) == null ? void 0 : i.filter((n) => e !== n);
      }
    );
  },
});
class D3 {
  constructor(
    e,
    { wheelMultiplier: t = 1, touchMultiplier: i = 2, normalizeWheel: n = !1 }
  ) {
    (this.onTouchStart = (s) => {
      const { clientX: a, clientY: o } = s.targetTouches
        ? s.targetTouches[0]
        : s;
      (this.touchStart.x = a),
        (this.touchStart.y = o),
        (this.lastDelta = { x: 0, y: 0 });
    }),
      (this.onTouchMove = (s) => {
        const { clientX: a, clientY: o } = s.targetTouches
            ? s.targetTouches[0]
            : s,
          u = -(a - this.touchStart.x) * this.touchMultiplier,
          h = -(o - this.touchStart.y) * this.touchMultiplier;
        (this.touchStart.x = a),
          (this.touchStart.y = o),
          (this.lastDelta = { x: u, y: h }),
          this.emitter.emit("scroll", {
            type: "touch",
            deltaX: u,
            deltaY: h,
            event: s,
          });
      }),
      (this.onTouchEnd = (s) => {
        this.emitter.emit("scroll", {
          type: "touch",
          inertia: !0,
          deltaX: this.lastDelta.x,
          deltaY: this.lastDelta.y,
          event: s,
        });
      }),
      (this.onWheel = (s) => {
        let { deltaX: a, deltaY: o } = s;
        this.normalizeWheel && ((a = Xh(-100, a, 100)), (o = Xh(-100, o, 100))),
          (a *= this.wheelMultiplier),
          (o *= this.wheelMultiplier),
          this.emitter.emit("scroll", {
            type: "wheel",
            deltaX: a,
            deltaY: o,
            event: s,
          });
      }),
      (this.element = e),
      (this.wheelMultiplier = t),
      (this.touchMultiplier = i),
      (this.normalizeWheel = n),
      (this.touchStart = { x: null, y: null }),
      (this.emitter = Nb()),
      this.element.addEventListener("wheel", this.onWheel, { passive: !1 }),
      this.element.addEventListener("touchstart", this.onTouchStart, {
        passive: !1,
      }),
      this.element.addEventListener("touchmove", this.onTouchMove, {
        passive: !1,
      }),
      this.element.addEventListener("touchend", this.onTouchEnd, {
        passive: !1,
      });
  }
  on(e, t) {
    return this.emitter.on(e, t);
  }
  destroy() {
    (this.emitter.events = {}),
      this.element.removeEventListener("wheel", this.onWheel, { passive: !1 }),
      this.element.removeEventListener("touchstart", this.onTouchStart, {
        passive: !1,
      }),
      this.element.removeEventListener("touchmove", this.onTouchMove, {
        passive: !1,
      }),
      this.element.removeEventListener("touchend", this.onTouchEnd, {
        passive: !1,
      });
  }
}
class qv {
  constructor({
    direction: e,
    gestureDirection: t,
    mouseMultiplier: i,
    smooth: n,
    wrapper: s = window,
    content: a = document.documentElement,
    wheelEventsTarget: o = s,
    smoothWheel: u = n == null || n,
    smoothTouch: h = !1,
    syncTouch: f = !1,
    syncTouchLerp: c = 0.1,
    touchInertiaMultiplier: d = 35,
    duration: m,
    easing: x = (I) => Math.min(1, 1.001 - Math.pow(2, -10 * I)),
    lerp: v = m ? null : 0.1,
    infinite: b = !1,
    orientation: y = e ?? "vertical",
    gestureOrientation: M = t ?? "vertical",
    touchMultiplier: D = 1,
    wheelMultiplier: C = i ?? 1,
    normalizeWheel: A = !1,
  } = {}) {
    (this.onVirtualScroll = ({
      type: I,
      inertia: F,
      deltaX: P,
      deltaY: k,
      event: O,
    }) => {
      if (O.ctrlKey) return;
      const J = I === "touch",
        ee = I === "wheel";
      if (
        (this.options.gestureOrientation === "vertical" && k === 0) ||
        (this.options.gestureOrientation === "horizontal" && P === 0) ||
        (J &&
          this.options.gestureOrientation === "vertical" &&
          this.scroll === 0 &&
          !this.options.infinite &&
          k <= 0) ||
        O.composedPath().find((ie) =>
          ie == null || ie.hasAttribute == null
            ? void 0
            : ie.hasAttribute("data-lenis-prevent")
        )
      )
        return;
      if (this.isStopped || this.isLocked) return void O.preventDefault();
      if (
        ((this.isSmooth =
          ((this.options.smoothTouch || this.options.syncTouch) && J) ||
          (this.options.smoothWheel && ee)),
        !this.isSmooth)
      )
        return (this.isScrolling = !1), void this.animate.stop();
      O.preventDefault();
      let X = k;
      this.options.gestureOrientation === "both"
        ? (X = Math.abs(k) > Math.abs(P) ? k : P)
        : this.options.gestureOrientation === "horizontal" && (X = P);
      const j = J && this.options.syncTouch,
        Y = J && F && Math.abs(X) > 1;
      Y && (X = this.velocity * this.options.touchInertiaMultiplier),
        this.scrollTo(
          this.targetScroll + X,
          Of({ programmatic: !1 }, j && { lerp: Y ? this.syncTouchLerp : 0.4 })
        );
    }),
      (this.onScroll = () => {
        if (!this.isScrolling) {
          const I = this.animatedScroll;
          (this.animatedScroll = this.targetScroll = this.actualScroll),
            (this.velocity = 0),
            (this.direction = Math.sign(this.animatedScroll - I)),
            this.emit();
        }
      }),
      e &&
        console.warn(
          "Lenis: `direction` option is deprecated, use `orientation` instead"
        ),
      t &&
        console.warn(
          "Lenis: `gestureDirection` option is deprecated, use `gestureOrientation` instead"
        ),
      i &&
        console.warn(
          "Lenis: `mouseMultiplier` option is deprecated, use `wheelMultiplier` instead"
        ),
      n &&
        console.warn(
          "Lenis: `smooth` option is deprecated, use `smoothWheel` instead"
        ),
      (window.lenisVersion = "1.0.11"),
      (s !== document.documentElement && s !== document.body) || (s = window),
      (this.options = {
        wrapper: s,
        content: a,
        wheelEventsTarget: o,
        smoothWheel: u,
        smoothTouch: h,
        syncTouch: f,
        syncTouchLerp: c,
        touchInertiaMultiplier: d,
        duration: m,
        easing: x,
        lerp: v,
        infinite: b,
        gestureOrientation: M,
        orientation: y,
        touchMultiplier: D,
        wheelMultiplier: C,
        normalizeWheel: A,
      }),
      (this.dimensions = new C3(s, a)),
      this.rootElement.classList.add("lenis"),
      (this.velocity = 0),
      (this.isStopped = !1),
      (this.isSmooth = u || h),
      (this.isScrolling = !1),
      (this.targetScroll = this.animatedScroll = this.actualScroll),
      (this.animate = new E3()),
      (this.emitter = Nb()),
      this.options.wrapper.addEventListener("scroll", this.onScroll, {
        passive: !1,
      }),
      (this.virtualScroll = new D3(o, {
        touchMultiplier: D,
        wheelMultiplier: C,
        normalizeWheel: A,
      })),
      this.virtualScroll.on("scroll", this.onVirtualScroll);
  }
  destroy() {
    (this.emitter.events = {}),
      this.options.wrapper.removeEventListener("scroll", this.onScroll, {
        passive: !1,
      }),
      this.virtualScroll.destroy();
  }
  on(e, t) {
    return this.emitter.on(e, t);
  }
  off(e, t) {
    var i;
    this.emitter.events[e] =
      (i = this.emitter.events[e]) == null ? void 0 : i.filter((n) => t !== n);
  }
  setScroll(e) {
    this.isHorizontal
      ? (this.rootElement.scrollLeft = e)
      : (this.rootElement.scrollTop = e);
  }
  emit() {
    this.emitter.emit("scroll", this);
  }
  reset() {
    (this.isLocked = !1),
      (this.isScrolling = !1),
      (this.velocity = 0),
      this.animate.stop();
  }
  start() {
    (this.isStopped = !1), this.reset();
  }
  stop() {
    (this.isStopped = !0), this.animate.stop(), this.reset();
  }
  raf(e) {
    const t = e - (this.time || e);
    (this.time = e), this.animate.advance(0.001 * t);
  }
  scrollTo(
    e,
    {
      offset: t = 0,
      immediate: i = !1,
      lock: n = !1,
      duration: s = this.options.duration,
      easing: a = this.options.easing,
      lerp: o = !s && this.options.lerp,
      onComplete: u = null,
      force: h = !1,
      programmatic: f = !0,
    } = {}
  ) {
    if (!this.isStopped || h) {
      if (["top", "left", "start"].includes(e)) e = 0;
      else if (["bottom", "right", "end"].includes(e)) e = this.limit;
      else {
        var c;
        let d;
        if (
          (typeof e == "string"
            ? (d = document.querySelector(e))
            : (c = e) != null && c.nodeType && (d = e),
          d)
        ) {
          if (this.options.wrapper !== window) {
            const x = this.options.wrapper.getBoundingClientRect();
            t -= this.isHorizontal ? x.left : x.top;
          }
          const m = d.getBoundingClientRect();
          e = (this.isHorizontal ? m.left : m.top) + this.animatedScroll;
        }
      }
      if (typeof e == "number") {
        if (
          ((e += t),
          (e = Math.round(e)),
          this.options.infinite
            ? f && (this.targetScroll = this.animatedScroll = this.scroll)
            : (e = Xh(0, e, this.limit)),
          i)
        )
          return (
            (this.animatedScroll = this.targetScroll = e),
            this.setScroll(this.scroll),
            this.reset(),
            this.emit(),
            void (u == null || u())
          );
        if (!f) {
          if (e === this.targetScroll) return;
          this.targetScroll = e;
        }
        this.animate.fromTo(this.animatedScroll, e, {
          duration: s,
          easing: a,
          lerp: o,
          onUpdate: (d, { completed: m }) => {
            n && (this.isLocked = !0),
              (this.isScrolling = !0),
              (this.velocity = d - this.animatedScroll),
              (this.direction = Math.sign(this.velocity)),
              (this.animatedScroll = d),
              this.setScroll(this.scroll),
              f && (this.targetScroll = d),
              m &&
                (n && (this.isLocked = !1),
                requestAnimationFrame(() => {
                  this.isScrolling = !1;
                }),
                (this.velocity = 0),
                u == null || u()),
              this.emit();
          },
        });
      }
    }
  }
  get rootElement() {
    return this.options.wrapper === window
      ? this.options.content
      : this.options.wrapper;
  }
  get limit() {
    return this.isHorizontal
      ? this.dimensions.limit.x
      : this.dimensions.limit.y;
  }
  get isHorizontal() {
    return this.options.orientation === "horizontal";
  }
  get actualScroll() {
    return this.isHorizontal
      ? this.rootElement.scrollLeft
      : this.rootElement.scrollTop;
  }
  get scroll() {
    return this.options.infinite
      ? (function (e, t) {
          let i = e % t;
          return ((t > 0 && i < 0) || (t < 0 && i > 0)) && (i += t), i;
        })(this.animatedScroll, this.limit)
      : this.animatedScroll;
  }
  get progress() {
    return this.limit === 0 ? 1 : this.scroll / this.limit;
  }
  get isSmooth() {
    return this.__isSmooth;
  }
  set isSmooth(e) {
    this.__isSmooth !== e &&
      (this.rootElement.classList.toggle("lenis-smooth", e),
      (this.__isSmooth = e));
  }
  get isScrolling() {
    return this.__isScrolling;
  }
  set isScrolling(e) {
    this.__isScrolling !== e &&
      (this.rootElement.classList.toggle("lenis-scrolling", e),
      (this.__isScrolling = e));
  }
  get isStopped() {
    return this.__isStopped;
  }
  set isStopped(e) {
    this.__isStopped !== e &&
      (this.rootElement.classList.toggle("lenis-stopped", e),
      (this.__isStopped = e));
  }
}
function Xv(r, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    (i.enumerable = i.enumerable || !1),
      (i.configurable = !0),
      "value" in i && (i.writable = !0),
      Object.defineProperty(r, i.key, i);
  }
}
function P3(r, e, t) {
  return e && Xv(r.prototype, e), t && Xv(r, t), r;
}
/*!
 * Observer 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var Ni,
  Nf,
  Fn,
  Hr,
  Wr,
  il,
  Bb,
  Eo,
  Tc,
  Vb,
  ur,
  gs,
  zb,
  Ub = function () {
    return (
      Ni ||
      (typeof window < "u" && (Ni = window.gsap) && Ni.registerPlugin && Ni)
    );
  },
  Gb = 1,
  $a = [],
  Lt = [],
  Fs = [],
  Ec = Date.now,
  Bf = function (e, t) {
    return t;
  },
  A3 = function () {
    var e = Tc.core,
      t = e.bridge || {},
      i = e._scrollers,
      n = e._proxies;
    i.push.apply(i, Lt),
      n.push.apply(n, Fs),
      (Lt = i),
      (Fs = n),
      (Bf = function (a, o) {
        return t[a](o);
      });
  },
  $r = function (e, t) {
    return ~Fs.indexOf(e) && Fs[Fs.indexOf(e) + 1][t];
  },
  Cc = function (e) {
    return !!~Vb.indexOf(e);
  },
  mn = function (e, t, i, n, s) {
    return e.addEventListener(t, i, { passive: !n, capture: !!s });
  },
  Ji = function (e, t, i, n) {
    return e.removeEventListener(t, i, !!n);
  },
  ph = "scrollLeft",
  fh = "scrollTop",
  Vf = function () {
    return (ur && ur.isPressed) || Lt.cache++;
  },
  $h = function (e, t) {
    var i = function n(s) {
      if (s || s === 0) {
        Gb && (Fn.history.scrollRestoration = "manual");
        var a = ur && ur.isPressed;
        (s = n.v = Math.round(s) || (ur && ur.iOS ? 1 : 0)),
          e(s),
          (n.cacheID = Lt.cache),
          a && Bf("ss", s);
      } else
        (t || Lt.cache !== n.cacheID || Bf("ref")) &&
          ((n.cacheID = Lt.cache), (n.v = e()));
      return n.v + n.offset;
    };
    return (i.offset = 0), e && i;
  },
  sn = {
    s: ph,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: $h(function (r) {
      return arguments.length
        ? Fn.scrollTo(r, yi.sc())
        : Fn.pageXOffset || Hr[ph] || Wr[ph] || il[ph] || 0;
    }),
  },
  yi = {
    s: fh,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: sn,
    sc: $h(function (r) {
      return arguments.length
        ? Fn.scrollTo(sn.sc(), r)
        : Fn.pageYOffset || Hr[fh] || Wr[fh] || il[fh] || 0;
    }),
  },
  vn = function (e, t) {
    return (
      ((t && t._ctx && t._ctx.selector) || Ni.utils.toArray)(e)[0] ||
      (typeof e == "string" && Ni.config().nullTargetWarn !== !1
        ? console.warn("Element not found:", e)
        : null)
    );
  },
  Jr = function (e, t) {
    var i = t.s,
      n = t.sc;
    Cc(e) && (e = Hr.scrollingElement || Wr);
    var s = Lt.indexOf(e),
      a = n === yi.sc ? 1 : 2;
    !~s && (s = Lt.push(e) - 1), Lt[s + a] || e.addEventListener("scroll", Vf);
    var o = Lt[s + a],
      u =
        o ||
        (Lt[s + a] =
          $h($r(e, i), !0) ||
          (Cc(e)
            ? n
            : $h(function (h) {
                return arguments.length ? (e[i] = h) : e[i];
              })));
    return (
      (u.target = e),
      o || (u.smooth = Ni.getProperty(e, "scrollBehavior") === "smooth"),
      u
    );
  },
  zf = function (e, t, i) {
    var n = e,
      s = e,
      a = Ec(),
      o = a,
      u = t || 50,
      h = Math.max(500, u * 3),
      f = function (x, v) {
        var b = Ec();
        v || b - a > u
          ? ((s = n), (n = x), (o = a), (a = b))
          : i
          ? (n += x)
          : (n = s + ((x - s) / (b - o)) * (a - o));
      },
      c = function () {
        (s = n = i ? 0 : n), (o = a = 0);
      },
      d = function (x) {
        var v = o,
          b = s,
          y = Ec();
        return (
          (x || x === 0) && x !== n && f(x),
          a === o || y - o > h
            ? 0
            : ((n + (i ? b : -b)) / ((i ? y : a) - v)) * 1e3
        );
      };
    return { update: f, reset: c, getVelocity: d };
  },
  hc = function (e, t) {
    return (
      t && !e._gsapAllow && e.preventDefault(),
      e.changedTouches ? e.changedTouches[0] : e
    );
  },
  $v = function (e) {
    var t = Math.max.apply(Math, e),
      i = Math.min.apply(Math, e);
    return Math.abs(t) >= Math.abs(i) ? t : i;
  },
  Hb = function () {
    (Tc = Ni.core.globals().ScrollTrigger), Tc && Tc.core && A3();
  },
  Wb = function (e) {
    return (
      (Ni = e || Ub()),
      Ni &&
        typeof document < "u" &&
        document.body &&
        ((Fn = window),
        (Hr = document),
        (Wr = Hr.documentElement),
        (il = Hr.body),
        (Vb = [Fn, Hr, Wr, il]),
        Ni.utils.clamp,
        (zb = Ni.core.context || function () {}),
        (Eo = "onpointerenter" in il ? "pointer" : "mouse"),
        (Bb = pi.isTouch =
          Fn.matchMedia &&
          Fn.matchMedia("(hover: none), (pointer: coarse)").matches
            ? 1
            : "ontouchstart" in Fn ||
              navigator.maxTouchPoints > 0 ||
              navigator.msMaxTouchPoints > 0
            ? 2
            : 0),
        (gs = pi.eventTypes =
          (
            "ontouchstart" in Wr
              ? "touchstart,touchmove,touchcancel,touchend"
              : "onpointerdown" in Wr
              ? "pointerdown,pointermove,pointercancel,pointerup"
              : "mousedown,mousemove,mouseup,mouseup"
          ).split(",")),
        setTimeout(function () {
          return (Gb = 0);
        }, 500),
        Hb(),
        (Nf = 1)),
      Nf
    );
  };
sn.op = yi;
Lt.cache = 0;
var pi = (function () {
  function r(t) {
    this.init(t);
  }
  var e = r.prototype;
  return (
    (e.init = function (i) {
      Nf || Wb(Ni) || console.warn("Please gsap.registerPlugin(Observer)"),
        Tc || Hb();
      var n = i.tolerance,
        s = i.dragMinimum,
        a = i.type,
        o = i.target,
        u = i.lineHeight,
        h = i.debounce,
        f = i.preventDefault,
        c = i.onStop,
        d = i.onStopDelay,
        m = i.ignore,
        x = i.wheelSpeed,
        v = i.event,
        b = i.onDragStart,
        y = i.onDragEnd,
        M = i.onDrag,
        D = i.onPress,
        C = i.onRelease,
        A = i.onRight,
        I = i.onLeft,
        F = i.onUp,
        P = i.onDown,
        k = i.onChangeX,
        O = i.onChangeY,
        J = i.onChange,
        ee = i.onToggleX,
        X = i.onToggleY,
        j = i.onHover,
        Y = i.onHoverEnd,
        ie = i.onMove,
        Q = i.ignoreCheck,
        V = i.isNormalizer,
        ve = i.onGestureStart,
        U = i.onGestureEnd,
        oe = i.onWheel,
        ue = i.onEnable,
        fe = i.onDisable,
        le = i.onClick,
        be = i.scrollSpeed,
        ce = i.capture,
        He = i.allowClicks,
        Se = i.lockAxis,
        Oe = i.onLockAxis;
      (this.target = o = vn(o) || Wr),
        (this.vars = i),
        m && (m = Ni.utils.toArray(m)),
        (n = n || 1e-9),
        (s = s || 0),
        (x = x || 1),
        (be = be || 1),
        (a = a || "wheel,touch,pointer"),
        (h = h !== !1),
        u || (u = parseFloat(Fn.getComputedStyle(il).lineHeight) || 22);
      var Me,
        Ke,
        Qe,
        Pe,
        ht,
        wt,
        dt,
        he = this,
        Et = 0,
        ft = 0,
        Bt = Jr(o, sn),
        bt = Jr(o, yi),
        G = Bt(),
        N = bt(),
        pe =
          ~a.indexOf("touch") &&
          !~a.indexOf("pointer") &&
          gs[0] === "pointerdown",
        xe = Cc(o),
        we = o.ownerDocument || Hr,
        Ce = [0, 0, 0],
        We = [0, 0, 0],
        H = 0,
        ne = function () {
          return (H = Ec());
        },
        Re = function (Te, gt) {
          return (
            ((he.event = Te) && m && ~m.indexOf(Te.target)) ||
            (gt && pe && Te.pointerType !== "touch") ||
            (Q && Q(Te, gt))
          );
        },
        Ae = function () {
          he._vx.reset(), he._vy.reset(), Ke.pause(), c && c(he);
        },
        ke = function () {
          var Te = (he.deltaX = $v(Ce)),
            gt = (he.deltaY = $v(We)),
            mt = Math.abs(Te) >= n,
            ze = Math.abs(gt) >= n;
          J && (mt || ze) && J(he, Te, gt, Ce, We),
            mt &&
              (A && he.deltaX > 0 && A(he),
              I && he.deltaX < 0 && I(he),
              k && k(he),
              ee && he.deltaX < 0 != Et < 0 && ee(he),
              (Et = he.deltaX),
              (Ce[0] = Ce[1] = Ce[2] = 0)),
            ze &&
              (P && he.deltaY > 0 && P(he),
              F && he.deltaY < 0 && F(he),
              O && O(he),
              X && he.deltaY < 0 != ft < 0 && X(he),
              (ft = he.deltaY),
              (We[0] = We[1] = We[2] = 0)),
            (Pe || Qe) && (ie && ie(he), Qe && (M(he), (Qe = !1)), (Pe = !1)),
            wt && !(wt = !1) && Oe && Oe(he),
            ht && (oe(he), (ht = !1)),
            (Me = 0);
        },
        je = function (Te, gt, mt) {
          (Ce[mt] += Te),
            (We[mt] += gt),
            he._vx.update(Te),
            he._vy.update(gt),
            h ? Me || (Me = requestAnimationFrame(ke)) : ke();
        },
        Ve = function (Te, gt) {
          Se &&
            !dt &&
            ((he.axis = dt = Math.abs(Te) > Math.abs(gt) ? "x" : "y"),
            (wt = !0)),
            dt !== "y" && ((Ce[2] += Te), he._vx.update(Te, !0)),
            dt !== "x" && ((We[2] += gt), he._vy.update(gt, !0)),
            h ? Me || (Me = requestAnimationFrame(ke)) : ke();
        },
        rt = function (Te) {
          if (!Re(Te, 1)) {
            Te = hc(Te, f);
            var gt = Te.clientX,
              mt = Te.clientY,
              ze = gt - he.x,
              yt = mt - he.y,
              st = he.isDragging;
            (he.x = gt),
              (he.y = mt),
              (st ||
                Math.abs(he.startX - gt) >= s ||
                Math.abs(he.startY - mt) >= s) &&
                (M && (Qe = !0),
                st || (he.isDragging = !0),
                Ve(ze, yt),
                st || (b && b(he)));
          }
        },
        lt = (he.onPress = function (tt) {
          Re(tt, 1) ||
            (tt && tt.button) ||
            ((he.axis = dt = null),
            Ke.pause(),
            (he.isPressed = !0),
            (tt = hc(tt)),
            (Et = ft = 0),
            (he.startX = he.x = tt.clientX),
            (he.startY = he.y = tt.clientY),
            he._vx.reset(),
            he._vy.reset(),
            mn(V ? o : we, gs[1], rt, f, !0),
            (he.deltaX = he.deltaY = 0),
            D && D(he));
        }),
        Ct = (he.onRelease = function (tt) {
          if (!Re(tt, 1)) {
            Ji(V ? o : we, gs[1], rt, !0);
            var Te = !isNaN(he.y - he.startY),
              gt =
                he.isDragging &&
                (Math.abs(he.x - he.startX) > 3 ||
                  Math.abs(he.y - he.startY) > 3),
              mt = hc(tt);
            !gt &&
              Te &&
              (he._vx.reset(),
              he._vy.reset(),
              f &&
                He &&
                Ni.delayedCall(0.08, function () {
                  if (Ec() - H > 300 && !tt.defaultPrevented) {
                    if (tt.target.click) tt.target.click();
                    else if (we.createEvent) {
                      var ze = we.createEvent("MouseEvents");
                      ze.initMouseEvent(
                        "click",
                        !0,
                        !0,
                        Fn,
                        1,
                        mt.screenX,
                        mt.screenY,
                        mt.clientX,
                        mt.clientY,
                        !1,
                        !1,
                        !1,
                        !1,
                        0,
                        null
                      ),
                        tt.target.dispatchEvent(ze);
                    }
                  }
                })),
              (he.isDragging = he.isGesturing = he.isPressed = !1),
              c && !V && Ke.restart(!0),
              y && gt && y(he),
              C && C(he, gt);
          }
        }),
        $ = function (Te) {
          return (
            Te.touches &&
            Te.touches.length > 1 &&
            (he.isGesturing = !0) &&
            ve(Te, he.isDragging)
          );
        },
        ge = function () {
          return (he.isGesturing = !1) || U(he);
        },
        ye = function (Te) {
          if (!Re(Te)) {
            var gt = Bt(),
              mt = bt();
            je((gt - G) * be, (mt - N) * be, 1),
              (G = gt),
              (N = mt),
              c && Ke.restart(!0);
          }
        },
        Ie = function (Te) {
          if (!Re(Te)) {
            (Te = hc(Te, f)), oe && (ht = !0);
            var gt =
              (Te.deltaMode === 1
                ? u
                : Te.deltaMode === 2
                ? Fn.innerHeight
                : 1) * x;
            je(Te.deltaX * gt, Te.deltaY * gt, 0), c && !V && Ke.restart(!0);
          }
        },
        Ge = function (Te) {
          if (!Re(Te)) {
            var gt = Te.clientX,
              mt = Te.clientY,
              ze = gt - he.x,
              yt = mt - he.y;
            (he.x = gt), (he.y = mt), (Pe = !0), (ze || yt) && Ve(ze, yt);
          }
        },
        Mt = function (Te) {
          (he.event = Te), j(he);
        },
        zt = function (Te) {
          (he.event = Te), Y(he);
        },
        Rt = function (Te) {
          return Re(Te) || (hc(Te, f) && le(he));
        };
      (Ke = he._dc = Ni.delayedCall(d || 0.25, Ae).pause()),
        (he.deltaX = he.deltaY = 0),
        (he._vx = zf(0, 50, !0)),
        (he._vy = zf(0, 50, !0)),
        (he.scrollX = Bt),
        (he.scrollY = bt),
        (he.isDragging = he.isGesturing = he.isPressed = !1),
        zb(this),
        (he.enable = function (tt) {
          return (
            he.isEnabled ||
              (mn(xe ? we : o, "scroll", Vf),
              a.indexOf("scroll") >= 0 && mn(xe ? we : o, "scroll", ye, f, ce),
              a.indexOf("wheel") >= 0 && mn(o, "wheel", Ie, f, ce),
              ((a.indexOf("touch") >= 0 && Bb) || a.indexOf("pointer") >= 0) &&
                (mn(o, gs[0], lt, f, ce),
                mn(we, gs[2], Ct),
                mn(we, gs[3], Ct),
                He && mn(o, "click", ne, !1, !0),
                le && mn(o, "click", Rt),
                ve && mn(we, "gesturestart", $),
                U && mn(we, "gestureend", ge),
                j && mn(o, Eo + "enter", Mt),
                Y && mn(o, Eo + "leave", zt),
                ie && mn(o, Eo + "move", Ge)),
              (he.isEnabled = !0),
              tt && tt.type && lt(tt),
              ue && ue(he)),
            he
          );
        }),
        (he.disable = function () {
          he.isEnabled &&
            ($a.filter(function (tt) {
              return tt !== he && Cc(tt.target);
            }).length || Ji(xe ? we : o, "scroll", Vf),
            he.isPressed &&
              (he._vx.reset(), he._vy.reset(), Ji(V ? o : we, gs[1], rt, !0)),
            Ji(xe ? we : o, "scroll", ye, ce),
            Ji(o, "wheel", Ie, ce),
            Ji(o, gs[0], lt, ce),
            Ji(we, gs[2], Ct),
            Ji(we, gs[3], Ct),
            Ji(o, "click", ne, !0),
            Ji(o, "click", Rt),
            Ji(we, "gesturestart", $),
            Ji(we, "gestureend", ge),
            Ji(o, Eo + "enter", Mt),
            Ji(o, Eo + "leave", zt),
            Ji(o, Eo + "move", Ge),
            (he.isEnabled = he.isPressed = he.isDragging = !1),
            fe && fe(he));
        }),
        (he.kill = he.revert =
          function () {
            he.disable();
            var tt = $a.indexOf(he);
            tt >= 0 && $a.splice(tt, 1), ur === he && (ur = 0);
          }),
        $a.push(he),
        V && Cc(o) && (ur = he),
        he.enable(v);
    }),
    P3(r, [
      {
        key: "velocityX",
        get: function () {
          return this._vx.getVelocity();
        },
      },
      {
        key: "velocityY",
        get: function () {
          return this._vy.getVelocity();
        },
      },
    ]),
    r
  );
})();
pi.version = "3.12.1";
pi.create = function (r) {
  return new pi(r);
};
pi.register = Wb;
pi.getAll = function () {
  return $a.slice();
};
pi.getById = function (r) {
  return $a.filter(function (e) {
    return e.vars.id === r;
  })[0];
};
Ub() && Ni.registerPlugin(pi);
/*!
 * ScrollTrigger 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var Ye,
  Wa,
  kt,
  ti,
  _s,
  si,
  jb,
  Yh,
  Kh,
  Ya,
  kh,
  mh,
  zi,
  md,
  Uf,
  en,
  Yv,
  Kv,
  ja,
  qb,
  $p,
  Xb,
  Ln,
  $b,
  Yb,
  Kb,
  Vr,
  Gf,
  Rm,
  Yp,
  gh = 1,
  nn = Date.now,
  Kp = nn(),
  rs = 0,
  _c = 0,
  Zv = function (e, t, i) {
    var n = kn(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
    return (i["_" + t + "Clamp"] = n), n ? e.substr(6, e.length - 7) : e;
  },
  Jv = function (e, t) {
    return t && (!kn(e) || e.substr(0, 6) !== "clamp(")
      ? "clamp(" + e + ")"
      : e;
  },
  L3 = function r() {
    return _c && requestAnimationFrame(r);
  },
  Qv = function () {
    return (md = 1);
  },
  e_ = function () {
    return (md = 0);
  },
  Ps = function (e) {
    return e;
  },
  bc = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  Zb = function () {
    return typeof window < "u";
  },
  Jb = function () {
    return Ye || (Zb() && (Ye = window.gsap) && Ye.registerPlugin && Ye);
  },
  Qo = function (e) {
    return !!~jb.indexOf(e);
  },
  Qb = function (e) {
    return (
      $r(e, "getBoundingClientRect") ||
      (Qo(e)
        ? function () {
            return (Vh.width = kt.innerWidth), (Vh.height = kt.innerHeight), Vh;
          }
        : function () {
            return ar(e);
          })
    );
  },
  R3 = function (e, t, i) {
    var n = i.d,
      s = i.d2,
      a = i.a;
    return (a = $r(e, "getBoundingClientRect"))
      ? function () {
          return a()[n];
        }
      : function () {
          return (t ? kt["inner" + s] : e["client" + s]) || 0;
        };
  },
  k3 = function (e, t) {
    return !t || ~Fs.indexOf(e)
      ? Qb(e)
      : function () {
          return Vh;
        };
  },
  hr = function (e, t) {
    var i = t.s,
      n = t.d2,
      s = t.d,
      a = t.a;
    return Math.max(
      0,
      (i = "scroll" + n) && (a = $r(e, i))
        ? a() - Qb(e)()[s]
        : Qo(e)
        ? (_s[i] || si[i]) -
          (kt["inner" + n] || _s["client" + n] || si["client" + n])
        : e[i] - e["offset" + n]
    );
  },
  vh = function (e, t) {
    for (var i = 0; i < ja.length; i += 3)
      (!t || ~t.indexOf(ja[i + 1])) && e(ja[i], ja[i + 1], ja[i + 2]);
  },
  kn = function (e) {
    return typeof e == "string";
  },
  rn = function (e) {
    return typeof e == "function";
  },
  Ih = function (e) {
    return typeof e == "number";
  },
  Co = function (e) {
    return typeof e == "object";
  },
  dc = function (e, t, i) {
    return e && e.progress(t ? 0 : 1) && i && e.pause();
  },
  Zp = function (e, t) {
    if (e.enabled) {
      var i = t(e);
      i && i.totalTime && (e.callbackAnimation = i);
    }
  },
  Na = Math.abs,
  ex = "left",
  tx = "top",
  km = "right",
  Im = "bottom",
  Go = "width",
  Ho = "height",
  Dc = "Right",
  Pc = "Left",
  Ac = "Top",
  Lc = "Bottom",
  _i = "padding",
  Jn = "margin",
  pl = "Width",
  Fm = "Height",
  Fi = "px",
  Qn = function (e) {
    return kt.getComputedStyle(e);
  },
  I3 = function (e) {
    var t = Qn(e).position;
    e.style.position = t === "absolute" || t === "fixed" ? t : "relative";
  },
  t_ = function (e, t) {
    for (var i in t) i in e || (e[i] = t[i]);
    return e;
  },
  ar = function (e, t) {
    var i =
        t &&
        Qn(e)[Uf] !== "matrix(1, 0, 0, 1, 0, 0)" &&
        Ye.to(e, {
          x: 0,
          y: 0,
          xPercent: 0,
          yPercent: 0,
          rotation: 0,
          rotationX: 0,
          rotationY: 0,
          scale: 1,
          skewX: 0,
          skewY: 0,
        }).progress(1),
      n = e.getBoundingClientRect();
    return i && i.progress(0).kill(), n;
  },
  Hf = function (e, t) {
    var i = t.d2;
    return e["offset" + i] || e["client" + i] || 0;
  },
  ix = function (e) {
    var t = [],
      i = e.labels,
      n = e.duration(),
      s;
    for (s in i) t.push(i[s] / n);
    return t;
  },
  F3 = function (e) {
    return function (t) {
      return Ye.utils.snap(ix(e), t);
    };
  },
  Om = function (e) {
    var t = Ye.utils.snap(e),
      i =
        Array.isArray(e) &&
        e.slice(0).sort(function (n, s) {
          return n - s;
        });
    return i
      ? function (n, s, a) {
          a === void 0 && (a = 0.001);
          var o;
          if (!s) return t(n);
          if (s > 0) {
            for (n -= a, o = 0; o < i.length; o++) if (i[o] >= n) return i[o];
            return i[o - 1];
          } else for (o = i.length, n += a; o--; ) if (i[o] <= n) return i[o];
          return i[0];
        }
      : function (n, s, a) {
          a === void 0 && (a = 0.001);
          var o = t(n);
          return !s || Math.abs(o - n) < a || o - n < 0 == s < 0
            ? o
            : t(s < 0 ? n - e : n + e);
        };
  },
  O3 = function (e) {
    return function (t, i) {
      return Om(ix(e))(t, i.direction);
    };
  },
  _h = function (e, t, i, n) {
    return i.split(",").forEach(function (s) {
      return e(t, s, n);
    });
  },
  Pi = function (e, t, i, n, s) {
    return e.addEventListener(t, i, { passive: !n, capture: !!s });
  },
  Di = function (e, t, i, n) {
    return e.removeEventListener(t, i, !!n);
  },
  bh = function (e, t, i) {
    (i = i && i.wheelHandler), i && (e(t, "wheel", i), e(t, "touchmove", i));
  },
  i_ = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal",
  },
  xh = { toggleActions: "play", anticipatePin: 0 },
  Zh = { top: 0, left: 0, center: 0.5, bottom: 1, right: 1 },
  Fh = function (e, t) {
    if (kn(e)) {
      var i = e.indexOf("="),
        n = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0;
      ~i && (e.indexOf("%") > i && (n *= t / 100), (e = e.substr(0, i - 1))),
        (e =
          n +
          (e in Zh
            ? Zh[e] * t
            : ~e.indexOf("%")
            ? (parseFloat(e) * t) / 100
            : parseFloat(e) || 0));
    }
    return e;
  },
  wh = function (e, t, i, n, s, a, o, u) {
    var h = s.startColor,
      f = s.endColor,
      c = s.fontSize,
      d = s.indent,
      m = s.fontWeight,
      x = ti.createElement("div"),
      v = Qo(i) || $r(i, "pinType") === "fixed",
      b = e.indexOf("scroller") !== -1,
      y = v ? si : i,
      M = e.indexOf("start") !== -1,
      D = M ? h : f,
      C =
        "border-color:" +
        D +
        ";font-size:" +
        c +
        ";color:" +
        D +
        ";font-weight:" +
        m +
        ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return (
      (C += "position:" + ((b || u) && v ? "fixed;" : "absolute;")),
      (b || u || !v) &&
        (C += (n === yi ? km : Im) + ":" + (a + parseFloat(d)) + "px;"),
      o &&
        (C +=
          "box-sizing:border-box;text-align:left;width:" +
          o.offsetWidth +
          "px;"),
      (x._isStart = M),
      x.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")),
      (x.style.cssText = C),
      (x.innerText = t || t === 0 ? e + "-" + t : e),
      y.children[0] ? y.insertBefore(x, y.children[0]) : y.appendChild(x),
      (x._offset = x["offset" + n.op.d2]),
      Oh(x, 0, n, M),
      x
    );
  },
  Oh = function (e, t, i, n) {
    var s = { display: "block" },
      a = i[n ? "os2" : "p2"],
      o = i[n ? "p2" : "os2"];
    (e._isFlipped = n),
      (s[i.a + "Percent"] = n ? -100 : 0),
      (s[i.a] = n ? "1px" : 0),
      (s["border" + a + pl] = 1),
      (s["border" + o + pl] = 0),
      (s[i.p] = t + "px"),
      Ye.set(e, s);
  },
  Pt = [],
  Wf = {},
  qc,
  n_ = function () {
    return nn() - rs > 34 && (qc || (qc = requestAnimationFrame(fr)));
  },
  Ba = function () {
    (!Ln || !Ln.isPressed || Ln.startX > si.clientWidth) &&
      (Lt.cache++,
      Ln ? qc || (qc = requestAnimationFrame(fr)) : fr(),
      rs || ta("scrollStart"),
      (rs = nn()));
  },
  Jp = function () {
    (Kb = kt.innerWidth), (Yb = kt.innerHeight);
  },
  xc = function () {
    Lt.cache++,
      !zi &&
        !Xb &&
        !ti.fullscreenElement &&
        !ti.webkitFullscreenElement &&
        (!$b ||
          Kb !== kt.innerWidth ||
          Math.abs(kt.innerHeight - Yb) > kt.innerHeight * 0.25) &&
        Yh.restart(!0);
  },
  ea = {},
  N3 = [],
  nx = function r() {
    return Di(ut, "scrollEnd", r) || ko(!0);
  },
  ta = function (e) {
    return (
      (ea[e] &&
        ea[e].map(function (t) {
          return t();
        })) ||
      N3
    );
  },
  Rn = [],
  sx = function (e) {
    for (var t = 0; t < Rn.length; t += 5)
      (!e || (Rn[t + 4] && Rn[t + 4].query === e)) &&
        ((Rn[t].style.cssText = Rn[t + 1]),
        Rn[t].getBBox && Rn[t].setAttribute("transform", Rn[t + 2] || ""),
        (Rn[t + 3].uncache = 1));
  },
  Nm = function (e, t) {
    var i;
    for (en = 0; en < Pt.length; en++)
      (i = Pt[en]),
        i && (!t || i._ctx === t) && (e ? i.kill(1) : i.revert(!0, !0));
    t && sx(t), t || ta("revert");
  },
  rx = function (e, t) {
    Lt.cache++,
      (t || !tn) &&
        Lt.forEach(function (i) {
          return rn(i) && i.cacheID++ && (i.rec = 0);
        }),
      kn(e) && (kt.history.scrollRestoration = Rm = e);
  },
  tn,
  Wo = 0,
  s_,
  B3 = function () {
    if (s_ !== Wo) {
      var e = (s_ = Wo);
      requestAnimationFrame(function () {
        return e === Wo && ko(!0);
      });
    }
  },
  ko = function (e, t) {
    if (rs && !e) {
      Pi(ut, "scrollEnd", nx);
      return;
    }
    (tn = ut.isRefreshing = !0),
      Lt.forEach(function (n) {
        return rn(n) && ++n.cacheID && (n.rec = n());
      });
    var i = ta("refreshInit");
    qb && ut.sort(),
      t || Nm(),
      Lt.forEach(function (n) {
        rn(n) && (n.smooth && (n.target.style.scrollBehavior = "auto"), n(0));
      }),
      Pt.slice(0).forEach(function (n) {
        return n.refresh();
      }),
      Pt.forEach(function (n, s) {
        if (n._subPinOffset && n.pin) {
          var a = n.vars.horizontal ? "offsetWidth" : "offsetHeight",
            o = n.pin[a];
          n.revert(!0, 1), n.adjustPinSpacing(n.pin[a] - o), n.refresh();
        }
      }),
      Pt.forEach(function (n) {
        var s = hr(n.scroller, n._dir);
        (n.vars.end === "max" || (n._endClamp && n.end > s)) &&
          n.setPositions(n.start, Math.max(n.start + 1, s), !0);
      }),
      i.forEach(function (n) {
        return n && n.render && n.render(-1);
      }),
      Lt.forEach(function (n) {
        rn(n) &&
          (n.smooth &&
            requestAnimationFrame(function () {
              return (n.target.style.scrollBehavior = "smooth");
            }),
          n.rec && n(n.rec));
      }),
      rx(Rm, 1),
      Yh.pause(),
      Wo++,
      (tn = 2),
      fr(2),
      Pt.forEach(function (n) {
        return rn(n.vars.onRefresh) && n.vars.onRefresh(n);
      }),
      (tn = ut.isRefreshing = !1),
      ta("refresh");
  },
  jf = 0,
  Nh = 1,
  Rc,
  fr = function (e) {
    if (!tn || e === 2) {
      (ut.isUpdating = !0), Rc && Rc.update(0);
      var t = Pt.length,
        i = nn(),
        n = i - Kp >= 50,
        s = t && Pt[0].scroll();
      if (
        ((Nh = jf > s ? -1 : 1),
        tn || (jf = s),
        n &&
          (rs && !md && i - rs > 200 && ((rs = 0), ta("scrollEnd")),
          (kh = Kp),
          (Kp = i)),
        Nh < 0)
      ) {
        for (en = t; en-- > 0; ) Pt[en] && Pt[en].update(0, n);
        Nh = 1;
      } else for (en = 0; en < t; en++) Pt[en] && Pt[en].update(0, n);
      ut.isUpdating = !1;
    }
    qc = 0;
  },
  qf = [
    ex,
    tx,
    Im,
    km,
    Jn + Lc,
    Jn + Dc,
    Jn + Ac,
    Jn + Pc,
    "display",
    "flexShrink",
    "float",
    "zIndex",
    "gridColumnStart",
    "gridColumnEnd",
    "gridRowStart",
    "gridRowEnd",
    "gridArea",
    "justifySelf",
    "alignSelf",
    "placeSelf",
    "order",
  ],
  Bh = qf.concat([
    Go,
    Ho,
    "boxSizing",
    "max" + pl,
    "max" + Fm,
    "position",
    Jn,
    _i,
    _i + Ac,
    _i + Dc,
    _i + Lc,
    _i + Pc,
  ]),
  V3 = function (e, t, i) {
    nl(i);
    var n = e._gsap;
    if (n.spacerIsNative) nl(n.spacerState);
    else if (e._gsap.swappedIn) {
      var s = t.parentNode;
      s && (s.insertBefore(e, t), s.removeChild(t));
    }
    e._gsap.swappedIn = !1;
  },
  Qp = function (e, t, i, n) {
    if (!e._gsap.swappedIn) {
      for (var s = qf.length, a = t.style, o = e.style, u; s--; )
        (u = qf[s]), (a[u] = i[u]);
      (a.position = i.position === "absolute" ? "absolute" : "relative"),
        i.display === "inline" && (a.display = "inline-block"),
        (o[Im] = o[km] = "auto"),
        (a.flexBasis = i.flexBasis || "auto"),
        (a.overflow = "visible"),
        (a.boxSizing = "border-box"),
        (a[Go] = Hf(e, sn) + Fi),
        (a[Ho] = Hf(e, yi) + Fi),
        (a[_i] = o[Jn] = o[tx] = o[ex] = "0"),
        nl(n),
        (o[Go] = o["max" + pl] = i[Go]),
        (o[Ho] = o["max" + Fm] = i[Ho]),
        (o[_i] = i[_i]),
        e.parentNode !== t &&
          (e.parentNode.insertBefore(t, e), t.appendChild(e)),
        (e._gsap.swappedIn = !0);
    }
  },
  z3 = /([A-Z])/g,
  nl = function (e) {
    if (e) {
      var t = e.t.style,
        i = e.length,
        n = 0,
        s,
        a;
      for ((e.t._gsap || Ye.core.getCache(e.t)).uncache = 1; n < i; n += 2)
        (a = e[n + 1]),
          (s = e[n]),
          a
            ? (t[s] = a)
            : t[s] && t.removeProperty(s.replace(z3, "-$1").toLowerCase());
    }
  },
  yh = function (e) {
    for (var t = Bh.length, i = e.style, n = [], s = 0; s < t; s++)
      n.push(Bh[s], i[Bh[s]]);
    return (n.t = e), n;
  },
  U3 = function (e, t, i) {
    for (var n = [], s = e.length, a = i ? 8 : 0, o; a < s; a += 2)
      (o = e[a]), n.push(o, o in t ? t[o] : e[a + 1]);
    return (n.t = e.t), n;
  },
  Vh = { left: 0, top: 0 },
  r_ = function (e, t, i, n, s, a, o, u, h, f, c, d, m, x) {
    rn(e) && (e = e(u)),
      kn(e) &&
        e.substr(0, 3) === "max" &&
        (e = d + (e.charAt(4) === "=" ? Fh("0" + e.substr(3), i) : 0));
    var v = m ? m.time() : 0,
      b,
      y,
      M;
    if ((m && m.seek(0), isNaN(e) || (e = +e), Ih(e)))
      m &&
        (e = Ye.utils.mapRange(
          m.scrollTrigger.start,
          m.scrollTrigger.end,
          0,
          d,
          e
        )),
        o && Oh(o, i, n, !0);
    else {
      rn(t) && (t = t(u));
      var D = (e || "0").split(" "),
        C,
        A,
        I,
        F;
      (M = vn(t, u) || si),
        (C = ar(M) || {}),
        (!C || (!C.left && !C.top)) &&
          Qn(M).display === "none" &&
          ((F = M.style.display),
          (M.style.display = "block"),
          (C = ar(M)),
          F ? (M.style.display = F) : M.style.removeProperty("display")),
        (A = Fh(D[0], C[n.d])),
        (I = Fh(D[1] || "0", i)),
        (e = C[n.p] - h[n.p] - f + A + s - I),
        o && Oh(o, I, n, i - I < 20 || (o._isStart && I > 20)),
        (i -= i - I);
    }
    if ((x && ((u[x] = e || -0.001), e < 0 && (e = 0)), a)) {
      var P = e + i,
        k = a._isStart;
      (b = "scroll" + n.d2),
        Oh(
          a,
          P,
          n,
          (k && P > 20) ||
            (!k && (c ? Math.max(si[b], _s[b]) : a.parentNode[b]) <= P + 1)
        ),
        c &&
          ((h = ar(o)),
          c && (a.style[n.op.p] = h[n.op.p] - n.op.m - a._offset + Fi));
    }
    return (
      m &&
        M &&
        ((b = ar(M)),
        m.seek(d),
        (y = ar(M)),
        (m._caScrollDist = b[n.p] - y[n.p]),
        (e = (e / m._caScrollDist) * d)),
      m && m.seek(v),
      m ? e : Math.round(e)
    );
  },
  G3 = /(webkit|moz|length|cssText|inset)/i,
  o_ = function (e, t, i, n) {
    if (e.parentNode !== t) {
      var s = e.style,
        a,
        o;
      if (t === si) {
        (e._stOrig = s.cssText), (o = Qn(e));
        for (a in o)
          !+a &&
            !G3.test(a) &&
            o[a] &&
            typeof s[a] == "string" &&
            a !== "0" &&
            (s[a] = o[a]);
        (s.top = i), (s.left = n);
      } else s.cssText = e._stOrig;
      (Ye.core.getCache(e).uncache = 1), t.appendChild(e);
    }
  },
  ox = function (e, t, i) {
    var n = t,
      s = n;
    return function (a) {
      var o = Math.round(e());
      return (
        o !== n &&
          o !== s &&
          Math.abs(o - n) > 3 &&
          Math.abs(o - s) > 3 &&
          ((a = o), i && i()),
        (s = n),
        (n = a),
        a
      );
    };
  },
  Sh = function (e, t, i) {
    var n = {};
    (n[t.p] = "+=" + i), Ye.set(e, n);
  },
  a_ = function (e, t) {
    var i = Jr(e, t),
      n = "_scroll" + t.p2,
      s = function a(o, u, h, f, c) {
        var d = a.tween,
          m = u.onComplete,
          x = {};
        h = h || i();
        var v = ox(i, h, function () {
          d.kill(), (a.tween = 0);
        });
        return (
          (c = (f && c) || 0),
          (f = f || o - h),
          d && d.kill(),
          (u[n] = o),
          (u.modifiers = x),
          (x[n] = function () {
            return v(h + f * d.ratio + c * d.ratio * d.ratio);
          }),
          (u.onUpdate = function () {
            Lt.cache++, fr();
          }),
          (u.onComplete = function () {
            (a.tween = 0), m && m.call(d);
          }),
          (d = a.tween = Ye.to(e, u)),
          d
        );
      };
    return (
      (e[n] = i),
      (i.wheelHandler = function () {
        return s.tween && s.tween.kill() && (s.tween = 0);
      }),
      Pi(e, "wheel", i.wheelHandler),
      ut.isTouch && Pi(e, "touchmove", i.wheelHandler),
      s
    );
  },
  ut = (function () {
    function r(t, i) {
      Wa ||
        r.register(Ye) ||
        console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
        Gf(this),
        this.init(t, i);
    }
    var e = r.prototype;
    return (
      (e.init = function (i, n) {
        if (
          ((this.progress = this.start = 0),
          this.vars && this.kill(!0, !0),
          !_c)
        ) {
          this.update = this.refresh = this.kill = Ps;
          return;
        }
        i = t_(kn(i) || Ih(i) || i.nodeType ? { trigger: i } : i, xh);
        var s = i,
          a = s.onUpdate,
          o = s.toggleClass,
          u = s.id,
          h = s.onToggle,
          f = s.onRefresh,
          c = s.scrub,
          d = s.trigger,
          m = s.pin,
          x = s.pinSpacing,
          v = s.invalidateOnRefresh,
          b = s.anticipatePin,
          y = s.onScrubComplete,
          M = s.onSnapComplete,
          D = s.once,
          C = s.snap,
          A = s.pinReparent,
          I = s.pinSpacer,
          F = s.containerAnimation,
          P = s.fastScrollEnd,
          k = s.preventOverlaps,
          O =
            i.horizontal || (i.containerAnimation && i.horizontal !== !1)
              ? sn
              : yi,
          J = !c && c !== 0,
          ee = vn(i.scroller || kt),
          X = Ye.core.getCache(ee),
          j = Qo(ee),
          Y =
            ("pinType" in i
              ? i.pinType
              : $r(ee, "pinType") || (j && "fixed")) === "fixed",
          ie = [i.onEnter, i.onLeave, i.onEnterBack, i.onLeaveBack],
          Q = J && i.toggleActions.split(" "),
          V = "markers" in i ? i.markers : xh.markers,
          ve = j ? 0 : parseFloat(Qn(ee)["border" + O.p2 + pl]) || 0,
          U = this,
          oe =
            i.onRefreshInit &&
            function () {
              return i.onRefreshInit(U);
            },
          ue = R3(ee, j, O),
          fe = k3(ee, j),
          le = 0,
          be = 0,
          ce = 0,
          He = Jr(ee, O),
          Se,
          Oe,
          Me,
          Ke,
          Qe,
          Pe,
          ht,
          wt,
          dt,
          he,
          Et,
          ft,
          Bt,
          bt,
          G,
          N,
          pe,
          xe,
          we,
          Ce,
          We,
          H,
          ne,
          Re,
          Ae,
          ke,
          je,
          Ve,
          rt,
          lt,
          Ct,
          $,
          ge,
          ye,
          Ie,
          Ge,
          Mt,
          zt,
          Rt;
        if (
          ((U._startClamp = U._endClamp = !1),
          (U._dir = O),
          (b *= 45),
          (U.scroller = ee),
          (U.scroll = F ? F.time.bind(F) : He),
          (Ke = He()),
          (U.vars = i),
          (n = n || i.animation),
          "refreshPriority" in i &&
            ((qb = 1), i.refreshPriority === -9999 && (Rc = U)),
          (X.tweenScroll = X.tweenScroll || {
            top: a_(ee, yi),
            left: a_(ee, sn),
          }),
          (U.tweenTo = Se = X.tweenScroll[O.p]),
          (U.scrubDuration = function (ze) {
            (ge = Ih(ze) && ze),
              ge
                ? $
                  ? $.duration(ze)
                  : ($ = Ye.to(n, {
                      ease: "expo",
                      totalProgress: "+=0",
                      duration: ge,
                      paused: !0,
                      onComplete: function () {
                        return y && y(U);
                      },
                    }))
                : ($ && $.progress(1).kill(), ($ = 0));
          }),
          n &&
            ((n.vars.lazy = !1),
            (n._initted && !U.isReverted) ||
              (n.vars.immediateRender !== !1 &&
                i.immediateRender !== !1 &&
                n.duration() &&
                n.render(0, !0, !0)),
            (U.animation = n.pause()),
            (n.scrollTrigger = U),
            U.scrubDuration(c),
            (lt = 0),
            u || (u = n.vars.id)),
          C &&
            ((!Co(C) || C.push) && (C = { snapTo: C }),
            "scrollBehavior" in si.style &&
              Ye.set(j ? [si, _s] : ee, { scrollBehavior: "auto" }),
            Lt.forEach(function (ze) {
              return (
                rn(ze) &&
                ze.target === (j ? ti.scrollingElement || _s : ee) &&
                (ze.smooth = !1)
              );
            }),
            (Me = rn(C.snapTo)
              ? C.snapTo
              : C.snapTo === "labels"
              ? F3(n)
              : C.snapTo === "labelsDirectional"
              ? O3(n)
              : C.directional !== !1
              ? function (ze, yt) {
                  return Om(C.snapTo)(ze, nn() - be < 500 ? 0 : yt.direction);
                }
              : Ye.utils.snap(C.snapTo)),
            (ye = C.duration || { min: 0.1, max: 2 }),
            (ye = Co(ye) ? Ya(ye.min, ye.max) : Ya(ye, ye)),
            (Ie = Ye.delayedCall(C.delay || ge / 2 || 0.1, function () {
              var ze = He(),
                yt = nn() - be < 500,
                st = Se.tween;
              if (
                (yt || Math.abs(U.getVelocity()) < 10) &&
                !st &&
                !md &&
                le !== ze
              ) {
                var _t = (ze - Pe) / bt,
                  B = n && !J ? n.totalProgress() : _t,
                  te = yt ? 0 : ((B - Ct) / (nn() - kh)) * 1e3 || 0,
                  de = Ye.utils.clamp(-_t, 1 - _t, (Na(te / 2) * te) / 0.185),
                  se = _t + (C.inertia === !1 ? 0 : de),
                  me = Ya(0, 1, Me(se, U)),
                  Fe = Math.round(Pe + me * bt),
                  Ne = C,
                  it = Ne.onStart,
                  $e = Ne.onInterrupt,
                  nt = Ne.onComplete;
                if (ze <= ht && ze >= Pe && Fe !== ze) {
                  if (st && !st._initted && st.data <= Na(Fe - ze)) return;
                  C.inertia === !1 && (de = me - _t),
                    Se(
                      Fe,
                      {
                        duration: ye(
                          Na(
                            (Math.max(Na(se - B), Na(me - B)) * 0.185) /
                              te /
                              0.05 || 0
                          )
                        ),
                        ease: C.ease || "power3",
                        data: Na(Fe - ze),
                        onInterrupt: function () {
                          return Ie.restart(!0) && $e && $e(U);
                        },
                        onComplete: function () {
                          U.update(),
                            (le = He()),
                            (lt = Ct =
                              n && !J ? n.totalProgress() : U.progress),
                            M && M(U),
                            nt && nt(U);
                        },
                      },
                      ze,
                      de * bt,
                      Fe - ze - de * bt
                    ),
                    it && it(U, Se.tween);
                }
              } else U.isActive && le !== ze && Ie.restart(!0);
            }).pause())),
          u && (Wf[u] = U),
          (d = U.trigger = vn(d || (m !== !0 && m))),
          (Rt = d && d._gsap && d._gsap.stRevert),
          Rt && (Rt = Rt(U)),
          (m = m === !0 ? d : vn(m)),
          kn(o) && (o = { targets: d, className: o }),
          m &&
            (x === !1 ||
              x === Jn ||
              (x =
                !x &&
                m.parentNode &&
                m.parentNode.style &&
                Qn(m.parentNode).display === "flex"
                  ? !1
                  : _i),
            (U.pin = m),
            (Oe = Ye.core.getCache(m)),
            Oe.spacer
              ? (G = Oe.pinState)
              : (I &&
                  ((I = vn(I)),
                  I && !I.nodeType && (I = I.current || I.nativeElement),
                  (Oe.spacerIsNative = !!I),
                  I && (Oe.spacerState = yh(I))),
                (Oe.spacer = xe = I || ti.createElement("div")),
                xe.classList.add("pin-spacer"),
                u && xe.classList.add("pin-spacer-" + u),
                (Oe.pinState = G = yh(m))),
            i.force3D !== !1 && Ye.set(m, { force3D: !0 }),
            (U.spacer = xe = Oe.spacer),
            (rt = Qn(m)),
            (Re = rt[x + O.os2]),
            (Ce = Ye.getProperty(m)),
            (We = Ye.quickSetter(m, O.a, Fi)),
            Qp(m, xe, rt),
            (pe = yh(m))),
          V)
        ) {
          (ft = Co(V) ? t_(V, i_) : i_),
            (he = wh("scroller-start", u, ee, O, ft, 0)),
            (Et = wh("scroller-end", u, ee, O, ft, 0, he)),
            (we = he["offset" + O.op.d2]);
          var tt = vn($r(ee, "content") || ee);
          (wt = this.markerStart = wh("start", u, tt, O, ft, we, 0, F)),
            (dt = this.markerEnd = wh("end", u, tt, O, ft, we, 0, F)),
            F && (zt = Ye.quickSetter([wt, dt], O.a, Fi)),
            !Y &&
              !(Fs.length && $r(ee, "fixedMarkers") === !0) &&
              (I3(j ? si : ee),
              Ye.set([he, Et], { force3D: !0 }),
              (ke = Ye.quickSetter(he, O.a, Fi)),
              (Ve = Ye.quickSetter(Et, O.a, Fi)));
        }
        if (F) {
          var Te = F.vars.onUpdate,
            gt = F.vars.onUpdateParams;
          F.eventCallback("onUpdate", function () {
            U.update(0, 0, 1), Te && Te.apply(F, gt || []);
          });
        }
        if (
          ((U.previous = function () {
            return Pt[Pt.indexOf(U) - 1];
          }),
          (U.next = function () {
            return Pt[Pt.indexOf(U) + 1];
          }),
          (U.revert = function (ze, yt) {
            if (!yt) return U.kill(!0);
            var st = ze !== !1 || !U.enabled,
              _t = zi;
            st !== U.isReverted &&
              (st &&
                ((Ge = Math.max(He(), U.scroll.rec || 0)),
                (ce = U.progress),
                (Mt = n && n.progress())),
              wt &&
                [wt, dt, he, Et].forEach(function (B) {
                  return (B.style.display = st ? "none" : "block");
                }),
              st && ((zi = U), U.update(st)),
              m &&
                (!A || !U.isActive) &&
                (st ? V3(m, xe, G) : Qp(m, xe, Qn(m), Ae)),
              st || U.update(st),
              (zi = _t),
              (U.isReverted = st));
          }),
          (U.refresh = function (ze, yt, st, _t) {
            if (!((zi || !U.enabled) && !yt)) {
              if (m && ze && rs) {
                Pi(r, "scrollEnd", nx);
                return;
              }
              !tn && oe && oe(U),
                (zi = U),
                Se.tween && (Se.tween.kill(), (Se.tween = 0)),
                $ && $.pause(),
                v && n && n.revert({ kill: !1 }).invalidate(),
                U.isReverted || U.revert(!0, !0),
                (U._subPinOffset = !1);
              var B = ue(),
                te = fe(),
                de = F ? F.duration() : hr(ee, O),
                se = bt <= 0.01,
                me = 0,
                Fe = _t || 0,
                Ne = Co(st) ? st.end : i.end,
                it = i.endTrigger || d,
                $e = Co(st)
                  ? st.start
                  : i.start || (i.start === 0 || !d ? 0 : m ? "0 0" : "0 100%"),
                nt = (U.pinnedContainer =
                  i.pinnedContainer && vn(i.pinnedContainer, U)),
                pt = (d && Math.max(0, Pt.indexOf(U))) || 0,
                ot = pt,
                xt,
                Ot,
                Zt,
                ki,
                St,
                Je,
                ai,
                Jt,
                Ut,
                Gn,
                ni,
                un,
                Qt;
              for (
                V &&
                Co(st) &&
                ((un = Ye.getProperty(he, O.p)),
                (Qt = Ye.getProperty(Et, O.p)));
                ot--;

              )
                (Je = Pt[ot]),
                  Je.end || Je.refresh(0, 1) || (zi = U),
                  (ai = Je.pin),
                  ai &&
                    (ai === d || ai === m || ai === nt) &&
                    !Je.isReverted &&
                    (Gn || (Gn = []), Gn.unshift(Je), Je.revert(!0, !0)),
                  Je !== Pt[ot] && (pt--, ot--);
              for (
                rn($e) && ($e = $e(U)),
                  $e = Zv($e, "start", U),
                  Pe =
                    r_(
                      $e,
                      d,
                      B,
                      O,
                      He(),
                      wt,
                      he,
                      U,
                      te,
                      ve,
                      Y,
                      de,
                      F,
                      U._startClamp && "_startClamp"
                    ) || (m ? -0.001 : 0),
                  rn(Ne) && (Ne = Ne(U)),
                  kn(Ne) &&
                    !Ne.indexOf("+=") &&
                    (~Ne.indexOf(" ")
                      ? (Ne = (kn($e) ? $e.split(" ")[0] : "") + Ne)
                      : ((me = Fh(Ne.substr(2), B)),
                        (Ne = kn($e)
                          ? $e
                          : (F
                              ? Ye.utils.mapRange(
                                  0,
                                  F.duration(),
                                  F.scrollTrigger.start,
                                  F.scrollTrigger.end,
                                  Pe
                                )
                              : Pe) + me),
                        (it = d))),
                  Ne = Zv(Ne, "end", U),
                  ht =
                    Math.max(
                      Pe,
                      r_(
                        Ne || (it ? "100% 0" : de),
                        it,
                        B,
                        O,
                        He() + me,
                        dt,
                        Et,
                        U,
                        te,
                        ve,
                        Y,
                        de,
                        F,
                        U._endClamp && "_endClamp"
                      )
                    ) || -0.001,
                  me = 0,
                  ot = pt;
                ot--;

              )
                (Je = Pt[ot]),
                  (ai = Je.pin),
                  ai &&
                    Je.start - Je._pinPush <= Pe &&
                    !F &&
                    Je.end > 0 &&
                    ((xt =
                      Je.end -
                      (U._startClamp ? Math.max(0, Je.start) : Je.start)),
                    ((ai === d && Je.start - Je._pinPush < Pe) || ai === nt) &&
                      isNaN($e) &&
                      (me += xt * (1 - Je.progress)),
                    ai === m && (Fe += xt));
              if (
                ((Pe += me),
                (ht += me),
                U._startClamp && (U._startClamp += me),
                U._endClamp &&
                  !tn &&
                  ((U._endClamp = ht || -0.001),
                  (ht = Math.min(ht, hr(ee, O)))),
                (bt = ht - Pe || ((Pe -= 0.01) && 0.001)),
                se &&
                  (ce = Ye.utils.clamp(0, 1, Ye.utils.normalize(Pe, ht, Ge))),
                (U._pinPush = Fe),
                wt &&
                  me &&
                  ((xt = {}),
                  (xt[O.a] = "+=" + me),
                  nt && (xt[O.p] = "-=" + He()),
                  Ye.set([wt, dt], xt)),
                m)
              )
                (xt = Qn(m)),
                  (ki = O === yi),
                  (Zt = He()),
                  (H = parseFloat(Ce(O.a)) + Fe),
                  !de &&
                    ht > 1 &&
                    ((ni = (j ? ti.scrollingElement || _s : ee).style),
                    (ni = {
                      style: ni,
                      value: ni["overflow" + O.a.toUpperCase()],
                    }),
                    j &&
                      Qn(si)["overflow" + O.a.toUpperCase()] !== "scroll" &&
                      (ni.style["overflow" + O.a.toUpperCase()] = "scroll")),
                  Qp(m, xe, xt),
                  (pe = yh(m)),
                  (Ot = ar(m, !0)),
                  (Jt = Y && Jr(ee, ki ? sn : yi)()),
                  x &&
                    ((Ae = [x + O.os2, bt + Fe + Fi]),
                    (Ae.t = xe),
                    (ot = x === _i ? Hf(m, O) + bt + Fe : 0),
                    ot && Ae.push(O.d, ot + Fi),
                    nl(Ae),
                    nt &&
                      Pt.forEach(function (Ti) {
                        Ti.pin === nt &&
                          Ti.vars.pinSpacing !== !1 &&
                          (Ti._subPinOffset = !0);
                      }),
                    Y && He(Ge)),
                  Y &&
                    ((St = {
                      top: Ot.top + (ki ? Zt - Pe : Jt) + Fi,
                      left: Ot.left + (ki ? Jt : Zt - Pe) + Fi,
                      boxSizing: "border-box",
                      position: "fixed",
                    }),
                    (St[Go] = St["max" + pl] = Math.ceil(Ot.width) + Fi),
                    (St[Ho] = St["max" + Fm] = Math.ceil(Ot.height) + Fi),
                    (St[Jn] =
                      St[Jn + Ac] =
                      St[Jn + Dc] =
                      St[Jn + Lc] =
                      St[Jn + Pc] =
                        "0"),
                    (St[_i] = xt[_i]),
                    (St[_i + Ac] = xt[_i + Ac]),
                    (St[_i + Dc] = xt[_i + Dc]),
                    (St[_i + Lc] = xt[_i + Lc]),
                    (St[_i + Pc] = xt[_i + Pc]),
                    (N = U3(G, St, A)),
                    tn && He(0)),
                  n
                    ? ((Ut = n._initted),
                      $p(1),
                      n.render(n.duration(), !0, !0),
                      (ne = Ce(O.a) - H + bt + Fe),
                      (je = Math.abs(bt - ne) > 1),
                      Y && je && N.splice(N.length - 2, 2),
                      n.render(0, !0, !0),
                      Ut || n.invalidate(!0),
                      n.parent || n.totalTime(n.totalTime()),
                      $p(0))
                    : (ne = bt),
                  ni &&
                    (ni.value
                      ? (ni.style["overflow" + O.a.toUpperCase()] = ni.value)
                      : ni.style.removeProperty("overflow-" + O.a));
              else if (d && He() && !F)
                for (Ot = d.parentNode; Ot && Ot !== si; )
                  Ot._pinOffset &&
                    ((Pe -= Ot._pinOffset), (ht -= Ot._pinOffset)),
                    (Ot = Ot.parentNode);
              Gn &&
                Gn.forEach(function (Ti) {
                  return Ti.revert(!1, !0);
                }),
                (U.start = Pe),
                (U.end = ht),
                (Ke = Qe = tn ? Ge : He()),
                !F && !tn && (Ke < Ge && He(Ge), (U.scroll.rec = 0)),
                U.revert(!1, !0),
                (be = nn()),
                Ie &&
                  ((le = -1), U.isActive && He(Pe + bt * ce), Ie.restart(!0)),
                (zi = 0),
                n &&
                  J &&
                  (n._initted || Mt) &&
                  n.progress() !== Mt &&
                  n.progress(Mt || 0, !0).render(n.time(), !0, !0),
                (se || ce !== U.progress || F) &&
                  (n &&
                    !J &&
                    n.totalProgress(
                      F && Pe < -0.001 && !ce
                        ? Ye.utils.normalize(Pe, ht, 0)
                        : ce,
                      !0
                    ),
                  (U.progress = se || (Ke - Pe) / bt === ce ? 0 : ce)),
                m && x && (xe._pinOffset = Math.round(U.progress * ne)),
                $ && $.invalidate(),
                isNaN(un) ||
                  ((un -= Ye.getProperty(he, O.p)),
                  (Qt -= Ye.getProperty(Et, O.p)),
                  Sh(he, O, un),
                  Sh(wt, O, un - (_t || 0)),
                  Sh(Et, O, Qt),
                  Sh(dt, O, Qt - (_t || 0))),
                se && !tn && U.update(),
                f && !tn && !Bt && ((Bt = !0), f(U), (Bt = !1));
            }
          }),
          (U.getVelocity = function () {
            return ((He() - Qe) / (nn() - kh)) * 1e3 || 0;
          }),
          (U.endAnimation = function () {
            dc(U.callbackAnimation),
              n &&
                ($
                  ? $.progress(1)
                  : n.paused()
                  ? J || dc(n, U.direction < 0, 1)
                  : dc(n, n.reversed()));
          }),
          (U.labelToScroll = function (ze) {
            return (
              (n &&
                n.labels &&
                (Pe || U.refresh() || Pe) +
                  (n.labels[ze] / n.duration()) * bt) ||
              0
            );
          }),
          (U.getTrailing = function (ze) {
            var yt = Pt.indexOf(U),
              st =
                U.direction > 0 ? Pt.slice(0, yt).reverse() : Pt.slice(yt + 1);
            return (
              kn(ze)
                ? st.filter(function (_t) {
                    return _t.vars.preventOverlaps === ze;
                  })
                : st
            ).filter(function (_t) {
              return U.direction > 0 ? _t.end <= Pe : _t.start >= ht;
            });
          }),
          (U.update = function (ze, yt, st) {
            if (!(F && !st && !ze)) {
              var _t = tn === !0 ? Ge : U.scroll(),
                B = ze ? 0 : (_t - Pe) / bt,
                te = B < 0 ? 0 : B > 1 ? 1 : B || 0,
                de = U.progress,
                se,
                me,
                Fe,
                Ne,
                it,
                $e,
                nt,
                pt;
              if (
                (yt &&
                  ((Qe = Ke),
                  (Ke = F ? He() : _t),
                  C && ((Ct = lt), (lt = n && !J ? n.totalProgress() : te))),
                b &&
                  !te &&
                  m &&
                  !zi &&
                  !gh &&
                  rs &&
                  Pe < _t + ((_t - Qe) / (nn() - kh)) * b &&
                  (te = 1e-4),
                te !== de && U.enabled)
              ) {
                if (
                  ((se = U.isActive = !!te && te < 1),
                  (me = !!de && de < 1),
                  ($e = se !== me),
                  (it = $e || !!te != !!de),
                  (U.direction = te > de ? 1 : -1),
                  (U.progress = te),
                  it &&
                    !zi &&
                    ((Fe = te && !de ? 0 : te === 1 ? 1 : de === 1 ? 2 : 3),
                    J &&
                      ((Ne =
                        (!$e && Q[Fe + 1] !== "none" && Q[Fe + 1]) || Q[Fe]),
                      (pt =
                        n &&
                        (Ne === "complete" || Ne === "reset" || Ne in n)))),
                  k &&
                    ($e || pt) &&
                    (pt || c || !n) &&
                    (rn(k)
                      ? k(U)
                      : U.getTrailing(k).forEach(function (Zt) {
                          return Zt.endAnimation();
                        })),
                  J ||
                    ($ && !zi && !gh
                      ? ($._dp._time - $._start !== $._time &&
                          $.render($._dp._time - $._start),
                        $.resetTo
                          ? $.resetTo("totalProgress", te, n._tTime / n._tDur)
                          : (($.vars.totalProgress = te),
                            $.invalidate().restart()))
                      : n && n.totalProgress(te, !!(zi && (be || ze)))),
                  m)
                ) {
                  if ((ze && x && (xe.style[x + O.os2] = Re), !Y))
                    We(bc(H + ne * te));
                  else if (it) {
                    if (
                      ((nt =
                        !ze && te > de && ht + 1 > _t && _t + 1 >= hr(ee, O)),
                      A)
                    )
                      if (!ze && (se || nt)) {
                        var ot = ar(m, !0),
                          xt = _t - Pe;
                        o_(
                          m,
                          si,
                          ot.top + (O === yi ? xt : 0) + Fi,
                          ot.left + (O === yi ? 0 : xt) + Fi
                        );
                      } else o_(m, xe);
                    nl(se || nt ? N : pe),
                      (je && te < 1 && se) ||
                        We(H + (te === 1 && !nt ? ne : 0));
                  }
                }
                C && !Se.tween && !zi && !gh && Ie.restart(!0),
                  o &&
                    ($e || (D && te && (te < 1 || !Yp))) &&
                    Kh(o.targets).forEach(function (Zt) {
                      return Zt.classList[se || D ? "add" : "remove"](
                        o.className
                      );
                    }),
                  a && !J && !ze && a(U),
                  it && !zi
                    ? (J &&
                        (pt &&
                          (Ne === "complete"
                            ? n.pause().totalProgress(1)
                            : Ne === "reset"
                            ? n.restart(!0).pause()
                            : Ne === "restart"
                            ? n.restart(!0)
                            : n[Ne]()),
                        a && a(U)),
                      ($e || !Yp) &&
                        (h && $e && Zp(U, h),
                        ie[Fe] && Zp(U, ie[Fe]),
                        D && (te === 1 ? U.kill(!1, 1) : (ie[Fe] = 0)),
                        $e ||
                          ((Fe = te === 1 ? 1 : 3), ie[Fe] && Zp(U, ie[Fe]))),
                      P &&
                        !se &&
                        Math.abs(U.getVelocity()) > (Ih(P) ? P : 2500) &&
                        (dc(U.callbackAnimation),
                        $
                          ? $.progress(1)
                          : dc(n, Ne === "reverse" ? 1 : !te, 1)))
                    : J && a && !zi && a(U);
              }
              if (Ve) {
                var Ot = F ? (_t / F.duration()) * (F._caScrollDist || 0) : _t;
                ke(Ot + (he._isFlipped ? 1 : 0)), Ve(Ot);
              }
              zt && zt((-_t / F.duration()) * (F._caScrollDist || 0));
            }
          }),
          (U.enable = function (ze, yt) {
            U.enabled ||
              ((U.enabled = !0),
              Pi(ee, "resize", xc),
              Pi(j ? ti : ee, "scroll", Ba),
              oe && Pi(r, "refreshInit", oe),
              ze !== !1 && ((U.progress = ce = 0), (Ke = Qe = le = He())),
              yt !== !1 && U.refresh());
          }),
          (U.getTween = function (ze) {
            return ze && Se ? Se.tween : $;
          }),
          (U.setPositions = function (ze, yt, st, _t) {
            if (F) {
              var B = F.scrollTrigger,
                te = F.duration(),
                de = B.end - B.start;
              (ze = B.start + (de * ze) / te), (yt = B.start + (de * yt) / te);
            }
            U.refresh(
              !1,
              !1,
              {
                start: Jv(ze, st && !!U._startClamp),
                end: Jv(yt, st && !!U._endClamp),
              },
              _t
            ),
              U.update();
          }),
          (U.adjustPinSpacing = function (ze) {
            if (Ae && ze) {
              var yt = Ae.indexOf(O.d) + 1;
              (Ae[yt] = parseFloat(Ae[yt]) + ze + Fi),
                (Ae[1] = parseFloat(Ae[1]) + ze + Fi),
                nl(Ae);
            }
          }),
          (U.disable = function (ze, yt) {
            if (
              U.enabled &&
              (ze !== !1 && U.revert(!0, !0),
              (U.enabled = U.isActive = !1),
              yt || ($ && $.pause()),
              (Ge = 0),
              Oe && (Oe.uncache = 1),
              oe && Di(r, "refreshInit", oe),
              Ie && (Ie.pause(), Se.tween && Se.tween.kill() && (Se.tween = 0)),
              !j)
            ) {
              for (var st = Pt.length; st--; )
                if (Pt[st].scroller === ee && Pt[st] !== U) return;
              Di(ee, "resize", xc), Di(ee, "scroll", Ba);
            }
          }),
          (U.kill = function (ze, yt) {
            U.disable(ze, yt), $ && !yt && $.kill(), u && delete Wf[u];
            var st = Pt.indexOf(U);
            st >= 0 && Pt.splice(st, 1),
              st === en && Nh > 0 && en--,
              (st = 0),
              Pt.forEach(function (_t) {
                return _t.scroller === U.scroller && (st = 1);
              }),
              st || tn || (U.scroll.rec = 0),
              n &&
                ((n.scrollTrigger = null),
                ze && n.revert({ kill: !1 }),
                yt || n.kill()),
              wt &&
                [wt, dt, he, Et].forEach(function (_t) {
                  return _t.parentNode && _t.parentNode.removeChild(_t);
                }),
              Rc === U && (Rc = 0),
              m &&
                (Oe && (Oe.uncache = 1),
                (st = 0),
                Pt.forEach(function (_t) {
                  return _t.pin === m && st++;
                }),
                st || (Oe.spacer = 0)),
              i.onKill && i.onKill(U);
          }),
          Pt.push(U),
          U.enable(!1, !1),
          Rt && Rt(U),
          n && n.add && !bt)
        ) {
          var mt = U.update;
          (U.update = function () {
            (U.update = mt), Pe || ht || U.refresh();
          }),
            Ye.delayedCall(0.01, U.update),
            (bt = 0.01),
            (Pe = ht = 0);
        } else U.refresh();
        m && B3();
      }),
      (r.register = function (i) {
        return (
          Wa ||
            ((Ye = i || Jb()),
            Zb() && window.document && r.enable(),
            (Wa = _c)),
          Wa
        );
      }),
      (r.defaults = function (i) {
        if (i) for (var n in i) xh[n] = i[n];
        return xh;
      }),
      (r.disable = function (i, n) {
        (_c = 0),
          Pt.forEach(function (a) {
            return a[n ? "kill" : "disable"](i);
          }),
          Di(kt, "wheel", Ba),
          Di(ti, "scroll", Ba),
          clearInterval(mh),
          Di(ti, "touchcancel", Ps),
          Di(si, "touchstart", Ps),
          _h(Di, ti, "pointerdown,touchstart,mousedown", Qv),
          _h(Di, ti, "pointerup,touchend,mouseup", e_),
          Yh.kill(),
          vh(Di);
        for (var s = 0; s < Lt.length; s += 3)
          bh(Di, Lt[s], Lt[s + 1]), bh(Di, Lt[s], Lt[s + 2]);
      }),
      (r.enable = function () {
        if (
          ((kt = window),
          (ti = document),
          (_s = ti.documentElement),
          (si = ti.body),
          Ye &&
            ((Kh = Ye.utils.toArray),
            (Ya = Ye.utils.clamp),
            (Gf = Ye.core.context || Ps),
            ($p = Ye.core.suppressOverwrites || Ps),
            (Rm = kt.history.scrollRestoration || "auto"),
            (jf = kt.pageYOffset),
            Ye.core.globals("ScrollTrigger", r),
            si))
        ) {
          (_c = 1),
            L3(),
            pi.register(Ye),
            (r.isTouch = pi.isTouch),
            (Vr =
              pi.isTouch &&
              /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent)),
            Pi(kt, "wheel", Ba),
            (jb = [kt, ti, _s, si]),
            Ye.matchMedia
              ? ((r.matchMedia = function (u) {
                  var h = Ye.matchMedia(),
                    f;
                  for (f in u) h.add(f, u[f]);
                  return h;
                }),
                Ye.addEventListener("matchMediaInit", function () {
                  return Nm();
                }),
                Ye.addEventListener("matchMediaRevert", function () {
                  return sx();
                }),
                Ye.addEventListener("matchMedia", function () {
                  ko(0, 1), ta("matchMedia");
                }),
                Ye.matchMedia("(orientation: portrait)", function () {
                  return Jp(), Jp;
                }))
              : console.warn("Requires GSAP 3.11.0 or later"),
            Jp(),
            Pi(ti, "scroll", Ba);
          var i = si.style,
            n = i.borderTopStyle,
            s = Ye.core.Animation.prototype,
            a,
            o;
          for (
            s.revert ||
              Object.defineProperty(s, "revert", {
                value: function () {
                  return this.time(-0.01, !0);
                },
              }),
              i.borderTopStyle = "solid",
              a = ar(si),
              yi.m = Math.round(a.top + yi.sc()) || 0,
              sn.m = Math.round(a.left + sn.sc()) || 0,
              n ? (i.borderTopStyle = n) : i.removeProperty("border-top-style"),
              mh = setInterval(n_, 250),
              Ye.delayedCall(0.5, function () {
                return (gh = 0);
              }),
              Pi(ti, "touchcancel", Ps),
              Pi(si, "touchstart", Ps),
              _h(Pi, ti, "pointerdown,touchstart,mousedown", Qv),
              _h(Pi, ti, "pointerup,touchend,mouseup", e_),
              Uf = Ye.utils.checkPrefix("transform"),
              Bh.push(Uf),
              Wa = nn(),
              Yh = Ye.delayedCall(0.2, ko).pause(),
              ja = [
                ti,
                "visibilitychange",
                function () {
                  var u = kt.innerWidth,
                    h = kt.innerHeight;
                  ti.hidden
                    ? ((Yv = u), (Kv = h))
                    : (Yv !== u || Kv !== h) && xc();
                },
                ti,
                "DOMContentLoaded",
                ko,
                kt,
                "load",
                ko,
                kt,
                "resize",
                xc,
              ],
              vh(Pi),
              Pt.forEach(function (u) {
                return u.enable(0, 1);
              }),
              o = 0;
            o < Lt.length;
            o += 3
          )
            bh(Di, Lt[o], Lt[o + 1]), bh(Di, Lt[o], Lt[o + 2]);
        }
      }),
      (r.config = function (i) {
        "limitCallbacks" in i && (Yp = !!i.limitCallbacks);
        var n = i.syncInterval;
        (n && clearInterval(mh)) || ((mh = n) && setInterval(n_, n)),
          "ignoreMobileResize" in i &&
            ($b = r.isTouch === 1 && i.ignoreMobileResize),
          "autoRefreshEvents" in i &&
            (vh(Di) || vh(Pi, i.autoRefreshEvents || "none"),
            (Xb = (i.autoRefreshEvents + "").indexOf("resize") === -1));
      }),
      (r.scrollerProxy = function (i, n) {
        var s = vn(i),
          a = Lt.indexOf(s),
          o = Qo(s);
        ~a && Lt.splice(a, o ? 6 : 2),
          n && (o ? Fs.unshift(kt, n, si, n, _s, n) : Fs.unshift(s, n));
      }),
      (r.clearMatchMedia = function (i) {
        Pt.forEach(function (n) {
          return n._ctx && n._ctx.query === i && n._ctx.kill(!0, !0);
        });
      }),
      (r.isInViewport = function (i, n, s) {
        var a = (kn(i) ? vn(i) : i).getBoundingClientRect(),
          o = a[s ? Go : Ho] * n || 0;
        return s
          ? a.right - o > 0 && a.left + o < kt.innerWidth
          : a.bottom - o > 0 && a.top + o < kt.innerHeight;
      }),
      (r.positionInViewport = function (i, n, s) {
        kn(i) && (i = vn(i));
        var a = i.getBoundingClientRect(),
          o = a[s ? Go : Ho],
          u =
            n == null
              ? o / 2
              : n in Zh
              ? Zh[n] * o
              : ~n.indexOf("%")
              ? (parseFloat(n) * o) / 100
              : parseFloat(n) || 0;
        return s ? (a.left + u) / kt.innerWidth : (a.top + u) / kt.innerHeight;
      }),
      (r.killAll = function (i) {
        if (
          (Pt.slice(0).forEach(function (s) {
            return s.vars.id !== "ScrollSmoother" && s.kill();
          }),
          i !== !0)
        ) {
          var n = ea.killAll || [];
          (ea = {}),
            n.forEach(function (s) {
              return s();
            });
        }
      }),
      r
    );
  })();
ut.version = "3.12.1";
ut.saveStyles = function (r) {
  return r
    ? Kh(r).forEach(function (e) {
        if (e && e.style) {
          var t = Rn.indexOf(e);
          t >= 0 && Rn.splice(t, 5),
            Rn.push(
              e,
              e.style.cssText,
              e.getBBox && e.getAttribute("transform"),
              Ye.core.getCache(e),
              Gf()
            );
        }
      })
    : Rn;
};
ut.revert = function (r, e) {
  return Nm(!r, e);
};
ut.create = function (r, e) {
  return new ut(r, e);
};
ut.refresh = function (r) {
  return r ? xc() : (Wa || ut.register()) && ko(!0);
};
ut.update = function (r) {
  return ++Lt.cache && fr(r === !0 ? 2 : 0);
};
ut.clearScrollMemory = rx;
ut.maxScroll = function (r, e) {
  return hr(r, e ? sn : yi);
};
ut.getScrollFunc = function (r, e) {
  return Jr(vn(r), e ? sn : yi);
};
ut.getById = function (r) {
  return Wf[r];
};
ut.getAll = function () {
  return Pt.filter(function (r) {
    return r.vars.id !== "ScrollSmoother";
  });
};
ut.isScrolling = function () {
  return !!rs;
};
ut.snapDirectional = Om;
ut.addEventListener = function (r, e) {
  var t = ea[r] || (ea[r] = []);
  ~t.indexOf(e) || t.push(e);
};
ut.removeEventListener = function (r, e) {
  var t = ea[r],
    i = t && t.indexOf(e);
  i >= 0 && t.splice(i, 1);
};
ut.batch = function (r, e) {
  var t = [],
    i = {},
    n = e.interval || 0.016,
    s = e.batchMax || 1e9,
    a = function (h, f) {
      var c = [],
        d = [],
        m = Ye.delayedCall(n, function () {
          f(c, d), (c = []), (d = []);
        }).pause();
      return function (x) {
        c.length || m.restart(!0),
          c.push(x.trigger),
          d.push(x),
          s <= c.length && m.progress(1);
      };
    },
    o;
  for (o in e)
    i[o] =
      o.substr(0, 2) === "on" && rn(e[o]) && o !== "onRefreshInit"
        ? a(o, e[o])
        : e[o];
  return (
    rn(s) &&
      ((s = s()),
      Pi(ut, "refresh", function () {
        return (s = e.batchMax());
      })),
    Kh(r).forEach(function (u) {
      var h = {};
      for (o in i) h[o] = i[o];
      (h.trigger = u), t.push(ut.create(h));
    }),
    t
  );
};
var l_ = function (e, t, i, n) {
    return (
      t > n ? e(n) : t < 0 && e(0),
      i > n ? (n - t) / (i - t) : i < 0 ? t / (t - i) : 1
    );
  },
  ef = function r(e, t) {
    t === !0
      ? e.style.removeProperty("touch-action")
      : (e.style.touchAction =
          t === !0
            ? "auto"
            : t
            ? "pan-" + t + (pi.isTouch ? " pinch-zoom" : "")
            : "none"),
      e === _s && r(si, t);
  },
  Mh = { auto: 1, scroll: 1 },
  H3 = function (e) {
    var t = e.event,
      i = e.target,
      n = e.axis,
      s = (t.changedTouches ? t.changedTouches[0] : t).target,
      a = s._gsap || Ye.core.getCache(s),
      o = nn(),
      u;
    if (!a._isScrollT || o - a._isScrollT > 2e3) {
      for (
        ;
        s &&
        s !== si &&
        ((s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth) ||
          !(Mh[(u = Qn(s)).overflowY] || Mh[u.overflowX]));

      )
        s = s.parentNode;
      (a._isScroll =
        s &&
        s !== i &&
        !Qo(s) &&
        (Mh[(u = Qn(s)).overflowY] || Mh[u.overflowX])),
        (a._isScrollT = o);
    }
    (a._isScroll || n === "x") && (t.stopPropagation(), (t._gsapAllow = !0));
  },
  ax = function (e, t, i, n) {
    return pi.create({
      target: e,
      capture: !0,
      debounce: !1,
      lockAxis: !0,
      type: t,
      onWheel: (n = n && H3),
      onPress: n,
      onDrag: n,
      onScroll: n,
      onEnable: function () {
        return i && Pi(ti, pi.eventTypes[0], u_, !1, !0);
      },
      onDisable: function () {
        return Di(ti, pi.eventTypes[0], u_, !0);
      },
    });
  },
  W3 = /(input|label|select|textarea)/i,
  c_,
  u_ = function (e) {
    var t = W3.test(e.target.tagName);
    (t || c_) && ((e._gsapAllow = !0), (c_ = t));
  },
  j3 = function (e) {
    Co(e) || (e = {}),
      (e.preventDefault = e.isNormalizer = e.allowClicks = !0),
      e.type || (e.type = "wheel,touch"),
      (e.debounce = !!e.debounce),
      (e.id = e.id || "normalizer");
    var t = e,
      i = t.normalizeScrollX,
      n = t.momentum,
      s = t.allowNestedScroll,
      a = t.onRelease,
      o,
      u,
      h = vn(e.target) || _s,
      f = Ye.core.globals().ScrollSmoother,
      c = f && f.get(),
      d =
        Vr &&
        ((e.content && vn(e.content)) ||
          (c && e.content !== !1 && !c.smooth() && c.content())),
      m = Jr(h, yi),
      x = Jr(h, sn),
      v = 1,
      b =
        (pi.isTouch && kt.visualViewport
          ? kt.visualViewport.scale * kt.visualViewport.width
          : kt.outerWidth) / kt.innerWidth,
      y = 0,
      M = rn(n)
        ? function () {
            return n(o);
          }
        : function () {
            return n || 2.8;
          },
      D,
      C,
      A = ax(h, e.type, !0, s),
      I = function () {
        return (C = !1);
      },
      F = Ps,
      P = Ps,
      k = function () {
        (u = hr(h, yi)),
          (P = Ya(Vr ? 1 : 0, u)),
          i && (F = Ya(0, hr(h, sn))),
          (D = Wo);
      },
      O = function () {
        (d._gsap.y = bc(parseFloat(d._gsap.y) + m.offset) + "px"),
          (d.style.transform =
            "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
            parseFloat(d._gsap.y) +
            ", 0, 1)"),
          (m.offset = m.cacheID = 0);
      },
      J = function () {
        if (C) {
          requestAnimationFrame(I);
          var V = bc(o.deltaY / 2),
            ve = P(m.v - V);
          if (d && ve !== m.v + m.offset) {
            m.offset = ve - m.v;
            var U = bc((parseFloat(d && d._gsap.y) || 0) - m.offset);
            (d.style.transform =
              "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
              U +
              ", 0, 1)"),
              (d._gsap.y = U + "px"),
              (m.cacheID = Lt.cache),
              fr();
          }
          return !0;
        }
        m.offset && O(), (C = !0);
      },
      ee,
      X,
      j,
      Y,
      ie = function () {
        k(),
          ee.isActive() &&
            ee.vars.scrollY > u &&
            (m() > u ? ee.progress(1) && m(u) : ee.resetTo("scrollY", u));
      };
    return (
      d && Ye.set(d, { y: "+=0" }),
      (e.ignoreCheck = function (Q) {
        return (
          (Vr && Q.type === "touchmove" && J()) ||
          (v > 1.05 && Q.type !== "touchstart") ||
          o.isGesturing ||
          (Q.touches && Q.touches.length > 1)
        );
      }),
      (e.onPress = function () {
        C = !1;
        var Q = v;
        (v = bc(((kt.visualViewport && kt.visualViewport.scale) || 1) / b)),
          ee.pause(),
          Q !== v && ef(h, v > 1.01 ? !0 : i ? !1 : "x"),
          (X = x()),
          (j = m()),
          k(),
          (D = Wo);
      }),
      (e.onRelease = e.onGestureStart =
        function (Q, V) {
          if ((m.offset && O(), !V)) Y.restart(!0);
          else {
            Lt.cache++;
            var ve = M(),
              U,
              oe;
            i &&
              ((U = x()),
              (oe = U + (ve * 0.05 * -Q.velocityX) / 0.227),
              (ve *= l_(x, U, oe, hr(h, sn))),
              (ee.vars.scrollX = F(oe))),
              (U = m()),
              (oe = U + (ve * 0.05 * -Q.velocityY) / 0.227),
              (ve *= l_(m, U, oe, hr(h, yi))),
              (ee.vars.scrollY = P(oe)),
              ee.invalidate().duration(ve).play(0.01),
              ((Vr && ee.vars.scrollY >= u) || U >= u - 1) &&
                Ye.to({}, { onUpdate: ie, duration: ve });
          }
          a && a(Q);
        }),
      (e.onWheel = function () {
        ee._ts && ee.pause(), nn() - y > 1e3 && ((D = 0), (y = nn()));
      }),
      (e.onChange = function (Q, V, ve, U, oe) {
        if (
          (Wo !== D && k(),
          V && i && x(F(U[2] === V ? X + (Q.startX - Q.x) : x() + V - U[1])),
          ve)
        ) {
          m.offset && O();
          var ue = oe[2] === ve,
            fe = ue ? j + Q.startY - Q.y : m() + ve - oe[1],
            le = P(fe);
          ue && fe !== le && (j += le - fe), m(le);
        }
        (ve || V) && fr();
      }),
      (e.onEnable = function () {
        ef(h, i ? !1 : "x"),
          ut.addEventListener("refresh", ie),
          Pi(kt, "resize", ie),
          m.smooth &&
            ((m.target.style.scrollBehavior = "auto"),
            (m.smooth = x.smooth = !1)),
          A.enable();
      }),
      (e.onDisable = function () {
        ef(h, !0),
          Di(kt, "resize", ie),
          ut.removeEventListener("refresh", ie),
          A.kill();
      }),
      (e.lockAxis = e.lockAxis !== !1),
      (o = new pi(e)),
      (o.iOS = Vr),
      Vr && !m() && m(1),
      Vr && Ye.ticker.add(Ps),
      (Y = o._dc),
      (ee = Ye.to(o, {
        ease: "power4",
        paused: !0,
        scrollX: i ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        modifiers: {
          scrollY: ox(m, m(), function () {
            return ee.pause();
          }),
        },
        onUpdate: fr,
        onComplete: Y.vars.onComplete,
      })),
      o
    );
  };
ut.sort = function (r) {
  return Pt.sort(
    r ||
      function (e, t) {
        return (
          (e.vars.refreshPriority || 0) * -1e6 +
          e.start -
          (t.start + (t.vars.refreshPriority || 0) * -1e6)
        );
      }
  );
};
ut.observe = function (r) {
  return new pi(r);
};
ut.normalizeScroll = function (r) {
  if (typeof r > "u") return Ln;
  if (r === !0 && Ln) return Ln.enable();
  if (r === !1) return Ln && Ln.kill();
  var e = r instanceof pi ? r : j3(r);
  return Ln && Ln.target === e.target && Ln.kill(), Qo(e.target) && (Ln = e), e;
};
ut.core = {
  _getVelocityProp: zf,
  _inputObserver: ax,
  _scrollers: Lt,
  _proxies: Fs,
  bridge: {
    ss: function () {
      rs || ta("scrollStart"), (rs = nn());
    },
    ref: function () {
      return zi;
    },
  },
};
Jb() && Ye.registerPlugin(ut);
const Ja = class Ja {
  static init(e = !1, t = {}, i = !0) {
    e ? this.scrollBody(t) : this.scrollContainer(t),
      De.on("scroll:lock", () => this.lock()),
      De.on("scroll:unlock", () => this.unlock()),
      (E.SmoothScroll = this),
      i && (this.scrollbar = new q3(this.Lenis)),
      this.lock();
  }
  static scrollTo(e, t = {}) {
    this.Lenis.scrollTo(e, t);
  }
  static lock() {
    E.body.classList.remove("smoothscroll-enabled"), this.Lenis.stop();
  }
  static unlock() {
    E.body.classList.add("smoothscroll-enabled"), this.Lenis.start();
  }
  static scrollBody(e = {}) {
    const t = Object.assign({}, e);
    (this.Lenis = new qv(t)),
      (this.isBody = !0),
      this.configureScrollTrigger(),
      E.body.classList.add("smoothscroll-body"),
      E.RAFCollection.remove(this.onRAF),
      E.RAFCollection.add(this.onRAF, 0);
  }
  static scrollContainer(e = {}) {
    const t = Object.assign(
      {
        wrapper: at(".scroll-container"),
        content: at(".scroll-container > div"),
      },
      e
    );
    (this.Lenis = new qv(t)),
      (this.isBody = !1),
      this.configureScrollTrigger(),
      E.body.classList.remove("smoothscroll-body"),
      E.RAFCollection.remove(this.onRAF),
      E.RAFCollection.add(this.onRAF, 0);
  }
  static configureScrollTrigger() {
    const e = at(".scroll-container");
    this.isBody
      ? ut.defaults({ scroller: window })
      : ut.defaults({ scroller: e }),
      this.Lenis.on("scroll", ut.update),
      ut.scrollerProxy(e, {
        scrollTop: (t) => (
          arguments.length &&
            (this.isBody ? (E.html.scrollTop = t) : (e.scrollTop = t)),
          this.isBody ? E.html.scrollTop : this.Lenis.scroll
        ),
        getBoundingClientRect() {
          return { top: 0, left: 0, width: E.window.w, height: E.window.h };
        },
      });
  }
};
q(Ja, "Lenis", null),
  q(Ja, "isBody", null),
  q(Ja, "onRAF", (e) => {
    Ja.Lenis.raf(e * 1e3);
  });
let fl = Ja;
class q3 {
  constructor(e) {
    q(this, "transform", () => {
      this.mouseDown ||
        (this.position =
          (this.controller.scroll / this.controller.limit) *
          (E.window.h - this.handleElHeight)),
        (this.handleEl.style.transform = `translate(0px, ${this.position}px)`);
    });
    q(this, "onScroll", () => {
      this.transform(),
        Math.abs(this.controller.velocity) > 0 ? this.show() : this.hide();
    });
    q(this, "onResize", () => {
      const e = this.controller.options.content.offsetHeight;
      if (((this.scale = (e + E.window.h) / E.window.h), this.scale <= 1)) {
        this.handleEl.style.height = 0;
        return;
      }
      (this.trueSize = E.window.h / this.scale),
        (this.handleElHeight = Math.max(this.trueSize, 40)),
        (this.handleEl.style.height = `${this.handleElHeight}px`),
        (this.maxY = E.window.h - this.handleElHeight);
    });
    q(this, "onMouseMove", (e) => {
      this.mouseDown &&
        ((this.mousePos = e.clientY),
        (this.position -= this.prevMousePos - this.mousePos),
        (this.position = Math.min(Math.max(this.position, 0), this.maxY)),
        (this.prevMousePos = this.mousePos),
        this.controller.scrollTo(
          (this.position / this.maxY) * this.controller.limit,
          { immediate: !0 }
        ));
    });
    q(this, "onMouseDown", (e) => {
      (this.mousePos = this.prevMousePos = e.clientY),
        (this.mouseDown = !0),
        (E.body.style.userSelect = "none"),
        this.wrapperEl.classList.add("active");
    });
    q(this, "onMouseUp", () => {
      (this.mouseDown = !1),
        E.body.style.removeProperty("user-select"),
        this.wrapperEl.classList.remove("active");
    });
    (this.controller = e),
      (this.options = { wrapperClass: ".unseen-scrollbar" }),
      (this.position = 0),
      (this.mousePos = 0),
      (this.prevMousePos = 0),
      this.buildHTML(),
      this.addEvents(),
      this.onResize();
  }
  show() {
    this.wrapperEl.classList.add("show");
  }
  hide() {
    this.wrapperEl.classList.remove("show");
  }
  addEvents() {
    this.controller.on("scroll", this.onScroll),
      De.on("mousedown", this.handleEl, this.onMouseDown),
      De.on("mousemove", window, this.onMouseMove),
      De.on("mouseup", window, this.onMouseUp),
      De.on(Ze.RESIZE, this.onResize),
      De.on("NAVIGATE_END", this.onResize);
  }
  buildHTML() {
    (this.wrapperEl = document.createElement("div")),
      this.wrapperEl.classList.add(this.options.wrapperClass.substring(1)),
      (this.handleEl = document.createElement("div")),
      (this.handleEl.innerHTML = "<div></div>"),
      this.wrapperEl.appendChild(this.handleEl),
      document.body.appendChild(this.wrapperEl);
  }
  destroy() {
    this.controller.off("scroll", this.onScroll),
      De.off("mousedown", this.handleEl, this.onMouseDown),
      De.off("mousemove", window, this.onMouseMove),
      De.off("mouseup", window, this.onMouseUp),
      De.off(Ze.RESIZE, this.onResize),
      De.off("NAVIGATE_END", this.onResize);
  }
}
function sr(r) {
  if (r === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return r;
}
function lx(r, e) {
  (r.prototype = Object.create(e.prototype)),
    (r.prototype.constructor = r),
    (r.__proto__ = e);
}
/*!
 * GSAP 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var Vn = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: { lineHeight: "" },
  },
  ml = { duration: 0.5, overwrite: !1, delay: 0 },
  Bm,
  ji,
  hi,
  is = 1e8,
  Yt = 1 / is,
  Xf = Math.PI * 2,
  X3 = Xf / 4,
  $3 = 0,
  cx = Math.sqrt,
  Y3 = Math.cos,
  K3 = Math.sin,
  Ri = function (e) {
    return typeof e == "string";
  },
  di = function (e) {
    return typeof e == "function";
  },
  _r = function (e) {
    return typeof e == "number";
  },
  Vm = function (e) {
    return typeof e > "u";
  },
  Vs = function (e) {
    return typeof e == "object";
  },
  wn = function (e) {
    return e !== !1;
  },
  zm = function () {
    return typeof window < "u";
  },
  Th = function (e) {
    return di(e) || Ri(e);
  },
  ux =
    (typeof ArrayBuffer == "function" && ArrayBuffer.isView) || function () {},
  qi = Array.isArray,
  $f = /(?:-?\.?\d|\.)+/gi,
  hx = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  Ka = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  tf = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  dx = /[+-]=-?[.\d]+/,
  px = /[^,'"\[\]\s]+/gi,
  Z3 = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
  ri,
  Zn,
  Yf,
  Um,
  zn = {},
  Jh = {},
  fx,
  mx = function (e) {
    return (Jh = ia(e, zn)) && Xi;
  },
  Gm = function (e, t) {
    return console.warn(
      "Invalid property",
      e,
      "set to",
      t,
      "Missing plugin? gsap.registerPlugin()"
    );
  },
  Qh = function (e, t) {
    return !t && console.warn(e);
  },
  gx = function (e, t) {
    return (e && (zn[e] = t) && Jh && (Jh[e] = t)) || zn;
  },
  Xc = function () {
    return 0;
  },
  J3 = { suppressEvents: !0, isStart: !0, kill: !1 },
  zh = { suppressEvents: !0, kill: !1 },
  Q3 = { suppressEvents: !0 },
  Hm = {},
  Yr = [],
  Kf = {},
  vx,
  In = {},
  nf = {},
  h_ = 30,
  Uh = [],
  Wm = "",
  jm = function (e) {
    var t = e[0],
      i,
      n;
    if ((Vs(t) || di(t) || (e = [e]), !(i = (t._gsap || {}).harness))) {
      for (n = Uh.length; n-- && !Uh[n].targetTest(t); );
      i = Uh[n];
    }
    for (n = e.length; n--; )
      (e[n] && (e[n]._gsap || (e[n]._gsap = new Ux(e[n], i)))) ||
        e.splice(n, 1);
    return e;
  },
  jo = function (e) {
    return e._gsap || jm(ns(e))[0]._gsap;
  },
  _x = function (e, t, i) {
    return (i = e[t]) && di(i)
      ? e[t]()
      : (Vm(i) && e.getAttribute && e.getAttribute(t)) || i;
  },
  yn = function (e, t) {
    return (e = e.split(",")).forEach(t) || e;
  },
  mi = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  Oi = function (e) {
    return Math.round(e * 1e7) / 1e7 || 0;
  },
  sl = function (e, t) {
    var i = t.charAt(0),
      n = parseFloat(t.substr(2));
    return (
      (e = parseFloat(e)),
      i === "+" ? e + n : i === "-" ? e - n : i === "*" ? e * n : e / n
    );
  },
  eP = function (e, t) {
    for (var i = t.length, n = 0; e.indexOf(t[n]) < 0 && ++n < i; );
    return n < i;
  },
  ed = function () {
    var e = Yr.length,
      t = Yr.slice(0),
      i,
      n;
    for (Kf = {}, Yr.length = 0, i = 0; i < e; i++)
      (n = t[i]),
        n && n._lazy && (n.render(n._lazy[0], n._lazy[1], !0)._lazy = 0);
  },
  bx = function (e, t, i, n) {
    Yr.length && !ji && ed(),
      e.render(t, i, n || (ji && t < 0 && (e._initted || e._startAt))),
      Yr.length && !ji && ed();
  },
  xx = function (e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(px).length < 2
      ? t
      : Ri(e)
      ? e.trim()
      : e;
  },
  wx = function (e) {
    return e;
  },
  as = function (e, t) {
    for (var i in t) i in e || (e[i] = t[i]);
    return e;
  },
  tP = function (e) {
    return function (t, i) {
      for (var n in i)
        n in t || (n === "duration" && e) || n === "ease" || (t[n] = i[n]);
    };
  },
  ia = function (e, t) {
    for (var i in t) e[i] = t[i];
    return e;
  },
  d_ = function r(e, t) {
    for (var i in t)
      i !== "__proto__" &&
        i !== "constructor" &&
        i !== "prototype" &&
        (e[i] = Vs(t[i]) ? r(e[i] || (e[i] = {}), t[i]) : t[i]);
    return e;
  },
  td = function (e, t) {
    var i = {},
      n;
    for (n in e) n in t || (i[n] = e[n]);
    return i;
  },
  kc = function (e) {
    var t = e.parent || ri,
      i = e.keyframes ? tP(qi(e.keyframes)) : as;
    if (wn(e.inherit))
      for (; t; ) i(e, t.vars.defaults), (t = t.parent || t._dp);
    return e;
  },
  iP = function (e, t) {
    for (var i = e.length, n = i === t.length; n && i-- && e[i] === t[i]; );
    return i < 0;
  },
  yx = function (e, t, i, n, s) {
    i === void 0 && (i = "_first"), n === void 0 && (n = "_last");
    var a = e[n],
      o;
    if (s) for (o = t[s]; a && a[s] > o; ) a = a._prev;
    return (
      a ? ((t._next = a._next), (a._next = t)) : ((t._next = e[i]), (e[i] = t)),
      t._next ? (t._next._prev = t) : (e[n] = t),
      (t._prev = a),
      (t.parent = t._dp = e),
      t
    );
  },
  gd = function (e, t, i, n) {
    i === void 0 && (i = "_first"), n === void 0 && (n = "_last");
    var s = t._prev,
      a = t._next;
    s ? (s._next = a) : e[i] === t && (e[i] = a),
      a ? (a._prev = s) : e[n] === t && (e[n] = s),
      (t._next = t._prev = t.parent = null);
  },
  Qr = function (e, t) {
    e.parent &&
      (!t || e.parent.autoRemoveChildren) &&
      e.parent.remove &&
      e.parent.remove(e),
      (e._act = 0);
  },
  qo = function (e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
      for (var i = e; i; ) (i._dirty = 1), (i = i.parent);
    return e;
  },
  nP = function (e) {
    for (var t = e.parent; t && t.parent; )
      (t._dirty = 1), t.totalDuration(), (t = t.parent);
    return e;
  },
  Zf = function (e, t, i, n) {
    return (
      e._startAt &&
      (ji
        ? e._startAt.revert(zh)
        : (e.vars.immediateRender && !e.vars.autoRevert) ||
          e._startAt.render(t, !0, n))
    );
  },
  sP = function r(e) {
    return !e || (e._ts && r(e.parent));
  },
  p_ = function (e) {
    return e._repeat ? gl(e._tTime, (e = e.duration() + e._rDelay)) * e : 0;
  },
  gl = function (e, t) {
    var i = Math.floor((e /= t));
    return e && i === e ? i - 1 : i;
  },
  id = function (e, t) {
    return (
      (e - t._start) * t._ts +
      (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
    );
  },
  vd = function (e) {
    return (e._end = Oi(
      e._start + (e._tDur / Math.abs(e._ts || e._rts || Yt) || 0)
    ));
  },
  _d = function (e, t) {
    var i = e._dp;
    return (
      i &&
        i.smoothChildTiming &&
        e._ts &&
        ((e._start = Oi(
          i._time -
            (e._ts > 0
              ? t / e._ts
              : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)
        )),
        vd(e),
        i._dirty || qo(i, e)),
      e
    );
  },
  Sx = function (e, t) {
    var i;
    if (
      ((t._time || (t._initted && !t._dur)) &&
        ((i = id(e.rawTime(), t)),
        (!t._dur || du(0, t.totalDuration(), i) - t._tTime > Yt) &&
          t.render(i, !0)),
      qo(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
    ) {
      if (e._dur < e.duration())
        for (i = e; i._dp; )
          i.rawTime() >= 0 && i.totalTime(i._tTime), (i = i._dp);
      e._zTime = -Yt;
    }
  },
  Rs = function (e, t, i, n) {
    return (
      t.parent && Qr(t),
      (t._start = Oi(
        (_r(i) ? i : i || e !== ri ? Yn(e, i, t) : e._time) + t._delay
      )),
      (t._end = Oi(
        t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)
      )),
      yx(e, t, "_first", "_last", e._sort ? "_start" : 0),
      Jf(t) || (e._recent = t),
      n || Sx(e, t),
      e._ts < 0 && _d(e, e._tTime),
      e
    );
  },
  Mx = function (e, t) {
    return (
      (zn.ScrollTrigger || Gm("scrollTrigger", t)) &&
      zn.ScrollTrigger.create(t, e)
    );
  },
  Tx = function (e, t, i, n, s) {
    if ((Xm(e, t, s), !e._initted)) return 1;
    if (
      !i &&
      e._pt &&
      !ji &&
      ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) &&
      vx !== On.frame
    )
      return Yr.push(e), (e._lazy = [s, n]), 1;
  },
  rP = function r(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || r(t));
  },
  Jf = function (e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart";
  },
  oP = function (e, t, i, n) {
    var s = e.ratio,
      a =
        t < 0 ||
        (!t &&
          ((!e._start && rP(e) && !(!e._initted && Jf(e))) ||
            ((e._ts < 0 || e._dp._ts < 0) && !Jf(e))))
          ? 0
          : 1,
      o = e._rDelay,
      u = 0,
      h,
      f,
      c;
    if (
      (o &&
        e._repeat &&
        ((u = du(0, e._tDur, t)),
        (f = gl(u, o)),
        e._yoyo && f & 1 && (a = 1 - a),
        f !== gl(e._tTime, o) &&
          ((s = 1 - a), e.vars.repeatRefresh && e._initted && e.invalidate())),
      a !== s || ji || n || e._zTime === Yt || (!t && e._zTime))
    ) {
      if (!e._initted && Tx(e, t, n, i, u)) return;
      for (
        c = e._zTime,
          e._zTime = t || (i ? Yt : 0),
          i || (i = t && !c),
          e.ratio = a,
          e._from && (a = 1 - a),
          e._time = 0,
          e._tTime = u,
          h = e._pt;
        h;

      )
        h.r(a, h.d), (h = h._next);
      t < 0 && Zf(e, t, i, !0),
        e._onUpdate && !i && ss(e, "onUpdate"),
        u && e._repeat && !i && e.parent && ss(e, "onRepeat"),
        (t >= e._tDur || t < 0) &&
          e.ratio === a &&
          (a && Qr(e, 1),
          !i &&
            !ji &&
            (ss(e, a ? "onComplete" : "onReverseComplete", !0),
            e._prom && e._prom()));
    } else e._zTime || (e._zTime = t);
  },
  aP = function (e, t, i) {
    var n;
    if (i > t)
      for (n = e._first; n && n._start <= i; ) {
        if (n.data === "isPause" && n._start > t) return n;
        n = n._next;
      }
    else
      for (n = e._last; n && n._start >= i; ) {
        if (n.data === "isPause" && n._start < t) return n;
        n = n._prev;
      }
  },
  vl = function (e, t, i, n) {
    var s = e._repeat,
      a = Oi(t) || 0,
      o = e._tTime / e._tDur;
    return (
      o && !n && (e._time *= a / e._dur),
      (e._dur = a),
      (e._tDur = s ? (s < 0 ? 1e10 : Oi(a * (s + 1) + e._rDelay * s)) : a),
      o > 0 && !n && _d(e, (e._tTime = e._tDur * o)),
      e.parent && vd(e),
      i || qo(e.parent, e),
      e
    );
  },
  f_ = function (e) {
    return e instanceof on ? qo(e) : vl(e, e._dur);
  },
  lP = { _start: 0, endTime: Xc, totalDuration: Xc },
  Yn = function r(e, t, i) {
    var n = e.labels,
      s = e._recent || lP,
      a = e.duration() >= is ? s.endTime(!1) : e._dur,
      o,
      u,
      h;
    return Ri(t) && (isNaN(t) || t in n)
      ? ((u = t.charAt(0)),
        (h = t.substr(-1) === "%"),
        (o = t.indexOf("=")),
        u === "<" || u === ">"
          ? (o >= 0 && (t = t.replace(/=/, "")),
            (u === "<" ? s._start : s.endTime(s._repeat >= 0)) +
              (parseFloat(t.substr(1)) || 0) *
                (h ? (o < 0 ? s : i).totalDuration() / 100 : 1))
          : o < 0
          ? (t in n || (n[t] = a), n[t])
          : ((u = parseFloat(t.charAt(o - 1) + t.substr(o + 1))),
            h && i && (u = (u / 100) * (qi(i) ? i[0] : i).totalDuration()),
            o > 1 ? r(e, t.substr(0, o - 1), i) + u : a + u))
      : t == null
      ? a
      : +t;
  },
  Ic = function (e, t, i) {
    var n = _r(t[1]),
      s = (n ? 2 : 1) + (e < 2 ? 0 : 1),
      a = t[s],
      o,
      u;
    if ((n && (a.duration = t[1]), (a.parent = i), e)) {
      for (o = a, u = i; u && !("immediateRender" in o); )
        (o = u.vars.defaults || {}), (u = wn(u.vars.inherit) && u.parent);
      (a.immediateRender = wn(o.immediateRender)),
        e < 2 ? (a.runBackwards = 1) : (a.startAt = t[s - 1]);
    }
    return new bi(t[0], a, t[s + 1]);
  },
  to = function (e, t) {
    return e || e === 0 ? t(e) : t;
  },
  du = function (e, t, i) {
    return i < e ? e : i > t ? t : i;
  },
  Hi = function (e, t) {
    return !Ri(e) || !(t = Z3.exec(e)) ? "" : t[1];
  },
  cP = function (e, t, i) {
    return to(i, function (n) {
      return du(e, t, n);
    });
  },
  Qf = [].slice,
  Ex = function (e, t) {
    return (
      e &&
      Vs(e) &&
      "length" in e &&
      ((!t && !e.length) || (e.length - 1 in e && Vs(e[0]))) &&
      !e.nodeType &&
      e !== Zn
    );
  },
  uP = function (e, t, i) {
    return (
      i === void 0 && (i = []),
      e.forEach(function (n) {
        var s;
        return (Ri(n) && !t) || Ex(n, 1)
          ? (s = i).push.apply(s, ns(n))
          : i.push(n);
      }) || i
    );
  },
  ns = function (e, t, i) {
    return hi && !t && hi.selector
      ? hi.selector(e)
      : Ri(e) && !i && (Yf || !_l())
      ? Qf.call((t || Um).querySelectorAll(e), 0)
      : qi(e)
      ? uP(e, i)
      : Ex(e)
      ? Qf.call(e, 0)
      : e
      ? [e]
      : [];
  },
  em = function (e) {
    return (
      (e = ns(e)[0] || Qh("Invalid scope") || {}),
      function (t) {
        var i = e.current || e.nativeElement || e;
        return ns(
          t,
          i.querySelectorAll
            ? i
            : i === e
            ? Qh("Invalid scope") || Um.createElement("div")
            : e
        );
      }
    );
  },
  Cx = function (e) {
    return e.sort(function () {
      return 0.5 - Math.random();
    });
  },
  Dx = function (e) {
    if (di(e)) return e;
    var t = Vs(e) ? e : { each: e },
      i = Xo(t.ease),
      n = t.from || 0,
      s = parseFloat(t.base) || 0,
      a = {},
      o = n > 0 && n < 1,
      u = isNaN(n) || o,
      h = t.axis,
      f = n,
      c = n;
    return (
      Ri(n)
        ? (f = c = { center: 0.5, edges: 0.5, end: 1 }[n] || 0)
        : !o && u && ((f = n[0]), (c = n[1])),
      function (d, m, x) {
        var v = (x || t).length,
          b = a[v],
          y,
          M,
          D,
          C,
          A,
          I,
          F,
          P,
          k;
        if (!b) {
          if (((k = t.grid === "auto" ? 0 : (t.grid || [1, is])[1]), !k)) {
            for (
              F = -is;
              F < (F = x[k++].getBoundingClientRect().left) && k < v;

            );
            k--;
          }
          for (
            b = a[v] = [],
              y = u ? Math.min(k, v) * f - 0.5 : n % k,
              M = k === is ? 0 : u ? (v * c) / k - 0.5 : (n / k) | 0,
              F = 0,
              P = is,
              I = 0;
            I < v;
            I++
          )
            (D = (I % k) - y),
              (C = M - ((I / k) | 0)),
              (b[I] = A = h ? Math.abs(h === "y" ? C : D) : cx(D * D + C * C)),
              A > F && (F = A),
              A < P && (P = A);
          n === "random" && Cx(b),
            (b.max = F - P),
            (b.min = P),
            (b.v = v =
              (parseFloat(t.amount) ||
                parseFloat(t.each) *
                  (k > v
                    ? v - 1
                    : h
                    ? h === "y"
                      ? v / k
                      : k
                    : Math.max(k, v / k)) ||
                0) * (n === "edges" ? -1 : 1)),
            (b.b = v < 0 ? s - v : s),
            (b.u = Hi(t.amount || t.each) || 0),
            (i = i && v < 0 ? Bx(i) : i);
        }
        return (
          (v = (b[d] - b.min) / b.max || 0),
          Oi(b.b + (i ? i(v) : v) * b.v) + b.u
        );
      }
    );
  },
  tm = function (e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function (i) {
      var n = Oi(Math.round(parseFloat(i) / e) * e * t);
      return (n - (n % 1)) / t + (_r(i) ? 0 : Hi(i));
    };
  },
  Px = function (e, t) {
    var i = qi(e),
      n,
      s;
    return (
      !i &&
        Vs(e) &&
        ((n = i = e.radius || is),
        e.values
          ? ((e = ns(e.values)), (s = !_r(e[0])) && (n *= n))
          : (e = tm(e.increment))),
      to(
        t,
        i
          ? di(e)
            ? function (a) {
                return (s = e(a)), Math.abs(s - a) <= n ? s : a;
              }
            : function (a) {
                for (
                  var o = parseFloat(s ? a.x : a),
                    u = parseFloat(s ? a.y : 0),
                    h = is,
                    f = 0,
                    c = e.length,
                    d,
                    m;
                  c--;

                )
                  s
                    ? ((d = e[c].x - o), (m = e[c].y - u), (d = d * d + m * m))
                    : (d = Math.abs(e[c] - o)),
                    d < h && ((h = d), (f = c));
                return (
                  (f = !n || h <= n ? e[f] : a),
                  s || f === a || _r(a) ? f : f + Hi(a)
                );
              }
          : tm(e)
      )
    );
  },
  Ax = function (e, t, i, n) {
    return to(qi(e) ? !t : i === !0 ? !!(i = 0) : !n, function () {
      return qi(e)
        ? e[~~(Math.random() * e.length)]
        : (i = i || 1e-5) &&
            (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) &&
            Math.floor(
              Math.round((e - i / 2 + Math.random() * (t - e + i * 0.99)) / i) *
                i *
                n
            ) / n;
    });
  },
  hP = function () {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return function (n) {
      return t.reduce(function (s, a) {
        return a(s);
      }, n);
    };
  },
  dP = function (e, t) {
    return function (i) {
      return e(parseFloat(i)) + (t || Hi(i));
    };
  },
  pP = function (e, t, i) {
    return Rx(e, t, 0, 1, i);
  },
  Lx = function (e, t, i) {
    return to(i, function (n) {
      return e[~~t(n)];
    });
  },
  fP = function r(e, t, i) {
    var n = t - e;
    return qi(e)
      ? Lx(e, r(0, e.length), t)
      : to(i, function (s) {
          return ((n + ((s - e) % n)) % n) + e;
        });
  },
  mP = function r(e, t, i) {
    var n = t - e,
      s = n * 2;
    return qi(e)
      ? Lx(e, r(0, e.length - 1), t)
      : to(i, function (a) {
          return (a = (s + ((a - e) % s)) % s || 0), e + (a > n ? s - a : a);
        });
  },
  $c = function (e) {
    for (var t = 0, i = "", n, s, a, o; ~(n = e.indexOf("random(", t)); )
      (a = e.indexOf(")", n)),
        (o = e.charAt(n + 7) === "["),
        (s = e.substr(n + 7, a - n - 7).match(o ? px : $f)),
        (i +=
          e.substr(t, n - t) + Ax(o ? s : +s[0], o ? 0 : +s[1], +s[2] || 1e-5)),
        (t = a + 1);
    return i + e.substr(t, e.length - t);
  },
  Rx = function (e, t, i, n, s) {
    var a = t - e,
      o = n - i;
    return to(s, function (u) {
      return i + (((u - e) / a) * o || 0);
    });
  },
  gP = function r(e, t, i, n) {
    var s = isNaN(e + t)
      ? 0
      : function (m) {
          return (1 - m) * e + m * t;
        };
    if (!s) {
      var a = Ri(e),
        o = {},
        u,
        h,
        f,
        c,
        d;
      if ((i === !0 && (n = 1) && (i = null), a))
        (e = { p: e }), (t = { p: t });
      else if (qi(e) && !qi(t)) {
        for (f = [], c = e.length, d = c - 2, h = 1; h < c; h++)
          f.push(r(e[h - 1], e[h]));
        c--,
          (s = function (x) {
            x *= c;
            var v = Math.min(d, ~~x);
            return f[v](x - v);
          }),
          (i = t);
      } else n || (e = ia(qi(e) ? [] : {}, e));
      if (!f) {
        for (u in t) qm.call(o, e, u, "get", t[u]);
        s = function (x) {
          return Km(x, o) || (a ? e.p : e);
        };
      }
    }
    return to(i, s);
  },
  m_ = function (e, t, i) {
    var n = e.labels,
      s = is,
      a,
      o,
      u;
    for (a in n)
      (o = n[a] - t),
        o < 0 == !!i && o && s > (o = Math.abs(o)) && ((u = a), (s = o));
    return u;
  },
  ss = function (e, t, i) {
    var n = e.vars,
      s = n[t],
      a = hi,
      o = e._ctx,
      u,
      h,
      f;
    if (s)
      return (
        (u = n[t + "Params"]),
        (h = n.callbackScope || e),
        i && Yr.length && ed(),
        o && (hi = o),
        (f = u ? s.apply(h, u) : s.call(h)),
        (hi = a),
        f
      );
  },
  wc = function (e) {
    return (
      Qr(e),
      e.scrollTrigger && e.scrollTrigger.kill(!!ji),
      e.progress() < 1 && ss(e, "onInterrupt"),
      e
    );
  },
  Za,
  kx = [],
  Ix = function (e) {
    if (zm() && e) {
      e = (!e.name && e.default) || e;
      var t = e.name,
        i = di(e),
        n =
          t && !i && e.init
            ? function () {
                this._props = [];
              }
            : e,
        s = {
          init: Xc,
          render: Km,
          add: qm,
          kill: RP,
          modifier: LP,
          rawVars: 0,
        },
        a = { targetTest: 0, get: 0, getSetter: Ym, aliases: {}, register: 0 };
      if ((_l(), e !== n)) {
        if (In[t]) return;
        as(n, as(td(e, s), a)),
          ia(n.prototype, ia(s, td(e, a))),
          (In[(n.prop = t)] = n),
          e.targetTest && (Uh.push(n), (Hm[t] = 1)),
          (t =
            (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) +
            "Plugin");
      }
      gx(t, n), e.register && e.register(Xi, n, Sn);
    } else e && kx.push(e);
  },
  Xt = 255,
  yc = {
    aqua: [0, Xt, Xt],
    lime: [0, Xt, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, Xt],
    navy: [0, 0, 128],
    white: [Xt, Xt, Xt],
    olive: [128, 128, 0],
    yellow: [Xt, Xt, 0],
    orange: [Xt, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [Xt, 0, 0],
    pink: [Xt, 192, 203],
    cyan: [0, Xt, Xt],
    transparent: [Xt, Xt, Xt, 0],
  },
  sf = function (e, t, i) {
    return (
      (e += e < 0 ? 1 : e > 1 ? -1 : 0),
      ((e * 6 < 1
        ? t + (i - t) * e * 6
        : e < 0.5
        ? i
        : e * 3 < 2
        ? t + (i - t) * (2 / 3 - e) * 6
        : t) *
        Xt +
        0.5) |
        0
    );
  },
  Fx = function (e, t, i) {
    var n = e ? (_r(e) ? [e >> 16, (e >> 8) & Xt, e & Xt] : 0) : yc.black,
      s,
      a,
      o,
      u,
      h,
      f,
      c,
      d,
      m,
      x;
    if (!n) {
      if ((e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), yc[e]))
        n = yc[e];
      else if (e.charAt(0) === "#") {
        if (
          (e.length < 6 &&
            ((s = e.charAt(1)),
            (a = e.charAt(2)),
            (o = e.charAt(3)),
            (e =
              "#" +
              s +
              s +
              a +
              a +
              o +
              o +
              (e.length === 5 ? e.charAt(4) + e.charAt(4) : ""))),
          e.length === 9)
        )
          return (
            (n = parseInt(e.substr(1, 6), 16)),
            [n >> 16, (n >> 8) & Xt, n & Xt, parseInt(e.substr(7), 16) / 255]
          );
        (e = parseInt(e.substr(1), 16)), (n = [e >> 16, (e >> 8) & Xt, e & Xt]);
      } else if (e.substr(0, 3) === "hsl") {
        if (((n = x = e.match($f)), !t))
          (u = (+n[0] % 360) / 360),
            (h = +n[1] / 100),
            (f = +n[2] / 100),
            (a = f <= 0.5 ? f * (h + 1) : f + h - f * h),
            (s = f * 2 - a),
            n.length > 3 && (n[3] *= 1),
            (n[0] = sf(u + 1 / 3, s, a)),
            (n[1] = sf(u, s, a)),
            (n[2] = sf(u - 1 / 3, s, a));
        else if (~e.indexOf("="))
          return (n = e.match(hx)), i && n.length < 4 && (n[3] = 1), n;
      } else n = e.match($f) || yc.transparent;
      n = n.map(Number);
    }
    return (
      t &&
        !x &&
        ((s = n[0] / Xt),
        (a = n[1] / Xt),
        (o = n[2] / Xt),
        (c = Math.max(s, a, o)),
        (d = Math.min(s, a, o)),
        (f = (c + d) / 2),
        c === d
          ? (u = h = 0)
          : ((m = c - d),
            (h = f > 0.5 ? m / (2 - c - d) : m / (c + d)),
            (u =
              c === s
                ? (a - o) / m + (a < o ? 6 : 0)
                : c === a
                ? (o - s) / m + 2
                : (s - a) / m + 4),
            (u *= 60)),
        (n[0] = ~~(u + 0.5)),
        (n[1] = ~~(h * 100 + 0.5)),
        (n[2] = ~~(f * 100 + 0.5))),
      i && n.length < 4 && (n[3] = 1),
      n
    );
  },
  Ox = function (e) {
    var t = [],
      i = [],
      n = -1;
    return (
      e.split(Kr).forEach(function (s) {
        var a = s.match(Ka) || [];
        t.push.apply(t, a), i.push((n += a.length + 1));
      }),
      (t.c = i),
      t
    );
  },
  g_ = function (e, t, i) {
    var n = "",
      s = (e + n).match(Kr),
      a = t ? "hsla(" : "rgba(",
      o = 0,
      u,
      h,
      f,
      c;
    if (!s) return e;
    if (
      ((s = s.map(function (d) {
        return (
          (d = Fx(d, t, 1)) &&
          a +
            (t ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) +
            ")"
        );
      })),
      i && ((f = Ox(e)), (u = i.c), u.join(n) !== f.c.join(n)))
    )
      for (h = e.replace(Kr, "1").split(Ka), c = h.length - 1; o < c; o++)
        n +=
          h[o] +
          (~u.indexOf(o)
            ? s.shift() || a + "0,0,0,0)"
            : (f.length ? f : s.length ? s : i).shift());
    if (!h)
      for (h = e.split(Kr), c = h.length - 1; o < c; o++) n += h[o] + s[o];
    return n + h[c];
  },
  Kr = (function () {
    var r =
        "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      e;
    for (e in yc) r += "|" + e + "\\b";
    return new RegExp(r + ")", "gi");
  })(),
  vP = /hsl[a]?\(/,
  Nx = function (e) {
    var t = e.join(" "),
      i;
    if (((Kr.lastIndex = 0), Kr.test(t)))
      return (
        (i = vP.test(t)),
        (e[1] = g_(e[1], i)),
        (e[0] = g_(e[0], i, Ox(e[1]))),
        !0
      );
  },
  Yc,
  On = (function () {
    var r = Date.now,
      e = 500,
      t = 33,
      i = r(),
      n = i,
      s = 1e3 / 240,
      a = s,
      o = [],
      u,
      h,
      f,
      c,
      d,
      m,
      x = function v(b) {
        var y = r() - n,
          M = b === !0,
          D,
          C,
          A,
          I;
        if (
          (y > e && (i += y - t),
          (n += y),
          (A = n - i),
          (D = A - a),
          (D > 0 || M) &&
            ((I = ++c.frame),
            (d = A - c.time * 1e3),
            (c.time = A = A / 1e3),
            (a += D + (D >= s ? 4 : s - D)),
            (C = 1)),
          M || (u = h(v)),
          C)
        )
          for (m = 0; m < o.length; m++) o[m](A, d, I, b);
      };
    return (
      (c = {
        time: 0,
        frame: 0,
        tick: function () {
          x(!0);
        },
        deltaRatio: function (b) {
          return d / (1e3 / (b || 60));
        },
        wake: function () {
          fx &&
            (!Yf &&
              zm() &&
              ((Zn = Yf = window),
              (Um = Zn.document || {}),
              (zn.gsap = Xi),
              (Zn.gsapVersions || (Zn.gsapVersions = [])).push(Xi.version),
              mx(Jh || Zn.GreenSockGlobals || (!Zn.gsap && Zn) || {}),
              (f = Zn.requestAnimationFrame),
              kx.forEach(Ix)),
            u && c.sleep(),
            (h =
              f ||
              function (b) {
                return setTimeout(b, (a - c.time * 1e3 + 1) | 0);
              }),
            (Yc = 1),
            x(2));
        },
        sleep: function () {
          (f ? Zn.cancelAnimationFrame : clearTimeout)(u), (Yc = 0), (h = Xc);
        },
        lagSmoothing: function (b, y) {
          (e = b || 1 / 0), (t = Math.min(y || 33, e));
        },
        fps: function (b) {
          (s = 1e3 / (b || 240)), (a = c.time * 1e3 + s);
        },
        add: function (b, y, M) {
          var D = y
            ? function (C, A, I, F) {
                b(C, A, I, F), c.remove(D);
              }
            : b;
          return c.remove(b), o[M ? "unshift" : "push"](D), _l(), D;
        },
        remove: function (b, y) {
          ~(y = o.indexOf(b)) && o.splice(y, 1) && m >= y && m--;
        },
        _listeners: o,
      }),
      c
    );
  })(),
  _l = function () {
    return !Yc && On.wake();
  },
  Ft = {},
  _P = /^[\d.\-M][\d.\-,\s]/,
  bP = /["']/g,
  xP = function (e) {
    for (
      var t = {},
        i = e.substr(1, e.length - 3).split(":"),
        n = i[0],
        s = 1,
        a = i.length,
        o,
        u,
        h;
      s < a;
      s++
    )
      (u = i[s]),
        (o = s !== a - 1 ? u.lastIndexOf(",") : u.length),
        (h = u.substr(0, o)),
        (t[n] = isNaN(h) ? h.replace(bP, "").trim() : +h),
        (n = u.substr(o + 1).trim());
    return t;
  },
  wP = function (e) {
    var t = e.indexOf("(") + 1,
      i = e.indexOf(")"),
      n = e.indexOf("(", t);
    return e.substring(t, ~n && n < i ? e.indexOf(")", i + 1) : i);
  },
  yP = function (e) {
    var t = (e + "").split("("),
      i = Ft[t[0]];
    return i && t.length > 1 && i.config
      ? i.config.apply(
          null,
          ~e.indexOf("{") ? [xP(t[1])] : wP(e).split(",").map(xx)
        )
      : Ft._CE && _P.test(e)
      ? Ft._CE("", e)
      : i;
  },
  Bx = function (e) {
    return function (t) {
      return 1 - e(1 - t);
    };
  },
  Vx = function r(e, t) {
    for (var i = e._first, n; i; )
      i instanceof on
        ? r(i, t)
        : i.vars.yoyoEase &&
          (!i._yoyo || !i._repeat) &&
          i._yoyo !== t &&
          (i.timeline
            ? r(i.timeline, t)
            : ((n = i._ease),
              (i._ease = i._yEase),
              (i._yEase = n),
              (i._yoyo = t))),
        (i = i._next);
  },
  Xo = function (e, t) {
    return (e && (di(e) ? e : Ft[e] || yP(e))) || t;
  },
  aa = function (e, t, i, n) {
    i === void 0 &&
      (i = function (u) {
        return 1 - t(1 - u);
      }),
      n === void 0 &&
        (n = function (u) {
          return u < 0.5 ? t(u * 2) / 2 : 1 - t((1 - u) * 2) / 2;
        });
    var s = { easeIn: t, easeOut: i, easeInOut: n },
      a;
    return (
      yn(e, function (o) {
        (Ft[o] = zn[o] = s), (Ft[(a = o.toLowerCase())] = i);
        for (var u in s)
          Ft[
            a + (u === "easeIn" ? ".in" : u === "easeOut" ? ".out" : ".inOut")
          ] = Ft[o + "." + u] = s[u];
      }),
      s
    );
  },
  zx = function (e) {
    return function (t) {
      return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
    };
  },
  rf = function r(e, t, i) {
    var n = t >= 1 ? t : 1,
      s = (i || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1),
      a = (s / Xf) * (Math.asin(1 / n) || 0),
      o = function (f) {
        return f === 1 ? 1 : n * Math.pow(2, -10 * f) * K3((f - a) * s) + 1;
      },
      u =
        e === "out"
          ? o
          : e === "in"
          ? function (h) {
              return 1 - o(1 - h);
            }
          : zx(o);
    return (
      (s = Xf / s),
      (u.config = function (h, f) {
        return r(e, h, f);
      }),
      u
    );
  },
  of = function r(e, t) {
    t === void 0 && (t = 1.70158);
    var i = function (a) {
        return a ? --a * a * ((t + 1) * a + t) + 1 : 0;
      },
      n =
        e === "out"
          ? i
          : e === "in"
          ? function (s) {
              return 1 - i(1 - s);
            }
          : zx(i);
    return (
      (n.config = function (s) {
        return r(e, s);
      }),
      n
    );
  };
yn("Linear,Quad,Cubic,Quart,Quint,Strong", function (r, e) {
  var t = e < 5 ? e + 1 : e;
  aa(
    r + ",Power" + (t - 1),
    e
      ? function (i) {
          return Math.pow(i, t);
        }
      : function (i) {
          return i;
        },
    function (i) {
      return 1 - Math.pow(1 - i, t);
    },
    function (i) {
      return i < 0.5
        ? Math.pow(i * 2, t) / 2
        : 1 - Math.pow((1 - i) * 2, t) / 2;
    }
  );
});
Ft.Linear.easeNone = Ft.none = Ft.Linear.easeIn;
aa("Elastic", rf("in"), rf("out"), rf());
(function (r, e) {
  var t = 1 / e,
    i = 2 * t,
    n = 2.5 * t,
    s = function (o) {
      return o < t
        ? r * o * o
        : o < i
        ? r * Math.pow(o - 1.5 / e, 2) + 0.75
        : o < n
        ? r * (o -= 2.25 / e) * o + 0.9375
        : r * Math.pow(o - 2.625 / e, 2) + 0.984375;
    };
  aa(
    "Bounce",
    function (a) {
      return 1 - s(1 - a);
    },
    s
  );
})(7.5625, 2.75);
aa("Expo", function (r) {
  return r ? Math.pow(2, 10 * (r - 1)) : 0;
});
aa("Circ", function (r) {
  return -(cx(1 - r * r) - 1);
});
aa("Sine", function (r) {
  return r === 1 ? 1 : -Y3(r * X3) + 1;
});
aa("Back", of("in"), of("out"), of());
Ft.SteppedEase =
  Ft.steps =
  zn.SteppedEase =
    {
      config: function (e, t) {
        e === void 0 && (e = 1);
        var i = 1 / e,
          n = e + (t ? 0 : 1),
          s = t ? 1 : 0,
          a = 1 - Yt;
        return function (o) {
          return (((n * du(0, a, o)) | 0) + s) * i;
        };
      },
    };
ml.ease = Ft["quad.out"];
yn(
  "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
  function (r) {
    return (Wm += r + "," + r + "Params,");
  }
);
var Ux = function (e, t) {
    (this.id = $3++),
      (e._gsap = this),
      (this.target = e),
      (this.harness = t),
      (this.get = t ? t.get : _x),
      (this.set = t ? t.getSetter : Ym);
  },
  Kc = (function () {
    function r(t) {
      (this.vars = t),
        (this._delay = +t.delay || 0),
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
          ((this._rDelay = t.repeatDelay || 0),
          (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
        (this._ts = 1),
        vl(this, +t.duration, 1, 1),
        (this.data = t.data),
        hi && ((this._ctx = hi), hi.data.push(this)),
        Yc || On.wake();
    }
    var e = r.prototype;
    return (
      (e.delay = function (i) {
        return i || i === 0
          ? (this.parent &&
              this.parent.smoothChildTiming &&
              this.startTime(this._start + i - this._delay),
            (this._delay = i),
            this)
          : this._delay;
      }),
      (e.duration = function (i) {
        return arguments.length
          ? this.totalDuration(
              this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i
            )
          : this.totalDuration() && this._dur;
      }),
      (e.totalDuration = function (i) {
        return arguments.length
          ? ((this._dirty = 0),
            vl(
              this,
              this._repeat < 0
                ? i
                : (i - this._repeat * this._rDelay) / (this._repeat + 1)
            ))
          : this._tDur;
      }),
      (e.totalTime = function (i, n) {
        if ((_l(), !arguments.length)) return this._tTime;
        var s = this._dp;
        if (s && s.smoothChildTiming && this._ts) {
          for (_d(this, i), !s._dp || s.parent || Sx(s, this); s && s.parent; )
            s.parent._time !==
              s._start +
                (s._ts >= 0
                  ? s._tTime / s._ts
                  : (s.totalDuration() - s._tTime) / -s._ts) &&
              s.totalTime(s._tTime, !0),
              (s = s.parent);
          !this.parent &&
            this._dp.autoRemoveChildren &&
            ((this._ts > 0 && i < this._tDur) ||
              (this._ts < 0 && i > 0) ||
              (!this._tDur && !i)) &&
            Rs(this._dp, this, this._start - this._delay);
        }
        return (
          (this._tTime !== i ||
            (!this._dur && !n) ||
            (this._initted && Math.abs(this._zTime) === Yt) ||
            (!i && !this._initted && (this.add || this._ptLookup))) &&
            (this._ts || (this._pTime = i), bx(this, i, n)),
          this
        );
      }),
      (e.time = function (i, n) {
        return arguments.length
          ? this.totalTime(
              Math.min(this.totalDuration(), i + p_(this)) %
                (this._dur + this._rDelay) || (i ? this._dur : 0),
              n
            )
          : this._time;
      }),
      (e.totalProgress = function (i, n) {
        return arguments.length
          ? this.totalTime(this.totalDuration() * i, n)
          : this.totalDuration()
          ? Math.min(1, this._tTime / this._tDur)
          : this.ratio;
      }),
      (e.progress = function (i, n) {
        return arguments.length
          ? this.totalTime(
              this.duration() *
                (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) +
                p_(this),
              n
            )
          : this.duration()
          ? Math.min(1, this._time / this._dur)
          : this.ratio;
      }),
      (e.iteration = function (i, n) {
        var s = this.duration() + this._rDelay;
        return arguments.length
          ? this.totalTime(this._time + (i - 1) * s, n)
          : this._repeat
          ? gl(this._tTime, s) + 1
          : 1;
      }),
      (e.timeScale = function (i) {
        if (!arguments.length) return this._rts === -Yt ? 0 : this._rts;
        if (this._rts === i) return this;
        var n =
          this.parent && this._ts ? id(this.parent._time, this) : this._tTime;
        return (
          (this._rts = +i || 0),
          (this._ts = this._ps || i === -Yt ? 0 : this._rts),
          this.totalTime(du(-Math.abs(this._delay), this._tDur, n), !0),
          vd(this),
          nP(this)
        );
      }),
      (e.paused = function (i) {
        return arguments.length
          ? (this._ps !== i &&
              ((this._ps = i),
              i
                ? ((this._pTime =
                    this._tTime || Math.max(-this._delay, this.rawTime())),
                  (this._ts = this._act = 0))
                : (_l(),
                  (this._ts = this._rts),
                  this.totalTime(
                    this.parent && !this.parent.smoothChildTiming
                      ? this.rawTime()
                      : this._tTime || this._pTime,
                    this.progress() === 1 &&
                      Math.abs(this._zTime) !== Yt &&
                      (this._tTime -= Yt)
                  ))),
            this)
          : this._ps;
      }),
      (e.startTime = function (i) {
        if (arguments.length) {
          this._start = i;
          var n = this.parent || this._dp;
          return (
            n && (n._sort || !this.parent) && Rs(n, this, i - this._delay), this
          );
        }
        return this._start;
      }),
      (e.endTime = function (i) {
        return (
          this._start +
          (wn(i) ? this.totalDuration() : this.duration()) /
            Math.abs(this._ts || 1)
        );
      }),
      (e.rawTime = function (i) {
        var n = this.parent || this._dp;
        return n
          ? i &&
            (!this._ts ||
              (this._repeat && this._time && this.totalProgress() < 1))
            ? this._tTime % (this._dur + this._rDelay)
            : this._ts
            ? id(n.rawTime(i), this)
            : this._tTime
          : this._tTime;
      }),
      (e.revert = function (i) {
        i === void 0 && (i = Q3);
        var n = ji;
        return (
          (ji = i),
          (this._initted || this._startAt) &&
            (this.timeline && this.timeline.revert(i),
            this.totalTime(-0.01, i.suppressEvents)),
          this.data !== "nested" && i.kill !== !1 && this.kill(),
          (ji = n),
          this
        );
      }),
      (e.globalTime = function (i) {
        for (var n = this, s = arguments.length ? i : n.rawTime(); n; )
          (s = n._start + s / (n._ts || 1)), (n = n._dp);
        return !this.parent && this._sat
          ? this._sat.vars.immediateRender
            ? -1
            : this._sat.globalTime(i)
          : s;
      }),
      (e.repeat = function (i) {
        return arguments.length
          ? ((this._repeat = i === 1 / 0 ? -2 : i), f_(this))
          : this._repeat === -2
          ? 1 / 0
          : this._repeat;
      }),
      (e.repeatDelay = function (i) {
        if (arguments.length) {
          var n = this._time;
          return (this._rDelay = i), f_(this), n ? this.time(n) : this;
        }
        return this._rDelay;
      }),
      (e.yoyo = function (i) {
        return arguments.length ? ((this._yoyo = i), this) : this._yoyo;
      }),
      (e.seek = function (i, n) {
        return this.totalTime(Yn(this, i), wn(n));
      }),
      (e.restart = function (i, n) {
        return this.play().totalTime(i ? -this._delay : 0, wn(n));
      }),
      (e.play = function (i, n) {
        return i != null && this.seek(i, n), this.reversed(!1).paused(!1);
      }),
      (e.reverse = function (i, n) {
        return (
          i != null && this.seek(i || this.totalDuration(), n),
          this.reversed(!0).paused(!1)
        );
      }),
      (e.pause = function (i, n) {
        return i != null && this.seek(i, n), this.paused(!0);
      }),
      (e.resume = function () {
        return this.paused(!1);
      }),
      (e.reversed = function (i) {
        return arguments.length
          ? (!!i !== this.reversed() &&
              this.timeScale(-this._rts || (i ? -Yt : 0)),
            this)
          : this._rts < 0;
      }),
      (e.invalidate = function () {
        return (this._initted = this._act = 0), (this._zTime = -Yt), this;
      }),
      (e.isActive = function () {
        var i = this.parent || this._dp,
          n = this._start,
          s;
        return !!(
          !i ||
          (this._ts &&
            this._initted &&
            i.isActive() &&
            (s = i.rawTime(!0)) >= n &&
            s < this.endTime(!0) - Yt)
        );
      }),
      (e.eventCallback = function (i, n, s) {
        var a = this.vars;
        return arguments.length > 1
          ? (n
              ? ((a[i] = n),
                s && (a[i + "Params"] = s),
                i === "onUpdate" && (this._onUpdate = n))
              : delete a[i],
            this)
          : a[i];
      }),
      (e.then = function (i) {
        var n = this;
        return new Promise(function (s) {
          var a = di(i) ? i : wx,
            o = function () {
              var h = n.then;
              (n.then = null),
                di(a) && (a = a(n)) && (a.then || a === n) && (n.then = h),
                s(a),
                (n.then = h);
            };
          (n._initted && n.totalProgress() === 1 && n._ts >= 0) ||
          (!n._tTime && n._ts < 0)
            ? o()
            : (n._prom = o);
        });
      }),
      (e.kill = function () {
        wc(this);
      }),
      r
    );
  })();
as(Kc.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -Yt,
  _prom: 0,
  _ps: !1,
  _rts: 1,
});
var on = (function (r) {
  lx(e, r);
  function e(i, n) {
    var s;
    return (
      i === void 0 && (i = {}),
      (s = r.call(this, i) || this),
      (s.labels = {}),
      (s.smoothChildTiming = !!i.smoothChildTiming),
      (s.autoRemoveChildren = !!i.autoRemoveChildren),
      (s._sort = wn(i.sortChildren)),
      ri && Rs(i.parent || ri, sr(s), n),
      i.reversed && s.reverse(),
      i.paused && s.paused(!0),
      i.scrollTrigger && Mx(sr(s), i.scrollTrigger),
      s
    );
  }
  var t = e.prototype;
  return (
    (t.to = function (n, s, a) {
      return Ic(0, arguments, this), this;
    }),
    (t.from = function (n, s, a) {
      return Ic(1, arguments, this), this;
    }),
    (t.fromTo = function (n, s, a, o) {
      return Ic(2, arguments, this), this;
    }),
    (t.set = function (n, s, a) {
      return (
        (s.duration = 0),
        (s.parent = this),
        kc(s).repeatDelay || (s.repeat = 0),
        (s.immediateRender = !!s.immediateRender),
        new bi(n, s, Yn(this, a), 1),
        this
      );
    }),
    (t.call = function (n, s, a) {
      return Rs(this, bi.delayedCall(0, n, s), a);
    }),
    (t.staggerTo = function (n, s, a, o, u, h, f) {
      return (
        (a.duration = s),
        (a.stagger = a.stagger || o),
        (a.onComplete = h),
        (a.onCompleteParams = f),
        (a.parent = this),
        new bi(n, a, Yn(this, u)),
        this
      );
    }),
    (t.staggerFrom = function (n, s, a, o, u, h, f) {
      return (
        (a.runBackwards = 1),
        (kc(a).immediateRender = wn(a.immediateRender)),
        this.staggerTo(n, s, a, o, u, h, f)
      );
    }),
    (t.staggerFromTo = function (n, s, a, o, u, h, f, c) {
      return (
        (o.startAt = a),
        (kc(o).immediateRender = wn(o.immediateRender)),
        this.staggerTo(n, s, o, u, h, f, c)
      );
    }),
    (t.render = function (n, s, a) {
      var o = this._time,
        u = this._dirty ? this.totalDuration() : this._tDur,
        h = this._dur,
        f = n <= 0 ? 0 : Oi(n),
        c = this._zTime < 0 != n < 0 && (this._initted || !h),
        d,
        m,
        x,
        v,
        b,
        y,
        M,
        D,
        C,
        A,
        I,
        F;
      if (
        (this !== ri && f > u && n >= 0 && (f = u), f !== this._tTime || a || c)
      ) {
        if (
          (o !== this._time &&
            h &&
            ((f += this._time - o), (n += this._time - o)),
          (d = f),
          (C = this._start),
          (D = this._ts),
          (y = !D),
          c && (h || (o = this._zTime), (n || !s) && (this._zTime = n)),
          this._repeat)
        ) {
          if (
            ((I = this._yoyo),
            (b = h + this._rDelay),
            this._repeat < -1 && n < 0)
          )
            return this.totalTime(b * 100 + n, s, a);
          if (
            ((d = Oi(f % b)),
            f === u
              ? ((v = this._repeat), (d = h))
              : ((v = ~~(f / b)),
                v && v === f / b && ((d = h), v--),
                d > h && (d = h)),
            (A = gl(this._tTime, b)),
            !o &&
              this._tTime &&
              A !== v &&
              this._tTime - A * b - this._dur <= 0 &&
              (A = v),
            I && v & 1 && ((d = h - d), (F = 1)),
            v !== A && !this._lock)
          ) {
            var P = I && A & 1,
              k = P === (I && v & 1);
            if (
              (v < A && (P = !P),
              (o = P ? 0 : h),
              (this._lock = 1),
              (this.render(o || (F ? 0 : Oi(v * b)), s, !h)._lock = 0),
              (this._tTime = f),
              !s && this.parent && ss(this, "onRepeat"),
              this.vars.repeatRefresh && !F && (this.invalidate()._lock = 1),
              (o && o !== this._time) ||
                y !== !this._ts ||
                (this.vars.onRepeat && !this.parent && !this._act))
            )
              return this;
            if (
              ((h = this._dur),
              (u = this._tDur),
              k &&
                ((this._lock = 2),
                (o = P ? h : -1e-4),
                this.render(o, !0),
                this.vars.repeatRefresh && !F && this.invalidate()),
              (this._lock = 0),
              !this._ts && !y)
            )
              return this;
            Vx(this, F);
          }
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((M = aP(this, Oi(o), Oi(d))), M && (f -= d - (d = M._start))),
          (this._tTime = f),
          (this._time = d),
          (this._act = !D),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = n),
            (o = 0)),
          !o && d && !s && !v && (ss(this, "onStart"), this._tTime !== f))
        )
          return this;
        if (d >= o && n >= 0)
          for (m = this._first; m; ) {
            if (
              ((x = m._next), (m._act || d >= m._start) && m._ts && M !== m)
            ) {
              if (m.parent !== this) return this.render(n, s, a);
              if (
                (m.render(
                  m._ts > 0
                    ? (d - m._start) * m._ts
                    : (m._dirty ? m.totalDuration() : m._tDur) +
                        (d - m._start) * m._ts,
                  s,
                  a
                ),
                d !== this._time || (!this._ts && !y))
              ) {
                (M = 0), x && (f += this._zTime = -Yt);
                break;
              }
            }
            m = x;
          }
        else {
          m = this._last;
          for (var O = n < 0 ? n : d; m; ) {
            if (((x = m._prev), (m._act || O <= m._end) && m._ts && M !== m)) {
              if (m.parent !== this) return this.render(n, s, a);
              if (
                (m.render(
                  m._ts > 0
                    ? (O - m._start) * m._ts
                    : (m._dirty ? m.totalDuration() : m._tDur) +
                        (O - m._start) * m._ts,
                  s,
                  a || (ji && (m._initted || m._startAt))
                ),
                d !== this._time || (!this._ts && !y))
              ) {
                (M = 0), x && (f += this._zTime = O ? -Yt : Yt);
                break;
              }
            }
            m = x;
          }
        }
        if (
          M &&
          !s &&
          (this.pause(),
          (M.render(d >= o ? 0 : -Yt)._zTime = d >= o ? 1 : -1),
          this._ts)
        )
          return (this._start = C), vd(this), this.render(n, s, a);
        this._onUpdate && !s && ss(this, "onUpdate", !0),
          ((f === u && this._tTime >= this.totalDuration()) || (!f && o)) &&
            (C === this._start || Math.abs(D) !== Math.abs(this._ts)) &&
            (this._lock ||
              ((n || !h) &&
                ((f === u && this._ts > 0) || (!f && this._ts < 0)) &&
                Qr(this, 1),
              !s &&
                !(n < 0 && !o) &&
                (f || o || !u) &&
                (ss(
                  this,
                  f === u && n >= 0 ? "onComplete" : "onReverseComplete",
                  !0
                ),
                this._prom &&
                  !(f < u && this.timeScale() > 0) &&
                  this._prom())));
      }
      return this;
    }),
    (t.add = function (n, s) {
      var a = this;
      if ((_r(s) || (s = Yn(this, s, n)), !(n instanceof Kc))) {
        if (qi(n))
          return (
            n.forEach(function (o) {
              return a.add(o, s);
            }),
            this
          );
        if (Ri(n)) return this.addLabel(n, s);
        if (di(n)) n = bi.delayedCall(0, n);
        else return this;
      }
      return this !== n ? Rs(this, n, s) : this;
    }),
    (t.getChildren = function (n, s, a, o) {
      n === void 0 && (n = !0),
        s === void 0 && (s = !0),
        a === void 0 && (a = !0),
        o === void 0 && (o = -is);
      for (var u = [], h = this._first; h; )
        h._start >= o &&
          (h instanceof bi
            ? s && u.push(h)
            : (a && u.push(h), n && u.push.apply(u, h.getChildren(!0, s, a)))),
          (h = h._next);
      return u;
    }),
    (t.getById = function (n) {
      for (var s = this.getChildren(1, 1, 1), a = s.length; a--; )
        if (s[a].vars.id === n) return s[a];
    }),
    (t.remove = function (n) {
      return Ri(n)
        ? this.removeLabel(n)
        : di(n)
        ? this.killTweensOf(n)
        : (gd(this, n),
          n === this._recent && (this._recent = this._last),
          qo(this));
    }),
    (t.totalTime = function (n, s) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = Oi(
              On.time -
                (this._ts > 0
                  ? n / this._ts
                  : (this.totalDuration() - n) / -this._ts)
            )),
          r.prototype.totalTime.call(this, n, s),
          (this._forcing = 0),
          this)
        : this._tTime;
    }),
    (t.addLabel = function (n, s) {
      return (this.labels[n] = Yn(this, s)), this;
    }),
    (t.removeLabel = function (n) {
      return delete this.labels[n], this;
    }),
    (t.addPause = function (n, s, a) {
      var o = bi.delayedCall(0, s || Xc, a);
      return (
        (o.data = "isPause"), (this._hasPause = 1), Rs(this, o, Yn(this, n))
      );
    }),
    (t.removePause = function (n) {
      var s = this._first;
      for (n = Yn(this, n); s; )
        s._start === n && s.data === "isPause" && Qr(s), (s = s._next);
    }),
    (t.killTweensOf = function (n, s, a) {
      for (var o = this.getTweensOf(n, a), u = o.length; u--; )
        jr !== o[u] && o[u].kill(n, s);
      return this;
    }),
    (t.getTweensOf = function (n, s) {
      for (var a = [], o = ns(n), u = this._first, h = _r(s), f; u; )
        u instanceof bi
          ? eP(u._targets, o) &&
            (h
              ? (!jr || (u._initted && u._ts)) &&
                u.globalTime(0) <= s &&
                u.globalTime(u.totalDuration()) > s
              : !s || u.isActive()) &&
            a.push(u)
          : (f = u.getTweensOf(o, s)).length && a.push.apply(a, f),
          (u = u._next);
      return a;
    }),
    (t.tweenTo = function (n, s) {
      s = s || {};
      var a = this,
        o = Yn(a, n),
        u = s,
        h = u.startAt,
        f = u.onStart,
        c = u.onStartParams,
        d = u.immediateRender,
        m,
        x = bi.to(
          a,
          as(
            {
              ease: s.ease || "none",
              lazy: !1,
              immediateRender: !1,
              time: o,
              overwrite: "auto",
              duration:
                s.duration ||
                Math.abs(
                  (o - (h && "time" in h ? h.time : a._time)) / a.timeScale()
                ) ||
                Yt,
              onStart: function () {
                if ((a.pause(), !m)) {
                  var b =
                    s.duration ||
                    Math.abs(
                      (o - (h && "time" in h ? h.time : a._time)) /
                        a.timeScale()
                    );
                  x._dur !== b && vl(x, b, 0, 1).render(x._time, !0, !0),
                    (m = 1);
                }
                f && f.apply(x, c || []);
              },
            },
            s
          )
        );
      return d ? x.render(0) : x;
    }),
    (t.tweenFromTo = function (n, s, a) {
      return this.tweenTo(s, as({ startAt: { time: Yn(this, n) } }, a));
    }),
    (t.recent = function () {
      return this._recent;
    }),
    (t.nextLabel = function (n) {
      return n === void 0 && (n = this._time), m_(this, Yn(this, n));
    }),
    (t.previousLabel = function (n) {
      return n === void 0 && (n = this._time), m_(this, Yn(this, n), 1);
    }),
    (t.currentLabel = function (n) {
      return arguments.length
        ? this.seek(n, !0)
        : this.previousLabel(this._time + Yt);
    }),
    (t.shiftChildren = function (n, s, a) {
      a === void 0 && (a = 0);
      for (var o = this._first, u = this.labels, h; o; )
        o._start >= a && ((o._start += n), (o._end += n)), (o = o._next);
      if (s) for (h in u) u[h] >= a && (u[h] += n);
      return qo(this);
    }),
    (t.invalidate = function (n) {
      var s = this._first;
      for (this._lock = 0; s; ) s.invalidate(n), (s = s._next);
      return r.prototype.invalidate.call(this, n);
    }),
    (t.clear = function (n) {
      n === void 0 && (n = !0);
      for (var s = this._first, a; s; ) (a = s._next), this.remove(s), (s = a);
      return (
        this._dp && (this._time = this._tTime = this._pTime = 0),
        n && (this.labels = {}),
        qo(this)
      );
    }),
    (t.totalDuration = function (n) {
      var s = 0,
        a = this,
        o = a._last,
        u = is,
        h,
        f,
        c;
      if (arguments.length)
        return a.timeScale(
          (a._repeat < 0 ? a.duration() : a.totalDuration()) /
            (a.reversed() ? -n : n)
        );
      if (a._dirty) {
        for (c = a.parent; o; )
          (h = o._prev),
            o._dirty && o.totalDuration(),
            (f = o._start),
            f > u && a._sort && o._ts && !a._lock
              ? ((a._lock = 1), (Rs(a, o, f - o._delay, 1)._lock = 0))
              : (u = f),
            f < 0 &&
              o._ts &&
              ((s -= f),
              ((!c && !a._dp) || (c && c.smoothChildTiming)) &&
                ((a._start += f / a._ts), (a._time -= f), (a._tTime -= f)),
              a.shiftChildren(-f, !1, -1 / 0),
              (u = 0)),
            o._end > s && o._ts && (s = o._end),
            (o = h);
        vl(a, a === ri && a._time > s ? a._time : s, 1, 1), (a._dirty = 0);
      }
      return a._tDur;
    }),
    (e.updateRoot = function (n) {
      if ((ri._ts && (bx(ri, id(n, ri)), (vx = On.frame)), On.frame >= h_)) {
        h_ += Vn.autoSleep || 120;
        var s = ri._first;
        if ((!s || !s._ts) && Vn.autoSleep && On._listeners.length < 2) {
          for (; s && !s._ts; ) s = s._next;
          s || On.sleep();
        }
      }
    }),
    e
  );
})(Kc);
as(on.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var SP = function (e, t, i, n, s, a, o) {
    var u = new Sn(this._pt, e, t, 0, 1, Xx, null, s),
      h = 0,
      f = 0,
      c,
      d,
      m,
      x,
      v,
      b,
      y,
      M;
    for (
      u.b = i,
        u.e = n,
        i += "",
        n += "",
        (y = ~n.indexOf("random(")) && (n = $c(n)),
        a && ((M = [i, n]), a(M, e, t), (i = M[0]), (n = M[1])),
        d = i.match(tf) || [];
      (c = tf.exec(n));

    )
      (x = c[0]),
        (v = n.substring(h, c.index)),
        m ? (m = (m + 1) % 5) : v.substr(-5) === "rgba(" && (m = 1),
        x !== d[f++] &&
          ((b = parseFloat(d[f - 1]) || 0),
          (u._pt = {
            _next: u._pt,
            p: v || f === 1 ? v : ",",
            s: b,
            c: x.charAt(1) === "=" ? sl(b, x) - b : parseFloat(x) - b,
            m: m && m < 4 ? Math.round : 0,
          }),
          (h = tf.lastIndex));
    return (
      (u.c = h < n.length ? n.substring(h, n.length) : ""),
      (u.fp = o),
      (dx.test(n) || y) && (u.e = 0),
      (this._pt = u),
      u
    );
  },
  qm = function (e, t, i, n, s, a, o, u, h, f) {
    di(n) && (n = n(s || 0, e, a));
    var c = e[t],
      d =
        i !== "get"
          ? i
          : di(c)
          ? h
            ? e[
                t.indexOf("set") || !di(e["get" + t.substr(3)])
                  ? t
                  : "get" + t.substr(3)
              ](h)
            : e[t]()
          : c,
      m = di(c) ? (h ? DP : jx) : $m,
      x;
    if (
      (Ri(n) &&
        (~n.indexOf("random(") && (n = $c(n)),
        n.charAt(1) === "=" &&
          ((x = sl(d, n) + (Hi(d) || 0)), (x || x === 0) && (n = x))),
      !f || d !== n || im)
    )
      return !isNaN(d * n) && n !== ""
        ? ((x = new Sn(
            this._pt,
            e,
            t,
            +d || 0,
            n - (d || 0),
            typeof c == "boolean" ? AP : qx,
            0,
            m
          )),
          h && (x.fp = h),
          o && x.modifier(o, this, e),
          (this._pt = x))
        : (!c && !(t in e) && Gm(t, n),
          SP.call(this, e, t, d, n, m, u || Vn.stringFilter, h));
  },
  MP = function (e, t, i, n, s) {
    if (
      (di(e) && (e = Fc(e, s, t, i, n)),
      !Vs(e) || (e.style && e.nodeType) || qi(e) || ux(e))
    )
      return Ri(e) ? Fc(e, s, t, i, n) : e;
    var a = {},
      o;
    for (o in e) a[o] = Fc(e[o], s, t, i, n);
    return a;
  },
  Gx = function (e, t, i, n, s, a) {
    var o, u, h, f;
    if (
      In[e] &&
      (o = new In[e]()).init(
        s,
        o.rawVars ? t[e] : MP(t[e], n, s, a, i),
        i,
        n,
        a
      ) !== !1 &&
      ((i._pt = u = new Sn(i._pt, s, e, 0, 1, o.render, o, 0, o.priority)),
      i !== Za)
    )
      for (h = i._ptLookup[i._targets.indexOf(s)], f = o._props.length; f--; )
        h[o._props[f]] = u;
    return o;
  },
  jr,
  im,
  Xm = function r(e, t, i) {
    var n = e.vars,
      s = n.ease,
      a = n.startAt,
      o = n.immediateRender,
      u = n.lazy,
      h = n.onUpdate,
      f = n.onUpdateParams,
      c = n.callbackScope,
      d = n.runBackwards,
      m = n.yoyoEase,
      x = n.keyframes,
      v = n.autoRevert,
      b = e._dur,
      y = e._startAt,
      M = e._targets,
      D = e.parent,
      C = D && D.data === "nested" ? D.vars.targets : M,
      A = e._overwrite === "auto" && !Bm,
      I = e.timeline,
      F,
      P,
      k,
      O,
      J,
      ee,
      X,
      j,
      Y,
      ie,
      Q,
      V,
      ve;
    if (
      (I && (!x || !s) && (s = "none"),
      (e._ease = Xo(s, ml.ease)),
      (e._yEase = m ? Bx(Xo(m === !0 ? s : m, ml.ease)) : 0),
      m &&
        e._yoyo &&
        !e._repeat &&
        ((m = e._yEase), (e._yEase = e._ease), (e._ease = m)),
      (e._from = !I && !!n.runBackwards),
      !I || (x && !n.stagger))
    ) {
      if (
        ((j = M[0] ? jo(M[0]).harness : 0),
        (V = j && n[j.prop]),
        (F = td(n, Hm)),
        y &&
          (y._zTime < 0 && y.progress(1),
          t < 0 && d && o && !v ? y.render(-1, !0) : y.revert(d && b ? zh : J3),
          (y._lazy = 0)),
        a)
      ) {
        if (
          (Qr(
            (e._startAt = bi.set(
              M,
              as(
                {
                  data: "isStart",
                  overwrite: !1,
                  parent: D,
                  immediateRender: !0,
                  lazy: !y && wn(u),
                  startAt: null,
                  delay: 0,
                  onUpdate: h,
                  onUpdateParams: f,
                  callbackScope: c,
                  stagger: 0,
                },
                a
              )
            ))
          ),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (ji || (!o && !v)) && e._startAt.revert(zh),
          o && b && t <= 0 && i <= 0)
        ) {
          t && (e._zTime = t);
          return;
        }
      } else if (d && b && !y) {
        if (
          (t && (o = !1),
          (k = as(
            {
              overwrite: !1,
              data: "isFromStart",
              lazy: o && !y && wn(u),
              immediateRender: o,
              stagger: 0,
              parent: D,
            },
            F
          )),
          V && (k[j.prop] = V),
          Qr((e._startAt = bi.set(M, k))),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (ji ? e._startAt.revert(zh) : e._startAt.render(-1, !0)),
          (e._zTime = t),
          !o)
        )
          r(e._startAt, Yt, Yt);
        else if (!t) return;
      }
      for (
        e._pt = e._ptCache = 0, u = (b && wn(u)) || (u && !b), P = 0;
        P < M.length;
        P++
      ) {
        if (
          ((J = M[P]),
          (X = J._gsap || jm(M)[P]._gsap),
          (e._ptLookup[P] = ie = {}),
          Kf[X.id] && Yr.length && ed(),
          (Q = C === M ? P : C.indexOf(J)),
          j &&
            (Y = new j()).init(J, V || F, e, Q, C) !== !1 &&
            ((e._pt = O =
              new Sn(e._pt, J, Y.name, 0, 1, Y.render, Y, 0, Y.priority)),
            Y._props.forEach(function (U) {
              ie[U] = O;
            }),
            Y.priority && (ee = 1)),
          !j || V)
        )
          for (k in F)
            In[k] && (Y = Gx(k, F, e, Q, J, C))
              ? Y.priority && (ee = 1)
              : (ie[k] = O =
                  qm.call(e, J, k, "get", F[k], Q, C, 0, n.stringFilter));
        e._op && e._op[P] && e.kill(J, e._op[P]),
          A &&
            e._pt &&
            ((jr = e),
            ri.killTweensOf(J, ie, e.globalTime(t)),
            (ve = !e.parent),
            (jr = 0)),
          e._pt && u && (Kf[X.id] = 1);
      }
      ee && $x(e), e._onInit && e._onInit(e);
    }
    (e._onUpdate = h),
      (e._initted = (!e._op || e._pt) && !ve),
      x && t <= 0 && I.render(is, !0, !0);
  },
  TP = function (e, t, i, n, s, a, o) {
    var u = ((e._pt && e._ptCache) || (e._ptCache = {}))[t],
      h,
      f,
      c,
      d;
    if (!u)
      for (
        u = e._ptCache[t] = [], c = e._ptLookup, d = e._targets.length;
        d--;

      ) {
        if (((h = c[d][t]), h && h.d && h.d._pt))
          for (h = h.d._pt; h && h.p !== t && h.fp !== t; ) h = h._next;
        if (!h) return (im = 1), (e.vars[t] = "+=0"), Xm(e, o), (im = 0), 1;
        u.push(h);
      }
    for (d = u.length; d--; )
      (f = u[d]),
        (h = f._pt || f),
        (h.s = (n || n === 0) && !s ? n : h.s + (n || 0) + a * h.c),
        (h.c = i - h.s),
        f.e && (f.e = mi(i) + Hi(f.e)),
        f.b && (f.b = h.s + Hi(f.b));
  },
  EP = function (e, t) {
    var i = e[0] ? jo(e[0]).harness : 0,
      n = i && i.aliases,
      s,
      a,
      o,
      u;
    if (!n) return t;
    s = ia({}, t);
    for (a in n)
      if (a in s) for (u = n[a].split(","), o = u.length; o--; ) s[u[o]] = s[a];
    return s;
  },
  CP = function (e, t, i, n) {
    var s = t.ease || n || "power1.inOut",
      a,
      o;
    if (qi(t))
      (o = i[e] || (i[e] = [])),
        t.forEach(function (u, h) {
          return o.push({ t: (h / (t.length - 1)) * 100, v: u, e: s });
        });
    else
      for (a in t)
        (o = i[a] || (i[a] = [])),
          a === "ease" || o.push({ t: parseFloat(e), v: t[a], e: s });
  },
  Fc = function (e, t, i, n, s) {
    return di(e)
      ? e.call(t, i, n, s)
      : Ri(e) && ~e.indexOf("random(")
      ? $c(e)
      : e;
  },
  Hx = Wm + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
  Wx = {};
yn(Hx + ",id,stagger,delay,duration,paused,scrollTrigger", function (r) {
  return (Wx[r] = 1);
});
var bi = (function (r) {
  lx(e, r);
  function e(i, n, s, a) {
    var o;
    typeof n == "number" && ((s.duration = n), (n = s), (s = null)),
      (o = r.call(this, a ? n : kc(n)) || this);
    var u = o.vars,
      h = u.duration,
      f = u.delay,
      c = u.immediateRender,
      d = u.stagger,
      m = u.overwrite,
      x = u.keyframes,
      v = u.defaults,
      b = u.scrollTrigger,
      y = u.yoyoEase,
      M = n.parent || ri,
      D = (qi(i) || ux(i) ? _r(i[0]) : "length" in n) ? [i] : ns(i),
      C,
      A,
      I,
      F,
      P,
      k,
      O,
      J;
    if (
      ((o._targets = D.length
        ? jm(D)
        : Qh(
            "GSAP target " + i + " not found. https://greensock.com",
            !Vn.nullTargetWarn
          ) || []),
      (o._ptLookup = []),
      (o._overwrite = m),
      x || d || Th(h) || Th(f))
    ) {
      if (
        ((n = o.vars),
        (C = o.timeline =
          new on({
            data: "nested",
            defaults: v || {},
            targets: M && M.data === "nested" ? M.vars.targets : D,
          })),
        C.kill(),
        (C.parent = C._dp = sr(o)),
        (C._start = 0),
        d || Th(h) || Th(f))
      ) {
        if (((F = D.length), (O = d && Dx(d)), Vs(d)))
          for (P in d) ~Hx.indexOf(P) && (J || (J = {}), (J[P] = d[P]));
        for (A = 0; A < F; A++)
          (I = td(n, Wx)),
            (I.stagger = 0),
            y && (I.yoyoEase = y),
            J && ia(I, J),
            (k = D[A]),
            (I.duration = +Fc(h, sr(o), A, k, D)),
            (I.delay = (+Fc(f, sr(o), A, k, D) || 0) - o._delay),
            !d &&
              F === 1 &&
              I.delay &&
              ((o._delay = f = I.delay), (o._start += f), (I.delay = 0)),
            C.to(k, I, O ? O(A, k, D) : 0),
            (C._ease = Ft.none);
        C.duration() ? (h = f = 0) : (o.timeline = 0);
      } else if (x) {
        kc(as(C.vars.defaults, { ease: "none" })),
          (C._ease = Xo(x.ease || n.ease || "none"));
        var ee = 0,
          X,
          j,
          Y;
        if (qi(x))
          x.forEach(function (ie) {
            return C.to(D, ie, ">");
          }),
            C.duration();
        else {
          I = {};
          for (P in x)
            P === "ease" || P === "easeEach" || CP(P, x[P], I, x.easeEach);
          for (P in I)
            for (
              X = I[P].sort(function (ie, Q) {
                return ie.t - Q.t;
              }),
                ee = 0,
                A = 0;
              A < X.length;
              A++
            )
              (j = X[A]),
                (Y = {
                  ease: j.e,
                  duration: ((j.t - (A ? X[A - 1].t : 0)) / 100) * h,
                }),
                (Y[P] = j.v),
                C.to(D, Y, ee),
                (ee += Y.duration);
          C.duration() < h && C.to({}, { duration: h - C.duration() });
        }
      }
      h || o.duration((h = C.duration()));
    } else o.timeline = 0;
    return (
      m === !0 && !Bm && ((jr = sr(o)), ri.killTweensOf(D), (jr = 0)),
      Rs(M, sr(o), s),
      n.reversed && o.reverse(),
      n.paused && o.paused(!0),
      (c ||
        (!h &&
          !x &&
          o._start === Oi(M._time) &&
          wn(c) &&
          sP(sr(o)) &&
          M.data !== "nested")) &&
        ((o._tTime = -Yt), o.render(Math.max(0, -f) || 0)),
      b && Mx(sr(o), b),
      o
    );
  }
  var t = e.prototype;
  return (
    (t.render = function (n, s, a) {
      var o = this._time,
        u = this._tDur,
        h = this._dur,
        f = n < 0,
        c = n > u - Yt && !f ? u : n < Yt ? 0 : n,
        d,
        m,
        x,
        v,
        b,
        y,
        M,
        D,
        C;
      if (!h) oP(this, n, s, a);
      else if (
        c !== this._tTime ||
        !n ||
        a ||
        (!this._initted && this._tTime) ||
        (this._startAt && this._zTime < 0 !== f)
      ) {
        if (((d = c), (D = this.timeline), this._repeat)) {
          if (((v = h + this._rDelay), this._repeat < -1 && f))
            return this.totalTime(v * 100 + n, s, a);
          if (
            ((d = Oi(c % v)),
            c === u
              ? ((x = this._repeat), (d = h))
              : ((x = ~~(c / v)),
                x && x === c / v && ((d = h), x--),
                d > h && (d = h)),
            (y = this._yoyo && x & 1),
            y && ((C = this._yEase), (d = h - d)),
            (b = gl(this._tTime, v)),
            d === o && !a && this._initted)
          )
            return (this._tTime = c), this;
          x !== b &&
            (D && this._yEase && Vx(D, y),
            this.vars.repeatRefresh &&
              !y &&
              !this._lock &&
              ((this._lock = a = 1),
              (this.render(Oi(v * x), !0).invalidate()._lock = 0)));
        }
        if (!this._initted) {
          if (Tx(this, f ? n : d, a, s, c)) return (this._tTime = 0), this;
          if (o !== this._time) return this;
          if (h !== this._dur) return this.render(n, s, a);
        }
        if (
          ((this._tTime = c),
          (this._time = d),
          !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
          (this.ratio = M = (C || this._ease)(d / h)),
          this._from && (this.ratio = M = 1 - M),
          d && !o && !s && !x && (ss(this, "onStart"), this._tTime !== c))
        )
          return this;
        for (m = this._pt; m; ) m.r(M, m.d), (m = m._next);
        (D &&
          D.render(
            n < 0 ? n : !d && y ? -Yt : D._dur * D._ease(d / this._dur),
            s,
            a
          )) ||
          (this._startAt && (this._zTime = n)),
          this._onUpdate &&
            !s &&
            (f && Zf(this, n, s, a), ss(this, "onUpdate")),
          this._repeat &&
            x !== b &&
            this.vars.onRepeat &&
            !s &&
            this.parent &&
            ss(this, "onRepeat"),
          (c === this._tDur || !c) &&
            this._tTime === c &&
            (f && !this._onUpdate && Zf(this, n, !0, !0),
            (n || !h) &&
              ((c === this._tDur && this._ts > 0) || (!c && this._ts < 0)) &&
              Qr(this, 1),
            !s &&
              !(f && !o) &&
              (c || o || y) &&
              (ss(this, c === u ? "onComplete" : "onReverseComplete", !0),
              this._prom && !(c < u && this.timeScale() > 0) && this._prom()));
      }
      return this;
    }),
    (t.targets = function () {
      return this._targets;
    }),
    (t.invalidate = function (n) {
      return (
        (!n || !this.vars.runBackwards) && (this._startAt = 0),
        (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
        (this._ptLookup = []),
        this.timeline && this.timeline.invalidate(n),
        r.prototype.invalidate.call(this, n)
      );
    }),
    (t.resetTo = function (n, s, a, o) {
      Yc || On.wake(), this._ts || this.play();
      var u = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        h;
      return (
        this._initted || Xm(this, u),
        (h = this._ease(u / this._dur)),
        TP(this, n, s, a, o, h, u)
          ? this.resetTo(n, s, a, o)
          : (_d(this, 0),
            this.parent ||
              yx(
                this._dp,
                this,
                "_first",
                "_last",
                this._dp._sort ? "_start" : 0
              ),
            this.render(0))
      );
    }),
    (t.kill = function (n, s) {
      if ((s === void 0 && (s = "all"), !n && (!s || s === "all")))
        return (this._lazy = this._pt = 0), this.parent ? wc(this) : this;
      if (this.timeline) {
        var a = this.timeline.totalDuration();
        return (
          this.timeline.killTweensOf(n, s, jr && jr.vars.overwrite !== !0)
            ._first || wc(this),
          this.parent &&
            a !== this.timeline.totalDuration() &&
            vl(this, (this._dur * this.timeline._tDur) / a, 0, 1),
          this
        );
      }
      var o = this._targets,
        u = n ? ns(n) : o,
        h = this._ptLookup,
        f = this._pt,
        c,
        d,
        m,
        x,
        v,
        b,
        y;
      if ((!s || s === "all") && iP(o, u))
        return s === "all" && (this._pt = 0), wc(this);
      for (
        c = this._op = this._op || [],
          s !== "all" &&
            (Ri(s) &&
              ((v = {}),
              yn(s, function (M) {
                return (v[M] = 1);
              }),
              (s = v)),
            (s = EP(o, s))),
          y = o.length;
        y--;

      )
        if (~u.indexOf(o[y])) {
          (d = h[y]),
            s === "all"
              ? ((c[y] = s), (x = d), (m = {}))
              : ((m = c[y] = c[y] || {}), (x = s));
          for (v in x)
            (b = d && d[v]),
              b &&
                ((!("kill" in b.d) || b.d.kill(v) === !0) && gd(this, b, "_pt"),
                delete d[v]),
              m !== "all" && (m[v] = 1);
        }
      return this._initted && !this._pt && f && wc(this), this;
    }),
    (e.to = function (n, s) {
      return new e(n, s, arguments[2]);
    }),
    (e.from = function (n, s) {
      return Ic(1, arguments);
    }),
    (e.delayedCall = function (n, s, a, o) {
      return new e(s, 0, {
        immediateRender: !1,
        lazy: !1,
        overwrite: !1,
        delay: n,
        onComplete: s,
        onReverseComplete: s,
        onCompleteParams: a,
        onReverseCompleteParams: a,
        callbackScope: o,
      });
    }),
    (e.fromTo = function (n, s, a) {
      return Ic(2, arguments);
    }),
    (e.set = function (n, s) {
      return (s.duration = 0), s.repeatDelay || (s.repeat = 0), new e(n, s);
    }),
    (e.killTweensOf = function (n, s, a) {
      return ri.killTweensOf(n, s, a);
    }),
    e
  );
})(Kc);
as(bi.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
yn("staggerTo,staggerFrom,staggerFromTo", function (r) {
  bi[r] = function () {
    var e = new on(),
      t = Qf.call(arguments, 0);
    return t.splice(r === "staggerFromTo" ? 5 : 4, 0, 0), e[r].apply(e, t);
  };
});
var $m = function (e, t, i) {
    return (e[t] = i);
  },
  jx = function (e, t, i) {
    return e[t](i);
  },
  DP = function (e, t, i, n) {
    return e[t](n.fp, i);
  },
  PP = function (e, t, i) {
    return e.setAttribute(t, i);
  },
  Ym = function (e, t) {
    return di(e[t]) ? jx : Vm(e[t]) && e.setAttribute ? PP : $m;
  },
  qx = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
  },
  AP = function (e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t);
  },
  Xx = function (e, t) {
    var i = t._pt,
      n = "";
    if (!e && t.b) n = t.b;
    else if (e === 1 && t.e) n = t.e;
    else {
      for (; i; )
        (n =
          i.p +
          (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) +
          n),
          (i = i._next);
      n += t.c;
    }
    t.set(t.t, t.p, n, t);
  },
  Km = function (e, t) {
    for (var i = t._pt; i; ) i.r(e, i.d), (i = i._next);
  },
  LP = function (e, t, i, n) {
    for (var s = this._pt, a; s; )
      (a = s._next), s.p === n && s.modifier(e, t, i), (s = a);
  },
  RP = function (e) {
    for (var t = this._pt, i, n; t; )
      (n = t._next),
        (t.p === e && !t.op) || t.op === e
          ? gd(this, t, "_pt")
          : t.dep || (i = 1),
        (t = n);
    return !i;
  },
  kP = function (e, t, i, n) {
    n.mSet(e, t, n.m.call(n.tween, i, n.mt), n);
  },
  $x = function (e) {
    for (var t = e._pt, i, n, s, a; t; ) {
      for (i = t._next, n = s; n && n.pr > t.pr; ) n = n._next;
      (t._prev = n ? n._prev : a) ? (t._prev._next = t) : (s = t),
        (t._next = n) ? (n._prev = t) : (a = t),
        (t = i);
    }
    e._pt = s;
  },
  Sn = (function () {
    function r(t, i, n, s, a, o, u, h, f) {
      (this.t = i),
        (this.s = s),
        (this.c = a),
        (this.p = n),
        (this.r = o || qx),
        (this.d = u || this),
        (this.set = h || $m),
        (this.pr = f || 0),
        (this._next = t),
        t && (t._prev = this);
    }
    var e = r.prototype;
    return (
      (e.modifier = function (i, n, s) {
        (this.mSet = this.mSet || this.set),
          (this.set = kP),
          (this.m = i),
          (this.mt = s),
          (this.tween = n);
      }),
      r
    );
  })();
yn(
  Wm +
    "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
  function (r) {
    return (Hm[r] = 1);
  }
);
zn.TweenMax = zn.TweenLite = bi;
zn.TimelineLite = zn.TimelineMax = on;
ri = new on({
  sortChildren: !1,
  defaults: ml,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0,
});
Vn.stringFilter = Nx;
var $o = [],
  Gh = {},
  IP = [],
  v_ = 0,
  FP = 0,
  af = function (e) {
    return (Gh[e] || IP).map(function (t) {
      return t();
    });
  },
  nm = function () {
    var e = Date.now(),
      t = [];
    e - v_ > 2 &&
      (af("matchMediaInit"),
      $o.forEach(function (i) {
        var n = i.queries,
          s = i.conditions,
          a,
          o,
          u,
          h;
        for (o in n)
          (a = Zn.matchMedia(n[o]).matches),
            a && (u = 1),
            a !== s[o] && ((s[o] = a), (h = 1));
        h && (i.revert(), u && t.push(i));
      }),
      af("matchMediaRevert"),
      t.forEach(function (i) {
        return i.onMatch(i);
      }),
      (v_ = e),
      af("matchMedia"));
  },
  Yx = (function () {
    function r(t, i) {
      (this.selector = i && em(i)),
        (this.data = []),
        (this._r = []),
        (this.isReverted = !1),
        (this.id = FP++),
        t && this.add(t);
    }
    var e = r.prototype;
    return (
      (e.add = function (i, n, s) {
        di(i) && ((s = n), (n = i), (i = di));
        var a = this,
          o = function () {
            var h = hi,
              f = a.selector,
              c;
            return (
              h && h !== a && h.data.push(a),
              s && (a.selector = em(s)),
              (hi = a),
              (c = n.apply(a, arguments)),
              di(c) && a._r.push(c),
              (hi = h),
              (a.selector = f),
              (a.isReverted = !1),
              c
            );
          };
        return (a.last = o), i === di ? o(a) : i ? (a[i] = o) : o;
      }),
      (e.ignore = function (i) {
        var n = hi;
        (hi = null), i(this), (hi = n);
      }),
      (e.getTweens = function () {
        var i = [];
        return (
          this.data.forEach(function (n) {
            return n instanceof r
              ? i.push.apply(i, n.getTweens())
              : n instanceof bi &&
                  !(n.parent && n.parent.data === "nested") &&
                  i.push(n);
          }),
          i
        );
      }),
      (e.clear = function () {
        this._r.length = this.data.length = 0;
      }),
      (e.kill = function (i, n) {
        var s = this;
        if (i) {
          var a = this.getTweens();
          this.data.forEach(function (u) {
            u.data === "isFlip" &&
              (u.revert(),
              u.getChildren(!0, !0, !1).forEach(function (h) {
                return a.splice(a.indexOf(h), 1);
              }));
          }),
            a
              .map(function (u) {
                return { g: u.globalTime(0), t: u };
              })
              .sort(function (u, h) {
                return h.g - u.g || -1;
              })
              .forEach(function (u) {
                return u.t.revert(i);
              }),
            this.data.forEach(function (u) {
              return u instanceof on
                ? u.data !== "nested" && u.kill()
                : !(u instanceof bi) && u.revert && u.revert(i);
            }),
            this._r.forEach(function (u) {
              return u(i, s);
            }),
            (this.isReverted = !0);
        } else
          this.data.forEach(function (u) {
            return u.kill && u.kill();
          });
        if ((this.clear(), n))
          for (var o = $o.length; o--; )
            $o[o].id === this.id && $o.splice(o, 1);
      }),
      (e.revert = function (i) {
        this.kill(i || {});
      }),
      r
    );
  })(),
  OP = (function () {
    function r(t) {
      (this.contexts = []), (this.scope = t);
    }
    var e = r.prototype;
    return (
      (e.add = function (i, n, s) {
        Vs(i) || (i = { matches: i });
        var a = new Yx(0, s || this.scope),
          o = (a.conditions = {}),
          u,
          h,
          f;
        hi && !a.selector && (a.selector = hi.selector),
          this.contexts.push(a),
          (n = a.add("onMatch", n)),
          (a.queries = i);
        for (h in i)
          h === "all"
            ? (f = 1)
            : ((u = Zn.matchMedia(i[h])),
              u &&
                ($o.indexOf(a) < 0 && $o.push(a),
                (o[h] = u.matches) && (f = 1),
                u.addListener
                  ? u.addListener(nm)
                  : u.addEventListener("change", nm)));
        return f && n(a), this;
      }),
      (e.revert = function (i) {
        this.kill(i || {});
      }),
      (e.kill = function (i) {
        this.contexts.forEach(function (n) {
          return n.kill(i, !0);
        });
      }),
      r
    );
  })(),
  nd = {
    registerPlugin: function () {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      t.forEach(function (n) {
        return Ix(n);
      });
    },
    timeline: function (e) {
      return new on(e);
    },
    getTweensOf: function (e, t) {
      return ri.getTweensOf(e, t);
    },
    getProperty: function (e, t, i, n) {
      Ri(e) && (e = ns(e)[0]);
      var s = jo(e || {}).get,
        a = i ? wx : xx;
      return (
        i === "native" && (i = ""),
        e &&
          (t
            ? a(((In[t] && In[t].get) || s)(e, t, i, n))
            : function (o, u, h) {
                return a(((In[o] && In[o].get) || s)(e, o, u, h));
              })
      );
    },
    quickSetter: function (e, t, i) {
      if (((e = ns(e)), e.length > 1)) {
        var n = e.map(function (f) {
            return Xi.quickSetter(f, t, i);
          }),
          s = n.length;
        return function (f) {
          for (var c = s; c--; ) n[c](f);
        };
      }
      e = e[0] || {};
      var a = In[t],
        o = jo(e),
        u = (o.harness && (o.harness.aliases || {})[t]) || t,
        h = a
          ? function (f) {
              var c = new a();
              (Za._pt = 0),
                c.init(e, i ? f + i : f, Za, 0, [e]),
                c.render(1, c),
                Za._pt && Km(1, Za);
            }
          : o.set(e, u);
      return a
        ? h
        : function (f) {
            return h(e, u, i ? f + i : f, o, 1);
          };
    },
    quickTo: function (e, t, i) {
      var n,
        s = Xi.to(
          e,
          ia(((n = {}), (n[t] = "+=0.1"), (n.paused = !0), n), i || {})
        ),
        a = function (u, h, f) {
          return s.resetTo(t, u, h, f);
        };
      return (a.tween = s), a;
    },
    isTweening: function (e) {
      return ri.getTweensOf(e, !0).length > 0;
    },
    defaults: function (e) {
      return e && e.ease && (e.ease = Xo(e.ease, ml.ease)), d_(ml, e || {});
    },
    config: function (e) {
      return d_(Vn, e || {});
    },
    registerEffect: function (e) {
      var t = e.name,
        i = e.effect,
        n = e.plugins,
        s = e.defaults,
        a = e.extendTimeline;
      (n || "").split(",").forEach(function (o) {
        return (
          o && !In[o] && !zn[o] && Qh(t + " effect requires " + o + " plugin.")
        );
      }),
        (nf[t] = function (o, u, h) {
          return i(ns(o), as(u || {}, s), h);
        }),
        a &&
          (on.prototype[t] = function (o, u, h) {
            return this.add(nf[t](o, Vs(u) ? u : (h = u) && {}, this), h);
          });
    },
    registerEase: function (e, t) {
      Ft[e] = Xo(t);
    },
    parseEase: function (e, t) {
      return arguments.length ? Xo(e, t) : Ft;
    },
    getById: function (e) {
      return ri.getById(e);
    },
    exportRoot: function (e, t) {
      e === void 0 && (e = {});
      var i = new on(e),
        n,
        s;
      for (
        i.smoothChildTiming = wn(e.smoothChildTiming),
          ri.remove(i),
          i._dp = 0,
          i._time = i._tTime = ri._time,
          n = ri._first;
        n;

      )
        (s = n._next),
          (t ||
            !(
              !n._dur &&
              n instanceof bi &&
              n.vars.onComplete === n._targets[0]
            )) &&
            Rs(i, n, n._start - n._delay),
          (n = s);
      return Rs(ri, i, 0), i;
    },
    context: function (e, t) {
      return e ? new Yx(e, t) : hi;
    },
    matchMedia: function (e) {
      return new OP(e);
    },
    matchMediaRefresh: function () {
      return (
        $o.forEach(function (e) {
          var t = e.conditions,
            i,
            n;
          for (n in t) t[n] && ((t[n] = !1), (i = 1));
          i && e.revert();
        }) || nm()
      );
    },
    addEventListener: function (e, t) {
      var i = Gh[e] || (Gh[e] = []);
      ~i.indexOf(t) || i.push(t);
    },
    removeEventListener: function (e, t) {
      var i = Gh[e],
        n = i && i.indexOf(t);
      n >= 0 && i.splice(n, 1);
    },
    utils: {
      wrap: fP,
      wrapYoyo: mP,
      distribute: Dx,
      random: Ax,
      snap: Px,
      normalize: pP,
      getUnit: Hi,
      clamp: cP,
      splitColor: Fx,
      toArray: ns,
      selector: em,
      mapRange: Rx,
      pipe: hP,
      unitize: dP,
      interpolate: gP,
      shuffle: Cx,
    },
    install: mx,
    effects: nf,
    ticker: On,
    updateRoot: on.updateRoot,
    plugins: In,
    globalTimeline: ri,
    core: {
      PropTween: Sn,
      globals: gx,
      Tween: bi,
      Timeline: on,
      Animation: Kc,
      getCache: jo,
      _removeLinkedListItem: gd,
      reverting: function () {
        return ji;
      },
      context: function (e) {
        return e && hi && (hi.data.push(e), (e._ctx = hi)), hi;
      },
      suppressOverwrites: function (e) {
        return (Bm = e);
      },
    },
  };
yn("to,from,fromTo,delayedCall,set,killTweensOf", function (r) {
  return (nd[r] = bi[r]);
});
On.add(on.updateRoot);
Za = nd.to({}, { duration: 0 });
var NP = function (e, t) {
    for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t; )
      i = i._next;
    return i;
  },
  BP = function (e, t) {
    var i = e._targets,
      n,
      s,
      a;
    for (n in t)
      for (s = i.length; s--; )
        (a = e._ptLookup[s][n]),
          a &&
            (a = a.d) &&
            (a._pt && (a = NP(a, n)),
            a && a.modifier && a.modifier(t[n], e, i[s], n));
  },
  lf = function (e, t) {
    return {
      name: e,
      rawVars: 1,
      init: function (n, s, a) {
        a._onInit = function (o) {
          var u, h;
          if (
            (Ri(s) &&
              ((u = {}),
              yn(s, function (f) {
                return (u[f] = 1);
              }),
              (s = u)),
            t)
          ) {
            u = {};
            for (h in s) u[h] = t(s[h]);
            s = u;
          }
          BP(o, s);
        };
      },
    };
  },
  Xi =
    nd.registerPlugin(
      {
        name: "attr",
        init: function (e, t, i, n, s) {
          var a, o, u;
          this.tween = i;
          for (a in t)
            (u = e.getAttribute(a) || ""),
              (o = this.add(
                e,
                "setAttribute",
                (u || 0) + "",
                t[a],
                n,
                s,
                0,
                0,
                a
              )),
              (o.op = a),
              (o.b = u),
              this._props.push(a);
        },
        render: function (e, t) {
          for (var i = t._pt; i; )
            ji ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), (i = i._next);
        },
      },
      {
        name: "endArray",
        init: function (e, t) {
          for (var i = t.length; i--; )
            this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1);
        },
      },
      lf("roundProps", tm),
      lf("modifiers"),
      lf("snap", Px)
    ) || nd;
bi.version = on.version = Xi.version = "3.12.1";
fx = 1;
zm() && _l();
Ft.Power0;
Ft.Power1;
Ft.Power2;
Ft.Power3;
Ft.Power4;
Ft.Linear;
Ft.Quad;
Ft.Cubic;
Ft.Quart;
Ft.Quint;
Ft.Strong;
Ft.Elastic;
Ft.Back;
Ft.SteppedEase;
Ft.Bounce;
Ft.Sine;
Ft.Expo;
Ft.Circ;
/*!
 * CSSPlugin 3.12.1
 * https://greensock.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var __,
  qr,
  rl,
  Zm,
  Io,
  b_,
  Jm,
  VP = function () {
    return typeof window < "u";
  },
  br = {},
  Do = 180 / Math.PI,
  ol = Math.PI / 180,
  Va = Math.atan2,
  x_ = 1e8,
  Qm = /([A-Z])/g,
  zP = /(left|right|width|margin|padding|x)/i,
  UP = /[\s,\(]\S/,
  ks = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity",
  },
  sm = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
  },
  GP = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u,
      t
    );
  },
  HP = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b,
      t
    );
  },
  WP = function (e, t) {
    var i = t.s + t.c * e;
    t.set(t.t, t.p, ~~(i + (i < 0 ? -0.5 : 0.5)) + t.u, t);
  },
  Kx = function (e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t);
  },
  Zx = function (e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
  },
  jP = function (e, t, i) {
    return (e.style[t] = i);
  },
  qP = function (e, t, i) {
    return e.style.setProperty(t, i);
  },
  XP = function (e, t, i) {
    return (e._gsap[t] = i);
  },
  $P = function (e, t, i) {
    return (e._gsap.scaleX = e._gsap.scaleY = i);
  },
  YP = function (e, t, i, n, s) {
    var a = e._gsap;
    (a.scaleX = a.scaleY = i), a.renderTransform(s, a);
  },
  KP = function (e, t, i, n, s) {
    var a = e._gsap;
    (a[t] = i), a.renderTransform(s, a);
  },
  oi = "transform",
  xs = oi + "Origin",
  ZP = function r(e, t) {
    var i = this,
      n = this.target,
      s = n.style;
    if (e in br && s) {
      if (((this.tfm = this.tfm || {}), e !== "transform"))
        (e = ks[e] || e),
          ~e.indexOf(",")
            ? e.split(",").forEach(function (a) {
                return (i.tfm[a] = rr(n, a));
              })
            : (this.tfm[e] = n._gsap.x ? n._gsap[e] : rr(n, e));
      else
        return ks.transform.split(",").forEach(function (a) {
          return r.call(i, a, t);
        });
      if (this.props.indexOf(oi) >= 0) return;
      n._gsap.svg &&
        ((this.svgo = n.getAttribute("data-svg-origin")),
        this.props.push(xs, t, "")),
        (e = oi);
    }
    (s || t) && this.props.push(e, t, s[e]);
  },
  Jx = function (e) {
    e.translate &&
      (e.removeProperty("translate"),
      e.removeProperty("scale"),
      e.removeProperty("rotate"));
  },
  JP = function () {
    var e = this.props,
      t = this.target,
      i = t.style,
      n = t._gsap,
      s,
      a;
    for (s = 0; s < e.length; s += 3)
      e[s + 1]
        ? (t[e[s]] = e[s + 2])
        : e[s + 2]
        ? (i[e[s]] = e[s + 2])
        : i.removeProperty(
            e[s].substr(0, 2) === "--"
              ? e[s]
              : e[s].replace(Qm, "-$1").toLowerCase()
          );
    if (this.tfm) {
      for (a in this.tfm) n[a] = this.tfm[a];
      n.svg &&
        (n.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        (s = Jm()),
        (!s || !s.isStart) && !i[oi] && (Jx(i), (n.uncache = 1));
    }
  },
  Qx = function (e, t) {
    var i = { target: e, props: [], revert: JP, save: ZP };
    return (
      e._gsap || Xi.core.getCache(e),
      t &&
        t.split(",").forEach(function (n) {
          return i.save(n);
        }),
      i
    );
  },
  ew,
  rm = function (e, t) {
    var i = qr.createElementNS
      ? qr.createElementNS(
          (t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
          e
        )
      : qr.createElement(e);
    return i.style ? i : qr.createElement(e);
  },
  Os = function r(e, t, i) {
    var n = getComputedStyle(e);
    return (
      n[t] ||
      n.getPropertyValue(t.replace(Qm, "-$1").toLowerCase()) ||
      n.getPropertyValue(t) ||
      (!i && r(e, bl(t) || t, 1)) ||
      ""
    );
  },
  w_ = "O,Moz,ms,Ms,Webkit".split(","),
  bl = function (e, t, i) {
    var n = t || Io,
      s = n.style,
      a = 5;
    if (e in s && !i) return e;
    for (
      e = e.charAt(0).toUpperCase() + e.substr(1);
      a-- && !(w_[a] + e in s);

    );
    return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? w_[a] : "") + e;
  },
  om = function () {
    VP() &&
      window.document &&
      ((__ = window),
      (qr = __.document),
      (rl = qr.documentElement),
      (Io = rm("div") || { style: {} }),
      rm("div"),
      (oi = bl(oi)),
      (xs = oi + "Origin"),
      (Io.style.cssText =
        "border-width:0;line-height:0;position:absolute;padding:0"),
      (ew = !!bl("perspective")),
      (Jm = Xi.core.reverting),
      (Zm = 1));
  },
  cf = function r(e) {
    var t = rm(
        "svg",
        (this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns")) ||
          "http://www.w3.org/2000/svg"
      ),
      i = this.parentNode,
      n = this.nextSibling,
      s = this.style.cssText,
      a;
    if (
      (rl.appendChild(t),
      t.appendChild(this),
      (this.style.display = "block"),
      e)
    )
      try {
        (a = this.getBBox()),
          (this._gsapBBox = this.getBBox),
          (this.getBBox = r);
      } catch {}
    else this._gsapBBox && (a = this._gsapBBox());
    return (
      i && (n ? i.insertBefore(this, n) : i.appendChild(this)),
      rl.removeChild(t),
      (this.style.cssText = s),
      a
    );
  },
  y_ = function (e, t) {
    for (var i = t.length; i--; )
      if (e.hasAttribute(t[i])) return e.getAttribute(t[i]);
  },
  tw = function (e) {
    var t;
    try {
      t = e.getBBox();
    } catch {
      t = cf.call(e, !0);
    }
    return (
      (t && (t.width || t.height)) || e.getBBox === cf || (t = cf.call(e, !0)),
      t && !t.width && !t.x && !t.y
        ? {
            x: +y_(e, ["x", "cx", "x1"]) || 0,
            y: +y_(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0,
          }
        : t
    );
  },
  iw = function (e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && tw(e));
  },
  Zc = function (e, t) {
    if (t) {
      var i = e.style;
      t in br && t !== xs && (t = oi),
        i.removeProperty
          ? ((t.substr(0, 2) === "ms" || t.substr(0, 6) === "webkit") &&
              (t = "-" + t),
            i.removeProperty(t.replace(Qm, "-$1").toLowerCase()))
          : i.removeAttribute(t);
    }
  },
  Xr = function (e, t, i, n, s, a) {
    var o = new Sn(e._pt, t, i, 0, 1, a ? Zx : Kx);
    return (e._pt = o), (o.b = n), (o.e = s), e._props.push(i), o;
  },
  S_ = { deg: 1, rad: 1, turn: 1 },
  QP = { grid: 1, flex: 1 },
  eo = function r(e, t, i, n) {
    var s = parseFloat(i) || 0,
      a = (i + "").trim().substr((s + "").length) || "px",
      o = Io.style,
      u = zP.test(t),
      h = e.tagName.toLowerCase() === "svg",
      f = (h ? "client" : "offset") + (u ? "Width" : "Height"),
      c = 100,
      d = n === "px",
      m = n === "%",
      x,
      v,
      b,
      y;
    return n === a || !s || S_[n] || S_[a]
      ? s
      : (a !== "px" && !d && (s = r(e, t, i, "px")),
        (y = e.getCTM && iw(e)),
        (m || a === "%") && (br[t] || ~t.indexOf("adius"))
          ? ((x = y ? e.getBBox()[u ? "width" : "height"] : e[f]),
            mi(m ? (s / x) * c : (s / 100) * x))
          : ((o[u ? "width" : "height"] = c + (d ? a : n)),
            (v =
              ~t.indexOf("adius") || (n === "em" && e.appendChild && !h)
                ? e
                : e.parentNode),
            y && (v = (e.ownerSVGElement || {}).parentNode),
            (!v || v === qr || !v.appendChild) && (v = qr.body),
            (b = v._gsap),
            b && m && b.width && u && b.time === On.time && !b.uncache
              ? mi((s / b.width) * c)
              : ((m || a === "%") &&
                  !QP[Os(v, "display")] &&
                  (o.position = Os(e, "position")),
                v === e && (o.position = "static"),
                v.appendChild(Io),
                (x = Io[f]),
                v.removeChild(Io),
                (o.position = "absolute"),
                u && m && ((b = jo(v)), (b.time = On.time), (b.width = v[f])),
                mi(d ? (x * s) / c : x && s ? (c / x) * s : 0))));
  },
  rr = function (e, t, i, n) {
    var s;
    return (
      Zm || om(),
      t in ks &&
        t !== "transform" &&
        ((t = ks[t]), ~t.indexOf(",") && (t = t.split(",")[0])),
      br[t] && t !== "transform"
        ? ((s = Qc(e, n)),
          (s =
            t !== "transformOrigin"
              ? s[t]
              : s.svg
              ? s.origin
              : rd(Os(e, xs)) + " " + s.zOrigin + "px"))
        : ((s = e.style[t]),
          (!s || s === "auto" || n || ~(s + "").indexOf("calc(")) &&
            (s =
              (sd[t] && sd[t](e, t, i)) ||
              Os(e, t) ||
              _x(e, t) ||
              (t === "opacity" ? 1 : 0))),
      i && !~(s + "").trim().indexOf(" ") ? eo(e, t, s, i) + i : s
    );
  },
  eA = function (e, t, i, n) {
    if (!i || i === "none") {
      var s = bl(t, e, 1),
        a = s && Os(e, s, 1);
      a && a !== i
        ? ((t = s), (i = a))
        : t === "borderColor" && (i = Os(e, "borderTopColor"));
    }
    var o = new Sn(this._pt, e.style, t, 0, 1, Xx),
      u = 0,
      h = 0,
      f,
      c,
      d,
      m,
      x,
      v,
      b,
      y,
      M,
      D,
      C,
      A;
    if (
      ((o.b = i),
      (o.e = n),
      (i += ""),
      (n += ""),
      n === "auto" && ((e.style[t] = n), (n = Os(e, t) || n), (e.style[t] = i)),
      (f = [i, n]),
      Nx(f),
      (i = f[0]),
      (n = f[1]),
      (d = i.match(Ka) || []),
      (A = n.match(Ka) || []),
      A.length)
    ) {
      for (; (c = Ka.exec(n)); )
        (b = c[0]),
          (M = n.substring(u, c.index)),
          x
            ? (x = (x + 1) % 5)
            : (M.substr(-5) === "rgba(" || M.substr(-5) === "hsla(") && (x = 1),
          b !== (v = d[h++] || "") &&
            ((m = parseFloat(v) || 0),
            (C = v.substr((m + "").length)),
            b.charAt(1) === "=" && (b = sl(m, b) + C),
            (y = parseFloat(b)),
            (D = b.substr((y + "").length)),
            (u = Ka.lastIndex - D.length),
            D ||
              ((D = D || Vn.units[t] || C),
              u === n.length && ((n += D), (o.e += D))),
            C !== D && (m = eo(e, t, v, D) || 0),
            (o._pt = {
              _next: o._pt,
              p: M || h === 1 ? M : ",",
              s: m,
              c: y - m,
              m: (x && x < 4) || t === "zIndex" ? Math.round : 0,
            }));
      o.c = u < n.length ? n.substring(u, n.length) : "";
    } else o.r = t === "display" && n === "none" ? Zx : Kx;
    return dx.test(n) && (o.e = 0), (this._pt = o), o;
  },
  M_ = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" },
  tA = function (e) {
    var t = e.split(" "),
      i = t[0],
      n = t[1] || "50%";
    return (
      (i === "top" || i === "bottom" || n === "left" || n === "right") &&
        ((e = i), (i = n), (n = e)),
      (t[0] = M_[i] || i),
      (t[1] = M_[n] || n),
      t.join(" ")
    );
  },
  iA = function (e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
      var i = t.t,
        n = i.style,
        s = t.u,
        a = i._gsap,
        o,
        u,
        h;
      if (s === "all" || s === !0) (n.cssText = ""), (u = 1);
      else
        for (s = s.split(","), h = s.length; --h > -1; )
          (o = s[h]),
            br[o] && ((u = 1), (o = o === "transformOrigin" ? xs : oi)),
            Zc(i, o);
      u &&
        (Zc(i, oi),
        a &&
          (a.svg && i.removeAttribute("transform"),
          Qc(i, 1),
          (a.uncache = 1),
          Jx(n)));
    }
  },
  sd = {
    clearProps: function (e, t, i, n, s) {
      if (s.data !== "isFromStart") {
        var a = (e._pt = new Sn(e._pt, t, i, 0, 0, iA));
        return (a.u = n), (a.pr = -10), (a.tween = s), e._props.push(i), 1;
      }
    },
  },
  Jc = [1, 0, 0, 1, 0, 0],
  nw = {},
  sw = function (e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
  },
  T_ = function (e) {
    var t = Os(e, oi);
    return sw(t) ? Jc : t.substr(7).match(hx).map(mi);
  },
  eg = function (e, t) {
    var i = e._gsap || jo(e),
      n = e.style,
      s = T_(e),
      a,
      o,
      u,
      h;
    return i.svg && e.getAttribute("transform")
      ? ((u = e.transform.baseVal.consolidate().matrix),
        (s = [u.a, u.b, u.c, u.d, u.e, u.f]),
        s.join(",") === "1,0,0,1,0,0" ? Jc : s)
      : (s === Jc &&
          !e.offsetParent &&
          e !== rl &&
          !i.svg &&
          ((u = n.display),
          (n.display = "block"),
          (a = e.parentNode),
          (!a || !e.offsetParent) &&
            ((h = 1), (o = e.nextElementSibling), rl.appendChild(e)),
          (s = T_(e)),
          u ? (n.display = u) : Zc(e, "display"),
          h &&
            (o
              ? a.insertBefore(e, o)
              : a
              ? a.appendChild(e)
              : rl.removeChild(e))),
        t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s);
  },
  am = function (e, t, i, n, s, a) {
    var o = e._gsap,
      u = s || eg(e, !0),
      h = o.xOrigin || 0,
      f = o.yOrigin || 0,
      c = o.xOffset || 0,
      d = o.yOffset || 0,
      m = u[0],
      x = u[1],
      v = u[2],
      b = u[3],
      y = u[4],
      M = u[5],
      D = t.split(" "),
      C = parseFloat(D[0]) || 0,
      A = parseFloat(D[1]) || 0,
      I,
      F,
      P,
      k;
    i
      ? u !== Jc &&
        (F = m * b - x * v) &&
        ((P = C * (b / F) + A * (-v / F) + (v * M - b * y) / F),
        (k = C * (-x / F) + A * (m / F) - (m * M - x * y) / F),
        (C = P),
        (A = k))
      : ((I = tw(e)),
        (C = I.x + (~D[0].indexOf("%") ? (C / 100) * I.width : C)),
        (A = I.y + (~(D[1] || D[0]).indexOf("%") ? (A / 100) * I.height : A))),
      n || (n !== !1 && o.smooth)
        ? ((y = C - h),
          (M = A - f),
          (o.xOffset = c + (y * m + M * v) - y),
          (o.yOffset = d + (y * x + M * b) - M))
        : (o.xOffset = o.yOffset = 0),
      (o.xOrigin = C),
      (o.yOrigin = A),
      (o.smooth = !!n),
      (o.origin = t),
      (o.originIsAbsolute = !!i),
      (e.style[xs] = "0px 0px"),
      a &&
        (Xr(a, o, "xOrigin", h, C),
        Xr(a, o, "yOrigin", f, A),
        Xr(a, o, "xOffset", c, o.xOffset),
        Xr(a, o, "yOffset", d, o.yOffset)),
      e.setAttribute("data-svg-origin", C + " " + A);
  },
  Qc = function (e, t) {
    var i = e._gsap || new Ux(e);
    if ("x" in i && !t && !i.uncache) return i;
    var n = e.style,
      s = i.scaleX < 0,
      a = "px",
      o = "deg",
      u = getComputedStyle(e),
      h = Os(e, xs) || "0",
      f,
      c,
      d,
      m,
      x,
      v,
      b,
      y,
      M,
      D,
      C,
      A,
      I,
      F,
      P,
      k,
      O,
      J,
      ee,
      X,
      j,
      Y,
      ie,
      Q,
      V,
      ve,
      U,
      oe,
      ue,
      fe,
      le,
      be;
    return (
      (f = c = d = v = b = y = M = D = C = 0),
      (m = x = 1),
      (i.svg = !!(e.getCTM && iw(e))),
      u.translate &&
        ((u.translate !== "none" ||
          u.scale !== "none" ||
          u.rotate !== "none") &&
          (n[oi] =
            (u.translate !== "none"
              ? "translate3d(" +
                (u.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                ") "
              : "") +
            (u.rotate !== "none" ? "rotate(" + u.rotate + ") " : "") +
            (u.scale !== "none"
              ? "scale(" + u.scale.split(" ").join(",") + ") "
              : "") +
            (u[oi] !== "none" ? u[oi] : "")),
        (n.scale = n.rotate = n.translate = "none")),
      (F = eg(e, i.svg)),
      i.svg &&
        (i.uncache
          ? ((V = e.getBBox()),
            (h = i.xOrigin - V.x + "px " + (i.yOrigin - V.y) + "px"),
            (Q = ""))
          : (Q = !t && e.getAttribute("data-svg-origin")),
        am(e, Q || h, !!Q || i.originIsAbsolute, i.smooth !== !1, F)),
      (A = i.xOrigin || 0),
      (I = i.yOrigin || 0),
      F !== Jc &&
        ((J = F[0]),
        (ee = F[1]),
        (X = F[2]),
        (j = F[3]),
        (f = Y = F[4]),
        (c = ie = F[5]),
        F.length === 6
          ? ((m = Math.sqrt(J * J + ee * ee)),
            (x = Math.sqrt(j * j + X * X)),
            (v = J || ee ? Va(ee, J) * Do : 0),
            (M = X || j ? Va(X, j) * Do + v : 0),
            M && (x *= Math.abs(Math.cos(M * ol))),
            i.svg && ((f -= A - (A * J + I * X)), (c -= I - (A * ee + I * j))))
          : ((be = F[6]),
            (fe = F[7]),
            (U = F[8]),
            (oe = F[9]),
            (ue = F[10]),
            (le = F[11]),
            (f = F[12]),
            (c = F[13]),
            (d = F[14]),
            (P = Va(be, ue)),
            (b = P * Do),
            P &&
              ((k = Math.cos(-P)),
              (O = Math.sin(-P)),
              (Q = Y * k + U * O),
              (V = ie * k + oe * O),
              (ve = be * k + ue * O),
              (U = Y * -O + U * k),
              (oe = ie * -O + oe * k),
              (ue = be * -O + ue * k),
              (le = fe * -O + le * k),
              (Y = Q),
              (ie = V),
              (be = ve)),
            (P = Va(-X, ue)),
            (y = P * Do),
            P &&
              ((k = Math.cos(-P)),
              (O = Math.sin(-P)),
              (Q = J * k - U * O),
              (V = ee * k - oe * O),
              (ve = X * k - ue * O),
              (le = j * O + le * k),
              (J = Q),
              (ee = V),
              (X = ve)),
            (P = Va(ee, J)),
            (v = P * Do),
            P &&
              ((k = Math.cos(P)),
              (O = Math.sin(P)),
              (Q = J * k + ee * O),
              (V = Y * k + ie * O),
              (ee = ee * k - J * O),
              (ie = ie * k - Y * O),
              (J = Q),
              (Y = V)),
            b &&
              Math.abs(b) + Math.abs(v) > 359.9 &&
              ((b = v = 0), (y = 180 - y)),
            (m = mi(Math.sqrt(J * J + ee * ee + X * X))),
            (x = mi(Math.sqrt(ie * ie + be * be))),
            (P = Va(Y, ie)),
            (M = Math.abs(P) > 2e-4 ? P * Do : 0),
            (C = le ? 1 / (le < 0 ? -le : le) : 0)),
        i.svg &&
          ((Q = e.getAttribute("transform")),
          (i.forceCSS = e.setAttribute("transform", "") || !sw(Os(e, oi))),
          Q && e.setAttribute("transform", Q))),
      Math.abs(M) > 90 &&
        Math.abs(M) < 270 &&
        (s
          ? ((m *= -1), (M += v <= 0 ? 180 : -180), (v += v <= 0 ? 180 : -180))
          : ((x *= -1), (M += M <= 0 ? 180 : -180))),
      (t = t || i.uncache),
      (i.x =
        f -
        ((i.xPercent =
          f &&
          ((!t && i.xPercent) ||
            (Math.round(e.offsetWidth / 2) === Math.round(-f) ? -50 : 0)))
          ? (e.offsetWidth * i.xPercent) / 100
          : 0) +
        a),
      (i.y =
        c -
        ((i.yPercent =
          c &&
          ((!t && i.yPercent) ||
            (Math.round(e.offsetHeight / 2) === Math.round(-c) ? -50 : 0)))
          ? (e.offsetHeight * i.yPercent) / 100
          : 0) +
        a),
      (i.z = d + a),
      (i.scaleX = mi(m)),
      (i.scaleY = mi(x)),
      (i.rotation = mi(v) + o),
      (i.rotationX = mi(b) + o),
      (i.rotationY = mi(y) + o),
      (i.skewX = M + o),
      (i.skewY = D + o),
      (i.transformPerspective = C + a),
      (i.zOrigin = parseFloat(h.split(" ")[2]) || 0) && (n[xs] = rd(h)),
      (i.xOffset = i.yOffset = 0),
      (i.force3D = Vn.force3D),
      (i.renderTransform = i.svg ? sA : ew ? rw : nA),
      (i.uncache = 0),
      i
    );
  },
  rd = function (e) {
    return (e = e.split(" "))[0] + " " + e[1];
  },
  uf = function (e, t, i) {
    var n = Hi(t);
    return mi(parseFloat(t) + parseFloat(eo(e, "x", i + "px", n))) + n;
  },
  nA = function (e, t) {
    (t.z = "0px"),
      (t.rotationY = t.rotationX = "0deg"),
      (t.force3D = 0),
      rw(e, t);
  },
  xo = "0deg",
  pc = "0px",
  wo = ") ",
  rw = function (e, t) {
    var i = t || this,
      n = i.xPercent,
      s = i.yPercent,
      a = i.x,
      o = i.y,
      u = i.z,
      h = i.rotation,
      f = i.rotationY,
      c = i.rotationX,
      d = i.skewX,
      m = i.skewY,
      x = i.scaleX,
      v = i.scaleY,
      b = i.transformPerspective,
      y = i.force3D,
      M = i.target,
      D = i.zOrigin,
      C = "",
      A = (y === "auto" && e && e !== 1) || y === !0;
    if (D && (c !== xo || f !== xo)) {
      var I = parseFloat(f) * ol,
        F = Math.sin(I),
        P = Math.cos(I),
        k;
      (I = parseFloat(c) * ol),
        (k = Math.cos(I)),
        (a = uf(M, a, F * k * -D)),
        (o = uf(M, o, -Math.sin(I) * -D)),
        (u = uf(M, u, P * k * -D + D));
    }
    b !== pc && (C += "perspective(" + b + wo),
      (n || s) && (C += "translate(" + n + "%, " + s + "%) "),
      (A || a !== pc || o !== pc || u !== pc) &&
        (C +=
          u !== pc || A
            ? "translate3d(" + a + ", " + o + ", " + u + ") "
            : "translate(" + a + ", " + o + wo),
      h !== xo && (C += "rotate(" + h + wo),
      f !== xo && (C += "rotateY(" + f + wo),
      c !== xo && (C += "rotateX(" + c + wo),
      (d !== xo || m !== xo) && (C += "skew(" + d + ", " + m + wo),
      (x !== 1 || v !== 1) && (C += "scale(" + x + ", " + v + wo),
      (M.style[oi] = C || "translate(0, 0)");
  },
  sA = function (e, t) {
    var i = t || this,
      n = i.xPercent,
      s = i.yPercent,
      a = i.x,
      o = i.y,
      u = i.rotation,
      h = i.skewX,
      f = i.skewY,
      c = i.scaleX,
      d = i.scaleY,
      m = i.target,
      x = i.xOrigin,
      v = i.yOrigin,
      b = i.xOffset,
      y = i.yOffset,
      M = i.forceCSS,
      D = parseFloat(a),
      C = parseFloat(o),
      A,
      I,
      F,
      P,
      k;
    (u = parseFloat(u)),
      (h = parseFloat(h)),
      (f = parseFloat(f)),
      f && ((f = parseFloat(f)), (h += f), (u += f)),
      u || h
        ? ((u *= ol),
          (h *= ol),
          (A = Math.cos(u) * c),
          (I = Math.sin(u) * c),
          (F = Math.sin(u - h) * -d),
          (P = Math.cos(u - h) * d),
          h &&
            ((f *= ol),
            (k = Math.tan(h - f)),
            (k = Math.sqrt(1 + k * k)),
            (F *= k),
            (P *= k),
            f &&
              ((k = Math.tan(f)),
              (k = Math.sqrt(1 + k * k)),
              (A *= k),
              (I *= k))),
          (A = mi(A)),
          (I = mi(I)),
          (F = mi(F)),
          (P = mi(P)))
        : ((A = c), (P = d), (I = F = 0)),
      ((D && !~(a + "").indexOf("px")) || (C && !~(o + "").indexOf("px"))) &&
        ((D = eo(m, "x", a, "px")), (C = eo(m, "y", o, "px"))),
      (x || v || b || y) &&
        ((D = mi(D + x - (x * A + v * F) + b)),
        (C = mi(C + v - (x * I + v * P) + y))),
      (n || s) &&
        ((k = m.getBBox()),
        (D = mi(D + (n / 100) * k.width)),
        (C = mi(C + (s / 100) * k.height))),
      (k =
        "matrix(" + A + "," + I + "," + F + "," + P + "," + D + "," + C + ")"),
      m.setAttribute("transform", k),
      M && (m.style[oi] = k);
  },
  rA = function (e, t, i, n, s) {
    var a = 360,
      o = Ri(s),
      u = parseFloat(s) * (o && ~s.indexOf("rad") ? Do : 1),
      h = u - n,
      f = n + h + "deg",
      c,
      d;
    return (
      o &&
        ((c = s.split("_")[1]),
        c === "short" && ((h %= a), h !== h % (a / 2) && (h += h < 0 ? a : -a)),
        c === "cw" && h < 0
          ? (h = ((h + a * x_) % a) - ~~(h / a) * a)
          : c === "ccw" && h > 0 && (h = ((h - a * x_) % a) - ~~(h / a) * a)),
      (e._pt = d = new Sn(e._pt, t, i, n, h, GP)),
      (d.e = f),
      (d.u = "deg"),
      e._props.push(i),
      d
    );
  },
  E_ = function (e, t) {
    for (var i in t) e[i] = t[i];
    return e;
  },
  oA = function (e, t, i) {
    var n = E_({}, i._gsap),
      s = "perspective,force3D,transformOrigin,svgOrigin",
      a = i.style,
      o,
      u,
      h,
      f,
      c,
      d,
      m,
      x;
    n.svg
      ? ((h = i.getAttribute("transform")),
        i.setAttribute("transform", ""),
        (a[oi] = t),
        (o = Qc(i, 1)),
        Zc(i, oi),
        i.setAttribute("transform", h))
      : ((h = getComputedStyle(i)[oi]),
        (a[oi] = t),
        (o = Qc(i, 1)),
        (a[oi] = h));
    for (u in br)
      (h = n[u]),
        (f = o[u]),
        h !== f &&
          s.indexOf(u) < 0 &&
          ((m = Hi(h)),
          (x = Hi(f)),
          (c = m !== x ? eo(i, u, h, x) : parseFloat(h)),
          (d = parseFloat(f)),
          (e._pt = new Sn(e._pt, o, u, c, d - c, sm)),
          (e._pt.u = x || 0),
          e._props.push(u));
    E_(o, n);
  };
yn("padding,margin,Width,Radius", function (r, e) {
  var t = "Top",
    i = "Right",
    n = "Bottom",
    s = "Left",
    a = (e < 3 ? [t, i, n, s] : [t + s, t + i, n + i, n + s]).map(function (o) {
      return e < 2 ? r + o : "border" + o + r;
    });
  sd[e > 1 ? "border" + r : r] = function (o, u, h, f, c) {
    var d, m;
    if (arguments.length < 4)
      return (
        (d = a.map(function (x) {
          return rr(o, x, h);
        })),
        (m = d.join(" ")),
        m.split(d[0]).length === 5 ? d[0] : m
      );
    (d = (f + "").split(" ")),
      (m = {}),
      a.forEach(function (x, v) {
        return (m[x] = d[v] = d[v] || d[((v - 1) / 2) | 0]);
      }),
      o.init(u, m, c);
  };
});
var tg = {
  name: "css",
  register: om,
  targetTest: function (e) {
    return e.style && e.nodeType;
  },
  init: function (e, t, i, n, s) {
    var a = this._props,
      o = e.style,
      u = i.vars.startAt,
      h,
      f,
      c,
      d,
      m,
      x,
      v,
      b,
      y,
      M,
      D,
      C,
      A,
      I,
      F,
      P;
    Zm || om(),
      (this.styles = this.styles || Qx(e)),
      (P = this.styles.props),
      (this.tween = i);
    for (v in t)
      if (v !== "autoRound" && ((f = t[v]), !(In[v] && Gx(v, t, i, n, e, s)))) {
        if (
          ((m = typeof f),
          (x = sd[v]),
          m === "function" && ((f = f.call(i, n, e, s)), (m = typeof f)),
          m === "string" && ~f.indexOf("random(") && (f = $c(f)),
          x)
        )
          x(this, e, v, f, i) && (F = 1);
        else if (v.substr(0, 2) === "--")
          (h = (getComputedStyle(e).getPropertyValue(v) + "").trim()),
            (f += ""),
            (Kr.lastIndex = 0),
            Kr.test(h) || ((b = Hi(h)), (y = Hi(f))),
            y ? b !== y && (h = eo(e, v, h, y) + y) : b && (f += b),
            this.add(o, "setProperty", h, f, n, s, 0, 0, v),
            a.push(v),
            P.push(v, 0, o[v]);
        else if (m !== "undefined") {
          if (
            (u && v in u
              ? ((h = typeof u[v] == "function" ? u[v].call(i, n, e, s) : u[v]),
                Ri(h) && ~h.indexOf("random(") && (h = $c(h)),
                Hi(h + "") || (h += Vn.units[v] || Hi(rr(e, v)) || ""),
                (h + "").charAt(1) === "=" && (h = rr(e, v)))
              : (h = rr(e, v)),
            (d = parseFloat(h)),
            (M = m === "string" && f.charAt(1) === "=" && f.substr(0, 2)),
            M && (f = f.substr(2)),
            (c = parseFloat(f)),
            v in ks &&
              (v === "autoAlpha" &&
                (d === 1 && rr(e, "visibility") === "hidden" && c && (d = 0),
                P.push("visibility", 0, o.visibility),
                Xr(
                  this,
                  o,
                  "visibility",
                  d ? "inherit" : "hidden",
                  c ? "inherit" : "hidden",
                  !c
                )),
              v !== "scale" &&
                v !== "transform" &&
                ((v = ks[v]), ~v.indexOf(",") && (v = v.split(",")[0]))),
            (D = v in br),
            D)
          ) {
            if (
              (this.styles.save(v),
              C ||
                ((A = e._gsap),
                (A.renderTransform && !t.parseTransform) ||
                  Qc(e, t.parseTransform),
                (I = t.smoothOrigin !== !1 && A.smooth),
                (C = this._pt =
                  new Sn(this._pt, o, oi, 0, 1, A.renderTransform, A, 0, -1)),
                (C.dep = 1)),
              v === "scale")
            )
              (this._pt = new Sn(
                this._pt,
                A,
                "scaleY",
                A.scaleY,
                (M ? sl(A.scaleY, M + c) : c) - A.scaleY || 0,
                sm
              )),
                (this._pt.u = 0),
                a.push("scaleY", v),
                (v += "X");
            else if (v === "transformOrigin") {
              P.push(xs, 0, o[xs]),
                (f = tA(f)),
                A.svg
                  ? am(e, f, 0, I, 0, this)
                  : ((y = parseFloat(f.split(" ")[2]) || 0),
                    y !== A.zOrigin && Xr(this, A, "zOrigin", A.zOrigin, y),
                    Xr(this, o, v, rd(h), rd(f)));
              continue;
            } else if (v === "svgOrigin") {
              am(e, f, 1, I, 0, this);
              continue;
            } else if (v in nw) {
              rA(this, A, v, d, M ? sl(d, M + f) : f);
              continue;
            } else if (v === "smoothOrigin") {
              Xr(this, A, "smooth", A.smooth, f);
              continue;
            } else if (v === "force3D") {
              A[v] = f;
              continue;
            } else if (v === "transform") {
              oA(this, f, e);
              continue;
            }
          } else v in o || (v = bl(v) || v);
          if (D || ((c || c === 0) && (d || d === 0) && !UP.test(f) && v in o))
            (b = (h + "").substr((d + "").length)),
              c || (c = 0),
              (y = Hi(f) || (v in Vn.units ? Vn.units[v] : b)),
              b !== y && (d = eo(e, v, h, y)),
              (this._pt = new Sn(
                this._pt,
                D ? A : o,
                v,
                d,
                (M ? sl(d, M + c) : c) - d,
                !D && (y === "px" || v === "zIndex") && t.autoRound !== !1
                  ? WP
                  : sm
              )),
              (this._pt.u = y || 0),
              b !== y && y !== "%" && ((this._pt.b = h), (this._pt.r = HP));
          else if (v in o) eA.call(this, e, v, h, M ? M + f : f);
          else if (v in e) this.add(e, v, h || e[v], M ? M + f : f, n, s);
          else if (v !== "parseTransform") {
            Gm(v, f);
            continue;
          }
          D || (v in o ? P.push(v, 0, o[v]) : P.push(v, 1, h || e[v])),
            a.push(v);
        }
      }
    F && $x(this);
  },
  render: function (e, t) {
    if (t.tween._time || !Jm())
      for (var i = t._pt; i; ) i.r(e, i.d), (i = i._next);
    else t.styles.revert();
  },
  get: rr,
  aliases: ks,
  getSetter: function (e, t, i) {
    var n = ks[t];
    return (
      n && n.indexOf(",") < 0 && (t = n),
      t in br && t !== xs && (e._gsap.x || rr(e, "x"))
        ? i && b_ === i
          ? t === "scale"
            ? $P
            : XP
          : (b_ = i || {}) && (t === "scale" ? YP : KP)
        : e.style && !Vm(e.style[t])
        ? jP
        : ~t.indexOf("-")
        ? qP
        : Ym(e, t)
    );
  },
  core: { _removeProperty: Zc, _getMatrix: eg },
};
Xi.utils.checkPrefix = bl;
Xi.core.getStyleSaver = Qx;
(function (r, e, t, i) {
  var n = yn(r + "," + e + "," + t, function (s) {
    br[s] = 1;
  });
  yn(e, function (s) {
    (Vn.units[s] = "deg"), (nw[s] = 1);
  }),
    (ks[n[13]] = r + "," + e),
    yn(i, function (s) {
      var a = s.split(":");
      ks[a[1]] = n[a[0]];
    });
})(
  "x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
  "rotation,rotationX,rotationY,skewX,skewY",
  "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
  "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"
);
yn(
  "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
  function (r) {
    Vn.units[r] = "px";
  }
);
Xi.registerPlugin(tg);
var K = Xi.registerPlugin(tg) || Xi;
K.core.Tween;
const aA = {
  name: "fadeUp",
  extendTimeline: !0,
  effect: (r, e) => K.timeline(e).from(r[0], { y: 30, opacity: 0 }, 0),
  defaults: {},
};
/*!
 * strings: 3.11.3
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ const lA =
  /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
function ow(r) {
  let e = r.nodeType,
    t = "";
  if (e === 1 || e === 9 || e === 11) {
    if (typeof r.textContent == "string") return r.textContent;
    for (r = r.firstChild; r; r = r.nextSibling) t += ow(r);
  } else if (e === 3 || e === 4) return r.nodeValue;
  return t;
}
/*!
 * SplitText: 3.11.3
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ let Fo,
  aw,
  lw,
  cA = /(?:\r|\n|\t\t)/g,
  uA = /(?:\s\s+)/g,
  hA = () => {
    (Fo = document), (aw = window), (lw = 1);
  },
  cw = (r) => aw.getComputedStyle(r),
  dA = Array.isArray,
  C_ = [].slice,
  ig = (r, e) => {
    let t;
    return dA(r)
      ? r
      : (t = typeof r) == "string" && !e && r
      ? C_.call(Fo.querySelectorAll(r), 0)
      : r && t === "object" && "length" in r
      ? C_.call(r, 0)
      : r
      ? [r]
      : [];
  },
  ng = (r) => r.position === "absolute" || r.absolute === !0,
  pA = (r, e) => {
    let t = e.length,
      i;
    for (; --t > -1; )
      if (((i = e[t]), r.substr(0, i.length) === i)) return i.length;
  },
  fA = " style='position:relative;display:inline-block;'",
  D_ = (r = "", e) => {
    let t = ~r.indexOf("++"),
      i = 1;
    return (
      t && (r = r.split("++").join("")),
      () => "<" + e + fA + (r ? " class='" + r + (t ? i++ : "") + "'>" : ">")
    );
  },
  sg = (r, e, t) => {
    let i = r.nodeType;
    if (i === 1 || i === 9 || i === 11)
      for (r = r.firstChild; r; r = r.nextSibling) sg(r, e, t);
    else (i === 3 || i === 4) && (r.nodeValue = r.nodeValue.split(e).join(t));
  },
  hf = (r, e) => {
    let t = e.length;
    for (; --t > -1; ) r.push(e[t]);
  },
  P_ = (r, e, t) => {
    let i;
    for (; r && r !== e; ) {
      if (((i = r._next || r.nextSibling), i))
        return i.textContent.charAt(0) === t;
      r = r.parentNode || r._parent;
    }
  },
  uw = (r) => {
    let e = ig(r.childNodes),
      t = e.length,
      i,
      n;
    for (i = 0; i < t; i++)
      (n = e[i]),
        n._isSplit
          ? uw(n)
          : i && n.previousSibling && n.previousSibling.nodeType === 3
          ? ((n.previousSibling.nodeValue +=
              n.nodeType === 3 ? n.nodeValue : n.firstChild.nodeValue),
            r.removeChild(n))
          : n.nodeType !== 3 &&
            (r.insertBefore(n.firstChild, n), r.removeChild(n));
  },
  Cs = (r, e) => parseFloat(e[r]) || 0,
  mA = (r, e, t, i, n, s, a) => {
    let o = cw(r),
      u = Cs("paddingLeft", o),
      h = -999,
      f = Cs("borderBottomWidth", o) + Cs("borderTopWidth", o),
      c = Cs("borderLeftWidth", o) + Cs("borderRightWidth", o),
      d = Cs("paddingTop", o) + Cs("paddingBottom", o),
      m = Cs("paddingLeft", o) + Cs("paddingRight", o),
      x = Cs("fontSize", o) * (e.lineThreshold || 0.2),
      v = o.textAlign,
      b = [],
      y = [],
      M = [],
      D = e.wordDelimiter || " ",
      C = e.tag ? e.tag : e.span ? "span" : "div",
      A = e.type || e.split || "chars,words,lines",
      I = n && ~A.indexOf("lines") ? [] : null,
      F = ~A.indexOf("words"),
      P = ~A.indexOf("chars"),
      k = ng(e),
      O = e.linesClass,
      J = ~(O || "").indexOf("++"),
      ee = [],
      X = o.display === "flex",
      j = r.style.display,
      Y,
      ie,
      Q,
      V,
      ve,
      U,
      oe,
      ue,
      fe,
      le,
      be,
      ce;
    for (
      J && (O = O.split("++").join("")),
        X && (r.style.display = "block"),
        ie = r.getElementsByTagName("*"),
        Q = ie.length,
        ve = [],
        Y = 0;
      Y < Q;
      Y++
    )
      ve[Y] = ie[Y];
    if (I || k)
      for (Y = 0; Y < Q; Y++)
        (V = ve[Y]),
          (U = V.parentNode === r),
          (U || k || (P && !F)) &&
            ((ce = V.offsetTop),
            I &&
              U &&
              Math.abs(ce - h) > x &&
              (V.nodeName !== "BR" || Y === 0) &&
              ((oe = []), I.push(oe), (h = ce)),
            k &&
              ((V._x = V.offsetLeft),
              (V._y = ce),
              (V._w = V.offsetWidth),
              (V._h = V.offsetHeight)),
            I &&
              (((V._isSplit && U) ||
                (!P && U) ||
                (F && U) ||
                (!F &&
                  V.parentNode.parentNode === r &&
                  !V.parentNode._isSplit)) &&
                (oe.push(V), (V._x -= u), P_(V, r, D) && (V._wordEnd = !0)),
              V.nodeName === "BR" &&
                ((V.nextSibling && V.nextSibling.nodeName === "BR") ||
                  Y === 0) &&
                I.push([])));
    for (Y = 0; Y < Q; Y++) {
      if (((V = ve[Y]), (U = V.parentNode === r), V.nodeName === "BR")) {
        I || k
          ? (V.parentNode && V.parentNode.removeChild(V),
            ve.splice(Y--, 1),
            Q--)
          : F || r.appendChild(V);
        continue;
      }
      if (
        (k &&
          ((fe = V.style),
          !F && !U && ((V._x += V.parentNode._x), (V._y += V.parentNode._y)),
          (fe.left = V._x + "px"),
          (fe.top = V._y + "px"),
          (fe.position = "absolute"),
          (fe.display = "block"),
          (fe.width = V._w + 1 + "px"),
          (fe.height = V._h + "px")),
        !F && P)
      )
        if (V._isSplit)
          for (
            V._next = ie = V.nextSibling, V.parentNode.appendChild(V);
            ie && ie.nodeType === 3 && ie.textContent === " ";

          )
            (V._next = ie.nextSibling),
              V.parentNode.appendChild(ie),
              (ie = ie.nextSibling);
        else
          V.parentNode._isSplit
            ? ((V._parent = V.parentNode),
              !V.previousSibling &&
                V.firstChild &&
                (V.firstChild._isFirst = !0),
              V.nextSibling &&
                V.nextSibling.textContent === " " &&
                !V.nextSibling.nextSibling &&
                ee.push(V.nextSibling),
              (V._next =
                V.nextSibling && V.nextSibling._isFirst ? null : V.nextSibling),
              V.parentNode.removeChild(V),
              ve.splice(Y--, 1),
              Q--)
            : U ||
              ((ce = !V.nextSibling && P_(V.parentNode, r, D)),
              V.parentNode._parent && V.parentNode._parent.appendChild(V),
              ce && V.parentNode.appendChild(Fo.createTextNode(" ")),
              C === "span" && (V.style.display = "inline"),
              b.push(V));
      else
        V.parentNode._isSplit && !V._isSplit && V.innerHTML !== ""
          ? y.push(V)
          : P &&
            !V._isSplit &&
            (C === "span" && (V.style.display = "inline"), b.push(V));
    }
    for (Y = ee.length; --Y > -1; ) ee[Y].parentNode.removeChild(ee[Y]);
    if (I) {
      for (
        k &&
          ((le = Fo.createElement(C)),
          r.appendChild(le),
          (be = le.offsetWidth + "px"),
          (ce = le.offsetParent === r ? 0 : r.offsetLeft),
          r.removeChild(le)),
          fe = r.style.cssText,
          r.style.cssText = "display:none;";
        r.firstChild;

      )
        r.removeChild(r.firstChild);
      for (ue = D === " " && (!k || (!F && !P)), Y = 0; Y < I.length; Y++) {
        for (
          oe = I[Y],
            le = Fo.createElement(C),
            le.style.cssText =
              "display:block;text-align:" +
              v +
              ";position:" +
              (k ? "absolute;" : "relative;"),
            O && (le.className = O + (J ? Y + 1 : "")),
            M.push(le),
            Q = oe.length,
            ie = 0;
          ie < Q;
          ie++
        )
          oe[ie].nodeName !== "BR" &&
            ((V = oe[ie]),
            le.appendChild(V),
            ue && V._wordEnd && le.appendChild(Fo.createTextNode(" ")),
            k &&
              (ie === 0 &&
                ((le.style.top = V._y + "px"), (le.style.left = u + ce + "px")),
              (V.style.top = "0px"),
              ce && (V.style.left = V._x - ce + "px")));
        Q === 0
          ? (le.innerHTML = "&nbsp;")
          : !F && !P && (uw(le), sg(le, String.fromCharCode(160), " ")),
          k && ((le.style.width = be), (le.style.height = V._h + "px")),
          r.appendChild(le);
      }
      r.style.cssText = fe;
    }
    k &&
      (a > r.clientHeight &&
        ((r.style.height = a - d + "px"),
        r.clientHeight < a && (r.style.height = a + f + "px")),
      s > r.clientWidth &&
        ((r.style.width = s - m + "px"),
        r.clientWidth < s && (r.style.width = s + c + "px"))),
      X && (j ? (r.style.display = j) : r.style.removeProperty("display")),
      hf(t, b),
      F && hf(i, y),
      hf(n, M);
  },
  gA = (r, e, t, i) => {
    let n = e.tag ? e.tag : e.span ? "span" : "div",
      s = e.type || e.split || "chars,words,lines",
      a = ~s.indexOf("chars"),
      o = ng(e),
      u = e.wordDelimiter || " ",
      h = u !== " " ? "" : o ? "&#173; " : " ",
      f = "</" + n + ">",
      c = 1,
      d = e.specialChars
        ? typeof e.specialChars == "function"
          ? e.specialChars
          : pA
        : null,
      m,
      x,
      v,
      b,
      y,
      M,
      D,
      C,
      A = Fo.createElement("div"),
      I = r.parentNode;
    for (
      I.insertBefore(A, r),
        A.textContent = r.nodeValue,
        I.removeChild(r),
        r = A,
        m = ow(r),
        D = m.indexOf("<") !== -1,
        e.reduceWhiteSpace !== !1 && (m = m.replace(uA, " ").replace(cA, "")),
        D && (m = m.split("<").join("{{LT}}")),
        y = m.length,
        x = (m.charAt(0) === " " ? h : "") + t(),
        v = 0;
      v < y;
      v++
    )
      if (((M = m.charAt(v)), d && (C = d(m.substr(v), e.specialChars))))
        (M = m.substr(v, C || 1)),
          (x += a && M !== " " ? i() + M + "</" + n + ">" : M),
          (v += C - 1);
      else if (M === u && m.charAt(v - 1) !== u && v) {
        for (x += c ? f : "", c = 0; m.charAt(v + 1) === u; ) (x += h), v++;
        v === y - 1
          ? (x += h)
          : m.charAt(v + 1) !== ")" && ((x += h + t()), (c = 1));
      } else
        M === "{" && m.substr(v, 6) === "{{LT}}"
          ? ((x += a ? i() + "{{LT}}</" + n + ">" : "{{LT}}"), (v += 5))
          : (M.charCodeAt(0) >= 55296 && M.charCodeAt(0) <= 56319) ||
            (m.charCodeAt(v + 1) >= 65024 && m.charCodeAt(v + 1) <= 65039)
          ? ((b = ((m.substr(v, 12).split(lA) || [])[1] || "").length || 2),
            (x +=
              a && M !== " "
                ? i() + m.substr(v, b) + "</" + n + ">"
                : m.substr(v, b)),
            (v += b - 1))
          : (x += a && M !== " " ? i() + M + "</" + n + ">" : M);
    (r.outerHTML = x + (c ? f : "")), D && sg(I, "{{LT}}", "<");
  },
  hw = (r, e, t, i) => {
    let n = ig(r.childNodes),
      s = n.length,
      a = ng(e),
      o,
      u;
    if (r.nodeType !== 3 || s > 1) {
      for (e.absolute = !1, o = 0; o < s; o++)
        (u = n[o]),
          (u._next = u._isFirst = u._parent = u._wordEnd = null),
          (u.nodeType !== 3 || /\S+/.test(u.nodeValue)) &&
            (a &&
              u.nodeType !== 3 &&
              cw(u).display === "inline" &&
              ((u.style.display = "inline-block"),
              (u.style.position = "relative")),
            (u._isSplit = !0),
            hw(u, e, t, i));
      (e.absolute = a), (r._isSplit = !0);
      return;
    }
    gA(r, e, t, i);
  };
class xr {
  constructor(e, t) {
    lw || hA(),
      (this.elements = ig(e)),
      (this.chars = []),
      (this.words = []),
      (this.lines = []),
      (this._originals = []),
      (this.vars = t || {}),
      this.split(t);
  }
  split(e) {
    this.isSplit && this.revert(),
      (this.vars = e = e || this.vars),
      (this._originals.length =
        this.chars.length =
        this.words.length =
        this.lines.length =
          0);
    let t = this.elements.length,
      i = e.tag ? e.tag : e.span ? "span" : "div",
      n = D_(e.wordsClass, i),
      s = D_(e.charsClass, i),
      a,
      o,
      u;
    for (; --t > -1; )
      (u = this.elements[t]),
        (this._originals[t] = u.innerHTML),
        (a = u.clientHeight),
        (o = u.clientWidth),
        hw(u, e, n, s),
        mA(u, e, this.chars, this.words, this.lines, o, a);
    return (
      this.chars.reverse(),
      this.words.reverse(),
      this.lines.reverse(),
      (this.isSplit = !0),
      this
    );
  }
  revert() {
    let e = this._originals;
    if (!e) throw "revert() call wasn't scoped properly.";
    return (
      this.elements.forEach((t, i) => (t.innerHTML = e[i])),
      (this.chars = []),
      (this.words = []),
      (this.lines = []),
      (this.isSplit = !1),
      this
    );
  }
  static create(e, t) {
    return new xr(e, t);
  }
}
xr.version = "3.11.3";
const A_ = [],
  vA = {
    name: "titleIn",
    extendTimeline: !0,
    onResize: () => {
      A_.forEach((r) => {
        r.revert();
      });
    },
    effect: (r, e) => {
      const t = new xr(r, { type: "words", wordsClass: "split-word" }),
        i = t.words;
      return (
        A_.push(t),
        K.timeline(e)
          .fromTo(
            i,
            { y: "10rem" },
            { y: 0, stagger: 0.02, duration: 1, ease: "power2.inOut" },
            0
          )
          .fromTo(
            i,
            { opacity: 0 },
            { opacity: 1, stagger: 0.02, duration: 0.8, ease: "power2.inOut" },
            0.2
          )
      );
    },
  },
  L_ = [],
  _A = {
    name: "paragraphIn",
    extendTimeline: !0,
    onResize: () => {
      L_.forEach((r) => {
        r.revert();
      });
    },
    effect: (r, e) => {
      const t = new xr(r, { type: "lines", linesClass: "split-word" }),
        i = t.lines;
      return (
        L_.push(t),
        K.timeline(e)
          .fromTo(
            i,
            { y: "10rem" },
            { y: 0, stagger: 0.02, duration: 1, ease: "power2.inOut" },
            0
          )
          .fromTo(
            i,
            { opacity: 0 },
            { opacity: 1, stagger: 0.02, duration: 0.8, ease: "power2.inOut" },
            0.2
          )
      );
    },
  },
  bA = {
    name: "transformUp",
    extendTimeline: !0,
    effect: (r, e) =>
      K.timeline(e).fromTo(
        r[0],
        { y: "31.25rem", opacity: 0 },
        { y: 0, opacity: 1, ease: "expo.out", duration: 1, overwrite: "true" },
        0
      ),
    defaults: {},
  },
  ms = { fadeUp: aA, titleIn: vA, transformUp: bA, paragraphIn: _A };
function R_(r) {
  return Function('"use strict";return (' + r + ")")();
}
class xA {
  constructor() {
    q(this, "onResize", () => {
      var e, t, i;
      for (let n = 0; n < this.resizeTweens.length; n++) {
        const s =
          (e = this.resizeTweens[n].tween) == null ? void 0 : e.progress();
        (t = this.resizeTweens[n].tween) != null &&
          t.scrollTrigger &&
          this.resizeTweens[n].tween.scrollTrigger.kill(),
          (i = this.resizeTweens[n].tween) == null || i.kill(),
          this.resizeTweens[n].onResize(
            this.resizeTweens[n].tweenEl,
            this.resizeTweens[n].from,
            this.resizeTweens[n].tween
          ),
          s === 0 &&
            (this.resizeTweens[n].tween = K.effects[
              this.resizeTweens[n].preset
            ](this.resizeTweens[n].tweenEl, { ...this.resizeTweens[n].from }));
      }
    });
    (this.fromAttr = "animate-from"),
      (this.toAttr = "animate-to"),
      (this.mqAttr = "animate-mq"),
      (this.els = []),
      (this.resizeTweens = []),
      (this.mirrorGlProps = {
        x: "position.x",
        y: "position.y",
        z: "position.z",
        rotationX: "rotation.x",
        rotationY: "rotation.y",
        rotationZ: "rotation.z",
      }),
      De.on(Ze.RESIZE, this.onResize),
      this.registerGsapPlugins(),
      this.registerGsapEffects();
  }
  build(e) {
    const i = (e || document).querySelectorAll(
        `[${this.fromAttr}], [${this.toAttr}]`
      ),
      n = i.length;
    for (let s = 0; s < n; s++) {
      if (
        (i[s].attributes[this.mqAttr] &&
          i[s].attributes[this.mqAttr].value !== "" &&
          !E.mq[i[s].attributes[this.mqAttr].value].matches) ||
        (i[s].attributes[this.fromAttr] &&
          i[s].attributes[this.fromAttr].value === "" &&
          i[s].attributes[this.toAttr] &&
          i[s].attributes[this.toAttr].value === "")
      )
        continue;
      let a = { uniforms: {} };
      const o = {
          ease: "none",
          duration: 1.5,
          scrollTrigger: { trigger: i[s], start: "top 80%", once: !0 },
        },
        u = i[s].hasAttribute("dom2webgl");
      let h = null,
        f = i[s],
        c = !1,
        d = !1;
      if (
        (u && (h = i[s].getBoundingClientRect()),
        i[s].attributes[this.fromAttr] &&
          ((c = R_(`{${i[s].attributes[this.fromAttr].value}}`)), u))
      ) {
        const x = this.parseGlPropsFrom(c, a, h);
        (c = x.from), (a = x.glProps);
      }
      i[s].attributes[this.toAttr] &&
        ((d = { ...o, ...R_(`{${i[s].attributes[this.toAttr].value}}`) }),
        u && (d = this.parseGlPropsTo(d, h))),
        (d.stagger || c.stagger) && i[s].children.length && (f = i[s].children),
        (o.scrollTrigger = Object.assign(o.scrollTrigger, c.scrollTrigger)),
        delete c.scrollTrigger,
        !f.length &&
          f.hasAttribute("dom2webgl") &&
          (f._glProps || (f._glProps = a),
          o.scrollTrigger.pin &&
            (this.updateGlPropsPinPos(o, f),
            (o.scrollTrigger.onUpdate = () => {
              this.updateGlPropsPinPos(o, f);
            })));
      let m;
      if (c && c.preset) {
        const x = c.preset;
        delete c.preset,
          ms[x].defaults.scrollTrigger &&
            (o.scrollTrigger = Object.assign(
              o.scrollTrigger,
              ms[x].defaults.scrollTrigger
            )),
          (c.scrollTrigger = o.scrollTrigger);
        const v = { ...c };
        (m = K.effects[x](f, c)),
          ms[x].onResize &&
            this.resizeTweens.push({
              tween: m,
              preset: x,
              tweenEl: f,
              from: v,
              onResize: ms[x].onResize.bind(ms[x]),
            });
      } else
        c && d
          ? ((d = Object.assign(o, d)), (m = K.fromTo(f, c, d)))
          : !d && c
          ? ((c = Object.assign(o, c)), (m = K.from(f, c)))
          : ((d = Object.assign(o, d)), (m = K.to(f, d)));
      m.scrollTrigger && m.scrollTrigger.disable(),
        m.pause(),
        this.els.push({ el: i[s], tween: m });
    }
  }
  enable() {
    for (let e = 0; e < this.els.length; e++)
      this.els[e].tween.scrollTrigger &&
        (this.els[e].tween.scrollTrigger.enable(),
        this.els[e].tween.scrollTrigger &&
          this.els[e].tween.scrollTrigger.isActive &&
          !this.els[e].tween.scrollTrigger.vars.scrub &&
          this.els[e].tween.restart(!0));
  }
  registerGsapEffects() {
    for (const e in ms)
      ms[e].extendTimeline && K.registerEffect(ms[e]),
        ms[e].onResize &&
          this.resizeTweens.push({
            tween: null,
            preset: null,
            tweenEl: null,
            from: null,
            onResize: ms[e].onResize.bind(ms[e]),
          });
  }
  registerGsapPlugins() {
    K.registerPlugin({
      name: "glProps",
      init(e, t) {
        for (const i in t) {
          if (typeof t[i] == "object") {
            for (const n in t[i])
              this.add(e._glProps[i], n, e._glProps[i][n], t[i][n]),
                this._props.push(n);
            continue;
          }
          this.add(e._glProps, i, e._glProps[i], t[i]);
        }
      },
    });
  }
  destroy() {
    for (let e = 0; e < this.els.length; e++)
      this.els[e].tween.scrollTrigger &&
        this.els[e].tween.scrollTrigger.kill(!1),
        this.els[e].tween && this.els[e].tween.kill();
    (this.els = []), (this.resizeTweens = []);
  }
}
class wA {
  static init() {
    if (window.localStorage.getItem("isDarkMode") === "true") {
      this.set(!0);
      return;
    }
    this.set(E.isDarkMode);
  }
  static set(e) {
    window.localStorage.setItem("isDarkMode", e ? "true" : "false"),
      (E.isDarkMode = e),
      e
        ? E.html.classList.add("is-dark-mode")
        : E.html.classList.remove("is-dark-mode");
  }
}
function at(r, e = document) {
  return e.querySelector(r);
}
function od(r, e = document) {
  return Array.prototype.slice.call(e.querySelectorAll(r));
}
function Ao(r, e, t) {
  const i = (n, s) => {
    if (n === "style") {
      Object.assign(r.style, s);
      return;
    }
    if (n === "classList") {
      dw(r, s);
      return;
    }
    r.setAttribute(n, s === !0 ? n : s);
  };
  if (typeof e == "object")
    for (const n in e) {
      if (e[n] === !1) {
        r.removeAttribute(n);
        continue;
      }
      i(n, e[n]);
    }
  else {
    if (t === void 0) return r.getAttribute(e);
    if (t === !1) {
      r.removeAttribute(e);
      return;
    }
    i(e, t);
  }
}
function dw(r, e) {
  if (Array.isArray(e)) {
    r.classList.add(...e);
    return;
  }
  if (typeof e == "string") {
    r.classList.add(...e.split(" "));
    return;
  }
  e.add && dw(r, e.add), e.remove && yA(r, e.remove);
}
function yA(r, e) {
  if (Array.isArray(e)) {
    r.classList.remove(...e);
    return;
  }
  typeof e == "string" && r.classList.remove(...e.split(" "));
}
function SA(r, e) {
  let t = null;
  return function () {
    clearTimeout(t);
    const i = arguments,
      n = this;
    t = setTimeout(function () {
      r.apply(n, i);
    }, e);
  };
}
function MA(r, e) {
  let t, i;
  return function () {
    const n = this,
      s = arguments;
    i
      ? (clearTimeout(t),
        (t = setTimeout(function () {
          Date.now() - i >= e && (r.apply(n, s), (i = Date.now()));
        }, e - (Date.now() - i))))
      : (r.apply(n, s), (i = Date.now()));
  };
}
function rg(...r) {
  const e = (t) => t && typeof t == "object";
  return r.reduce(
    (t, i) => (
      Object.keys(i).forEach((n) => {
        const s = t[n],
          a = i[n];
        Array.isArray(s) && Array.isArray(a)
          ? (t[n] = s.concat(...a))
          : e(s) && e(a)
          ? (t[n] = rg(s, a))
          : (t[n] = a);
      }),
      t
    ),
    {}
  );
}
function df(r) {
  return r.replace(/#define\sGLSLIFY\s./, "");
}
function TA() {
  Array.from(document.styleSheets)
    .filter(
      (r) =>
        r.href === null ||
        r.href.startsWith(window.location.origin) ||
        r.href.startsWith("http://127.0.0.1") ||
        r.href.startsWith("https://www.cosmos.so") ||
        r.href.startsWith("https://cosmos.so") ||
        r.href.startsWith("https://landing.cosmos.so") ||
        r.href.startsWith("https://cosmos.unseen") ||
        r.href.startsWith("http://192.168")
    )
    .reduce(
      (r, e) =>
        (r = [
          ...r,
          ...Array.from(e.cssRules).reduce(
            (t, i) =>
              (t =
                i.selectorText === ":root"
                  ? [
                      ...t,
                      ...Array.from(i.style).filter((n) =>
                        n.startsWith("--bp-")
                      ),
                    ]
                  : t),
            []
          ),
        ]),
      []
    )
    .forEach((r) => {
      E.mq[r.replace("--bp-", "")] = window.matchMedia(
        getComputedStyle(document.documentElement).getPropertyValue(r)
      );
    }),
    (E.staticComponents = new Bv()),
    (E.components = new Bv()),
    (E.urlParams = new URLSearchParams(window.location.search)),
    Object.assign(E, { ...window.globalData });
}
const EA = new DOMParser();
function CA(r) {
  return typeof r == "string" ? EA.parseFromString(r, "text/html") : r;
}
function yo(r) {
  const e = new URL(r, window.location.origin);
  let t = null;
  return (
    e.hash.length && (t = r.replace(e.hash, "")),
    {
      hasHash: e.hash.length > 0,
      pathname: e.pathname,
      host: e.host,
      raw: r,
      href: t || e.href,
    }
  );
}
function DA(r) {
  r.parentNode.replaceChild(lm(r), r);
}
function PA(r) {
  r.parentNode.tagName === "HEAD"
    ? document.head.appendChild(lm(r))
    : document.body.appendChild(lm(r));
}
function lm(r) {
  const e = document.createElement("SCRIPT");
  for (let t = 0; t < r.attributes.length; t++) {
    const i = r.attributes[t];
    e.setAttribute(i.nodeName, i.nodeValue);
  }
  return r.innerHTML && (e.innerHTML = r.innerHTML), e;
}
class cm {
  constructor({ wrapper: e }) {
    this.wrapper = e;
  }
  leave(e) {
    return new Promise((t) => {
      this.onLeave({ ...e, done: t });
    });
  }
  enter(e) {
    return new Promise((t) => {
      this.onEnter({ ...e, done: t });
    });
  }
  onLeave({ from: e, trigger: t, done: i }) {
    i();
  }
  onEnter({ to: e, trigger: t, done: i }) {
    i();
  }
}
class um {
  constructor({ content: e, page: t, title: i, wrapper: n }) {
    (this._contentString = e.outerHTML),
      (this._DOM = null),
      (this.page = t),
      (this.title = i),
      (this.wrapper = n),
      (this.content = this.wrapper.lastElementChild);
  }
  onEnter() {}
  onEnterCompleted() {}
  onLeave() {}
  onLeaveCompleted() {}
  initialLoad() {
    this.onEnter(), this.onEnterCompleted();
  }
  update() {
    (document.title = this.title),
      this.wrapper.appendChild(this._DOM.firstElementChild),
      (this.content = this.wrapper.lastElementChild),
      (this._DOM = null);
  }
  createDom() {
    this._DOM ||
      ((this._DOM = document.createElement("div")),
      (this._DOM.innerHTML = this._contentString));
  }
  remove() {
    this.wrapper.firstElementChild.remove();
  }
  enter(e, t) {
    return new Promise((i) => {
      this.onEnter(),
        e.enter({ trigger: t, to: this.content }).then(() => {
          this.onEnterCompleted(), i();
        });
    });
  }
  leave(e, t, i) {
    return new Promise((n) => {
      this.onLeave(),
        e.leave({ trigger: t, from: this.content }).then(() => {
          i && this.remove(), this.onLeaveCompleted(), n();
        });
    });
  }
}
class AA {
  constructor() {
    q(this, "data", new Map());
    q(this, "regexCache", new Map());
  }
  add(e, t, i) {
    this.data.has(e) ||
      (this.data.set(e, new Map()),
      this.regexCache.set(e, new RegExp(`^${e}$`))),
      this.data.get(e).set(t, i),
      this.regexCache.set(t, new RegExp(`^${t}$`));
  }
  findMatch(e, t) {
    for (const [i, n] of this.data)
      if (e.pathname.match(this.regexCache.get(i))) {
        for (const [s, a] of n)
          if (t.pathname.match(this.regexCache.get(s))) return a;
        break;
      }
    return null;
  }
}
const k_ = "A transition is currently in progress";
class LA {
  constructor(e = {}) {
    q(this, "isTransitioning", !1);
    q(this, "currentCacheEntry", null);
    q(this, "cache", new Map());
    q(this, "onClick", (e) => {
      if (!(e.metaKey || e.ctrlKey)) {
        const t = yo(e.currentTarget.href);
        if (
          ((this.currentLocation = yo(window.location.href)),
          this.currentLocation.host !== t.host)
        )
          return;
        if (
          this.currentLocation.href !== t.href ||
          (this.currentLocation.hasHash && !t.hasHash)
        ) {
          e.preventDefault(),
            this.navigateTo(
              t.raw,
              e.currentTarget.dataset.transition || !1,
              e.currentTarget
            ).catch((i) => console.warn(i));
          return;
        }
        !this.currentLocation.hasHash && !t.hasHash && e.preventDefault();
      }
    });
    q(this, "onPopstate", () => {
      if (
        window.location.pathname === this.currentLocation.pathname &&
        !this.isPopping
      )
        return !1;
      if (!this.allowInterruption && (this.isTransitioning || this.isPopping))
        return (
          window.history.pushState({}, "", this.popTarget), console.warn(k_), !1
        );
      this.isPopping || (this.popTarget = window.location.href),
        (this.isPopping = !0),
        this.navigateTo(window.location.href, !1, "popstate");
    });
    const {
      links: t = "a:not([target]):not([href^=\\#]):not([data-taxi-ignore])",
      removeOldContent: i = !0,
      allowInterruption: n = !1,
      bypassCache: s = !1,
      renderers: a = { default: um },
      transitions: o = { default: cm },
      reloadJsFilter: u = (h) => h.dataset.taxiReload !== void 0,
    } = e;
    (this.renderers = a),
      (this.transitions = o),
      (this.defaultRenderer = this.renderers.default || um),
      (this.defaultTransition = this.transitions.default || cm),
      (this.wrapper = document.querySelector("[data-taxi]")),
      (this.reloadJsFilter = u),
      (this.removeOldContent = i),
      (this.allowInterruption = n),
      (this.bypassCache = s),
      (this.cache = new Map()),
      (this.isPopping = !1),
      this.attachEvents(t),
      (this.currentLocation = yo(window.location.href)),
      this.cache.set(
        this.currentLocation.href,
        this.createCacheEntry(document.cloneNode(!0))
      ),
      (this.currentCacheEntry = this.cache.get(this.currentLocation.href)),
      this.currentCacheEntry.renderer.initialLoad();
  }
  setDefaultRenderer(e) {
    this.defaultRenderer = this.renderers[e];
  }
  setDefaultTransition(e) {
    this.defaultTransition = this.transitions[e];
  }
  addRoute(e, t, i) {
    this.router || (this.router = new AA()), this.router.add(e, t, i);
  }
  preload(e, t = !1) {
    return (
      (e = yo(e).href),
      this.cache.has(e)
        ? Promise.resolve()
        : this.fetch(e, !1).then(async (i) => {
            this.cache.set(e, this.createCacheEntry(i)),
              t && this.cache.get(e).renderer.createDom();
          })
    );
  }
  updateCache(e) {
    const t = yo(e || window.location.href).href;
    this.cache.has(t) && this.cache.delete(t),
      this.cache.set(t, this.createCacheEntry(document.cloneNode(!0)));
  }
  clearCache(e) {
    const t = yo(e || window.location.href).href;
    this.cache.has(t) && this.cache.delete(t);
  }
  navigateTo(e, t = !1, i = !1) {
    return new Promise((n, s) => {
      if (!this.allowInterruption && this.isTransitioning) {
        s(new Error(k_));
        return;
      }
      (this.isTransitioning = !0),
        (this.isPopping = !0),
        (this.targetLocation = yo(e)),
        (this.popTarget = window.location.href);
      const a = new (this.chooseTransition(t))({ wrapper: this.wrapper });
      let o;
      if (
        this.bypassCache ||
        !this.cache.has(this.targetLocation.href) ||
        this.cache.get(this.targetLocation.href).skipCache
      ) {
        const u = this.fetch(this.targetLocation.raw).then((h) => {
          this.cache.set(this.targetLocation.href, this.createCacheEntry(h)),
            this.cache.get(this.targetLocation.href).renderer.createDom();
        });
        o = this.beforeFetch(this.targetLocation, a, i).then(async () =>
          u.then(
            async (h) =>
              await this.afterFetch(
                this.targetLocation,
                a,
                this.cache.get(this.targetLocation.href),
                i
              )
          )
        );
      } else
        this.cache.get(this.targetLocation.href).renderer.createDom(),
          (o = this.beforeFetch(this.targetLocation, a, i).then(
            async () =>
              await this.afterFetch(
                this.targetLocation,
                a,
                this.cache.get(this.targetLocation.href),
                i
              )
          ));
      o.then(() => {
        n();
      });
    });
  }
  on(e, t) {
    De.on(e, t);
  }
  off(e, t) {
    De.off(e, t);
  }
  beforeFetch(e, t, i) {
    return (
      De.emit("NAVIGATE_OUT", { from: this.currentCacheEntry, trigger: i }),
      new Promise((n) => {
        this.currentCacheEntry.renderer
          .leave(t, i, this.removeOldContent)
          .then(() => {
            i !== "popstate" && window.history.pushState({}, "", e.raw), n();
          });
      })
    );
  }
  afterFetch(e, t, i, n) {
    return (
      (this.currentLocation = e),
      (this.popTarget = this.currentLocation.href),
      new Promise((s) => {
        i.renderer.update(),
          De.emit("NAVIGATE_IN", {
            from: this.currentCacheEntry,
            to: i,
            trigger: n,
          }),
          this.reloadJsFilter && this.loadScripts(i.scripts),
          i.renderer.enter(t, n).then(() => {
            De.emit("NAVIGATE_END", {
              from: this.currentCacheEntry,
              to: i,
              trigger: n,
            }),
              (this.currentCacheEntry = i),
              (this.isTransitioning = !1),
              (this.isPopping = !1),
              s();
          });
      })
    );
  }
  loadScripts(e) {
    const t = [...e],
      i = Array.from(document.querySelectorAll("script")).filter(
        this.reloadJsFilter
      );
    for (let n = 0; n < i.length; n++)
      for (let s = 0; s < t.length; s++)
        if (i[n].outerHTML === t[s].outerHTML) {
          DA(i[n]), t.splice(s, 1);
          break;
        }
    for (const n of t) PA(n);
  }
  attachEvents(e) {
    De.delegate("click", e, this.onClick),
      De.on("popstate", window, this.onPopstate);
  }
  fetch(e, t = !0) {
    return new Promise((i, n) => {
      fetch(e, {
        mode: "same-origin",
        method: "GET",
        headers: { "X-Requested-With": "Taxi" },
        credentials: "same-origin",
      })
        .then(
          (s) => (
            s.ok ||
              (n("Taxi encountered a non 2xx HTTP status code"),
              t && (window.location.href = e)),
            s.text()
          )
        )
        .then((s) => {
          i(CA(s));
        })
        .catch((s) => {
          n(s), t && (window.location.href = e);
        });
    });
  }
  chooseTransition(e) {
    var i;
    if (e) return this.transitions[e];
    const t =
      (i = this.router) == null
        ? void 0
        : i.findMatch(this.currentLocation, this.targetLocation);
    return t ? this.transitions[t] : this.defaultTransition;
  }
  createCacheEntry(e) {
    const t = e.querySelector("[data-taxi-view]"),
      i = t.dataset.taxiView.length
        ? this.renderers[t.dataset.taxiView]
        : this.defaultRenderer;
    return (
      i ||
        console.warn(
          `The Renderer "${t.dataset.taxiView}" was set in the data-taxi-view of the requested page, but not registered in Taxi.`
        ),
      {
        page: e,
        content: t,
        skipCache: t.hasAttribute("data-taxi-nocache"),
        scripts: this.reloadJsFilter
          ? Array.from(e.querySelectorAll("script")).filter(this.reloadJsFilter)
          : [],
        title: e.title,
        renderer: new i({
          wrapper: this.wrapper,
          title: e.title,
          content: t,
          page: e,
        }),
      }
    );
  }
}
const RA = "modulepreload",
  kA = function (r) {
    return "/wp-content/themes/cosmos/public/" + r;
  },
  I_ = {},
  IA = function (e, t, i) {
    if (!t || t.length === 0) return e();
    const n = document.getElementsByTagName("link");
    return Promise.all(
      t.map((s) => {
        if (((s = kA(s)), s in I_)) return;
        I_[s] = !0;
        const a = s.endsWith(".css"),
          o = a ? '[rel="stylesheet"]' : "";
        if (!!i)
          for (let f = n.length - 1; f >= 0; f--) {
            const c = n[f];
            if (c.href === s && (!a || c.rel === "stylesheet")) return;
          }
        else if (document.querySelector(`link[href="${s}"]${o}`)) return;
        const h = document.createElement("link");
        if (
          ((h.rel = a ? "stylesheet" : RA),
          a || ((h.as = "script"), (h.crossOrigin = "")),
          (h.href = s),
          document.head.appendChild(h),
          a)
        )
          return new Promise((f, c) => {
            h.addEventListener("load", f),
              h.addEventListener("error", () =>
                c(new Error(`Unable to preload CSS for ${s}`))
              );
          });
      })
    )
      .then(() => e())
      .catch((s) => {
        const a = new Event("vite:preloadError", { cancelable: !0 });
        if (((a.payload = s), window.dispatchEvent(a), !a.defaultPrevented))
          throw s;
      });
  };
var Lo =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function FA(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default")
    ? r.default
    : r;
}
var hm = { exports: {} };
/*! Tweakpane 3.1.6 (c) 2016 cocopon, licensed under the MIT license. */ (function (
  r,
  e
) {
  (function (t, i) {
    i(e);
  })(Lo, function (t) {
    class i {
      constructor(l) {
        const [p, w] = l.split("-"),
          R = p.split(".");
        (this.major = parseInt(R[0], 10)),
          (this.minor = parseInt(R[1], 10)),
          (this.patch = parseInt(R[2], 10)),
          (this.prerelease = w ?? null);
      }
      toString() {
        const l = [this.major, this.minor, this.patch].join(".");
        return this.prerelease !== null ? [l, this.prerelease].join("-") : l;
      }
    }
    class n {
      constructor(l) {
        this.controller_ = l;
      }
      get element() {
        return this.controller_.view.element;
      }
      get disabled() {
        return this.controller_.viewProps.get("disabled");
      }
      set disabled(l) {
        this.controller_.viewProps.set("disabled", l);
      }
      get hidden() {
        return this.controller_.viewProps.get("hidden");
      }
      set hidden(l) {
        this.controller_.viewProps.set("hidden", l);
      }
      dispose() {
        this.controller_.viewProps.set("disposed", !0);
      }
    }
    class s {
      constructor(l) {
        this.target = l;
      }
    }
    class a extends s {
      constructor(l, p, w, R) {
        super(l), (this.value = p), (this.presetKey = w), (this.last = R ?? !0);
      }
    }
    class o extends s {
      constructor(l, p, w) {
        super(l), (this.value = p), (this.presetKey = w);
      }
    }
    class u extends s {
      constructor(l, p) {
        super(l), (this.expanded = p);
      }
    }
    class h extends s {
      constructor(l, p) {
        super(l), (this.index = p);
      }
    }
    function f(g) {
      return g;
    }
    function c(g) {
      return g == null;
    }
    function d(g, l) {
      if (g.length !== l.length) return !1;
      for (let p = 0; p < g.length; p++) if (g[p] !== l[p]) return !1;
      return !0;
    }
    function m(g, l) {
      let p = g;
      do {
        const w = Object.getOwnPropertyDescriptor(p, l);
        if (w && (w.set !== void 0 || w.writable === !0)) return !0;
        p = Object.getPrototypeOf(p);
      } while (p !== null);
      return !1;
    }
    const x = {
      alreadydisposed: () => "View has been already disposed",
      invalidparams: (g) => `Invalid parameters for '${g.name}'`,
      nomatchingcontroller: (g) => `No matching controller for '${g.key}'`,
      nomatchingview: (g) =>
        `No matching view for '${JSON.stringify(g.params)}'`,
      notbindable: () => "Value is not bindable",
      propertynotfound: (g) => `Property '${g.name}' not found`,
      shouldneverhappen: () => "This error should never happen",
    };
    class v {
      static alreadyDisposed() {
        return new v({ type: "alreadydisposed" });
      }
      static notBindable() {
        return new v({ type: "notbindable" });
      }
      static propertyNotFound(l) {
        return new v({ type: "propertynotfound", context: { name: l } });
      }
      static shouldNeverHappen() {
        return new v({ type: "shouldneverhappen" });
      }
      constructor(l) {
        var p;
        (this.message =
          (p = x[l.type](l.context)) !== null && p !== void 0
            ? p
            : "Unexpected error"),
          (this.name = this.constructor.name),
          (this.stack = new Error(this.message).stack),
          (this.type = l.type);
      }
    }
    class b {
      constructor(l, p, w) {
        (this.obj_ = l), (this.key_ = p), (this.presetKey_ = w ?? p);
      }
      static isBindable(l) {
        return !(l === null || typeof l != "object");
      }
      get key() {
        return this.key_;
      }
      get presetKey() {
        return this.presetKey_;
      }
      read() {
        return this.obj_[this.key_];
      }
      write(l) {
        this.obj_[this.key_] = l;
      }
      writeProperty(l, p) {
        const w = this.read();
        if (!b.isBindable(w)) throw v.notBindable();
        if (!(l in w)) throw v.propertyNotFound(l);
        w[l] = p;
      }
    }
    class y extends n {
      get label() {
        return this.controller_.props.get("label");
      }
      set label(l) {
        this.controller_.props.set("label", l);
      }
      get title() {
        var l;
        return (l = this.controller_.valueController.props.get("title")) !==
          null && l !== void 0
          ? l
          : "";
      }
      set title(l) {
        this.controller_.valueController.props.set("title", l);
      }
      on(l, p) {
        const w = p.bind(this);
        return (
          this.controller_.valueController.emitter.on(l, () => {
            w(new s(this));
          }),
          this
        );
      }
    }
    class M {
      constructor() {
        this.observers_ = {};
      }
      on(l, p) {
        let w = this.observers_[l];
        return w || (w = this.observers_[l] = []), w.push({ handler: p }), this;
      }
      off(l, p) {
        const w = this.observers_[l];
        return (
          w && (this.observers_[l] = w.filter((R) => R.handler !== p)), this
        );
      }
      emit(l, p) {
        const w = this.observers_[l];
        w &&
          w.forEach((R) => {
            R.handler(p);
          });
      }
    }
    const D = "tp";
    function C(g) {
      return (p, w) =>
        [D, "-", g, "v", p ? `_${p}` : "", w ? `-${w}` : ""].join("");
    }
    function A(g, l) {
      return (p) => l(g(p));
    }
    function I(g) {
      return g.rawValue;
    }
    function F(g, l) {
      g.emitter.on("change", A(I, l)), l(g.rawValue);
    }
    function P(g, l, p) {
      F(g.value(l), p);
    }
    function k(g, l, p) {
      p ? g.classList.add(l) : g.classList.remove(l);
    }
    function O(g, l) {
      return (p) => {
        k(g, l, p);
      };
    }
    function J(g, l) {
      F(g, (p) => {
        l.textContent = p ?? "";
      });
    }
    const ee = C("btn");
    class X {
      constructor(l, p) {
        (this.element = l.createElement("div")),
          this.element.classList.add(ee()),
          p.viewProps.bindClassModifiers(this.element);
        const w = l.createElement("button");
        w.classList.add(ee("b")),
          p.viewProps.bindDisabled(w),
          this.element.appendChild(w),
          (this.buttonElement = w);
        const R = l.createElement("div");
        R.classList.add(ee("t")),
          J(p.props.value("title"), R),
          this.buttonElement.appendChild(R);
      }
    }
    class j {
      constructor(l, p) {
        (this.emitter = new M()),
          (this.onClick_ = this.onClick_.bind(this)),
          (this.props = p.props),
          (this.viewProps = p.viewProps),
          (this.view = new X(l, {
            props: this.props,
            viewProps: this.viewProps,
          })),
          this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", { sender: this });
      }
    }
    class Y {
      constructor(l, p) {
        var w;
        (this.constraint_ = p == null ? void 0 : p.constraint),
          (this.equals_ =
            (w = p == null ? void 0 : p.equals) !== null && w !== void 0
              ? w
              : (R, W) => R === W),
          (this.emitter = new M()),
          (this.rawValue_ = l);
      }
      get constraint() {
        return this.constraint_;
      }
      get rawValue() {
        return this.rawValue_;
      }
      set rawValue(l) {
        this.setRawValue(l, { forceEmit: !1, last: !0 });
      }
      setRawValue(l, p) {
        const w = p ?? { forceEmit: !1, last: !0 },
          R = this.constraint_ ? this.constraint_.constrain(l) : l,
          W = this.rawValue_;
        (this.equals_(W, R) && !w.forceEmit) ||
          (this.emitter.emit("beforechange", { sender: this }),
          (this.rawValue_ = R),
          this.emitter.emit("change", {
            options: w,
            previousRawValue: W,
            rawValue: R,
            sender: this,
          }));
      }
    }
    class ie {
      constructor(l) {
        (this.emitter = new M()), (this.value_ = l);
      }
      get rawValue() {
        return this.value_;
      }
      set rawValue(l) {
        this.setRawValue(l, { forceEmit: !1, last: !0 });
      }
      setRawValue(l, p) {
        const w = p ?? { forceEmit: !1, last: !0 },
          R = this.value_;
        (R === l && !w.forceEmit) ||
          (this.emitter.emit("beforechange", { sender: this }),
          (this.value_ = l),
          this.emitter.emit("change", {
            options: w,
            previousRawValue: R,
            rawValue: this.value_,
            sender: this,
          }));
      }
    }
    function Q(g, l) {
      const p = l == null ? void 0 : l.constraint,
        w = l == null ? void 0 : l.equals;
      return !p && !w ? new ie(g) : new Y(g, l);
    }
    class V {
      constructor(l) {
        (this.emitter = new M()), (this.valMap_ = l);
        for (const p in this.valMap_)
          this.valMap_[p].emitter.on("change", () => {
            this.emitter.emit("change", { key: p, sender: this });
          });
      }
      static createCore(l) {
        return Object.keys(l).reduce(
          (w, R) => Object.assign(w, { [R]: Q(l[R]) }),
          {}
        );
      }
      static fromObject(l) {
        const p = this.createCore(l);
        return new V(p);
      }
      get(l) {
        return this.valMap_[l].rawValue;
      }
      set(l, p) {
        this.valMap_[l].rawValue = p;
      }
      value(l) {
        return this.valMap_[l];
      }
    }
    function ve(g, l) {
      const w = Object.keys(l).reduce((R, W) => {
        if (R === void 0) return;
        const ae = l[W],
          Ee = ae(g[W]);
        return Ee.succeeded
          ? Object.assign(Object.assign({}, R), { [W]: Ee.value })
          : void 0;
      }, {});
      return w;
    }
    function U(g, l) {
      return g.reduce((p, w) => {
        if (p === void 0) return;
        const R = l(w);
        if (!(!R.succeeded || R.value === void 0)) return [...p, R.value];
      }, []);
    }
    function oe(g) {
      return g === null ? !1 : typeof g == "object";
    }
    function ue(g) {
      return (l) => (p) => {
        if (!l && p === void 0) return { succeeded: !1, value: void 0 };
        if (l && p === void 0) return { succeeded: !0, value: void 0 };
        const w = g(p);
        return w !== void 0
          ? { succeeded: !0, value: w }
          : { succeeded: !1, value: void 0 };
      };
    }
    function fe(g) {
      return {
        custom: (l) => ue(l)(g),
        boolean: ue((l) => (typeof l == "boolean" ? l : void 0))(g),
        number: ue((l) => (typeof l == "number" ? l : void 0))(g),
        string: ue((l) => (typeof l == "string" ? l : void 0))(g),
        function: ue((l) => (typeof l == "function" ? l : void 0))(g),
        constant: (l) => ue((p) => (p === l ? l : void 0))(g),
        raw: ue((l) => l)(g),
        object: (l) =>
          ue((p) => {
            if (oe(p)) return ve(p, l);
          })(g),
        array: (l) =>
          ue((p) => {
            if (Array.isArray(p)) return U(p, l);
          })(g),
      };
    }
    const le = { optional: fe(!0), required: fe(!1) };
    function be(g, l) {
      const p = le.required.object(l)(g);
      return p.succeeded ? p.value : void 0;
    }
    function ce(g) {
      console.warn(
        [
          `Missing '${g.key}' of ${g.target} in ${g.place}.`,
          "Please rebuild plugins with the latest core package.",
        ].join(" ")
      );
    }
    function He(g) {
      return g && g.parentElement && g.parentElement.removeChild(g), null;
    }
    class Se {
      constructor(l) {
        this.value_ = l;
      }
      static create(l) {
        return [
          new Se(l),
          (p, w) => {
            l.setRawValue(p, w);
          },
        ];
      }
      get emitter() {
        return this.value_.emitter;
      }
      get rawValue() {
        return this.value_.rawValue;
      }
    }
    const Oe = C("");
    function Me(g, l) {
      return O(g, Oe(void 0, l));
    }
    class Ke extends V {
      constructor(l) {
        var p;
        super(l),
          (this.onDisabledChange_ = this.onDisabledChange_.bind(this)),
          (this.onParentChange_ = this.onParentChange_.bind(this)),
          (this.onParentGlobalDisabledChange_ =
            this.onParentGlobalDisabledChange_.bind(this)),
          ([this.globalDisabled_, this.setGlobalDisabled_] = Se.create(
            Q(this.getGlobalDisabled_())
          )),
          this.value("disabled").emitter.on("change", this.onDisabledChange_),
          this.value("parent").emitter.on("change", this.onParentChange_),
          (p = this.get("parent")) === null ||
            p === void 0 ||
            p.globalDisabled.emitter.on(
              "change",
              this.onParentGlobalDisabledChange_
            );
      }
      static create(l) {
        var p, w, R;
        const W = l ?? {};
        return new Ke(
          V.createCore({
            disabled: (p = W.disabled) !== null && p !== void 0 ? p : !1,
            disposed: !1,
            hidden: (w = W.hidden) !== null && w !== void 0 ? w : !1,
            parent: (R = W.parent) !== null && R !== void 0 ? R : null,
          })
        );
      }
      get globalDisabled() {
        return this.globalDisabled_;
      }
      bindClassModifiers(l) {
        F(this.globalDisabled_, Me(l, "disabled")),
          P(this, "hidden", Me(l, "hidden"));
      }
      bindDisabled(l) {
        F(this.globalDisabled_, (p) => {
          l.disabled = p;
        });
      }
      bindTabIndex(l) {
        F(this.globalDisabled_, (p) => {
          l.tabIndex = p ? -1 : 0;
        });
      }
      handleDispose(l) {
        this.value("disposed").emitter.on("change", (p) => {
          p && l();
        });
      }
      getGlobalDisabled_() {
        const l = this.get("parent");
        return (l ? l.globalDisabled.rawValue : !1) || this.get("disabled");
      }
      updateGlobalDisabled_() {
        this.setGlobalDisabled_(this.getGlobalDisabled_());
      }
      onDisabledChange_() {
        this.updateGlobalDisabled_();
      }
      onParentGlobalDisabledChange_() {
        this.updateGlobalDisabled_();
      }
      onParentChange_(l) {
        var p;
        const w = l.previousRawValue;
        w == null ||
          w.globalDisabled.emitter.off(
            "change",
            this.onParentGlobalDisabledChange_
          ),
          (p = this.get("parent")) === null ||
            p === void 0 ||
            p.globalDisabled.emitter.on(
              "change",
              this.onParentGlobalDisabledChange_
            ),
          this.updateGlobalDisabled_();
      }
    }
    function Qe() {
      return ["veryfirst", "first", "last", "verylast"];
    }
    const Pe = C(""),
      ht = { veryfirst: "vfst", first: "fst", last: "lst", verylast: "vlst" };
    class wt {
      constructor(l) {
        (this.parent_ = null),
          (this.blade = l.blade),
          (this.view = l.view),
          (this.viewProps = l.viewProps);
        const p = this.view.element;
        this.blade.value("positions").emitter.on("change", () => {
          Qe().forEach((w) => {
            p.classList.remove(Pe(void 0, ht[w]));
          }),
            this.blade.get("positions").forEach((w) => {
              p.classList.add(Pe(void 0, ht[w]));
            });
        }),
          this.viewProps.handleDispose(() => {
            He(p);
          });
      }
      get parent() {
        return this.parent_;
      }
      set parent(l) {
        if (((this.parent_ = l), !("parent" in this.viewProps.valMap_))) {
          ce({
            key: "parent",
            target: Ke.name,
            place: "BladeController.parent",
          });
          return;
        }
        this.viewProps.set(
          "parent",
          this.parent_ ? this.parent_.viewProps : null
        );
      }
    }
    const dt = "http://www.w3.org/2000/svg";
    function he(g) {
      g.offsetHeight;
    }
    function Et(g, l) {
      const p = g.style.transition;
      (g.style.transition = "none"), l(), (g.style.transition = p);
    }
    function ft(g) {
      return g.ontouchstart !== void 0;
    }
    function Bt() {
      return globalThis;
    }
    function bt() {
      return Bt().document;
    }
    function G(g) {
      const l = g.ownerDocument.defaultView;
      return l && "document" in l
        ? g.getContext("2d", { willReadFrequently: !0 })
        : null;
    }
    const N = {
      check: '<path d="M2 8l4 4l8 -8"/>',
      dropdown: '<path d="M5 7h6l-3 3 z"/>',
      p2dpad:
        '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>',
    };
    function pe(g, l) {
      const p = g.createElementNS(dt, "svg");
      return (p.innerHTML = N[l]), p;
    }
    function xe(g, l, p) {
      g.insertBefore(l, g.children[p]);
    }
    function we(g) {
      g.parentElement && g.parentElement.removeChild(g);
    }
    function Ce(g) {
      for (; g.children.length > 0; ) g.removeChild(g.children[0]);
    }
    function We(g) {
      for (; g.childNodes.length > 0; ) g.removeChild(g.childNodes[0]);
    }
    function H(g) {
      return g.relatedTarget
        ? g.relatedTarget
        : "explicitOriginalTarget" in g
        ? g.explicitOriginalTarget
        : null;
    }
    const ne = C("lbl");
    function Re(g, l) {
      const p = g.createDocumentFragment();
      return (
        l
          .split(
            `
`
          )
          .map((R) => g.createTextNode(R))
          .forEach((R, W) => {
            W > 0 && p.appendChild(g.createElement("br")), p.appendChild(R);
          }),
        p
      );
    }
    class Ae {
      constructor(l, p) {
        (this.element = l.createElement("div")),
          this.element.classList.add(ne()),
          p.viewProps.bindClassModifiers(this.element);
        const w = l.createElement("div");
        w.classList.add(ne("l")),
          P(p.props, "label", (W) => {
            c(W)
              ? this.element.classList.add(ne(void 0, "nol"))
              : (this.element.classList.remove(ne(void 0, "nol")),
                We(w),
                w.appendChild(Re(l, W)));
          }),
          this.element.appendChild(w),
          (this.labelElement = w);
        const R = l.createElement("div");
        R.classList.add(ne("v")),
          this.element.appendChild(R),
          (this.valueElement = R);
      }
    }
    class ke extends wt {
      constructor(l, p) {
        const w = p.valueController.viewProps;
        super(
          Object.assign(Object.assign({}, p), {
            view: new Ae(l, { props: p.props, viewProps: w }),
            viewProps: w,
          })
        ),
          (this.props = p.props),
          (this.valueController = p.valueController),
          this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    const je = {
      id: "button",
      type: "blade",
      accept(g) {
        const l = le,
          p = be(g, {
            title: l.required.string,
            view: l.required.constant("button"),
            label: l.optional.string,
          });
        return p ? { params: p } : null;
      },
      controller(g) {
        return new ke(g.document, {
          blade: g.blade,
          props: V.fromObject({ label: g.params.label }),
          valueController: new j(g.document, {
            props: V.fromObject({ title: g.params.title }),
            viewProps: g.viewProps,
          }),
        });
      },
      api(g) {
        return !(g.controller instanceof ke) ||
          !(g.controller.valueController instanceof j)
          ? null
          : new y(g.controller);
      },
    };
    class Ve extends wt {
      constructor(l) {
        super(l), (this.value = l.value);
      }
    }
    function rt() {
      return new V({ positions: Q([], { equals: d }) });
    }
    class lt extends V {
      constructor(l) {
        super(l);
      }
      static create(l) {
        const p = {
            completed: !0,
            expanded: l,
            expandedHeight: null,
            shouldFixHeight: !1,
            temporaryExpanded: null,
          },
          w = V.createCore(p);
        return new lt(w);
      }
      get styleExpanded() {
        var l;
        return (l = this.get("temporaryExpanded")) !== null && l !== void 0
          ? l
          : this.get("expanded");
      }
      get styleHeight() {
        if (!this.styleExpanded) return "0";
        const l = this.get("expandedHeight");
        return this.get("shouldFixHeight") && !c(l) ? `${l}px` : "auto";
      }
      bindExpandedClass(l, p) {
        const w = () => {
          this.styleExpanded ? l.classList.add(p) : l.classList.remove(p);
        };
        P(this, "expanded", w), P(this, "temporaryExpanded", w);
      }
      cleanUpTransition() {
        this.set("shouldFixHeight", !1),
          this.set("expandedHeight", null),
          this.set("completed", !0);
      }
    }
    function Ct(g, l) {
      let p = 0;
      return (
        Et(l, () => {
          g.set("expandedHeight", null),
            g.set("temporaryExpanded", !0),
            he(l),
            (p = l.clientHeight),
            g.set("temporaryExpanded", null),
            he(l);
        }),
        p
      );
    }
    function $(g, l) {
      l.style.height = g.styleHeight;
    }
    function ge(g, l) {
      g.value("expanded").emitter.on("beforechange", () => {
        if ((g.set("completed", !1), c(g.get("expandedHeight")))) {
          const p = Ct(g, l);
          p > 0 && g.set("expandedHeight", p);
        }
        g.set("shouldFixHeight", !0), he(l);
      }),
        g.emitter.on("change", () => {
          $(g, l);
        }),
        $(g, l),
        l.addEventListener("transitionend", (p) => {
          p.propertyName === "height" && g.cleanUpTransition();
        });
    }
    class ye extends n {
      constructor(l, p) {
        super(l), (this.rackApi_ = p);
      }
    }
    function Ie(g, l) {
      return g.addBlade(
        Object.assign(Object.assign({}, l), { view: "button" })
      );
    }
    function Ge(g, l) {
      return g.addBlade(
        Object.assign(Object.assign({}, l), { view: "folder" })
      );
    }
    function Mt(g, l) {
      const p = l ?? {};
      return g.addBlade(
        Object.assign(Object.assign({}, p), { view: "separator" })
      );
    }
    function zt(g, l) {
      return g.addBlade(Object.assign(Object.assign({}, l), { view: "tab" }));
    }
    class Rt {
      constructor(l) {
        (this.emitter = new M()),
          (this.items_ = []),
          (this.cache_ = new Set()),
          (this.onSubListAdd_ = this.onSubListAdd_.bind(this)),
          (this.onSubListRemove_ = this.onSubListRemove_.bind(this)),
          (this.extract_ = l);
      }
      get items() {
        return this.items_;
      }
      allItems() {
        return Array.from(this.cache_);
      }
      find(l) {
        for (const p of this.allItems()) if (l(p)) return p;
        return null;
      }
      includes(l) {
        return this.cache_.has(l);
      }
      add(l, p) {
        if (this.includes(l)) throw v.shouldNeverHappen();
        const w = p !== void 0 ? p : this.items_.length;
        this.items_.splice(w, 0, l), this.cache_.add(l);
        const R = this.extract_(l);
        R &&
          (R.emitter.on("add", this.onSubListAdd_),
          R.emitter.on("remove", this.onSubListRemove_),
          R.allItems().forEach((W) => {
            this.cache_.add(W);
          })),
          this.emitter.emit("add", {
            index: w,
            item: l,
            root: this,
            target: this,
          });
      }
      remove(l) {
        const p = this.items_.indexOf(l);
        if (p < 0) return;
        this.items_.splice(p, 1), this.cache_.delete(l);
        const w = this.extract_(l);
        w &&
          (w.emitter.off("add", this.onSubListAdd_),
          w.emitter.off("remove", this.onSubListRemove_)),
          this.emitter.emit("remove", {
            index: p,
            item: l,
            root: this,
            target: this,
          });
      }
      onSubListAdd_(l) {
        this.cache_.add(l.item),
          this.emitter.emit("add", {
            index: l.index,
            item: l.item,
            root: this,
            target: l.target,
          });
      }
      onSubListRemove_(l) {
        this.cache_.delete(l.item),
          this.emitter.emit("remove", {
            index: l.index,
            item: l.item,
            root: this,
            target: l.target,
          });
      }
    }
    class tt extends n {
      constructor(l) {
        super(l),
          (this.onBindingChange_ = this.onBindingChange_.bind(this)),
          (this.emitter_ = new M()),
          this.controller_.binding.emitter.on("change", this.onBindingChange_);
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(l) {
        this.controller_.props.set("label", l);
      }
      on(l, p) {
        const w = p.bind(this);
        return (
          this.emitter_.on(l, (R) => {
            w(R.event);
          }),
          this
        );
      }
      refresh() {
        this.controller_.binding.read();
      }
      onBindingChange_(l) {
        const p = l.sender.target.read();
        this.emitter_.emit("change", {
          event: new a(
            this,
            p,
            this.controller_.binding.target.presetKey,
            l.options.last
          ),
        });
      }
    }
    class Te extends ke {
      constructor(l, p) {
        super(l, p), (this.binding = p.binding);
      }
    }
    class gt extends n {
      constructor(l) {
        super(l),
          (this.onBindingUpdate_ = this.onBindingUpdate_.bind(this)),
          (this.emitter_ = new M()),
          this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(l) {
        this.controller_.props.set("label", l);
      }
      on(l, p) {
        const w = p.bind(this);
        return (
          this.emitter_.on(l, (R) => {
            w(R.event);
          }),
          this
        );
      }
      refresh() {
        this.controller_.binding.read();
      }
      onBindingUpdate_(l) {
        const p = l.sender.target.read();
        this.emitter_.emit("update", {
          event: new o(this, p, this.controller_.binding.target.presetKey),
        });
      }
    }
    class mt extends ke {
      constructor(l, p) {
        super(l, p),
          (this.binding = p.binding),
          this.viewProps.bindDisabled(this.binding.ticker),
          this.viewProps.handleDispose(() => {
            this.binding.dispose();
          });
      }
    }
    function ze(g) {
      return g instanceof _t
        ? g.apiSet_
        : g instanceof ye
        ? g.rackApi_.apiSet_
        : null;
    }
    function yt(g, l) {
      const p = g.find((w) => w.controller_ === l);
      if (!p) throw v.shouldNeverHappen();
      return p;
    }
    function st(g, l, p) {
      if (!b.isBindable(g)) throw v.notBindable();
      return new b(g, l, p);
    }
    class _t extends n {
      constructor(l, p) {
        super(l),
          (this.onRackAdd_ = this.onRackAdd_.bind(this)),
          (this.onRackRemove_ = this.onRackRemove_.bind(this)),
          (this.onRackInputChange_ = this.onRackInputChange_.bind(this)),
          (this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this)),
          (this.emitter_ = new M()),
          (this.apiSet_ = new Rt(ze)),
          (this.pool_ = p);
        const w = this.controller_.rack;
        w.emitter.on("add", this.onRackAdd_),
          w.emitter.on("remove", this.onRackRemove_),
          w.emitter.on("inputchange", this.onRackInputChange_),
          w.emitter.on("monitorupdate", this.onRackMonitorUpdate_),
          w.children.forEach((R) => {
            this.setUpApi_(R);
          });
      }
      get children() {
        return this.controller_.rack.children.map((l) => yt(this.apiSet_, l));
      }
      addInput(l, p, w) {
        const R = w ?? {},
          W = this.controller_.view.element.ownerDocument,
          ae = this.pool_.createInput(W, st(l, p, R.presetKey), R),
          Ee = new tt(ae);
        return this.add(Ee, R.index);
      }
      addMonitor(l, p, w) {
        const R = w ?? {},
          W = this.controller_.view.element.ownerDocument,
          ae = this.pool_.createMonitor(W, st(l, p), R),
          Ee = new gt(ae);
        return this.add(Ee, R.index);
      }
      addFolder(l) {
        return Ge(this, l);
      }
      addButton(l) {
        return Ie(this, l);
      }
      addSeparator(l) {
        return Mt(this, l);
      }
      addTab(l) {
        return zt(this, l);
      }
      add(l, p) {
        this.controller_.rack.add(l.controller_, p);
        const w = this.apiSet_.find((R) => R.controller_ === l.controller_);
        return w && this.apiSet_.remove(w), this.apiSet_.add(l), l;
      }
      remove(l) {
        this.controller_.rack.remove(l.controller_);
      }
      addBlade(l) {
        const p = this.controller_.view.element.ownerDocument,
          w = this.pool_.createBlade(p, l),
          R = this.pool_.createBladeApi(w);
        return this.add(R, l.index);
      }
      on(l, p) {
        const w = p.bind(this);
        return (
          this.emitter_.on(l, (R) => {
            w(R.event);
          }),
          this
        );
      }
      setUpApi_(l) {
        this.apiSet_.find((w) => w.controller_ === l) ||
          this.apiSet_.add(this.pool_.createBladeApi(l));
      }
      onRackAdd_(l) {
        this.setUpApi_(l.bladeController);
      }
      onRackRemove_(l) {
        if (l.isRoot) {
          const p = yt(this.apiSet_, l.bladeController);
          this.apiSet_.remove(p);
        }
      }
      onRackInputChange_(l) {
        const p = l.bladeController;
        if (p instanceof Te) {
          const w = yt(this.apiSet_, p),
            R = p.binding;
          this.emitter_.emit("change", {
            event: new a(
              w,
              R.target.read(),
              R.target.presetKey,
              l.options.last
            ),
          });
        } else if (p instanceof Ve) {
          const w = yt(this.apiSet_, p);
          this.emitter_.emit("change", {
            event: new a(w, p.value.rawValue, void 0, l.options.last),
          });
        }
      }
      onRackMonitorUpdate_(l) {
        if (!(l.bladeController instanceof mt)) throw v.shouldNeverHappen();
        const p = yt(this.apiSet_, l.bladeController),
          w = l.bladeController.binding;
        this.emitter_.emit("update", {
          event: new o(p, w.target.read(), w.target.presetKey),
        });
      }
    }
    class B extends ye {
      constructor(l, p) {
        super(l, new _t(l.rackController, p)),
          (this.emitter_ = new M()),
          this.controller_.foldable
            .value("expanded")
            .emitter.on("change", (w) => {
              this.emitter_.emit("fold", {
                event: new u(this, w.sender.rawValue),
              });
            }),
          this.rackApi_.on("change", (w) => {
            this.emitter_.emit("change", { event: w });
          }),
          this.rackApi_.on("update", (w) => {
            this.emitter_.emit("update", { event: w });
          });
      }
      get expanded() {
        return this.controller_.foldable.get("expanded");
      }
      set expanded(l) {
        this.controller_.foldable.set("expanded", l);
      }
      get title() {
        return this.controller_.props.get("title");
      }
      set title(l) {
        this.controller_.props.set("title", l);
      }
      get children() {
        return this.rackApi_.children;
      }
      addInput(l, p, w) {
        return this.rackApi_.addInput(l, p, w);
      }
      addMonitor(l, p, w) {
        return this.rackApi_.addMonitor(l, p, w);
      }
      addFolder(l) {
        return this.rackApi_.addFolder(l);
      }
      addButton(l) {
        return this.rackApi_.addButton(l);
      }
      addSeparator(l) {
        return this.rackApi_.addSeparator(l);
      }
      addTab(l) {
        return this.rackApi_.addTab(l);
      }
      add(l, p) {
        return this.rackApi_.add(l, p);
      }
      remove(l) {
        this.rackApi_.remove(l);
      }
      addBlade(l) {
        return this.rackApi_.addBlade(l);
      }
      on(l, p) {
        const w = p.bind(this);
        return (
          this.emitter_.on(l, (R) => {
            w(R.event);
          }),
          this
        );
      }
    }
    class te extends wt {
      constructor(l) {
        super({
          blade: l.blade,
          view: l.view,
          viewProps: l.rackController.viewProps,
        }),
          (this.rackController = l.rackController);
      }
    }
    class de {
      constructor(l, p) {
        const w = C(p.viewName);
        (this.element = l.createElement("div")),
          this.element.classList.add(w()),
          p.viewProps.bindClassModifiers(this.element);
      }
    }
    function se(g, l) {
      for (let p = 0; p < g.length; p++) {
        const w = g[p];
        if (w instanceof Te && w.binding === l) return w;
      }
      return null;
    }
    function me(g, l) {
      for (let p = 0; p < g.length; p++) {
        const w = g[p];
        if (w instanceof mt && w.binding === l) return w;
      }
      return null;
    }
    function Fe(g, l) {
      for (let p = 0; p < g.length; p++) {
        const w = g[p];
        if (w instanceof Ve && w.value === l) return w;
      }
      return null;
    }
    function Ne(g) {
      return g instanceof nt
        ? g.rack
        : g instanceof te
        ? g.rackController.rack
        : null;
    }
    function it(g) {
      const l = Ne(g);
      return l ? l.bcSet_ : null;
    }
    class $e {
      constructor(l) {
        var p, w;
        (this.onBladePositionsChange_ =
          this.onBladePositionsChange_.bind(this)),
          (this.onSetAdd_ = this.onSetAdd_.bind(this)),
          (this.onSetRemove_ = this.onSetRemove_.bind(this)),
          (this.onChildDispose_ = this.onChildDispose_.bind(this)),
          (this.onChildPositionsChange_ =
            this.onChildPositionsChange_.bind(this)),
          (this.onChildInputChange_ = this.onChildInputChange_.bind(this)),
          (this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this)),
          (this.onChildValueChange_ = this.onChildValueChange_.bind(this)),
          (this.onChildViewPropsChange_ =
            this.onChildViewPropsChange_.bind(this)),
          (this.onDescendantLayout_ = this.onDescendantLayout_.bind(this)),
          (this.onDescendantInputChange_ =
            this.onDescendantInputChange_.bind(this)),
          (this.onDescendantMonitorUpdate_ =
            this.onDescendantMonitorUpdate_.bind(this)),
          (this.emitter = new M()),
          (this.blade_ = (p = l.blade) !== null && p !== void 0 ? p : null),
          (w = this.blade_) === null ||
            w === void 0 ||
            w
              .value("positions")
              .emitter.on("change", this.onBladePositionsChange_),
          (this.viewProps = l.viewProps),
          (this.bcSet_ = new Rt(it)),
          this.bcSet_.emitter.on("add", this.onSetAdd_),
          this.bcSet_.emitter.on("remove", this.onSetRemove_);
      }
      get children() {
        return this.bcSet_.items;
      }
      add(l, p) {
        var w;
        (w = l.parent) === null || w === void 0 || w.remove(l),
          m(l, "parent")
            ? (l.parent = this)
            : ((l.parent_ = this),
              ce({
                key: "parent",
                target: "BladeController",
                place: "BladeRack.add",
              })),
          this.bcSet_.add(l, p);
      }
      remove(l) {
        m(l, "parent")
          ? (l.parent = null)
          : ((l.parent_ = null),
            ce({
              key: "parent",
              target: "BladeController",
              place: "BladeRack.remove",
            })),
          this.bcSet_.remove(l);
      }
      find(l) {
        return this.bcSet_.allItems().filter((p) => p instanceof l);
      }
      onSetAdd_(l) {
        this.updatePositions_();
        const p = l.target === l.root;
        if (
          (this.emitter.emit("add", {
            bladeController: l.item,
            index: l.index,
            isRoot: p,
            sender: this,
          }),
          !p)
        )
          return;
        const w = l.item;
        if (
          (w.viewProps.emitter.on("change", this.onChildViewPropsChange_),
          w.blade
            .value("positions")
            .emitter.on("change", this.onChildPositionsChange_),
          w.viewProps.handleDispose(this.onChildDispose_),
          w instanceof Te)
        )
          w.binding.emitter.on("change", this.onChildInputChange_);
        else if (w instanceof mt)
          w.binding.emitter.on("update", this.onChildMonitorUpdate_);
        else if (w instanceof Ve)
          w.value.emitter.on("change", this.onChildValueChange_);
        else {
          const R = Ne(w);
          if (R) {
            const W = R.emitter;
            W.on("layout", this.onDescendantLayout_),
              W.on("inputchange", this.onDescendantInputChange_),
              W.on("monitorupdate", this.onDescendantMonitorUpdate_);
          }
        }
      }
      onSetRemove_(l) {
        this.updatePositions_();
        const p = l.target === l.root;
        if (
          (this.emitter.emit("remove", {
            bladeController: l.item,
            isRoot: p,
            sender: this,
          }),
          !p)
        )
          return;
        const w = l.item;
        if (w instanceof Te)
          w.binding.emitter.off("change", this.onChildInputChange_);
        else if (w instanceof mt)
          w.binding.emitter.off("update", this.onChildMonitorUpdate_);
        else if (w instanceof Ve)
          w.value.emitter.off("change", this.onChildValueChange_);
        else {
          const R = Ne(w);
          if (R) {
            const W = R.emitter;
            W.off("layout", this.onDescendantLayout_),
              W.off("inputchange", this.onDescendantInputChange_),
              W.off("monitorupdate", this.onDescendantMonitorUpdate_);
          }
        }
      }
      updatePositions_() {
        const l = this.bcSet_.items.filter((R) => !R.viewProps.get("hidden")),
          p = l[0],
          w = l[l.length - 1];
        this.bcSet_.items.forEach((R) => {
          const W = [];
          R === p &&
            (W.push("first"),
            (!this.blade_ ||
              this.blade_.get("positions").includes("veryfirst")) &&
              W.push("veryfirst")),
            R === w &&
              (W.push("last"),
              (!this.blade_ ||
                this.blade_.get("positions").includes("verylast")) &&
                W.push("verylast")),
            R.blade.set("positions", W);
        });
      }
      onChildPositionsChange_() {
        this.updatePositions_(), this.emitter.emit("layout", { sender: this });
      }
      onChildViewPropsChange_(l) {
        this.updatePositions_(), this.emitter.emit("layout", { sender: this });
      }
      onChildDispose_() {
        this.bcSet_.items
          .filter((p) => p.viewProps.get("disposed"))
          .forEach((p) => {
            this.bcSet_.remove(p);
          });
      }
      onChildInputChange_(l) {
        const p = se(this.find(Te), l.sender);
        if (!p) throw v.alreadyDisposed();
        this.emitter.emit("inputchange", {
          bladeController: p,
          options: l.options,
          sender: this,
        });
      }
      onChildMonitorUpdate_(l) {
        const p = me(this.find(mt), l.sender);
        if (!p) throw v.alreadyDisposed();
        this.emitter.emit("monitorupdate", {
          bladeController: p,
          sender: this,
        });
      }
      onChildValueChange_(l) {
        const p = Fe(this.find(Ve), l.sender);
        if (!p) throw v.alreadyDisposed();
        this.emitter.emit("inputchange", {
          bladeController: p,
          options: l.options,
          sender: this,
        });
      }
      onDescendantLayout_(l) {
        this.updatePositions_(), this.emitter.emit("layout", { sender: this });
      }
      onDescendantInputChange_(l) {
        this.emitter.emit("inputchange", {
          bladeController: l.bladeController,
          options: l.options,
          sender: this,
        });
      }
      onDescendantMonitorUpdate_(l) {
        this.emitter.emit("monitorupdate", {
          bladeController: l.bladeController,
          sender: this,
        });
      }
      onBladePositionsChange_() {
        this.updatePositions_();
      }
    }
    class nt extends wt {
      constructor(l, p) {
        super(
          Object.assign(Object.assign({}, p), {
            view: new de(l, { viewName: "brk", viewProps: p.viewProps }),
          })
        ),
          (this.onRackAdd_ = this.onRackAdd_.bind(this)),
          (this.onRackRemove_ = this.onRackRemove_.bind(this));
        const w = new $e({
          blade: p.root ? void 0 : p.blade,
          viewProps: p.viewProps,
        });
        w.emitter.on("add", this.onRackAdd_),
          w.emitter.on("remove", this.onRackRemove_),
          (this.rack = w),
          this.viewProps.handleDispose(() => {
            for (let R = this.rack.children.length - 1; R >= 0; R--)
              this.rack.children[R].viewProps.set("disposed", !0);
          });
      }
      onRackAdd_(l) {
        l.isRoot &&
          xe(this.view.element, l.bladeController.view.element, l.index);
      }
      onRackRemove_(l) {
        l.isRoot && we(l.bladeController.view.element);
      }
    }
    const pt = C("cnt");
    class ot {
      constructor(l, p) {
        var w;
        (this.className_ = C(
          (w = p.viewName) !== null && w !== void 0 ? w : "fld"
        )),
          (this.element = l.createElement("div")),
          this.element.classList.add(this.className_(), pt()),
          p.viewProps.bindClassModifiers(this.element),
          (this.foldable_ = p.foldable),
          this.foldable_.bindExpandedClass(
            this.element,
            this.className_(void 0, "expanded")
          ),
          P(
            this.foldable_,
            "completed",
            O(this.element, this.className_(void 0, "cpl"))
          );
        const R = l.createElement("button");
        R.classList.add(this.className_("b")),
          P(p.props, "title", (vt) => {
            c(vt)
              ? this.element.classList.add(this.className_(void 0, "not"))
              : this.element.classList.remove(this.className_(void 0, "not"));
          }),
          p.viewProps.bindDisabled(R),
          this.element.appendChild(R),
          (this.buttonElement = R);
        const W = l.createElement("div");
        W.classList.add(this.className_("i")), this.element.appendChild(W);
        const ae = l.createElement("div");
        ae.classList.add(this.className_("t")),
          J(p.props.value("title"), ae),
          this.buttonElement.appendChild(ae),
          (this.titleElement = ae);
        const Ee = l.createElement("div");
        Ee.classList.add(this.className_("m")),
          this.buttonElement.appendChild(Ee);
        const et = p.containerElement;
        et.classList.add(this.className_("c")),
          this.element.appendChild(et),
          (this.containerElement = et);
      }
    }
    class xt extends te {
      constructor(l, p) {
        var w;
        const R = lt.create((w = p.expanded) !== null && w !== void 0 ? w : !0),
          W = new nt(l, {
            blade: p.blade,
            root: p.root,
            viewProps: p.viewProps,
          });
        super(
          Object.assign(Object.assign({}, p), {
            rackController: W,
            view: new ot(l, {
              containerElement: W.view.element,
              foldable: R,
              props: p.props,
              viewName: p.root ? "rot" : void 0,
              viewProps: p.viewProps,
            }),
          })
        ),
          (this.onTitleClick_ = this.onTitleClick_.bind(this)),
          (this.props = p.props),
          (this.foldable = R),
          ge(this.foldable, this.view.containerElement),
          this.rackController.rack.emitter.on("add", () => {
            this.foldable.cleanUpTransition();
          }),
          this.rackController.rack.emitter.on("remove", () => {
            this.foldable.cleanUpTransition();
          }),
          this.view.buttonElement.addEventListener("click", this.onTitleClick_);
      }
      get document() {
        return this.view.element.ownerDocument;
      }
      onTitleClick_() {
        this.foldable.set("expanded", !this.foldable.get("expanded"));
      }
    }
    const Ot = {
      id: "folder",
      type: "blade",
      accept(g) {
        const l = le,
          p = be(g, {
            title: l.required.string,
            view: l.required.constant("folder"),
            expanded: l.optional.boolean,
          });
        return p ? { params: p } : null;
      },
      controller(g) {
        return new xt(g.document, {
          blade: g.blade,
          expanded: g.params.expanded,
          props: V.fromObject({ title: g.params.title }),
          viewProps: g.viewProps,
        });
      },
      api(g) {
        return g.controller instanceof xt ? new B(g.controller, g.pool) : null;
      },
    };
    class Zt extends Ve {
      constructor(l, p) {
        const w = p.valueController.viewProps;
        super(
          Object.assign(Object.assign({}, p), {
            value: p.valueController.value,
            view: new Ae(l, { props: p.props, viewProps: w }),
            viewProps: w,
          })
        ),
          (this.props = p.props),
          (this.valueController = p.valueController),
          this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    class ki extends n {}
    const St = C("spr");
    class Je {
      constructor(l, p) {
        (this.element = l.createElement("div")),
          this.element.classList.add(St()),
          p.viewProps.bindClassModifiers(this.element);
        const w = l.createElement("hr");
        w.classList.add(St("r")), this.element.appendChild(w);
      }
    }
    class ai extends wt {
      constructor(l, p) {
        super(
          Object.assign(Object.assign({}, p), {
            view: new Je(l, { viewProps: p.viewProps }),
          })
        );
      }
    }
    const Jt = {
        id: "separator",
        type: "blade",
        accept(g) {
          const p = be(g, { view: le.required.constant("separator") });
          return p ? { params: p } : null;
        },
        controller(g) {
          return new ai(g.document, { blade: g.blade, viewProps: g.viewProps });
        },
        api(g) {
          return g.controller instanceof ai ? new ki(g.controller) : null;
        },
      },
      Ut = C("tbi");
    class Gn {
      constructor(l, p) {
        (this.element = l.createElement("div")),
          this.element.classList.add(Ut()),
          p.viewProps.bindClassModifiers(this.element),
          P(p.props, "selected", (W) => {
            W
              ? this.element.classList.add(Ut(void 0, "sel"))
              : this.element.classList.remove(Ut(void 0, "sel"));
          });
        const w = l.createElement("button");
        w.classList.add(Ut("b")),
          p.viewProps.bindDisabled(w),
          this.element.appendChild(w),
          (this.buttonElement = w);
        const R = l.createElement("div");
        R.classList.add(Ut("t")),
          J(p.props.value("title"), R),
          this.buttonElement.appendChild(R),
          (this.titleElement = R);
      }
    }
    class ni {
      constructor(l, p) {
        (this.emitter = new M()),
          (this.onClick_ = this.onClick_.bind(this)),
          (this.props = p.props),
          (this.viewProps = p.viewProps),
          (this.view = new Gn(l, { props: p.props, viewProps: p.viewProps })),
          this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", { sender: this });
      }
    }
    class un {
      constructor(l, p) {
        (this.onItemClick_ = this.onItemClick_.bind(this)),
          (this.ic_ = new ni(l, {
            props: p.itemProps,
            viewProps: Ke.create(),
          })),
          this.ic_.emitter.on("click", this.onItemClick_),
          (this.cc_ = new nt(l, { blade: rt(), viewProps: Ke.create() })),
          (this.props = p.props),
          P(this.props, "selected", (w) => {
            this.itemController.props.set("selected", w),
              this.contentController.viewProps.set("hidden", !w);
          });
      }
      get itemController() {
        return this.ic_;
      }
      get contentController() {
        return this.cc_;
      }
      onItemClick_() {
        this.props.set("selected", !0);
      }
    }
    class Qt {
      constructor(l, p) {
        (this.controller_ = l), (this.rackApi_ = p);
      }
      get title() {
        var l;
        return (l = this.controller_.itemController.props.get("title")) !==
          null && l !== void 0
          ? l
          : "";
      }
      set title(l) {
        this.controller_.itemController.props.set("title", l);
      }
      get selected() {
        return this.controller_.props.get("selected");
      }
      set selected(l) {
        this.controller_.props.set("selected", l);
      }
      get children() {
        return this.rackApi_.children;
      }
      addButton(l) {
        return this.rackApi_.addButton(l);
      }
      addFolder(l) {
        return this.rackApi_.addFolder(l);
      }
      addSeparator(l) {
        return this.rackApi_.addSeparator(l);
      }
      addTab(l) {
        return this.rackApi_.addTab(l);
      }
      add(l, p) {
        this.rackApi_.add(l, p);
      }
      remove(l) {
        this.rackApi_.remove(l);
      }
      addInput(l, p, w) {
        return this.rackApi_.addInput(l, p, w);
      }
      addMonitor(l, p, w) {
        return this.rackApi_.addMonitor(l, p, w);
      }
      addBlade(l) {
        return this.rackApi_.addBlade(l);
      }
    }
    class Ti extends ye {
      constructor(l, p) {
        super(l, new _t(l.rackController, p)),
          (this.onPageAdd_ = this.onPageAdd_.bind(this)),
          (this.onPageRemove_ = this.onPageRemove_.bind(this)),
          (this.onSelect_ = this.onSelect_.bind(this)),
          (this.emitter_ = new M()),
          (this.pageApiMap_ = new Map()),
          this.rackApi_.on("change", (w) => {
            this.emitter_.emit("change", { event: w });
          }),
          this.rackApi_.on("update", (w) => {
            this.emitter_.emit("update", { event: w });
          }),
          this.controller_.tab.selectedIndex.emitter.on(
            "change",
            this.onSelect_
          ),
          this.controller_.pageSet.emitter.on("add", this.onPageAdd_),
          this.controller_.pageSet.emitter.on("remove", this.onPageRemove_),
          this.controller_.pageSet.items.forEach((w) => {
            this.setUpPageApi_(w);
          });
      }
      get pages() {
        return this.controller_.pageSet.items.map((l) => {
          const p = this.pageApiMap_.get(l);
          if (!p) throw v.shouldNeverHappen();
          return p;
        });
      }
      addPage(l) {
        const p = this.controller_.view.element.ownerDocument,
          w = new un(p, {
            itemProps: V.fromObject({ selected: !1, title: l.title }),
            props: V.fromObject({ selected: !1 }),
          });
        this.controller_.add(w, l.index);
        const R = this.pageApiMap_.get(w);
        if (!R) throw v.shouldNeverHappen();
        return R;
      }
      removePage(l) {
        this.controller_.remove(l);
      }
      on(l, p) {
        const w = p.bind(this);
        return (
          this.emitter_.on(l, (R) => {
            w(R.event);
          }),
          this
        );
      }
      setUpPageApi_(l) {
        const p = this.rackApi_.apiSet_.find(
          (R) => R.controller_ === l.contentController
        );
        if (!p) throw v.shouldNeverHappen();
        const w = new Qt(l, p);
        this.pageApiMap_.set(l, w);
      }
      onPageAdd_(l) {
        this.setUpPageApi_(l.item);
      }
      onPageRemove_(l) {
        if (!this.pageApiMap_.get(l.item)) throw v.shouldNeverHappen();
        this.pageApiMap_.delete(l.item);
      }
      onSelect_(l) {
        this.emitter_.emit("select", { event: new h(this, l.rawValue) });
      }
    }
    const yr = -1;
    class Ii {
      constructor() {
        (this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this)),
          (this.empty = Q(!0)),
          (this.selectedIndex = Q(yr)),
          (this.items_ = []);
      }
      add(l, p) {
        const w = p ?? this.items_.length;
        this.items_.splice(w, 0, l),
          l.emitter.on("change", this.onItemSelectedChange_),
          this.keepSelection_();
      }
      remove(l) {
        const p = this.items_.indexOf(l);
        p < 0 ||
          (this.items_.splice(p, 1),
          l.emitter.off("change", this.onItemSelectedChange_),
          this.keepSelection_());
      }
      keepSelection_() {
        if (this.items_.length === 0) {
          (this.selectedIndex.rawValue = yr), (this.empty.rawValue = !0);
          return;
        }
        const l = this.items_.findIndex((p) => p.rawValue);
        l < 0
          ? (this.items_.forEach((p, w) => {
              p.rawValue = w === 0;
            }),
            (this.selectedIndex.rawValue = 0))
          : (this.items_.forEach((p, w) => {
              p.rawValue = w === l;
            }),
            (this.selectedIndex.rawValue = l)),
          (this.empty.rawValue = !1);
      }
      onItemSelectedChange_(l) {
        if (l.rawValue) {
          const p = this.items_.findIndex((w) => w === l.sender);
          this.items_.forEach((w, R) => {
            w.rawValue = R === p;
          }),
            (this.selectedIndex.rawValue = p);
        } else this.keepSelection_();
      }
    }
    const Hn = C("tab");
    class ys {
      constructor(l, p) {
        (this.element = l.createElement("div")),
          this.element.classList.add(Hn(), pt()),
          p.viewProps.bindClassModifiers(this.element),
          F(p.empty, O(this.element, Hn(void 0, "nop")));
        const w = l.createElement("div");
        w.classList.add(Hn("t")),
          this.element.appendChild(w),
          (this.itemsElement = w);
        const R = l.createElement("div");
        R.classList.add(Hn("i")), this.element.appendChild(R);
        const W = p.contentsElement;
        W.classList.add(Hn("c")),
          this.element.appendChild(W),
          (this.contentsElement = W);
      }
    }
    class Ss extends te {
      constructor(l, p) {
        const w = new nt(l, { blade: p.blade, viewProps: p.viewProps }),
          R = new Ii();
        super({
          blade: p.blade,
          rackController: w,
          view: new ys(l, {
            contentsElement: w.view.element,
            empty: R.empty,
            viewProps: p.viewProps,
          }),
        }),
          (this.onPageAdd_ = this.onPageAdd_.bind(this)),
          (this.onPageRemove_ = this.onPageRemove_.bind(this)),
          (this.pageSet_ = new Rt(() => null)),
          this.pageSet_.emitter.on("add", this.onPageAdd_),
          this.pageSet_.emitter.on("remove", this.onPageRemove_),
          (this.tab = R);
      }
      get pageSet() {
        return this.pageSet_;
      }
      add(l, p) {
        this.pageSet_.add(l, p);
      }
      remove(l) {
        this.pageSet_.remove(this.pageSet_.items[l]);
      }
      onPageAdd_(l) {
        const p = l.item;
        xe(this.view.itemsElement, p.itemController.view.element, l.index),
          p.itemController.viewProps.set("parent", this.viewProps),
          this.rackController.rack.add(p.contentController, l.index),
          this.tab.add(p.props.value("selected"));
      }
      onPageRemove_(l) {
        const p = l.item;
        we(p.itemController.view.element),
          p.itemController.viewProps.set("parent", null),
          this.rackController.rack.remove(p.contentController),
          this.tab.remove(p.props.value("selected"));
      }
    }
    const Ll = {
      id: "tab",
      type: "blade",
      accept(g) {
        const l = le,
          p = be(g, {
            pages: l.required.array(
              l.required.object({ title: l.required.string })
            ),
            view: l.required.constant("tab"),
          });
        return !p || p.pages.length === 0 ? null : { params: p };
      },
      controller(g) {
        const l = new Ss(g.document, {
          blade: g.blade,
          viewProps: g.viewProps,
        });
        return (
          g.params.pages.forEach((p) => {
            const w = new un(g.document, {
              itemProps: V.fromObject({ selected: !1, title: p.title }),
              props: V.fromObject({ selected: !1 }),
            });
            l.add(w);
          }),
          l
        );
      },
      api(g) {
        return g.controller instanceof Ss ? new Ti(g.controller, g.pool) : null;
      },
    };
    function Sd(g, l) {
      const p = g.accept(l.params);
      if (!p) return null;
      const w = le.optional.boolean(l.params.disabled).value,
        R = le.optional.boolean(l.params.hidden).value;
      return g.controller({
        blade: rt(),
        document: l.document,
        params: Object.assign(Object.assign({}, p.params), {
          disabled: w,
          hidden: R,
        }),
        viewProps: Ke.create({ disabled: w, hidden: R }),
      });
    }
    class _u {
      constructor() {
        (this.disabled = !1), (this.emitter = new M());
      }
      dispose() {}
      tick() {
        this.disabled || this.emitter.emit("tick", { sender: this });
      }
    }
    class Rl {
      constructor(l, p) {
        (this.disabled_ = !1),
          (this.timerId_ = null),
          (this.onTick_ = this.onTick_.bind(this)),
          (this.doc_ = l),
          (this.emitter = new M()),
          (this.interval_ = p),
          this.setTimer_();
      }
      get disabled() {
        return this.disabled_;
      }
      set disabled(l) {
        (this.disabled_ = l),
          this.disabled_ ? this.clearTimer_() : this.setTimer_();
      }
      dispose() {
        this.clearTimer_();
      }
      clearTimer_() {
        if (this.timerId_ === null) return;
        const l = this.doc_.defaultView;
        l && l.clearInterval(this.timerId_), (this.timerId_ = null);
      }
      setTimer_() {
        if ((this.clearTimer_(), this.interval_ <= 0)) return;
        const l = this.doc_.defaultView;
        l && (this.timerId_ = l.setInterval(this.onTick_, this.interval_));
      }
      onTick_() {
        this.disabled_ || this.emitter.emit("tick", { sender: this });
      }
    }
    class la {
      constructor(l) {
        (this.onValueChange_ = this.onValueChange_.bind(this)),
          (this.reader = l.reader),
          (this.writer = l.writer),
          (this.emitter = new M()),
          (this.value = l.value),
          this.value.emitter.on("change", this.onValueChange_),
          (this.target = l.target),
          this.read();
      }
      read() {
        const l = this.target.read();
        l !== void 0 && (this.value.rawValue = this.reader(l));
      }
      write_(l) {
        this.writer(this.target, l);
      }
      onValueChange_(l) {
        this.write_(l.rawValue),
          this.emitter.emit("change", {
            options: l.options,
            rawValue: l.rawValue,
            sender: this,
          });
      }
    }
    function li(g, l) {
      for (; g.length < l; ) g.push(void 0);
    }
    function bu(g) {
      const l = [];
      return li(l, g), Q(l);
    }
    function Sr(g) {
      const l = g.indexOf(void 0);
      return l < 0 ? g : g.slice(0, l);
    }
    function hn(g, l) {
      const p = [...Sr(g), l];
      return (
        p.length > g.length
          ? p.splice(0, p.length - g.length)
          : li(p, g.length),
        p
      );
    }
    class Md {
      constructor(l) {
        (this.onTick_ = this.onTick_.bind(this)),
          (this.reader_ = l.reader),
          (this.target = l.target),
          (this.emitter = new M()),
          (this.value = l.value),
          (this.ticker = l.ticker),
          this.ticker.emitter.on("tick", this.onTick_),
          this.read();
      }
      dispose() {
        this.ticker.dispose();
      }
      read() {
        const l = this.target.read();
        if (l === void 0) return;
        const p = this.value.rawValue,
          w = this.reader_(l);
        (this.value.rawValue = hn(p, w)),
          this.emitter.emit("update", { rawValue: w, sender: this });
      }
      onTick_(l) {
        this.read();
      }
    }
    class no {
      constructor(l) {
        this.constraints = l;
      }
      constrain(l) {
        return this.constraints.reduce((p, w) => w.constrain(p), l);
      }
    }
    function En(g, l) {
      if (g instanceof l) return g;
      if (g instanceof no) {
        const p = g.constraints.reduce(
          (w, R) => w || (R instanceof l ? R : null),
          null
        );
        if (p) return p;
      }
      return null;
    }
    class Mr {
      constructor(l) {
        this.values = V.fromObject({ max: l.max, min: l.min });
      }
      constrain(l) {
        const p = this.values.get("max"),
          w = this.values.get("min");
        return Math.min(Math.max(l, w), p);
      }
    }
    class so {
      constructor(l) {
        this.values = V.fromObject({ options: l });
      }
      get options() {
        return this.values.get("options");
      }
      constrain(l) {
        const p = this.values.get("options");
        return p.length === 0 || p.filter((R) => R.value === l).length > 0
          ? l
          : p[0].value;
      }
    }
    class kl {
      constructor(l) {
        this.values = V.fromObject({ max: l.max, min: l.min });
      }
      get maxValue() {
        return this.values.get("max");
      }
      get minValue() {
        return this.values.get("min");
      }
      constrain(l) {
        const p = this.values.get("max"),
          w = this.values.get("min");
        let R = l;
        return c(w) || (R = Math.max(R, w)), c(p) || (R = Math.min(R, p)), R;
      }
    }
    class ca {
      constructor(l, p = 0) {
        (this.step = l), (this.origin = p);
      }
      constrain(l) {
        const p = this.origin % this.step,
          w = Math.round((l - p) / this.step);
        return p + w * this.step;
      }
    }
    const Tr = C("lst");
    class xu {
      constructor(l, p) {
        (this.onValueChange_ = this.onValueChange_.bind(this)),
          (this.props_ = p.props),
          (this.element = l.createElement("div")),
          this.element.classList.add(Tr()),
          p.viewProps.bindClassModifiers(this.element);
        const w = l.createElement("select");
        w.classList.add(Tr("s")),
          P(this.props_, "options", (W) => {
            Ce(w),
              W.forEach((ae, Ee) => {
                const et = l.createElement("option");
                (et.dataset.index = String(Ee)),
                  (et.textContent = ae.text),
                  (et.value = String(ae.value)),
                  w.appendChild(et);
              });
          }),
          p.viewProps.bindDisabled(w),
          this.element.appendChild(w),
          (this.selectElement = w);
        const R = l.createElement("div");
        R.classList.add(Tr("m")),
          R.appendChild(pe(l, "dropdown")),
          this.element.appendChild(R),
          p.value.emitter.on("change", this.onValueChange_),
          (this.value_ = p.value),
          this.update_();
      }
      update_() {
        this.selectElement.value = String(this.value_.rawValue);
      }
      onValueChange_() {
        this.update_();
      }
    }
    class ro {
      constructor(l, p) {
        (this.onSelectChange_ = this.onSelectChange_.bind(this)),
          (this.props = p.props),
          (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.view = new xu(l, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps,
          })),
          this.view.selectElement.addEventListener(
            "change",
            this.onSelectChange_
          );
      }
      onSelectChange_(l) {
        const w = l.currentTarget.selectedOptions.item(0);
        if (!w) return;
        const R = Number(w.dataset.index);
        this.value.rawValue = this.props.get("options")[R].value;
      }
    }
    const wu = C("pop");
    class Td {
      constructor(l, p) {
        (this.element = l.createElement("div")),
          this.element.classList.add(wu()),
          p.viewProps.bindClassModifiers(this.element),
          F(p.shows, O(this.element, wu(void 0, "v")));
      }
    }
    class yu {
      constructor(l, p) {
        (this.shows = Q(!1)),
          (this.viewProps = p.viewProps),
          (this.view = new Td(l, {
            shows: this.shows,
            viewProps: this.viewProps,
          }));
      }
    }
    const Su = C("txt");
    class Ed {
      constructor(l, p) {
        (this.onChange_ = this.onChange_.bind(this)),
          (this.element = l.createElement("div")),
          this.element.classList.add(Su()),
          p.viewProps.bindClassModifiers(this.element),
          (this.props_ = p.props),
          this.props_.emitter.on("change", this.onChange_);
        const w = l.createElement("input");
        w.classList.add(Su("i")),
          (w.type = "text"),
          p.viewProps.bindDisabled(w),
          this.element.appendChild(w),
          (this.inputElement = w),
          p.value.emitter.on("change", this.onChange_),
          (this.value_ = p.value),
          this.refresh();
      }
      refresh() {
        const l = this.props_.get("formatter");
        this.inputElement.value = l(this.value_.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class ua {
      constructor(l, p) {
        (this.onInputChange_ = this.onInputChange_.bind(this)),
          (this.parser_ = p.parser),
          (this.props = p.props),
          (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.view = new Ed(l, {
            props: p.props,
            value: this.value,
            viewProps: this.viewProps,
          })),
          this.view.inputElement.addEventListener(
            "change",
            this.onInputChange_
          );
      }
      onInputChange_(l) {
        const w = l.currentTarget.value,
          R = this.parser_(w);
        c(R) || (this.value.rawValue = R), this.view.refresh();
      }
    }
    function Cd(g) {
      return String(g);
    }
    function Mu(g) {
      return g === "false" ? !1 : !!g;
    }
    function Tu(g) {
      return Cd(g);
    }
    class Dd {
      constructor(l) {
        this.text = l;
      }
      evaluate() {
        return Number(this.text);
      }
      toString() {
        return this.text;
      }
    }
    const Pd = {
      "**": (g, l) => Math.pow(g, l),
      "*": (g, l) => g * l,
      "/": (g, l) => g / l,
      "%": (g, l) => g % l,
      "+": (g, l) => g + l,
      "-": (g, l) => g - l,
      "<<": (g, l) => g << l,
      ">>": (g, l) => g >> l,
      ">>>": (g, l) => g >>> l,
      "&": (g, l) => g & l,
      "^": (g, l) => g ^ l,
      "|": (g, l) => g | l,
    };
    class Ad {
      constructor(l, p, w) {
        (this.left = p), (this.operator = l), (this.right = w);
      }
      evaluate() {
        const l = Pd[this.operator];
        if (!l)
          throw new Error(`unexpected binary operator: '${this.operator}`);
        return l(this.left.evaluate(), this.right.evaluate());
      }
      toString() {
        return [
          "b(",
          this.left.toString(),
          this.operator,
          this.right.toString(),
          ")",
        ].join(" ");
      }
    }
    const Eu = { "+": (g) => g, "-": (g) => -g, "~": (g) => ~g };
    class Ld {
      constructor(l, p) {
        (this.operator = l), (this.expression = p);
      }
      evaluate() {
        const l = Eu[this.operator];
        if (!l) throw new Error(`unexpected unary operator: '${this.operator}`);
        return l(this.expression.evaluate());
      }
      toString() {
        return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
      }
    }
    function Il(g) {
      return (l, p) => {
        for (let w = 0; w < g.length; w++) {
          const R = g[w](l, p);
          if (R !== "") return R;
        }
        return "";
      };
    }
    function Gs(g, l) {
      var p;
      const w = g.substr(l).match(/^\s+/);
      return (p = w && w[0]) !== null && p !== void 0 ? p : "";
    }
    function Rd(g, l) {
      const p = g.substr(l, 1);
      return p.match(/^[1-9]$/) ? p : "";
    }
    function oo(g, l) {
      var p;
      const w = g.substr(l).match(/^[0-9]+/);
      return (p = w && w[0]) !== null && p !== void 0 ? p : "";
    }
    function kd(g, l) {
      const p = oo(g, l);
      if (p !== "") return p;
      const w = g.substr(l, 1);
      if (((l += 1), w !== "-" && w !== "+")) return "";
      const R = oo(g, l);
      return R === "" ? "" : w + R;
    }
    function Wn(g, l) {
      const p = g.substr(l, 1);
      if (((l += 1), p.toLowerCase() !== "e")) return "";
      const w = kd(g, l);
      return w === "" ? "" : p + w;
    }
    function Cu(g, l) {
      const p = g.substr(l, 1);
      if (p === "0") return p;
      const w = Rd(g, l);
      return (l += w.length), w === "" ? "" : w + oo(g, l);
    }
    function Id(g, l) {
      const p = Cu(g, l);
      if (((l += p.length), p === "")) return "";
      const w = g.substr(l, 1);
      if (((l += w.length), w !== ".")) return "";
      const R = oo(g, l);
      return (l += R.length), p + w + R + Wn(g, l);
    }
    function Du(g, l) {
      const p = g.substr(l, 1);
      if (((l += p.length), p !== ".")) return "";
      const w = oo(g, l);
      return (l += w.length), w === "" ? "" : p + w + Wn(g, l);
    }
    function Fd(g, l) {
      const p = Cu(g, l);
      return (l += p.length), p === "" ? "" : p + Wn(g, l);
    }
    const Pu = Il([Id, Du, Fd]);
    function Fl(g, l) {
      var p;
      const w = g.substr(l).match(/^[01]+/);
      return (p = w && w[0]) !== null && p !== void 0 ? p : "";
    }
    function Od(g, l) {
      const p = g.substr(l, 2);
      if (((l += p.length), p.toLowerCase() !== "0b")) return "";
      const w = Fl(g, l);
      return w === "" ? "" : p + w;
    }
    function Au(g, l) {
      var p;
      const w = g.substr(l).match(/^[0-7]+/);
      return (p = w && w[0]) !== null && p !== void 0 ? p : "";
    }
    function dn(g, l) {
      const p = g.substr(l, 2);
      if (((l += p.length), p.toLowerCase() !== "0o")) return "";
      const w = Au(g, l);
      return w === "" ? "" : p + w;
    }
    function Nd(g, l) {
      var p;
      const w = g.substr(l).match(/^[0-9a-f]+/i);
      return (p = w && w[0]) !== null && p !== void 0 ? p : "";
    }
    function Bd(g, l) {
      const p = g.substr(l, 2);
      if (((l += p.length), p.toLowerCase() !== "0x")) return "";
      const w = Nd(g, l);
      return w === "" ? "" : p + w;
    }
    const Ol = Il([Od, dn, Bd]),
      Vd = Il([Ol, Pu]);
    function Ms(g, l) {
      const p = Vd(g, l);
      return (
        (l += p.length), p === "" ? null : { evaluable: new Dd(p), cursor: l }
      );
    }
    function Nl(g, l) {
      const p = g.substr(l, 1);
      if (((l += p.length), p !== "(")) return null;
      const w = ha(g, l);
      if (!w) return null;
      (l = w.cursor), (l += Gs(g, l).length);
      const R = g.substr(l, 1);
      return (
        (l += R.length),
        R !== ")" ? null : { evaluable: w.evaluable, cursor: l }
      );
    }
    function zd(g, l) {
      var p;
      return (p = Ms(g, l)) !== null && p !== void 0 ? p : Nl(g, l);
    }
    function Bl(g, l) {
      const p = zd(g, l);
      if (p) return p;
      const w = g.substr(l, 1);
      if (((l += w.length), w !== "+" && w !== "-" && w !== "~")) return null;
      const R = Bl(g, l);
      return R
        ? ((l = R.cursor), { cursor: l, evaluable: new Ld(w, R.evaluable) })
        : null;
    }
    function Ud(g, l, p) {
      p += Gs(l, p).length;
      const w = g.filter((R) => l.startsWith(R, p))[0];
      return w
        ? ((p += w.length), (p += Gs(l, p).length), { cursor: p, operator: w })
        : null;
    }
    function Hs(g, l) {
      return (p, w) => {
        const R = g(p, w);
        if (!R) return null;
        w = R.cursor;
        let W = R.evaluable;
        for (;;) {
          const ae = Ud(l, p, w);
          if (!ae) break;
          w = ae.cursor;
          const Ee = g(p, w);
          if (!Ee) return null;
          (w = Ee.cursor), (W = new Ad(ae.operator, W, Ee.evaluable));
        }
        return W ? { cursor: w, evaluable: W } : null;
      };
    }
    const Lu = [
      ["**"],
      ["*", "/", "%"],
      ["+", "-"],
      ["<<", ">>>", ">>"],
      ["&"],
      ["^"],
      ["|"],
    ].reduce((g, l) => Hs(g, l), Bl);
    function ha(g, l) {
      return (l += Gs(g, l).length), Lu(g, l);
    }
    function Ru(g) {
      const l = ha(g, 0);
      return !l || l.cursor + Gs(g, l.cursor).length !== g.length
        ? null
        : l.evaluable;
    }
    function jn(g) {
      var l;
      const p = Ru(g);
      return (l = p == null ? void 0 : p.evaluate()) !== null && l !== void 0
        ? l
        : null;
    }
    function us(g) {
      if (typeof g == "number") return g;
      if (typeof g == "string") {
        const l = jn(g);
        if (!c(l)) return l;
      }
      return 0;
    }
    function Gd(g) {
      return String(g);
    }
    function gi(g) {
      return (l) => l.toFixed(Math.max(Math.min(g, 20), 0));
    }
    const ku = gi(0);
    function ao(g) {
      return ku(g) + "%";
    }
    function Vl(g) {
      return String(g);
    }
    function Ts(g) {
      return g;
    }
    function Er({ primary: g, secondary: l, forward: p, backward: w }) {
      let R = !1;
      function W(ae) {
        R || ((R = !0), ae(), (R = !1));
      }
      g.emitter.on("change", (ae) => {
        W(() => {
          l.setRawValue(p(g, l), ae.options);
        });
      }),
        l.emitter.on("change", (ae) => {
          W(() => {
            g.setRawValue(w(g, l), ae.options);
          }),
            W(() => {
              l.setRawValue(p(g, l), ae.options);
            });
        }),
        W(() => {
          l.setRawValue(p(g, l), { forceEmit: !1, last: !0 });
        });
    }
    function Ei(g, l) {
      const p = g * (l.altKey ? 0.1 : 1) * (l.shiftKey ? 10 : 1);
      return l.upKey ? +p : l.downKey ? -p : 0;
    }
    function lo(g) {
      return {
        altKey: g.altKey,
        downKey: g.key === "ArrowDown",
        shiftKey: g.shiftKey,
        upKey: g.key === "ArrowUp",
      };
    }
    function qn(g) {
      return {
        altKey: g.altKey,
        downKey: g.key === "ArrowLeft",
        shiftKey: g.shiftKey,
        upKey: g.key === "ArrowRight",
      };
    }
    function Iu(g) {
      return g === "ArrowUp" || g === "ArrowDown";
    }
    function da(g) {
      return Iu(g) || g === "ArrowLeft" || g === "ArrowRight";
    }
    function zl(g, l) {
      var p, w;
      const R = l.ownerDocument.defaultView,
        W = l.getBoundingClientRect();
      return {
        x:
          g.pageX -
          (((p = R && R.scrollX) !== null && p !== void 0 ? p : 0) + W.left),
        y:
          g.pageY -
          (((w = R && R.scrollY) !== null && w !== void 0 ? w : 0) + W.top),
      };
    }
    class Ws {
      constructor(l) {
        (this.lastTouch_ = null),
          (this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this)),
          (this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this)),
          (this.onMouseDown_ = this.onMouseDown_.bind(this)),
          (this.onTouchEnd_ = this.onTouchEnd_.bind(this)),
          (this.onTouchMove_ = this.onTouchMove_.bind(this)),
          (this.onTouchStart_ = this.onTouchStart_.bind(this)),
          (this.elem_ = l),
          (this.emitter = new M()),
          l.addEventListener("touchstart", this.onTouchStart_, { passive: !1 }),
          l.addEventListener("touchmove", this.onTouchMove_, { passive: !0 }),
          l.addEventListener("touchend", this.onTouchEnd_),
          l.addEventListener("mousedown", this.onMouseDown_);
      }
      computePosition_(l) {
        const p = this.elem_.getBoundingClientRect();
        return {
          bounds: { width: p.width, height: p.height },
          point: l ? { x: l.x, y: l.y } : null,
        };
      }
      onMouseDown_(l) {
        var p;
        l.preventDefault(),
          (p = l.currentTarget) === null || p === void 0 || p.focus();
        const w = this.elem_.ownerDocument;
        w.addEventListener("mousemove", this.onDocumentMouseMove_),
          w.addEventListener("mouseup", this.onDocumentMouseUp_),
          this.emitter.emit("down", {
            altKey: l.altKey,
            data: this.computePosition_(zl(l, this.elem_)),
            sender: this,
            shiftKey: l.shiftKey,
          });
      }
      onDocumentMouseMove_(l) {
        this.emitter.emit("move", {
          altKey: l.altKey,
          data: this.computePosition_(zl(l, this.elem_)),
          sender: this,
          shiftKey: l.shiftKey,
        });
      }
      onDocumentMouseUp_(l) {
        const p = this.elem_.ownerDocument;
        p.removeEventListener("mousemove", this.onDocumentMouseMove_),
          p.removeEventListener("mouseup", this.onDocumentMouseUp_),
          this.emitter.emit("up", {
            altKey: l.altKey,
            data: this.computePosition_(zl(l, this.elem_)),
            sender: this,
            shiftKey: l.shiftKey,
          });
      }
      onTouchStart_(l) {
        l.preventDefault();
        const p = l.targetTouches.item(0),
          w = this.elem_.getBoundingClientRect();
        this.emitter.emit("down", {
          altKey: l.altKey,
          data: this.computePosition_(
            p ? { x: p.clientX - w.left, y: p.clientY - w.top } : void 0
          ),
          sender: this,
          shiftKey: l.shiftKey,
        }),
          (this.lastTouch_ = p);
      }
      onTouchMove_(l) {
        const p = l.targetTouches.item(0),
          w = this.elem_.getBoundingClientRect();
        this.emitter.emit("move", {
          altKey: l.altKey,
          data: this.computePosition_(
            p ? { x: p.clientX - w.left, y: p.clientY - w.top } : void 0
          ),
          sender: this,
          shiftKey: l.shiftKey,
        }),
          (this.lastTouch_ = p);
      }
      onTouchEnd_(l) {
        var p;
        const w =
            (p = l.targetTouches.item(0)) !== null && p !== void 0
              ? p
              : this.lastTouch_,
          R = this.elem_.getBoundingClientRect();
        this.emitter.emit("up", {
          altKey: l.altKey,
          data: this.computePosition_(
            w ? { x: w.clientX - R.left, y: w.clientY - R.top } : void 0
          ),
          sender: this,
          shiftKey: l.shiftKey,
        });
      }
    }
    function qt(g, l, p, w, R) {
      const W = (g - l) / (p - l);
      return w + W * (R - w);
    }
    function Ul(g) {
      return String(g.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
    }
    function ci(g, l, p) {
      return Math.min(Math.max(g, l), p);
    }
    function Cr(g, l) {
      return ((g % l) + l) % l;
    }
    const $i = C("txt");
    class Gl {
      constructor(l, p) {
        (this.onChange_ = this.onChange_.bind(this)),
          (this.props_ = p.props),
          this.props_.emitter.on("change", this.onChange_),
          (this.element = l.createElement("div")),
          this.element.classList.add($i(), $i(void 0, "num")),
          p.arrayPosition &&
            this.element.classList.add($i(void 0, p.arrayPosition)),
          p.viewProps.bindClassModifiers(this.element);
        const w = l.createElement("input");
        w.classList.add($i("i")),
          (w.type = "text"),
          p.viewProps.bindDisabled(w),
          this.element.appendChild(w),
          (this.inputElement = w),
          (this.onDraggingChange_ = this.onDraggingChange_.bind(this)),
          (this.dragging_ = p.dragging),
          this.dragging_.emitter.on("change", this.onDraggingChange_),
          this.element.classList.add($i()),
          this.inputElement.classList.add($i("i"));
        const R = l.createElement("div");
        R.classList.add($i("k")),
          this.element.appendChild(R),
          (this.knobElement = R);
        const W = l.createElementNS(dt, "svg");
        W.classList.add($i("g")), this.knobElement.appendChild(W);
        const ae = l.createElementNS(dt, "path");
        ae.classList.add($i("gb")),
          W.appendChild(ae),
          (this.guideBodyElem_ = ae);
        const Ee = l.createElementNS(dt, "path");
        Ee.classList.add($i("gh")),
          W.appendChild(Ee),
          (this.guideHeadElem_ = Ee);
        const et = l.createElement("div");
        et.classList.add(C("tt")()),
          this.knobElement.appendChild(et),
          (this.tooltipElem_ = et),
          p.value.emitter.on("change", this.onChange_),
          (this.value = p.value),
          this.refresh();
      }
      onDraggingChange_(l) {
        if (l.rawValue === null) {
          this.element.classList.remove($i(void 0, "drg"));
          return;
        }
        this.element.classList.add($i(void 0, "drg"));
        const p = l.rawValue / this.props_.get("draggingScale"),
          w = p + (p > 0 ? -1 : p < 0 ? 1 : 0),
          R = ci(-w, -4, 4);
        this.guideHeadElem_.setAttributeNS(
          null,
          "d",
          [`M ${w + R},0 L${w},4 L${w + R},8`, `M ${p},-1 L${p},9`].join(" ")
        ),
          this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${p},4`);
        const W = this.props_.get("formatter");
        (this.tooltipElem_.textContent = W(this.value.rawValue)),
          (this.tooltipElem_.style.left = `${p}px`);
      }
      refresh() {
        const l = this.props_.get("formatter");
        this.inputElement.value = l(this.value.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class co {
      constructor(l, p) {
        var w;
        (this.originRawValue_ = 0),
          (this.onInputChange_ = this.onInputChange_.bind(this)),
          (this.onInputKeyDown_ = this.onInputKeyDown_.bind(this)),
          (this.onInputKeyUp_ = this.onInputKeyUp_.bind(this)),
          (this.onPointerDown_ = this.onPointerDown_.bind(this)),
          (this.onPointerMove_ = this.onPointerMove_.bind(this)),
          (this.onPointerUp_ = this.onPointerUp_.bind(this)),
          (this.baseStep_ = p.baseStep),
          (this.parser_ = p.parser),
          (this.props = p.props),
          (this.sliderProps_ =
            (w = p.sliderProps) !== null && w !== void 0 ? w : null),
          (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.dragging_ = Q(null)),
          (this.view = new Gl(l, {
            arrayPosition: p.arrayPosition,
            dragging: this.dragging_,
            props: this.props,
            value: this.value,
            viewProps: this.viewProps,
          })),
          this.view.inputElement.addEventListener(
            "change",
            this.onInputChange_
          ),
          this.view.inputElement.addEventListener(
            "keydown",
            this.onInputKeyDown_
          ),
          this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
        const R = new Ws(this.view.knobElement);
        R.emitter.on("down", this.onPointerDown_),
          R.emitter.on("move", this.onPointerMove_),
          R.emitter.on("up", this.onPointerUp_);
      }
      constrainValue_(l) {
        var p, w;
        const R =
            (p = this.sliderProps_) === null || p === void 0
              ? void 0
              : p.get("minValue"),
          W =
            (w = this.sliderProps_) === null || w === void 0
              ? void 0
              : w.get("maxValue");
        let ae = l;
        return (
          R !== void 0 && (ae = Math.max(ae, R)),
          W !== void 0 && (ae = Math.min(ae, W)),
          ae
        );
      }
      onInputChange_(l) {
        const w = l.currentTarget.value,
          R = this.parser_(w);
        c(R) || (this.value.rawValue = this.constrainValue_(R)),
          this.view.refresh();
      }
      onInputKeyDown_(l) {
        const p = Ei(this.baseStep_, lo(l));
        p !== 0 &&
          this.value.setRawValue(
            this.constrainValue_(this.value.rawValue + p),
            { forceEmit: !1, last: !1 }
          );
      }
      onInputKeyUp_(l) {
        Ei(this.baseStep_, lo(l)) !== 0 &&
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0,
          });
      }
      onPointerDown_() {
        (this.originRawValue_ = this.value.rawValue),
          (this.dragging_.rawValue = 0);
      }
      computeDraggingValue_(l) {
        if (!l.point) return null;
        const p = l.point.x - l.bounds.width / 2;
        return this.constrainValue_(
          this.originRawValue_ + p * this.props.get("draggingScale")
        );
      }
      onPointerMove_(l) {
        const p = this.computeDraggingValue_(l.data);
        p !== null &&
          (this.value.setRawValue(p, { forceEmit: !1, last: !1 }),
          (this.dragging_.rawValue =
            this.value.rawValue - this.originRawValue_));
      }
      onPointerUp_(l) {
        const p = this.computeDraggingValue_(l.data);
        p !== null &&
          (this.value.setRawValue(p, { forceEmit: !0, last: !0 }),
          (this.dragging_.rawValue = null));
      }
    }
    const Hl = C("sld");
    class Yi {
      constructor(l, p) {
        (this.onChange_ = this.onChange_.bind(this)),
          (this.props_ = p.props),
          this.props_.emitter.on("change", this.onChange_),
          (this.element = l.createElement("div")),
          this.element.classList.add(Hl()),
          p.viewProps.bindClassModifiers(this.element);
        const w = l.createElement("div");
        w.classList.add(Hl("t")),
          p.viewProps.bindTabIndex(w),
          this.element.appendChild(w),
          (this.trackElement = w);
        const R = l.createElement("div");
        R.classList.add(Hl("k")),
          this.trackElement.appendChild(R),
          (this.knobElement = R),
          p.value.emitter.on("change", this.onChange_),
          (this.value = p.value),
          this.update_();
      }
      update_() {
        const l = ci(
          qt(
            this.value.rawValue,
            this.props_.get("minValue"),
            this.props_.get("maxValue"),
            0,
            100
          ),
          0,
          100
        );
        this.knobElement.style.width = `${l}%`;
      }
      onChange_() {
        this.update_();
      }
    }
    class Wl {
      constructor(l, p) {
        (this.onKeyDown_ = this.onKeyDown_.bind(this)),
          (this.onKeyUp_ = this.onKeyUp_.bind(this)),
          (this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this)),
          (this.onPointerUp_ = this.onPointerUp_.bind(this)),
          (this.baseStep_ = p.baseStep),
          (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.props = p.props),
          (this.view = new Yi(l, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps,
          })),
          (this.ptHandler_ = new Ws(this.view.trackElement)),
          this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_),
          this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_),
          this.ptHandler_.emitter.on("up", this.onPointerUp_),
          this.view.trackElement.addEventListener("keydown", this.onKeyDown_),
          this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(l, p) {
        l.point &&
          this.value.setRawValue(
            qt(
              ci(l.point.x, 0, l.bounds.width),
              0,
              l.bounds.width,
              this.props.get("minValue"),
              this.props.get("maxValue")
            ),
            p
          );
      }
      onPointerDownOrMove_(l) {
        this.handlePointerEvent_(l.data, { forceEmit: !1, last: !1 });
      }
      onPointerUp_(l) {
        this.handlePointerEvent_(l.data, { forceEmit: !0, last: !0 });
      }
      onKeyDown_(l) {
        const p = Ei(this.baseStep_, qn(l));
        p !== 0 &&
          this.value.setRawValue(this.value.rawValue + p, {
            forceEmit: !1,
            last: !1,
          });
      }
      onKeyUp_(l) {
        Ei(this.baseStep_, qn(l)) !== 0 &&
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0,
          });
      }
    }
    const uo = C("sldtxt");
    class jl {
      constructor(l, p) {
        (this.element = l.createElement("div")),
          this.element.classList.add(uo());
        const w = l.createElement("div");
        w.classList.add(uo("s")),
          (this.sliderView_ = p.sliderView),
          w.appendChild(this.sliderView_.element),
          this.element.appendChild(w);
        const R = l.createElement("div");
        R.classList.add(uo("t")),
          (this.textView_ = p.textView),
          R.appendChild(this.textView_.element),
          this.element.appendChild(R);
      }
    }
    class pa {
      constructor(l, p) {
        (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.sliderC_ = new Wl(l, {
            baseStep: p.baseStep,
            props: p.sliderProps,
            value: p.value,
            viewProps: this.viewProps,
          })),
          (this.textC_ = new co(l, {
            baseStep: p.baseStep,
            parser: p.parser,
            props: p.textProps,
            sliderProps: p.sliderProps,
            value: p.value,
            viewProps: p.viewProps,
          })),
          (this.view = new jl(l, {
            sliderView: this.sliderC_.view,
            textView: this.textC_.view,
          }));
      }
      get sliderController() {
        return this.sliderC_;
      }
      get textController() {
        return this.textC_;
      }
    }
    function Cn(g, l) {
      g.write(l);
    }
    function ho(g) {
      const l = le;
      if (Array.isArray(g))
        return l.required.array(
          l.required.object({ text: l.required.string, value: l.required.raw })
        )(g).value;
      if (typeof g == "object") return l.required.raw(g).value;
    }
    function ql(g) {
      if (g === "inline" || g === "popup") return g;
    }
    function hs(g) {
      const l = le;
      return l.required.object({
        max: l.optional.number,
        min: l.optional.number,
        step: l.optional.number,
      })(g).value;
    }
    function Fu(g) {
      if (Array.isArray(g)) return g;
      const l = [];
      return (
        Object.keys(g).forEach((p) => {
          l.push({ text: p, value: g[p] });
        }),
        l
      );
    }
    function Xl(g) {
      return c(g) ? null : new so(Fu(g));
    }
    function Hd(g) {
      const l = g ? En(g, ca) : null;
      return l ? l.step : null;
    }
    function fa(g, l) {
      const p = g && En(g, ca);
      return p ? Ul(p.step) : Math.max(Ul(l), 2);
    }
    function js(g) {
      const l = Hd(g);
      return l ?? 1;
    }
    function qs(g, l) {
      var p;
      const w = g && En(g, ca),
        R = Math.abs(
          (p = w == null ? void 0 : w.step) !== null && p !== void 0 ? p : l
        );
      return R === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(R)) - 1);
    }
    const po = C("ckb");
    class fo {
      constructor(l, p) {
        (this.onValueChange_ = this.onValueChange_.bind(this)),
          (this.element = l.createElement("div")),
          this.element.classList.add(po()),
          p.viewProps.bindClassModifiers(this.element);
        const w = l.createElement("label");
        w.classList.add(po("l")), this.element.appendChild(w);
        const R = l.createElement("input");
        R.classList.add(po("i")),
          (R.type = "checkbox"),
          w.appendChild(R),
          (this.inputElement = R),
          p.viewProps.bindDisabled(this.inputElement);
        const W = l.createElement("div");
        W.classList.add(po("w")), w.appendChild(W);
        const ae = pe(l, "check");
        W.appendChild(ae),
          p.value.emitter.on("change", this.onValueChange_),
          (this.value = p.value),
          this.update_();
      }
      update_() {
        this.inputElement.checked = this.value.rawValue;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class Ou {
      constructor(l, p) {
        (this.onInputChange_ = this.onInputChange_.bind(this)),
          (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.view = new fo(l, {
            value: this.value,
            viewProps: this.viewProps,
          })),
          this.view.inputElement.addEventListener(
            "change",
            this.onInputChange_
          );
      }
      onInputChange_(l) {
        const p = l.currentTarget;
        this.value.rawValue = p.checked;
      }
    }
    function Nu(g) {
      const l = [],
        p = Xl(g.options);
      return p && l.push(p), new no(l);
    }
    const ma = {
        id: "input-bool",
        type: "input",
        accept: (g, l) => {
          if (typeof g != "boolean") return null;
          const w = be(l, { options: le.optional.custom(ho) });
          return w ? { initialValue: g, params: w } : null;
        },
        binding: {
          reader: (g) => Mu,
          constraint: (g) => Nu(g.params),
          writer: (g) => Cn,
        },
        controller: (g) => {
          const l = g.document,
            p = g.value,
            w = g.constraint,
            R = w && En(w, so);
          return R
            ? new ro(l, {
                props: new V({ options: R.values.value("options") }),
                value: p,
                viewProps: g.viewProps,
              })
            : new Ou(l, { value: p, viewProps: g.viewProps });
        },
      },
      Xs = C("col");
    class $l {
      constructor(l, p) {
        (this.element = l.createElement("div")),
          this.element.classList.add(Xs()),
          p.foldable.bindExpandedClass(this.element, Xs(void 0, "expanded")),
          P(p.foldable, "completed", O(this.element, Xs(void 0, "cpl")));
        const w = l.createElement("div");
        w.classList.add(Xs("h")), this.element.appendChild(w);
        const R = l.createElement("div");
        R.classList.add(Xs("s")), w.appendChild(R), (this.swatchElement = R);
        const W = l.createElement("div");
        if (
          (W.classList.add(Xs("t")),
          w.appendChild(W),
          (this.textElement = W),
          p.pickerLayout === "inline")
        ) {
          const ae = l.createElement("div");
          ae.classList.add(Xs("p")),
            this.element.appendChild(ae),
            (this.pickerElement = ae);
        } else this.pickerElement = null;
      }
    }
    function Wd(g, l, p) {
      const w = ci(g / 255, 0, 1),
        R = ci(l / 255, 0, 1),
        W = ci(p / 255, 0, 1),
        ae = Math.max(w, R, W),
        Ee = Math.min(w, R, W),
        et = ae - Ee;
      let vt = 0,
        Vt = 0;
      const Gt = (Ee + ae) / 2;
      return (
        et !== 0 &&
          ((Vt = et / (1 - Math.abs(ae + Ee - 1))),
          w === ae
            ? (vt = (R - W) / et)
            : R === ae
            ? (vt = 2 + (W - w) / et)
            : (vt = 4 + (w - R) / et),
          (vt = vt / 6 + (vt < 0 ? 1 : 0))),
        [vt * 360, Vt * 100, Gt * 100]
      );
    }
    function jd(g, l, p) {
      const w = ((g % 360) + 360) % 360,
        R = ci(l / 100, 0, 1),
        W = ci(p / 100, 0, 1),
        ae = (1 - Math.abs(2 * W - 1)) * R,
        Ee = ae * (1 - Math.abs(((w / 60) % 2) - 1)),
        et = W - ae / 2;
      let vt, Vt, Gt;
      return (
        w >= 0 && w < 60
          ? ([vt, Vt, Gt] = [ae, Ee, 0])
          : w >= 60 && w < 120
          ? ([vt, Vt, Gt] = [Ee, ae, 0])
          : w >= 120 && w < 180
          ? ([vt, Vt, Gt] = [0, ae, Ee])
          : w >= 180 && w < 240
          ? ([vt, Vt, Gt] = [0, Ee, ae])
          : w >= 240 && w < 300
          ? ([vt, Vt, Gt] = [Ee, 0, ae])
          : ([vt, Vt, Gt] = [ae, 0, Ee]),
        [(vt + et) * 255, (Vt + et) * 255, (Gt + et) * 255]
      );
    }
    function qd(g, l, p) {
      const w = ci(g / 255, 0, 1),
        R = ci(l / 255, 0, 1),
        W = ci(p / 255, 0, 1),
        ae = Math.max(w, R, W),
        Ee = Math.min(w, R, W),
        et = ae - Ee;
      let vt;
      et === 0
        ? (vt = 0)
        : ae === w
        ? (vt = 60 * (((((R - W) / et) % 6) + 6) % 6))
        : ae === R
        ? (vt = 60 * ((W - w) / et + 2))
        : (vt = 60 * ((w - R) / et + 4));
      const Vt = ae === 0 ? 0 : et / ae,
        Gt = ae;
      return [vt, Vt * 100, Gt * 100];
    }
    function Bu(g, l, p) {
      const w = Cr(g, 360),
        R = ci(l / 100, 0, 1),
        W = ci(p / 100, 0, 1),
        ae = W * R,
        Ee = ae * (1 - Math.abs(((w / 60) % 2) - 1)),
        et = W - ae;
      let vt, Vt, Gt;
      return (
        w >= 0 && w < 60
          ? ([vt, Vt, Gt] = [ae, Ee, 0])
          : w >= 60 && w < 120
          ? ([vt, Vt, Gt] = [Ee, ae, 0])
          : w >= 120 && w < 180
          ? ([vt, Vt, Gt] = [0, ae, Ee])
          : w >= 180 && w < 240
          ? ([vt, Vt, Gt] = [0, Ee, ae])
          : w >= 240 && w < 300
          ? ([vt, Vt, Gt] = [Ee, 0, ae])
          : ([vt, Vt, Gt] = [ae, 0, Ee]),
        [(vt + et) * 255, (Vt + et) * 255, (Gt + et) * 255]
      );
    }
    function T(g, l, p) {
      const w = p + (l * (100 - Math.abs(2 * p - 100))) / 200;
      return [
        g,
        w !== 0 ? (l * (100 - Math.abs(2 * p - 100))) / w : 0,
        p + (l * (100 - Math.abs(2 * p - 100))) / (2 * 100),
      ];
    }
    function _(g, l, p) {
      const w = 100 - Math.abs((p * (200 - l)) / 100 - 100);
      return [g, w !== 0 ? (l * p) / w : 0, (p * (200 - l)) / (2 * 100)];
    }
    function S(g) {
      return [g[0], g[1], g[2]];
    }
    function L(g, l) {
      return [g[0], g[1], g[2], l];
    }
    const z = {
      hsl: { hsl: (g, l, p) => [g, l, p], hsv: T, rgb: jd },
      hsv: { hsl: _, hsv: (g, l, p) => [g, l, p], rgb: Bu },
      rgb: { hsl: Wd, hsv: qd, rgb: (g, l, p) => [g, l, p] },
    };
    function re(g, l) {
      return [
        l === "float" ? 1 : g === "rgb" ? 255 : 360,
        l === "float" ? 1 : g === "rgb" ? 255 : 100,
        l === "float" ? 1 : g === "rgb" ? 255 : 100,
      ];
    }
    function _e(g, l) {
      return g === l ? l : Cr(g, l);
    }
    function Le(g, l, p) {
      var w;
      const R = re(l, p);
      return [
        l === "rgb" ? ci(g[0], 0, R[0]) : _e(g[0], R[0]),
        ci(g[1], 0, R[1]),
        ci(g[2], 0, R[2]),
        ci((w = g[3]) !== null && w !== void 0 ? w : 1, 0, 1),
      ];
    }
    function It(g, l, p, w) {
      const R = re(l, p),
        W = re(l, w);
      return g.map((ae, Ee) => (ae / R[Ee]) * W[Ee]);
    }
    function pn(g, l, p) {
      const w = It(g, l.mode, l.type, "int"),
        R = z[l.mode][p.mode](...w);
      return It(R, p.mode, "int", p.type);
    }
    function fn(g, l) {
      return typeof g != "object" || c(g)
        ? !1
        : l in g && typeof g[l] == "number";
    }
    class Dt {
      static black(l = "int") {
        return new Dt([0, 0, 0], "rgb", l);
      }
      static fromObject(l, p = "int") {
        const w = "a" in l ? [l.r, l.g, l.b, l.a] : [l.r, l.g, l.b];
        return new Dt(w, "rgb", p);
      }
      static toRgbaObject(l, p = "int") {
        return l.toRgbaObject(p);
      }
      static isRgbColorObject(l) {
        return fn(l, "r") && fn(l, "g") && fn(l, "b");
      }
      static isRgbaColorObject(l) {
        return this.isRgbColorObject(l) && fn(l, "a");
      }
      static isColorObject(l) {
        return this.isRgbColorObject(l);
      }
      static equals(l, p) {
        if (l.mode !== p.mode) return !1;
        const w = l.comps_,
          R = p.comps_;
        for (let W = 0; W < w.length; W++) if (w[W] !== R[W]) return !1;
        return !0;
      }
      constructor(l, p, w = "int") {
        (this.mode = p), (this.type = w), (this.comps_ = Le(l, p, w));
      }
      getComponents(l, p = "int") {
        return L(
          pn(
            S(this.comps_),
            { mode: this.mode, type: this.type },
            { mode: l ?? this.mode, type: p }
          ),
          this.comps_[3]
        );
      }
      toRgbaObject(l = "int") {
        const p = this.getComponents("rgb", l);
        return { r: p[0], g: p[1], b: p[2], a: p[3] };
      }
    }
    const Es = C("colp");
    class Xd {
      constructor(l, p) {
        (this.alphaViews_ = null),
          (this.element = l.createElement("div")),
          this.element.classList.add(Es()),
          p.viewProps.bindClassModifiers(this.element);
        const w = l.createElement("div");
        w.classList.add(Es("hsv"));
        const R = l.createElement("div");
        R.classList.add(Es("sv")),
          (this.svPaletteView_ = p.svPaletteView),
          R.appendChild(this.svPaletteView_.element),
          w.appendChild(R);
        const W = l.createElement("div");
        W.classList.add(Es("h")),
          (this.hPaletteView_ = p.hPaletteView),
          W.appendChild(this.hPaletteView_.element),
          w.appendChild(W),
          this.element.appendChild(w);
        const ae = l.createElement("div");
        if (
          (ae.classList.add(Es("rgb")),
          (this.textView_ = p.textView),
          ae.appendChild(this.textView_.element),
          this.element.appendChild(ae),
          p.alphaViews)
        ) {
          this.alphaViews_ = {
            palette: p.alphaViews.palette,
            text: p.alphaViews.text,
          };
          const Ee = l.createElement("div");
          Ee.classList.add(Es("a"));
          const et = l.createElement("div");
          et.classList.add(Es("ap")),
            et.appendChild(this.alphaViews_.palette.element),
            Ee.appendChild(et);
          const vt = l.createElement("div");
          vt.classList.add(Es("at")),
            vt.appendChild(this.alphaViews_.text.element),
            Ee.appendChild(vt),
            this.element.appendChild(Ee);
        }
      }
      get allFocusableElements() {
        const l = [
          this.svPaletteView_.element,
          this.hPaletteView_.element,
          this.textView_.modeSelectElement,
          ...this.textView_.textViews.map((p) => p.inputElement),
        ];
        return (
          this.alphaViews_ &&
            l.push(
              this.alphaViews_.palette.element,
              this.alphaViews_.text.inputElement
            ),
          l
        );
      }
    }
    function Hw(g) {
      return g === "int" ? "int" : g === "float" ? "float" : void 0;
    }
    function $d(g) {
      const l = le;
      return be(g, {
        alpha: l.optional.boolean,
        color: l.optional.object({
          alpha: l.optional.boolean,
          type: l.optional.custom(Hw),
        }),
        expanded: l.optional.boolean,
        picker: l.optional.custom(ql),
      });
    }
    function mo(g) {
      return g ? 0.1 : 1;
    }
    function go(g) {
      var l;
      return (l = g.color) === null || l === void 0 ? void 0 : l.type;
    }
    function Ww(g, l) {
      return (
        g.alpha === l.alpha &&
        g.mode === l.mode &&
        g.notation === l.notation &&
        g.type === l.type
      );
    }
    function Xn(g, l) {
      const p = g.match(/^(.+)%$/);
      return Math.min(p ? parseFloat(p[1]) * 0.01 * l : parseFloat(g), l);
    }
    const jw = {
      deg: (g) => g,
      grad: (g) => (g * 360) / 400,
      rad: (g) => (g * 360) / (2 * Math.PI),
      turn: (g) => g * 360,
    };
    function _g(g) {
      const l = g.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
      if (!l) return parseFloat(g);
      const p = parseFloat(l[1]),
        w = l[2];
      return jw[w](p);
    }
    function bg(g) {
      const l = g.match(
        /^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
      );
      if (!l) return null;
      const p = [Xn(l[1], 255), Xn(l[2], 255), Xn(l[3], 255)];
      return isNaN(p[0]) || isNaN(p[1]) || isNaN(p[2]) ? null : p;
    }
    function xg(g) {
      return (l) => {
        const p = bg(l);
        return p ? new Dt(p, "rgb", g) : null;
      };
    }
    function wg(g) {
      const l = g.match(
        /^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
      );
      if (!l) return null;
      const p = [Xn(l[1], 255), Xn(l[2], 255), Xn(l[3], 255), Xn(l[4], 1)];
      return isNaN(p[0]) || isNaN(p[1]) || isNaN(p[2]) || isNaN(p[3])
        ? null
        : p;
    }
    function yg(g) {
      return (l) => {
        const p = wg(l);
        return p ? new Dt(p, "rgb", g) : null;
      };
    }
    function Sg(g) {
      const l = g.match(
        /^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
      );
      if (!l) return null;
      const p = [_g(l[1]), Xn(l[2], 100), Xn(l[3], 100)];
      return isNaN(p[0]) || isNaN(p[1]) || isNaN(p[2]) ? null : p;
    }
    function Mg(g) {
      return (l) => {
        const p = Sg(l);
        return p ? new Dt(p, "hsl", g) : null;
      };
    }
    function Tg(g) {
      const l = g.match(
        /^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
      );
      if (!l) return null;
      const p = [_g(l[1]), Xn(l[2], 100), Xn(l[3], 100), Xn(l[4], 1)];
      return isNaN(p[0]) || isNaN(p[1]) || isNaN(p[2]) || isNaN(p[3])
        ? null
        : p;
    }
    function Eg(g) {
      return (l) => {
        const p = Tg(l);
        return p ? new Dt(p, "hsl", g) : null;
      };
    }
    function Cg(g) {
      const l = g.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
      if (l)
        return [
          parseInt(l[1] + l[1], 16),
          parseInt(l[2] + l[2], 16),
          parseInt(l[3] + l[3], 16),
        ];
      const p = g.match(
        /^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/
      );
      return p
        ? [parseInt(p[1], 16), parseInt(p[2], 16), parseInt(p[3], 16)]
        : null;
    }
    function qw(g) {
      const l = Cg(g);
      return l ? new Dt(l, "rgb", "int") : null;
    }
    function Dg(g) {
      const l = g.match(
        /^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/
      );
      if (l)
        return [
          parseInt(l[1] + l[1], 16),
          parseInt(l[2] + l[2], 16),
          parseInt(l[3] + l[3], 16),
          qt(parseInt(l[4] + l[4], 16), 0, 255, 0, 1),
        ];
      const p = g.match(
        /^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/
      );
      return p
        ? [
            parseInt(p[1], 16),
            parseInt(p[2], 16),
            parseInt(p[3], 16),
            qt(parseInt(p[4], 16), 0, 255, 0, 1),
          ]
        : null;
    }
    function Xw(g) {
      const l = Dg(g);
      return l ? new Dt(l, "rgb", "int") : null;
    }
    function Pg(g) {
      const l = g.match(
        /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/
      );
      if (!l) return null;
      const p = [parseFloat(l[1]), parseFloat(l[2]), parseFloat(l[3])];
      return isNaN(p[0]) || isNaN(p[1]) || isNaN(p[2]) ? null : p;
    }
    function Ag(g) {
      return (l) => {
        const p = Pg(l);
        return p ? new Dt(p, "rgb", g) : null;
      };
    }
    function Lg(g) {
      const l = g.match(
        /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/
      );
      if (!l) return null;
      const p = [
        parseFloat(l[1]),
        parseFloat(l[2]),
        parseFloat(l[3]),
        parseFloat(l[4]),
      ];
      return isNaN(p[0]) || isNaN(p[1]) || isNaN(p[2]) || isNaN(p[3])
        ? null
        : p;
    }
    function Rg(g) {
      return (l) => {
        const p = Lg(l);
        return p ? new Dt(p, "rgb", g) : null;
      };
    }
    const $w = [
      { parser: Cg, result: { alpha: !1, mode: "rgb", notation: "hex" } },
      { parser: Dg, result: { alpha: !0, mode: "rgb", notation: "hex" } },
      { parser: bg, result: { alpha: !1, mode: "rgb", notation: "func" } },
      { parser: wg, result: { alpha: !0, mode: "rgb", notation: "func" } },
      { parser: Sg, result: { alpha: !1, mode: "hsl", notation: "func" } },
      { parser: Tg, result: { alpha: !0, mode: "hsl", notation: "func" } },
      { parser: Pg, result: { alpha: !1, mode: "rgb", notation: "object" } },
      { parser: Lg, result: { alpha: !0, mode: "rgb", notation: "object" } },
    ];
    function Yw(g) {
      return $w.reduce(
        (l, { parser: p, result: w }) => l || (p(g) ? w : null),
        null
      );
    }
    function Yd(g, l = "int") {
      const p = Yw(g);
      return p
        ? p.notation === "hex" && l !== "float"
          ? Object.assign(Object.assign({}, p), { type: "int" })
          : p.notation === "func"
          ? Object.assign(Object.assign({}, p), { type: l })
          : null
        : null;
    }
    const kg = {
      int: [
        qw,
        Xw,
        xg("int"),
        yg("int"),
        Mg("int"),
        Eg("int"),
        Ag("int"),
        Rg("int"),
      ],
      float: [
        xg("float"),
        yg("float"),
        Mg("float"),
        Eg("float"),
        Ag("float"),
        Rg("float"),
      ],
    };
    function Kw(g) {
      const l = kg[g];
      return (p) => {
        if (typeof p != "string") return Dt.black(g);
        const w = l.reduce((R, W) => R || W(p), null);
        return w ?? Dt.black(g);
      };
    }
    function Kd(g) {
      const l = kg[g];
      return (p) => l.reduce((w, R) => w || R(p), null);
    }
    function Ig(g) {
      const l = ci(Math.floor(g), 0, 255).toString(16);
      return l.length === 1 ? `0${l}` : l;
    }
    function Fg(g, l = "#") {
      const p = S(g.getComponents("rgb")).map(Ig).join("");
      return `${l}${p}`;
    }
    function Zd(g, l = "#") {
      const p = g.getComponents("rgb"),
        w = [p[0], p[1], p[2], p[3] * 255].map(Ig).join("");
      return `${l}${w}`;
    }
    function Og(g, l) {
      const p = gi(l === "float" ? 2 : 0);
      return `rgb(${S(g.getComponents("rgb", l))
        .map((R) => p(R))
        .join(", ")})`;
    }
    function Zw(g) {
      return (l) => Og(l, g);
    }
    function Vu(g, l) {
      const p = gi(2),
        w = gi(l === "float" ? 2 : 0);
      return `rgba(${g
        .getComponents("rgb", l)
        .map((W, ae) => (ae === 3 ? p : w)(W))
        .join(", ")})`;
    }
    function Jw(g) {
      return (l) => Vu(l, g);
    }
    function Qw(g) {
      const l = [gi(0), ao, ao];
      return `hsl(${S(g.getComponents("hsl"))
        .map((w, R) => l[R](w))
        .join(", ")})`;
    }
    function ey(g) {
      const l = [gi(0), ao, ao, gi(2)];
      return `hsla(${g
        .getComponents("hsl")
        .map((w, R) => l[R](w))
        .join(", ")})`;
    }
    function Ng(g, l) {
      const p = gi(l === "float" ? 2 : 0),
        w = ["r", "g", "b"];
      return `{${S(g.getComponents("rgb", l))
        .map((W, ae) => `${w[ae]}: ${p(W)}`)
        .join(", ")}}`;
    }
    function ty(g) {
      return (l) => Ng(l, g);
    }
    function Bg(g, l) {
      const p = gi(2),
        w = gi(l === "float" ? 2 : 0),
        R = ["r", "g", "b", "a"];
      return `{${g
        .getComponents("rgb", l)
        .map((ae, Ee) => {
          const et = Ee === 3 ? p : w;
          return `${R[Ee]}: ${et(ae)}`;
        })
        .join(", ")}}`;
    }
    function iy(g) {
      return (l) => Bg(l, g);
    }
    const ny = [
      {
        format: { alpha: !1, mode: "rgb", notation: "hex", type: "int" },
        stringifier: Fg,
      },
      {
        format: { alpha: !0, mode: "rgb", notation: "hex", type: "int" },
        stringifier: Zd,
      },
      {
        format: { alpha: !1, mode: "hsl", notation: "func", type: "int" },
        stringifier: Qw,
      },
      {
        format: { alpha: !0, mode: "hsl", notation: "func", type: "int" },
        stringifier: ey,
      },
      ...["int", "float"].reduce(
        (g, l) => [
          ...g,
          {
            format: { alpha: !1, mode: "rgb", notation: "func", type: l },
            stringifier: Zw(l),
          },
          {
            format: { alpha: !0, mode: "rgb", notation: "func", type: l },
            stringifier: Jw(l),
          },
          {
            format: { alpha: !1, mode: "rgb", notation: "object", type: l },
            stringifier: ty(l),
          },
          {
            format: { alpha: !0, mode: "rgb", notation: "object", type: l },
            stringifier: iy(l),
          },
        ],
        []
      ),
    ];
    function Jd(g) {
      return ny.reduce(
        (l, p) => l || (Ww(p.format, g) ? p.stringifier : null),
        null
      );
    }
    const Yl = C("apl");
    class sy {
      constructor(l, p) {
        (this.onValueChange_ = this.onValueChange_.bind(this)),
          (this.value = p.value),
          this.value.emitter.on("change", this.onValueChange_),
          (this.element = l.createElement("div")),
          this.element.classList.add(Yl()),
          p.viewProps.bindClassModifiers(this.element),
          p.viewProps.bindTabIndex(this.element);
        const w = l.createElement("div");
        w.classList.add(Yl("b")), this.element.appendChild(w);
        const R = l.createElement("div");
        R.classList.add(Yl("c")), w.appendChild(R), (this.colorElem_ = R);
        const W = l.createElement("div");
        W.classList.add(Yl("m")),
          this.element.appendChild(W),
          (this.markerElem_ = W);
        const ae = l.createElement("div");
        ae.classList.add(Yl("p")),
          this.markerElem_.appendChild(ae),
          (this.previewElem_ = ae),
          this.update_();
      }
      update_() {
        const l = this.value.rawValue,
          p = l.getComponents("rgb"),
          w = new Dt([p[0], p[1], p[2], 0], "rgb"),
          R = new Dt([p[0], p[1], p[2], 255], "rgb"),
          W = ["to right", Vu(w), Vu(R)];
        (this.colorElem_.style.background = `linear-gradient(${W.join(",")})`),
          (this.previewElem_.style.backgroundColor = Vu(l));
        const ae = qt(p[3], 0, 1, 0, 100);
        this.markerElem_.style.left = `${ae}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class ry {
      constructor(l, p) {
        (this.onKeyDown_ = this.onKeyDown_.bind(this)),
          (this.onKeyUp_ = this.onKeyUp_.bind(this)),
          (this.onPointerDown_ = this.onPointerDown_.bind(this)),
          (this.onPointerMove_ = this.onPointerMove_.bind(this)),
          (this.onPointerUp_ = this.onPointerUp_.bind(this)),
          (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.view = new sy(l, {
            value: this.value,
            viewProps: this.viewProps,
          })),
          (this.ptHandler_ = new Ws(this.view.element)),
          this.ptHandler_.emitter.on("down", this.onPointerDown_),
          this.ptHandler_.emitter.on("move", this.onPointerMove_),
          this.ptHandler_.emitter.on("up", this.onPointerUp_),
          this.view.element.addEventListener("keydown", this.onKeyDown_),
          this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(l, p) {
        if (!l.point) return;
        const w = l.point.x / l.bounds.width,
          R = this.value.rawValue,
          [W, ae, Ee] = R.getComponents("hsv");
        this.value.setRawValue(new Dt([W, ae, Ee, w], "hsv"), p);
      }
      onPointerDown_(l) {
        this.handlePointerEvent_(l.data, { forceEmit: !1, last: !1 });
      }
      onPointerMove_(l) {
        this.handlePointerEvent_(l.data, { forceEmit: !1, last: !1 });
      }
      onPointerUp_(l) {
        this.handlePointerEvent_(l.data, { forceEmit: !0, last: !0 });
      }
      onKeyDown_(l) {
        const p = Ei(mo(!0), qn(l));
        if (p === 0) return;
        const w = this.value.rawValue,
          [R, W, ae, Ee] = w.getComponents("hsv");
        this.value.setRawValue(new Dt([R, W, ae, Ee + p], "hsv"), {
          forceEmit: !1,
          last: !1,
        });
      }
      onKeyUp_(l) {
        Ei(mo(!0), qn(l)) !== 0 &&
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0,
          });
      }
    }
    const ga = C("coltxt");
    function oy(g) {
      const l = g.createElement("select"),
        p = [
          { text: "RGB", value: "rgb" },
          { text: "HSL", value: "hsl" },
          { text: "HSV", value: "hsv" },
        ];
      return (
        l.appendChild(
          p.reduce((w, R) => {
            const W = g.createElement("option");
            return (
              (W.textContent = R.text), (W.value = R.value), w.appendChild(W), w
            );
          }, g.createDocumentFragment())
        ),
        l
      );
    }
    class ay {
      constructor(l, p) {
        (this.element = l.createElement("div")),
          this.element.classList.add(ga()),
          p.viewProps.bindClassModifiers(this.element);
        const w = l.createElement("div");
        w.classList.add(ga("m")),
          (this.modeElem_ = oy(l)),
          this.modeElem_.classList.add(ga("ms")),
          w.appendChild(this.modeSelectElement),
          p.viewProps.bindDisabled(this.modeElem_);
        const R = l.createElement("div");
        R.classList.add(ga("mm")),
          R.appendChild(pe(l, "dropdown")),
          w.appendChild(R),
          this.element.appendChild(w);
        const W = l.createElement("div");
        W.classList.add(ga("w")),
          this.element.appendChild(W),
          (this.textsElem_ = W),
          (this.textViews_ = p.textViews),
          this.applyTextViews_(),
          F(p.colorMode, (ae) => {
            this.modeElem_.value = ae;
          });
      }
      get modeSelectElement() {
        return this.modeElem_;
      }
      get textViews() {
        return this.textViews_;
      }
      set textViews(l) {
        (this.textViews_ = l), this.applyTextViews_();
      }
      applyTextViews_() {
        Ce(this.textsElem_);
        const l = this.element.ownerDocument;
        this.textViews_.forEach((p) => {
          const w = l.createElement("div");
          w.classList.add(ga("c")),
            w.appendChild(p.element),
            this.textsElem_.appendChild(w);
        });
      }
    }
    function ly(g) {
      return gi(g === "float" ? 2 : 0);
    }
    function cy(g, l, p) {
      const w = re(g, l)[p];
      return new Mr({ min: 0, max: w });
    }
    function Qd(g, l, p) {
      return new co(g, {
        arrayPosition: p === 0 ? "fst" : p === 3 - 1 ? "lst" : "mid",
        baseStep: mo(!1),
        parser: l.parser,
        props: V.fromObject({
          draggingScale: l.colorType === "float" ? 0.01 : 1,
          formatter: ly(l.colorType),
        }),
        value: Q(0, { constraint: cy(l.colorMode, l.colorType, p) }),
        viewProps: l.viewProps,
      });
    }
    class uy {
      constructor(l, p) {
        (this.onModeSelectChange_ = this.onModeSelectChange_.bind(this)),
          (this.colorType_ = p.colorType),
          (this.parser_ = p.parser),
          (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.colorMode = Q(this.value.rawValue.mode)),
          (this.ccs_ = this.createComponentControllers_(l)),
          (this.view = new ay(l, {
            colorMode: this.colorMode,
            textViews: [
              this.ccs_[0].view,
              this.ccs_[1].view,
              this.ccs_[2].view,
            ],
            viewProps: this.viewProps,
          })),
          this.view.modeSelectElement.addEventListener(
            "change",
            this.onModeSelectChange_
          );
      }
      createComponentControllers_(l) {
        const p = {
            colorMode: this.colorMode.rawValue,
            colorType: this.colorType_,
            parser: this.parser_,
            viewProps: this.viewProps,
          },
          w = [Qd(l, p, 0), Qd(l, p, 1), Qd(l, p, 2)];
        return (
          w.forEach((R, W) => {
            Er({
              primary: this.value,
              secondary: R.value,
              forward: (ae) =>
                ae.rawValue.getComponents(
                  this.colorMode.rawValue,
                  this.colorType_
                )[W],
              backward: (ae, Ee) => {
                const et = this.colorMode.rawValue,
                  vt = ae.rawValue.getComponents(et, this.colorType_);
                return (
                  (vt[W] = Ee.rawValue),
                  new Dt(L(S(vt), vt[3]), et, this.colorType_)
                );
              },
            });
          }),
          w
        );
      }
      onModeSelectChange_(l) {
        const p = l.currentTarget;
        (this.colorMode.rawValue = p.value),
          (this.ccs_ = this.createComponentControllers_(
            this.view.element.ownerDocument
          )),
          (this.view.textViews = [
            this.ccs_[0].view,
            this.ccs_[1].view,
            this.ccs_[2].view,
          ]);
      }
    }
    const ep = C("hpl");
    class hy {
      constructor(l, p) {
        (this.onValueChange_ = this.onValueChange_.bind(this)),
          (this.value = p.value),
          this.value.emitter.on("change", this.onValueChange_),
          (this.element = l.createElement("div")),
          this.element.classList.add(ep()),
          p.viewProps.bindClassModifiers(this.element),
          p.viewProps.bindTabIndex(this.element);
        const w = l.createElement("div");
        w.classList.add(ep("c")), this.element.appendChild(w);
        const R = l.createElement("div");
        R.classList.add(ep("m")),
          this.element.appendChild(R),
          (this.markerElem_ = R),
          this.update_();
      }
      update_() {
        const l = this.value.rawValue,
          [p] = l.getComponents("hsv");
        this.markerElem_.style.backgroundColor = Og(
          new Dt([p, 100, 100], "hsv")
        );
        const w = qt(p, 0, 360, 0, 100);
        this.markerElem_.style.left = `${w}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class dy {
      constructor(l, p) {
        (this.onKeyDown_ = this.onKeyDown_.bind(this)),
          (this.onKeyUp_ = this.onKeyUp_.bind(this)),
          (this.onPointerDown_ = this.onPointerDown_.bind(this)),
          (this.onPointerMove_ = this.onPointerMove_.bind(this)),
          (this.onPointerUp_ = this.onPointerUp_.bind(this)),
          (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.view = new hy(l, {
            value: this.value,
            viewProps: this.viewProps,
          })),
          (this.ptHandler_ = new Ws(this.view.element)),
          this.ptHandler_.emitter.on("down", this.onPointerDown_),
          this.ptHandler_.emitter.on("move", this.onPointerMove_),
          this.ptHandler_.emitter.on("up", this.onPointerUp_),
          this.view.element.addEventListener("keydown", this.onKeyDown_),
          this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(l, p) {
        if (!l.point) return;
        const w = qt(
            ci(l.point.x, 0, l.bounds.width),
            0,
            l.bounds.width,
            0,
            360
          ),
          R = this.value.rawValue,
          [, W, ae, Ee] = R.getComponents("hsv");
        this.value.setRawValue(new Dt([w, W, ae, Ee], "hsv"), p);
      }
      onPointerDown_(l) {
        this.handlePointerEvent_(l.data, { forceEmit: !1, last: !1 });
      }
      onPointerMove_(l) {
        this.handlePointerEvent_(l.data, { forceEmit: !1, last: !1 });
      }
      onPointerUp_(l) {
        this.handlePointerEvent_(l.data, { forceEmit: !0, last: !0 });
      }
      onKeyDown_(l) {
        const p = Ei(mo(!1), qn(l));
        if (p === 0) return;
        const w = this.value.rawValue,
          [R, W, ae, Ee] = w.getComponents("hsv");
        this.value.setRawValue(new Dt([R + p, W, ae, Ee], "hsv"), {
          forceEmit: !1,
          last: !1,
        });
      }
      onKeyUp_(l) {
        Ei(mo(!1), qn(l)) !== 0 &&
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0,
          });
      }
    }
    const tp = C("svp"),
      Vg = 64;
    class py {
      constructor(l, p) {
        (this.onValueChange_ = this.onValueChange_.bind(this)),
          (this.value = p.value),
          this.value.emitter.on("change", this.onValueChange_),
          (this.element = l.createElement("div")),
          this.element.classList.add(tp()),
          p.viewProps.bindClassModifiers(this.element),
          p.viewProps.bindTabIndex(this.element);
        const w = l.createElement("canvas");
        (w.height = Vg),
          (w.width = Vg),
          w.classList.add(tp("c")),
          this.element.appendChild(w),
          (this.canvasElement = w);
        const R = l.createElement("div");
        R.classList.add(tp("m")),
          this.element.appendChild(R),
          (this.markerElem_ = R),
          this.update_();
      }
      update_() {
        const l = G(this.canvasElement);
        if (!l) return;
        const w = this.value.rawValue.getComponents("hsv"),
          R = this.canvasElement.width,
          W = this.canvasElement.height,
          ae = l.getImageData(0, 0, R, W),
          Ee = ae.data;
        for (let Vt = 0; Vt < W; Vt++)
          for (let Gt = 0; Gt < R; Gt++) {
            const Ys = qt(Gt, 0, R, 0, 100),
              Zl = qt(Vt, 0, W, 100, 0),
              Jl = Bu(w[0], Ys, Zl),
              xa = (Vt * R + Gt) * 4;
            (Ee[xa] = Jl[0]),
              (Ee[xa + 1] = Jl[1]),
              (Ee[xa + 2] = Jl[2]),
              (Ee[xa + 3] = 255);
          }
        l.putImageData(ae, 0, 0);
        const et = qt(w[1], 0, 100, 0, 100);
        this.markerElem_.style.left = `${et}%`;
        const vt = qt(w[2], 0, 100, 100, 0);
        this.markerElem_.style.top = `${vt}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class fy {
      constructor(l, p) {
        (this.onKeyDown_ = this.onKeyDown_.bind(this)),
          (this.onKeyUp_ = this.onKeyUp_.bind(this)),
          (this.onPointerDown_ = this.onPointerDown_.bind(this)),
          (this.onPointerMove_ = this.onPointerMove_.bind(this)),
          (this.onPointerUp_ = this.onPointerUp_.bind(this)),
          (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.view = new py(l, {
            value: this.value,
            viewProps: this.viewProps,
          })),
          (this.ptHandler_ = new Ws(this.view.element)),
          this.ptHandler_.emitter.on("down", this.onPointerDown_),
          this.ptHandler_.emitter.on("move", this.onPointerMove_),
          this.ptHandler_.emitter.on("up", this.onPointerUp_),
          this.view.element.addEventListener("keydown", this.onKeyDown_),
          this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(l, p) {
        if (!l.point) return;
        const w = qt(l.point.x, 0, l.bounds.width, 0, 100),
          R = qt(l.point.y, 0, l.bounds.height, 100, 0),
          [W, , , ae] = this.value.rawValue.getComponents("hsv");
        this.value.setRawValue(new Dt([W, w, R, ae], "hsv"), p);
      }
      onPointerDown_(l) {
        this.handlePointerEvent_(l.data, { forceEmit: !1, last: !1 });
      }
      onPointerMove_(l) {
        this.handlePointerEvent_(l.data, { forceEmit: !1, last: !1 });
      }
      onPointerUp_(l) {
        this.handlePointerEvent_(l.data, { forceEmit: !0, last: !0 });
      }
      onKeyDown_(l) {
        da(l.key) && l.preventDefault();
        const [p, w, R, W] = this.value.rawValue.getComponents("hsv"),
          ae = mo(!1),
          Ee = Ei(ae, qn(l)),
          et = Ei(ae, lo(l));
        (Ee === 0 && et === 0) ||
          this.value.setRawValue(new Dt([p, w + Ee, R + et, W], "hsv"), {
            forceEmit: !1,
            last: !1,
          });
      }
      onKeyUp_(l) {
        const p = mo(!1),
          w = Ei(p, qn(l)),
          R = Ei(p, lo(l));
        (w === 0 && R === 0) ||
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0,
          });
      }
    }
    class my {
      constructor(l, p) {
        (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.hPaletteC_ = new dy(l, {
            value: this.value,
            viewProps: this.viewProps,
          })),
          (this.svPaletteC_ = new fy(l, {
            value: this.value,
            viewProps: this.viewProps,
          })),
          (this.alphaIcs_ = p.supportsAlpha
            ? {
                palette: new ry(l, {
                  value: this.value,
                  viewProps: this.viewProps,
                }),
                text: new co(l, {
                  parser: jn,
                  baseStep: 0.1,
                  props: V.fromObject({
                    draggingScale: 0.01,
                    formatter: gi(2),
                  }),
                  value: Q(0, { constraint: new Mr({ min: 0, max: 1 }) }),
                  viewProps: this.viewProps,
                }),
              }
            : null),
          this.alphaIcs_ &&
            Er({
              primary: this.value,
              secondary: this.alphaIcs_.text.value,
              forward: (w) => w.rawValue.getComponents()[3],
              backward: (w, R) => {
                const W = w.rawValue.getComponents();
                return (W[3] = R.rawValue), new Dt(W, w.rawValue.mode);
              },
            }),
          (this.textC_ = new uy(l, {
            colorType: p.colorType,
            parser: jn,
            value: this.value,
            viewProps: this.viewProps,
          })),
          (this.view = new Xd(l, {
            alphaViews: this.alphaIcs_
              ? {
                  palette: this.alphaIcs_.palette.view,
                  text: this.alphaIcs_.text.view,
                }
              : null,
            hPaletteView: this.hPaletteC_.view,
            supportsAlpha: p.supportsAlpha,
            svPaletteView: this.svPaletteC_.view,
            textView: this.textC_.view,
            viewProps: this.viewProps,
          }));
      }
      get textController() {
        return this.textC_;
      }
    }
    const ip = C("colsw");
    class gy {
      constructor(l, p) {
        (this.onValueChange_ = this.onValueChange_.bind(this)),
          p.value.emitter.on("change", this.onValueChange_),
          (this.value = p.value),
          (this.element = l.createElement("div")),
          this.element.classList.add(ip()),
          p.viewProps.bindClassModifiers(this.element);
        const w = l.createElement("div");
        w.classList.add(ip("sw")),
          this.element.appendChild(w),
          (this.swatchElem_ = w);
        const R = l.createElement("button");
        R.classList.add(ip("b")),
          p.viewProps.bindDisabled(R),
          this.element.appendChild(R),
          (this.buttonElement = R),
          this.update_();
      }
      update_() {
        const l = this.value.rawValue;
        this.swatchElem_.style.backgroundColor = Zd(l);
      }
      onValueChange_() {
        this.update_();
      }
    }
    class vy {
      constructor(l, p) {
        (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.view = new gy(l, {
            value: this.value,
            viewProps: this.viewProps,
          }));
      }
    }
    class np {
      constructor(l, p) {
        (this.onButtonBlur_ = this.onButtonBlur_.bind(this)),
          (this.onButtonClick_ = this.onButtonClick_.bind(this)),
          (this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this)),
          (this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this)),
          (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.foldable_ = lt.create(p.expanded)),
          (this.swatchC_ = new vy(l, {
            value: this.value,
            viewProps: this.viewProps,
          }));
        const w = this.swatchC_.view.buttonElement;
        w.addEventListener("blur", this.onButtonBlur_),
          w.addEventListener("click", this.onButtonClick_),
          (this.textC_ = new ua(l, {
            parser: p.parser,
            props: V.fromObject({ formatter: p.formatter }),
            value: this.value,
            viewProps: this.viewProps,
          })),
          (this.view = new $l(l, {
            foldable: this.foldable_,
            pickerLayout: p.pickerLayout,
          })),
          this.view.swatchElement.appendChild(this.swatchC_.view.element),
          this.view.textElement.appendChild(this.textC_.view.element),
          (this.popC_ =
            p.pickerLayout === "popup"
              ? new yu(l, { viewProps: this.viewProps })
              : null);
        const R = new my(l, {
          colorType: p.colorType,
          supportsAlpha: p.supportsAlpha,
          value: this.value,
          viewProps: this.viewProps,
        });
        R.view.allFocusableElements.forEach((W) => {
          W.addEventListener("blur", this.onPopupChildBlur_),
            W.addEventListener("keydown", this.onPopupChildKeydown_);
        }),
          (this.pickerC_ = R),
          this.popC_
            ? (this.view.element.appendChild(this.popC_.view.element),
              this.popC_.view.element.appendChild(R.view.element),
              Er({
                primary: this.foldable_.value("expanded"),
                secondary: this.popC_.shows,
                forward: (W) => W.rawValue,
                backward: (W, ae) => ae.rawValue,
              }))
            : this.view.pickerElement &&
              (this.view.pickerElement.appendChild(this.pickerC_.view.element),
              ge(this.foldable_, this.view.pickerElement));
      }
      get textController() {
        return this.textC_;
      }
      onButtonBlur_(l) {
        if (!this.popC_) return;
        const p = this.view.element,
          w = l.relatedTarget;
        (!w || !p.contains(w)) && (this.popC_.shows.rawValue = !1);
      }
      onButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")),
          this.foldable_.get("expanded") &&
            this.pickerC_.view.allFocusableElements[0].focus();
      }
      onPopupChildBlur_(l) {
        if (!this.popC_) return;
        const p = this.popC_.view.element,
          w = H(l);
        (w && p.contains(w)) ||
          (w &&
            w === this.swatchC_.view.buttonElement &&
            !ft(p.ownerDocument)) ||
          (this.popC_.shows.rawValue = !1);
      }
      onPopupChildKeydown_(l) {
        this.popC_
          ? l.key === "Escape" && (this.popC_.shows.rawValue = !1)
          : this.view.pickerElement &&
            l.key === "Escape" &&
            this.swatchC_.view.buttonElement.focus();
      }
    }
    function _y(g, l) {
      return Dt.isColorObject(g) ? Dt.fromObject(g, l) : Dt.black(l);
    }
    function by(g) {
      return S(g.getComponents("rgb")).reduce(
        (l, p) => (l << 8) | (Math.floor(p) & 255),
        0
      );
    }
    function xy(g) {
      return (
        g.getComponents("rgb").reduce((l, p, w) => {
          const R = Math.floor(w === 3 ? p * 255 : p) & 255;
          return (l << 8) | R;
        }, 0) >>> 0
      );
    }
    function wy(g) {
      return new Dt([(g >> 16) & 255, (g >> 8) & 255, g & 255], "rgb");
    }
    function yy(g) {
      return new Dt(
        [
          (g >> 24) & 255,
          (g >> 16) & 255,
          (g >> 8) & 255,
          qt(g & 255, 0, 255, 0, 1),
        ],
        "rgb"
      );
    }
    function Sy(g) {
      return typeof g != "number" ? Dt.black() : wy(g);
    }
    function My(g) {
      return typeof g != "number" ? Dt.black() : yy(g);
    }
    function Ty(g) {
      const l = Jd(g);
      return l
        ? (p, w) => {
            Cn(p, l(w));
          }
        : null;
    }
    function Ey(g) {
      const l = g ? xy : by;
      return (p, w) => {
        Cn(p, l(w));
      };
    }
    function Cy(g, l, p) {
      const w = l.toRgbaObject(p);
      g.writeProperty("r", w.r),
        g.writeProperty("g", w.g),
        g.writeProperty("b", w.b),
        g.writeProperty("a", w.a);
    }
    function Dy(g, l, p) {
      const w = l.toRgbaObject(p);
      g.writeProperty("r", w.r),
        g.writeProperty("g", w.g),
        g.writeProperty("b", w.b);
    }
    function Py(g, l) {
      return (p, w) => {
        g ? Cy(p, w, l) : Dy(p, w, l);
      };
    }
    function sp(g) {
      var l;
      return !!(
        (g != null && g.alpha) ||
        (!((l = g == null ? void 0 : g.color) === null || l === void 0) &&
          l.alpha)
      );
    }
    function Ay(g) {
      return g ? (l) => Zd(l, "0x") : (l) => Fg(l, "0x");
    }
    function Ly(g) {
      return "color" in g || ("view" in g && g.view === "color");
    }
    const Ry = {
      id: "input-color-number",
      type: "input",
      accept: (g, l) => {
        if (typeof g != "number" || !Ly(l)) return null;
        const p = $d(l);
        return p ? { initialValue: g, params: p } : null;
      },
      binding: {
        reader: (g) => (sp(g.params) ? My : Sy),
        equals: Dt.equals,
        writer: (g) => Ey(sp(g.params)),
      },
      controller: (g) => {
        const l = sp(g.params),
          p = "expanded" in g.params ? g.params.expanded : void 0,
          w = "picker" in g.params ? g.params.picker : void 0;
        return new np(g.document, {
          colorType: "int",
          expanded: p ?? !1,
          formatter: Ay(l),
          parser: Kd("int"),
          pickerLayout: w ?? "popup",
          supportsAlpha: l,
          value: g.value,
          viewProps: g.viewProps,
        });
      },
    };
    function ky(g) {
      return Dt.isRgbaColorObject(g);
    }
    function Iy(g) {
      return (l) => _y(l, g);
    }
    function Fy(g, l) {
      return (p) => (g ? Bg(p, l) : Ng(p, l));
    }
    const Oy = {
        id: "input-color-object",
        type: "input",
        accept: (g, l) => {
          if (!Dt.isColorObject(g)) return null;
          const p = $d(l);
          return p ? { initialValue: g, params: p } : null;
        },
        binding: {
          reader: (g) => Iy(go(g.params)),
          equals: Dt.equals,
          writer: (g) => Py(ky(g.initialValue), go(g.params)),
        },
        controller: (g) => {
          var l;
          const p = Dt.isRgbaColorObject(g.initialValue),
            w = "expanded" in g.params ? g.params.expanded : void 0,
            R = "picker" in g.params ? g.params.picker : void 0,
            W = (l = go(g.params)) !== null && l !== void 0 ? l : "int";
          return new np(g.document, {
            colorType: W,
            expanded: w ?? !1,
            formatter: Fy(p, W),
            parser: Kd(W),
            pickerLayout: R ?? "popup",
            supportsAlpha: p,
            value: g.value,
            viewProps: g.viewProps,
          });
        },
      },
      Ny = {
        id: "input-color-string",
        type: "input",
        accept: (g, l) => {
          if (typeof g != "string" || ("view" in l && l.view === "text"))
            return null;
          const p = Yd(g, go(l));
          if (!p || !Jd(p)) return null;
          const R = $d(l);
          return R ? { initialValue: g, params: R } : null;
        },
        binding: {
          reader: (g) => {
            var l;
            return Kw((l = go(g.params)) !== null && l !== void 0 ? l : "int");
          },
          equals: Dt.equals,
          writer: (g) => {
            const l = Yd(g.initialValue, go(g.params));
            if (!l) throw v.shouldNeverHappen();
            const p = Ty(l);
            if (!p) throw v.notBindable();
            return p;
          },
        },
        controller: (g) => {
          const l = Yd(g.initialValue, go(g.params));
          if (!l) throw v.shouldNeverHappen();
          const p = Jd(l);
          if (!p) throw v.shouldNeverHappen();
          const w = "expanded" in g.params ? g.params.expanded : void 0,
            R = "picker" in g.params ? g.params.picker : void 0;
          return new np(g.document, {
            colorType: l.type,
            expanded: w ?? !1,
            formatter: p,
            parser: Kd(l.type),
            pickerLayout: R ?? "popup",
            supportsAlpha: l.alpha,
            value: g.value,
            viewProps: g.viewProps,
          });
        },
      };
    class Dr {
      constructor(l) {
        (this.components = l.components), (this.asm_ = l.assembly);
      }
      constrain(l) {
        const p = this.asm_.toComponents(l).map((w, R) => {
          var W, ae;
          return (ae =
            (W = this.components[R]) === null || W === void 0
              ? void 0
              : W.constrain(w)) !== null && ae !== void 0
            ? ae
            : w;
        });
        return this.asm_.fromComponents(p);
      }
    }
    const zg = C("pndtxt");
    class By {
      constructor(l, p) {
        (this.textViews = p.textViews),
          (this.element = l.createElement("div")),
          this.element.classList.add(zg()),
          this.textViews.forEach((w) => {
            const R = l.createElement("div");
            R.classList.add(zg("a")),
              R.appendChild(w.element),
              this.element.appendChild(R);
          });
      }
    }
    function Vy(g, l, p) {
      return new co(g, {
        arrayPosition:
          p === 0 ? "fst" : p === l.axes.length - 1 ? "lst" : "mid",
        baseStep: l.axes[p].baseStep,
        parser: l.parser,
        props: l.axes[p].textProps,
        value: Q(0, { constraint: l.axes[p].constraint }),
        viewProps: l.viewProps,
      });
    }
    class rp {
      constructor(l, p) {
        (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.acs_ = p.axes.map((w, R) => Vy(l, p, R))),
          this.acs_.forEach((w, R) => {
            Er({
              primary: this.value,
              secondary: w.value,
              forward: (W) => p.assembly.toComponents(W.rawValue)[R],
              backward: (W, ae) => {
                const Ee = p.assembly.toComponents(W.rawValue);
                return (Ee[R] = ae.rawValue), p.assembly.fromComponents(Ee);
              },
            });
          }),
          (this.view = new By(l, { textViews: this.acs_.map((w) => w.view) }));
      }
    }
    function Ug(g, l) {
      return "step" in g && !c(g.step) ? new ca(g.step, l) : null;
    }
    function Gg(g) {
      return !c(g.max) && !c(g.min)
        ? new Mr({ max: g.max, min: g.min })
        : !c(g.max) || !c(g.min)
        ? new kl({ max: g.max, min: g.min })
        : null;
    }
    function zy(g) {
      const l = En(g, Mr);
      if (l) return [l.values.get("min"), l.values.get("max")];
      const p = En(g, kl);
      return p ? [p.minValue, p.maxValue] : [void 0, void 0];
    }
    function Uy(g, l) {
      const p = [],
        w = Ug(g, l);
      w && p.push(w);
      const R = Gg(g);
      R && p.push(R);
      const W = Xl(g.options);
      return W && p.push(W), new no(p);
    }
    const Gy = {
      id: "input-number",
      type: "input",
      accept: (g, l) => {
        if (typeof g != "number") return null;
        const p = le,
          w = be(l, {
            format: p.optional.function,
            max: p.optional.number,
            min: p.optional.number,
            options: p.optional.custom(ho),
            step: p.optional.number,
          });
        return w ? { initialValue: g, params: w } : null;
      },
      binding: {
        reader: (g) => us,
        constraint: (g) => Uy(g.params, g.initialValue),
        writer: (g) => Cn,
      },
      controller: (g) => {
        var l;
        const p = g.value,
          w = g.constraint,
          R = w && En(w, so);
        if (R)
          return new ro(g.document, {
            props: new V({ options: R.values.value("options") }),
            value: p,
            viewProps: g.viewProps,
          });
        const W =
            (l = "format" in g.params ? g.params.format : void 0) !== null &&
            l !== void 0
              ? l
              : gi(fa(w, p.rawValue)),
          ae = w && En(w, Mr);
        return ae
          ? new pa(g.document, {
              baseStep: js(w),
              parser: jn,
              sliderProps: new V({
                maxValue: ae.values.value("max"),
                minValue: ae.values.value("min"),
              }),
              textProps: V.fromObject({
                draggingScale: qs(w, p.rawValue),
                formatter: W,
              }),
              value: p,
              viewProps: g.viewProps,
            })
          : new co(g.document, {
              baseStep: js(w),
              parser: jn,
              props: V.fromObject({
                draggingScale: qs(w, p.rawValue),
                formatter: W,
              }),
              value: p,
              viewProps: g.viewProps,
            });
      },
    };
    class Pr {
      constructor(l = 0, p = 0) {
        (this.x = l), (this.y = p);
      }
      getComponents() {
        return [this.x, this.y];
      }
      static isObject(l) {
        if (c(l)) return !1;
        const p = l.x,
          w = l.y;
        return !(typeof p != "number" || typeof w != "number");
      }
      static equals(l, p) {
        return l.x === p.x && l.y === p.y;
      }
      toObject() {
        return { x: this.x, y: this.y };
      }
    }
    const Hg = {
        toComponents: (g) => g.getComponents(),
        fromComponents: (g) => new Pr(...g),
      },
      va = C("p2d");
    class Hy {
      constructor(l, p) {
        (this.element = l.createElement("div")),
          this.element.classList.add(va()),
          p.viewProps.bindClassModifiers(this.element),
          F(p.expanded, O(this.element, va(void 0, "expanded")));
        const w = l.createElement("div");
        w.classList.add(va("h")), this.element.appendChild(w);
        const R = l.createElement("button");
        R.classList.add(va("b")),
          R.appendChild(pe(l, "p2dpad")),
          p.viewProps.bindDisabled(R),
          w.appendChild(R),
          (this.buttonElement = R);
        const W = l.createElement("div");
        if (
          (W.classList.add(va("t")),
          w.appendChild(W),
          (this.textElement = W),
          p.pickerLayout === "inline")
        ) {
          const ae = l.createElement("div");
          ae.classList.add(va("p")),
            this.element.appendChild(ae),
            (this.pickerElement = ae);
        } else this.pickerElement = null;
      }
    }
    const Ar = C("p2dp");
    class Wy {
      constructor(l, p) {
        (this.onFoldableChange_ = this.onFoldableChange_.bind(this)),
          (this.onValueChange_ = this.onValueChange_.bind(this)),
          (this.invertsY_ = p.invertsY),
          (this.maxValue_ = p.maxValue),
          (this.element = l.createElement("div")),
          this.element.classList.add(Ar()),
          p.layout === "popup" && this.element.classList.add(Ar(void 0, "p")),
          p.viewProps.bindClassModifiers(this.element);
        const w = l.createElement("div");
        w.classList.add(Ar("p")),
          p.viewProps.bindTabIndex(w),
          this.element.appendChild(w),
          (this.padElement = w);
        const R = l.createElementNS(dt, "svg");
        R.classList.add(Ar("g")),
          this.padElement.appendChild(R),
          (this.svgElem_ = R);
        const W = l.createElementNS(dt, "line");
        W.classList.add(Ar("ax")),
          W.setAttributeNS(null, "x1", "0"),
          W.setAttributeNS(null, "y1", "50%"),
          W.setAttributeNS(null, "x2", "100%"),
          W.setAttributeNS(null, "y2", "50%"),
          this.svgElem_.appendChild(W);
        const ae = l.createElementNS(dt, "line");
        ae.classList.add(Ar("ax")),
          ae.setAttributeNS(null, "x1", "50%"),
          ae.setAttributeNS(null, "y1", "0"),
          ae.setAttributeNS(null, "x2", "50%"),
          ae.setAttributeNS(null, "y2", "100%"),
          this.svgElem_.appendChild(ae);
        const Ee = l.createElementNS(dt, "line");
        Ee.classList.add(Ar("l")),
          Ee.setAttributeNS(null, "x1", "50%"),
          Ee.setAttributeNS(null, "y1", "50%"),
          this.svgElem_.appendChild(Ee),
          (this.lineElem_ = Ee);
        const et = l.createElement("div");
        et.classList.add(Ar("m")),
          this.padElement.appendChild(et),
          (this.markerElem_ = et),
          p.value.emitter.on("change", this.onValueChange_),
          (this.value = p.value),
          this.update_();
      }
      get allFocusableElements() {
        return [this.padElement];
      }
      update_() {
        const [l, p] = this.value.rawValue.getComponents(),
          w = this.maxValue_,
          R = qt(l, -w, +w, 0, 100),
          W = qt(p, -w, +w, 0, 100),
          ae = this.invertsY_ ? 100 - W : W;
        this.lineElem_.setAttributeNS(null, "x2", `${R}%`),
          this.lineElem_.setAttributeNS(null, "y2", `${ae}%`),
          (this.markerElem_.style.left = `${R}%`),
          (this.markerElem_.style.top = `${ae}%`);
      }
      onValueChange_() {
        this.update_();
      }
      onFoldableChange_() {
        this.update_();
      }
    }
    function Wg(g, l, p) {
      return [Ei(l[0], qn(g)), Ei(l[1], lo(g)) * (p ? 1 : -1)];
    }
    class jy {
      constructor(l, p) {
        (this.onPadKeyDown_ = this.onPadKeyDown_.bind(this)),
          (this.onPadKeyUp_ = this.onPadKeyUp_.bind(this)),
          (this.onPointerDown_ = this.onPointerDown_.bind(this)),
          (this.onPointerMove_ = this.onPointerMove_.bind(this)),
          (this.onPointerUp_ = this.onPointerUp_.bind(this)),
          (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.baseSteps_ = p.baseSteps),
          (this.maxValue_ = p.maxValue),
          (this.invertsY_ = p.invertsY),
          (this.view = new Wy(l, {
            invertsY: this.invertsY_,
            layout: p.layout,
            maxValue: this.maxValue_,
            value: this.value,
            viewProps: this.viewProps,
          })),
          (this.ptHandler_ = new Ws(this.view.padElement)),
          this.ptHandler_.emitter.on("down", this.onPointerDown_),
          this.ptHandler_.emitter.on("move", this.onPointerMove_),
          this.ptHandler_.emitter.on("up", this.onPointerUp_),
          this.view.padElement.addEventListener("keydown", this.onPadKeyDown_),
          this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
      }
      handlePointerEvent_(l, p) {
        if (!l.point) return;
        const w = this.maxValue_,
          R = qt(l.point.x, 0, l.bounds.width, -w, +w),
          W = qt(
            this.invertsY_ ? l.bounds.height - l.point.y : l.point.y,
            0,
            l.bounds.height,
            -w,
            +w
          );
        this.value.setRawValue(new Pr(R, W), p);
      }
      onPointerDown_(l) {
        this.handlePointerEvent_(l.data, { forceEmit: !1, last: !1 });
      }
      onPointerMove_(l) {
        this.handlePointerEvent_(l.data, { forceEmit: !1, last: !1 });
      }
      onPointerUp_(l) {
        this.handlePointerEvent_(l.data, { forceEmit: !0, last: !0 });
      }
      onPadKeyDown_(l) {
        da(l.key) && l.preventDefault();
        const [p, w] = Wg(l, this.baseSteps_, this.invertsY_);
        (p === 0 && w === 0) ||
          this.value.setRawValue(
            new Pr(this.value.rawValue.x + p, this.value.rawValue.y + w),
            { forceEmit: !1, last: !1 }
          );
      }
      onPadKeyUp_(l) {
        const [p, w] = Wg(l, this.baseSteps_, this.invertsY_);
        (p === 0 && w === 0) ||
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0,
          });
      }
    }
    class qy {
      constructor(l, p) {
        var w, R;
        (this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this)),
          (this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this)),
          (this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this)),
          (this.onPadButtonClick_ = this.onPadButtonClick_.bind(this)),
          (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.foldable_ = lt.create(p.expanded)),
          (this.popC_ =
            p.pickerLayout === "popup"
              ? new yu(l, { viewProps: this.viewProps })
              : null);
        const W = new jy(l, {
          baseSteps: [p.axes[0].baseStep, p.axes[1].baseStep],
          invertsY: p.invertsY,
          layout: p.pickerLayout,
          maxValue: p.maxValue,
          value: this.value,
          viewProps: this.viewProps,
        });
        W.view.allFocusableElements.forEach((ae) => {
          ae.addEventListener("blur", this.onPopupChildBlur_),
            ae.addEventListener("keydown", this.onPopupChildKeydown_);
        }),
          (this.pickerC_ = W),
          (this.textC_ = new rp(l, {
            assembly: Hg,
            axes: p.axes,
            parser: p.parser,
            value: this.value,
            viewProps: this.viewProps,
          })),
          (this.view = new Hy(l, {
            expanded: this.foldable_.value("expanded"),
            pickerLayout: p.pickerLayout,
            viewProps: this.viewProps,
          })),
          this.view.textElement.appendChild(this.textC_.view.element),
          (w = this.view.buttonElement) === null ||
            w === void 0 ||
            w.addEventListener("blur", this.onPadButtonBlur_),
          (R = this.view.buttonElement) === null ||
            R === void 0 ||
            R.addEventListener("click", this.onPadButtonClick_),
          this.popC_
            ? (this.view.element.appendChild(this.popC_.view.element),
              this.popC_.view.element.appendChild(this.pickerC_.view.element),
              Er({
                primary: this.foldable_.value("expanded"),
                secondary: this.popC_.shows,
                forward: (ae) => ae.rawValue,
                backward: (ae, Ee) => Ee.rawValue,
              }))
            : this.view.pickerElement &&
              (this.view.pickerElement.appendChild(this.pickerC_.view.element),
              ge(this.foldable_, this.view.pickerElement));
      }
      onPadButtonBlur_(l) {
        if (!this.popC_) return;
        const p = this.view.element,
          w = l.relatedTarget;
        (!w || !p.contains(w)) && (this.popC_.shows.rawValue = !1);
      }
      onPadButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")),
          this.foldable_.get("expanded") &&
            this.pickerC_.view.allFocusableElements[0].focus();
      }
      onPopupChildBlur_(l) {
        if (!this.popC_) return;
        const p = this.popC_.view.element,
          w = H(l);
        (w && p.contains(w)) ||
          (w && w === this.view.buttonElement && !ft(p.ownerDocument)) ||
          (this.popC_.shows.rawValue = !1);
      }
      onPopupChildKeydown_(l) {
        this.popC_
          ? l.key === "Escape" && (this.popC_.shows.rawValue = !1)
          : this.view.pickerElement &&
            l.key === "Escape" &&
            this.view.buttonElement.focus();
      }
    }
    class _a {
      constructor(l = 0, p = 0, w = 0) {
        (this.x = l), (this.y = p), (this.z = w);
      }
      getComponents() {
        return [this.x, this.y, this.z];
      }
      static isObject(l) {
        if (c(l)) return !1;
        const p = l.x,
          w = l.y,
          R = l.z;
        return !(
          typeof p != "number" ||
          typeof w != "number" ||
          typeof R != "number"
        );
      }
      static equals(l, p) {
        return l.x === p.x && l.y === p.y && l.z === p.z;
      }
      toObject() {
        return { x: this.x, y: this.y, z: this.z };
      }
    }
    const jg = {
      toComponents: (g) => g.getComponents(),
      fromComponents: (g) => new _a(...g),
    };
    function Xy(g) {
      return _a.isObject(g) ? new _a(g.x, g.y, g.z) : new _a();
    }
    function $y(g, l) {
      g.writeProperty("x", l.x),
        g.writeProperty("y", l.y),
        g.writeProperty("z", l.z);
    }
    function Yy(g, l) {
      return new Dr({
        assembly: jg,
        components: [
          $s("x" in g ? g.x : void 0, l.x),
          $s("y" in g ? g.y : void 0, l.y),
          $s("z" in g ? g.z : void 0, l.z),
        ],
      });
    }
    function op(g, l) {
      return {
        baseStep: js(l),
        constraint: l,
        textProps: V.fromObject({
          draggingScale: qs(l, g),
          formatter: gi(fa(l, g)),
        }),
      };
    }
    const Ky = {
      id: "input-point3d",
      type: "input",
      accept: (g, l) => {
        if (!_a.isObject(g)) return null;
        const p = le,
          w = be(l, {
            x: p.optional.custom(hs),
            y: p.optional.custom(hs),
            z: p.optional.custom(hs),
          });
        return w ? { initialValue: g, params: w } : null;
      },
      binding: {
        reader: (g) => Xy,
        constraint: (g) => Yy(g.params, g.initialValue),
        equals: _a.equals,
        writer: (g) => $y,
      },
      controller: (g) => {
        const l = g.value,
          p = g.constraint;
        if (!(p instanceof Dr)) throw v.shouldNeverHappen();
        return new rp(g.document, {
          assembly: jg,
          axes: [
            op(l.rawValue.x, p.components[0]),
            op(l.rawValue.y, p.components[1]),
            op(l.rawValue.z, p.components[2]),
          ],
          parser: jn,
          value: l,
          viewProps: g.viewProps,
        });
      },
    };
    class ba {
      constructor(l = 0, p = 0, w = 0, R = 0) {
        (this.x = l), (this.y = p), (this.z = w), (this.w = R);
      }
      getComponents() {
        return [this.x, this.y, this.z, this.w];
      }
      static isObject(l) {
        if (c(l)) return !1;
        const p = l.x,
          w = l.y,
          R = l.z,
          W = l.w;
        return !(
          typeof p != "number" ||
          typeof w != "number" ||
          typeof R != "number" ||
          typeof W != "number"
        );
      }
      static equals(l, p) {
        return l.x === p.x && l.y === p.y && l.z === p.z && l.w === p.w;
      }
      toObject() {
        return { x: this.x, y: this.y, z: this.z, w: this.w };
      }
    }
    const qg = {
      toComponents: (g) => g.getComponents(),
      fromComponents: (g) => new ba(...g),
    };
    function Zy(g) {
      return ba.isObject(g) ? new ba(g.x, g.y, g.z, g.w) : new ba();
    }
    function Jy(g, l) {
      g.writeProperty("x", l.x),
        g.writeProperty("y", l.y),
        g.writeProperty("z", l.z),
        g.writeProperty("w", l.w);
    }
    function Qy(g, l) {
      return new Dr({
        assembly: qg,
        components: [
          $s("x" in g ? g.x : void 0, l.x),
          $s("y" in g ? g.y : void 0, l.y),
          $s("z" in g ? g.z : void 0, l.z),
          $s("w" in g ? g.w : void 0, l.w),
        ],
      });
    }
    function e1(g, l) {
      return {
        baseStep: js(l),
        constraint: l,
        textProps: V.fromObject({
          draggingScale: qs(l, g),
          formatter: gi(fa(l, g)),
        }),
      };
    }
    const t1 = {
      id: "input-point4d",
      type: "input",
      accept: (g, l) => {
        if (!ba.isObject(g)) return null;
        const p = le,
          w = be(l, {
            x: p.optional.custom(hs),
            y: p.optional.custom(hs),
            z: p.optional.custom(hs),
            w: p.optional.custom(hs),
          });
        return w ? { initialValue: g, params: w } : null;
      },
      binding: {
        reader: (g) => Zy,
        constraint: (g) => Qy(g.params, g.initialValue),
        equals: ba.equals,
        writer: (g) => Jy,
      },
      controller: (g) => {
        const l = g.value,
          p = g.constraint;
        if (!(p instanceof Dr)) throw v.shouldNeverHappen();
        return new rp(g.document, {
          assembly: qg,
          axes: l.rawValue
            .getComponents()
            .map((w, R) => e1(w, p.components[R])),
          parser: jn,
          value: l,
          viewProps: g.viewProps,
        });
      },
    };
    function i1(g) {
      const l = [],
        p = Xl(g.options);
      return p && l.push(p), new no(l);
    }
    const n1 = {
        id: "input-string",
        type: "input",
        accept: (g, l) => {
          if (typeof g != "string") return null;
          const w = be(l, { options: le.optional.custom(ho) });
          return w ? { initialValue: g, params: w } : null;
        },
        binding: {
          reader: (g) => Vl,
          constraint: (g) => i1(g.params),
          writer: (g) => Cn,
        },
        controller: (g) => {
          const l = g.document,
            p = g.value,
            w = g.constraint,
            R = w && En(w, so);
          return R
            ? new ro(l, {
                props: new V({ options: R.values.value("options") }),
                value: p,
                viewProps: g.viewProps,
              })
            : new ua(l, {
                parser: (W) => W,
                props: V.fromObject({ formatter: Ts }),
                value: p,
                viewProps: g.viewProps,
              });
        },
      },
      Kl = { monitor: { defaultInterval: 200, defaultLineCount: 3 } },
      Xg = C("mll");
    class s1 {
      constructor(l, p) {
        (this.onValueUpdate_ = this.onValueUpdate_.bind(this)),
          (this.formatter_ = p.formatter),
          (this.element = l.createElement("div")),
          this.element.classList.add(Xg()),
          p.viewProps.bindClassModifiers(this.element);
        const w = l.createElement("textarea");
        w.classList.add(Xg("i")),
          (w.style.height = `calc(var(--bld-us) * ${p.lineCount})`),
          (w.readOnly = !0),
          p.viewProps.bindDisabled(w),
          this.element.appendChild(w),
          (this.textareaElem_ = w),
          p.value.emitter.on("change", this.onValueUpdate_),
          (this.value = p.value),
          this.update_();
      }
      update_() {
        const l = this.textareaElem_,
          p = l.scrollTop === l.scrollHeight - l.clientHeight,
          w = [];
        this.value.rawValue.forEach((R) => {
          R !== void 0 && w.push(this.formatter_(R));
        }),
          (l.textContent = w.join(`
`)),
          p && (l.scrollTop = l.scrollHeight);
      }
      onValueUpdate_() {
        this.update_();
      }
    }
    class ap {
      constructor(l, p) {
        (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.view = new s1(l, {
            formatter: p.formatter,
            lineCount: p.lineCount,
            value: this.value,
            viewProps: this.viewProps,
          }));
      }
    }
    const $g = C("sgl");
    class r1 {
      constructor(l, p) {
        (this.onValueUpdate_ = this.onValueUpdate_.bind(this)),
          (this.formatter_ = p.formatter),
          (this.element = l.createElement("div")),
          this.element.classList.add($g()),
          p.viewProps.bindClassModifiers(this.element);
        const w = l.createElement("input");
        w.classList.add($g("i")),
          (w.readOnly = !0),
          (w.type = "text"),
          p.viewProps.bindDisabled(w),
          this.element.appendChild(w),
          (this.inputElement = w),
          p.value.emitter.on("change", this.onValueUpdate_),
          (this.value = p.value),
          this.update_();
      }
      update_() {
        const l = this.value.rawValue,
          p = l[l.length - 1];
        this.inputElement.value = p !== void 0 ? this.formatter_(p) : "";
      }
      onValueUpdate_() {
        this.update_();
      }
    }
    class lp {
      constructor(l, p) {
        (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.view = new r1(l, {
            formatter: p.formatter,
            value: this.value,
            viewProps: this.viewProps,
          }));
      }
    }
    const o1 = {
        id: "monitor-bool",
        type: "monitor",
        accept: (g, l) => {
          if (typeof g != "boolean") return null;
          const w = be(l, { lineCount: le.optional.number });
          return w ? { initialValue: g, params: w } : null;
        },
        binding: { reader: (g) => Mu },
        controller: (g) => {
          var l;
          return g.value.rawValue.length === 1
            ? new lp(g.document, {
                formatter: Tu,
                value: g.value,
                viewProps: g.viewProps,
              })
            : new ap(g.document, {
                formatter: Tu,
                lineCount:
                  (l = g.params.lineCount) !== null && l !== void 0
                    ? l
                    : Kl.monitor.defaultLineCount,
                value: g.value,
                viewProps: g.viewProps,
              });
        },
      },
      Lr = C("grl");
    class a1 {
      constructor(l, p) {
        (this.onCursorChange_ = this.onCursorChange_.bind(this)),
          (this.onValueUpdate_ = this.onValueUpdate_.bind(this)),
          (this.element = l.createElement("div")),
          this.element.classList.add(Lr()),
          p.viewProps.bindClassModifiers(this.element),
          (this.formatter_ = p.formatter),
          (this.props_ = p.props),
          (this.cursor_ = p.cursor),
          this.cursor_.emitter.on("change", this.onCursorChange_);
        const w = l.createElementNS(dt, "svg");
        w.classList.add(Lr("g")),
          (w.style.height = `calc(var(--bld-us) * ${p.lineCount})`),
          this.element.appendChild(w),
          (this.svgElem_ = w);
        const R = l.createElementNS(dt, "polyline");
        this.svgElem_.appendChild(R), (this.lineElem_ = R);
        const W = l.createElement("div");
        W.classList.add(Lr("t"), C("tt")()),
          this.element.appendChild(W),
          (this.tooltipElem_ = W),
          p.value.emitter.on("change", this.onValueUpdate_),
          (this.value = p.value),
          this.update_();
      }
      get graphElement() {
        return this.svgElem_;
      }
      update_() {
        const l = this.svgElem_.getBoundingClientRect(),
          p = this.value.rawValue.length - 1,
          w = this.props_.get("minValue"),
          R = this.props_.get("maxValue"),
          W = [];
        this.value.rawValue.forEach((Vt, Gt) => {
          if (Vt === void 0) return;
          const Ys = qt(Gt, 0, p, 0, l.width),
            Zl = qt(Vt, w, R, l.height, 0);
          W.push([Ys, Zl].join(","));
        }),
          this.lineElem_.setAttributeNS(null, "points", W.join(" "));
        const ae = this.tooltipElem_,
          Ee = this.value.rawValue[this.cursor_.rawValue];
        if (Ee === void 0) {
          ae.classList.remove(Lr("t", "a"));
          return;
        }
        const et = qt(this.cursor_.rawValue, 0, p, 0, l.width),
          vt = qt(Ee, w, R, l.height, 0);
        (ae.style.left = `${et}px`),
          (ae.style.top = `${vt}px`),
          (ae.textContent = `${this.formatter_(Ee)}`),
          ae.classList.contains(Lr("t", "a")) ||
            (ae.classList.add(Lr("t", "a"), Lr("t", "in")),
            he(ae),
            ae.classList.remove(Lr("t", "in")));
      }
      onValueUpdate_() {
        this.update_();
      }
      onCursorChange_() {
        this.update_();
      }
    }
    class l1 {
      constructor(l, p) {
        if (
          ((this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this)),
          (this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this)),
          (this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this)),
          (this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this)),
          (this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this)),
          (this.props_ = p.props),
          (this.value = p.value),
          (this.viewProps = p.viewProps),
          (this.cursor_ = Q(-1)),
          (this.view = new a1(l, {
            cursor: this.cursor_,
            formatter: p.formatter,
            lineCount: p.lineCount,
            props: this.props_,
            value: this.value,
            viewProps: this.viewProps,
          })),
          !ft(l))
        )
          this.view.element.addEventListener(
            "mousemove",
            this.onGraphMouseMove_
          ),
            this.view.element.addEventListener(
              "mouseleave",
              this.onGraphMouseLeave_
            );
        else {
          const w = new Ws(this.view.element);
          w.emitter.on("down", this.onGraphPointerDown_),
            w.emitter.on("move", this.onGraphPointerMove_),
            w.emitter.on("up", this.onGraphPointerUp_);
        }
      }
      onGraphMouseLeave_() {
        this.cursor_.rawValue = -1;
      }
      onGraphMouseMove_(l) {
        const p = this.view.element.getBoundingClientRect();
        this.cursor_.rawValue = Math.floor(
          qt(l.offsetX, 0, p.width, 0, this.value.rawValue.length)
        );
      }
      onGraphPointerDown_(l) {
        this.onGraphPointerMove_(l);
      }
      onGraphPointerMove_(l) {
        if (!l.data.point) {
          this.cursor_.rawValue = -1;
          return;
        }
        this.cursor_.rawValue = Math.floor(
          qt(
            l.data.point.x,
            0,
            l.data.bounds.width,
            0,
            this.value.rawValue.length
          )
        );
      }
      onGraphPointerUp_() {
        this.cursor_.rawValue = -1;
      }
    }
    function cp(g) {
      return "format" in g && !c(g.format) ? g.format : gi(2);
    }
    function c1(g) {
      var l;
      return g.value.rawValue.length === 1
        ? new lp(g.document, {
            formatter: cp(g.params),
            value: g.value,
            viewProps: g.viewProps,
          })
        : new ap(g.document, {
            formatter: cp(g.params),
            lineCount:
              (l = g.params.lineCount) !== null && l !== void 0
                ? l
                : Kl.monitor.defaultLineCount,
            value: g.value,
            viewProps: g.viewProps,
          });
    }
    function u1(g) {
      var l, p, w;
      return new l1(g.document, {
        formatter: cp(g.params),
        lineCount:
          (l = g.params.lineCount) !== null && l !== void 0
            ? l
            : Kl.monitor.defaultLineCount,
        props: V.fromObject({
          maxValue:
            (p = "max" in g.params ? g.params.max : null) !== null &&
            p !== void 0
              ? p
              : 100,
          minValue:
            (w = "min" in g.params ? g.params.min : null) !== null &&
            w !== void 0
              ? w
              : 0,
        }),
        value: g.value,
        viewProps: g.viewProps,
      });
    }
    function Yg(g) {
      return "view" in g && g.view === "graph";
    }
    const h1 = {
        id: "monitor-number",
        type: "monitor",
        accept: (g, l) => {
          if (typeof g != "number") return null;
          const p = le,
            w = be(l, {
              format: p.optional.function,
              lineCount: p.optional.number,
              max: p.optional.number,
              min: p.optional.number,
              view: p.optional.string,
            });
          return w ? { initialValue: g, params: w } : null;
        },
        binding: {
          defaultBufferSize: (g) => (Yg(g) ? 64 : 1),
          reader: (g) => us,
        },
        controller: (g) => (Yg(g.params) ? u1(g) : c1(g)),
      },
      d1 = {
        id: "monitor-string",
        type: "monitor",
        accept: (g, l) => {
          if (typeof g != "string") return null;
          const p = le,
            w = be(l, {
              lineCount: p.optional.number,
              multiline: p.optional.boolean,
            });
          return w ? { initialValue: g, params: w } : null;
        },
        binding: { reader: (g) => Vl },
        controller: (g) => {
          var l;
          const p = g.value;
          return p.rawValue.length > 1 ||
            ("multiline" in g.params && g.params.multiline)
            ? new ap(g.document, {
                formatter: Ts,
                lineCount:
                  (l = g.params.lineCount) !== null && l !== void 0
                    ? l
                    : Kl.monitor.defaultLineCount,
                value: p,
                viewProps: g.viewProps,
              })
            : new lp(g.document, {
                formatter: Ts,
                value: p,
                viewProps: g.viewProps,
              });
        },
      };
    function p1(g, l) {
      const p = g.accept(l.target.read(), l.params);
      if (c(p)) return null;
      const w = le,
        R = {
          target: l.target,
          initialValue: p.initialValue,
          params: p.params,
        },
        W = g.binding.reader(R),
        ae = g.binding.constraint ? g.binding.constraint(R) : void 0,
        Ee = Q(W(p.initialValue), { constraint: ae, equals: g.binding.equals }),
        et = new la({
          reader: W,
          target: l.target,
          value: Ee,
          writer: g.binding.writer(R),
        }),
        vt = w.optional.boolean(l.params.disabled).value,
        Vt = w.optional.boolean(l.params.hidden).value,
        Gt = g.controller({
          constraint: ae,
          document: l.document,
          initialValue: p.initialValue,
          params: p.params,
          value: et.value,
          viewProps: Ke.create({ disabled: vt, hidden: Vt }),
        }),
        Ys = w.optional.string(l.params.label).value;
      return new Te(l.document, {
        binding: et,
        blade: rt(),
        props: V.fromObject({ label: Ys ?? l.target.key }),
        valueController: Gt,
      });
    }
    function f1(g, l) {
      return l === 0 ? new _u() : new Rl(g, l ?? Kl.monitor.defaultInterval);
    }
    function m1(g, l) {
      var p, w, R;
      const W = le,
        ae = g.accept(l.target.read(), l.params);
      if (c(ae)) return null;
      const Ee = {
          target: l.target,
          initialValue: ae.initialValue,
          params: ae.params,
        },
        et = g.binding.reader(Ee),
        vt =
          (w =
            (p = W.optional.number(l.params.bufferSize).value) !== null &&
            p !== void 0
              ? p
              : g.binding.defaultBufferSize &&
                g.binding.defaultBufferSize(ae.params)) !== null && w !== void 0
            ? w
            : 1,
        Vt = W.optional.number(l.params.interval).value,
        Gt = new Md({
          reader: et,
          target: l.target,
          ticker: f1(l.document, Vt),
          value: bu(vt),
        }),
        Ys = W.optional.boolean(l.params.disabled).value,
        Zl = W.optional.boolean(l.params.hidden).value,
        Jl = g.controller({
          document: l.document,
          params: ae.params,
          value: Gt.value,
          viewProps: Ke.create({ disabled: Ys, hidden: Zl }),
        }),
        xa =
          (R = W.optional.string(l.params.label).value) !== null && R !== void 0
            ? R
            : l.target.key;
      return new mt(l.document, {
        binding: Gt,
        blade: rt(),
        props: V.fromObject({ label: xa }),
        valueController: Jl,
      });
    }
    class g1 {
      constructor() {
        this.pluginsMap_ = { blades: [], inputs: [], monitors: [] };
      }
      getAll() {
        return [
          ...this.pluginsMap_.blades,
          ...this.pluginsMap_.inputs,
          ...this.pluginsMap_.monitors,
        ];
      }
      register(l) {
        l.type === "blade"
          ? this.pluginsMap_.blades.unshift(l)
          : l.type === "input"
          ? this.pluginsMap_.inputs.unshift(l)
          : l.type === "monitor" && this.pluginsMap_.monitors.unshift(l);
      }
      createInput(l, p, w) {
        const R = p.read();
        if (c(R))
          throw new v({
            context: { key: p.key },
            type: "nomatchingcontroller",
          });
        const W = this.pluginsMap_.inputs.reduce(
          (ae, Ee) => ae ?? p1(Ee, { document: l, target: p, params: w }),
          null
        );
        if (W) return W;
        throw new v({ context: { key: p.key }, type: "nomatchingcontroller" });
      }
      createMonitor(l, p, w) {
        const R = this.pluginsMap_.monitors.reduce(
          (W, ae) => W ?? m1(ae, { document: l, params: w, target: p }),
          null
        );
        if (R) return R;
        throw new v({ context: { key: p.key }, type: "nomatchingcontroller" });
      }
      createBlade(l, p) {
        const w = this.pluginsMap_.blades.reduce(
          (R, W) => R ?? Sd(W, { document: l, params: p }),
          null
        );
        if (!w) throw new v({ type: "nomatchingview", context: { params: p } });
        return w;
      }
      createBladeApi(l) {
        if (l instanceof Te) return new tt(l);
        if (l instanceof mt) return new gt(l);
        if (l instanceof nt) return new _t(l, this);
        const p = this.pluginsMap_.blades.reduce(
          (w, R) => w ?? R.api({ controller: l, pool: this }),
          null
        );
        if (!p) throw v.shouldNeverHappen();
        return p;
      }
    }
    function v1() {
      const g = new g1();
      return (
        [
          S1,
          Ky,
          t1,
          n1,
          Gy,
          Ny,
          Oy,
          Ry,
          ma,
          o1,
          d1,
          h1,
          je,
          Ot,
          Jt,
          Ll,
        ].forEach((l) => {
          g.register(l);
        }),
        g
      );
    }
    function _1(g) {
      return Pr.isObject(g) ? new Pr(g.x, g.y) : new Pr();
    }
    function b1(g, l) {
      g.writeProperty("x", l.x), g.writeProperty("y", l.y);
    }
    function $s(g, l) {
      if (!g) return;
      const p = [],
        w = Ug(g, l);
      w && p.push(w);
      const R = Gg(g);
      return R && p.push(R), new no(p);
    }
    function x1(g, l) {
      return new Dr({
        assembly: Hg,
        components: [
          $s("x" in g ? g.x : void 0, l.x),
          $s("y" in g ? g.y : void 0, l.y),
        ],
      });
    }
    function Kg(g, l) {
      const [p, w] = g ? zy(g) : [];
      if (!c(p) || !c(w)) return Math.max(Math.abs(p ?? 0), Math.abs(w ?? 0));
      const R = js(g);
      return Math.max(Math.abs(R) * 10, Math.abs(l) * 10);
    }
    function w1(g, l) {
      const p = l instanceof Dr ? l.components[0] : void 0,
        w = l instanceof Dr ? l.components[1] : void 0,
        R = Kg(p, g.x),
        W = Kg(w, g.y);
      return Math.max(R, W);
    }
    function Zg(g, l) {
      return {
        baseStep: js(l),
        constraint: l,
        textProps: V.fromObject({
          draggingScale: qs(l, g),
          formatter: gi(fa(l, g)),
        }),
      };
    }
    function y1(g) {
      if (!("y" in g)) return !1;
      const l = g.y;
      return l && "inverted" in l ? !!l.inverted : !1;
    }
    const S1 = {
      id: "input-point2d",
      type: "input",
      accept: (g, l) => {
        if (!Pr.isObject(g)) return null;
        const p = le,
          w = be(l, {
            expanded: p.optional.boolean,
            picker: p.optional.custom(ql),
            x: p.optional.custom(hs),
            y: p.optional.object({
              inverted: p.optional.boolean,
              max: p.optional.number,
              min: p.optional.number,
              step: p.optional.number,
            }),
          });
        return w ? { initialValue: g, params: w } : null;
      },
      binding: {
        reader: (g) => _1,
        constraint: (g) => x1(g.params, g.initialValue),
        equals: Pr.equals,
        writer: (g) => b1,
      },
      controller: (g) => {
        const l = g.document,
          p = g.value,
          w = g.constraint;
        if (!(w instanceof Dr)) throw v.shouldNeverHappen();
        const R = "expanded" in g.params ? g.params.expanded : void 0,
          W = "picker" in g.params ? g.params.picker : void 0;
        return new qy(l, {
          axes: [
            Zg(p.rawValue.x, w.components[0]),
            Zg(p.rawValue.y, w.components[1]),
          ],
          expanded: R ?? !1,
          invertsY: y1(g.params),
          maxValue: w1(p.rawValue, w),
          parser: jn,
          pickerLayout: W ?? "popup",
          value: p,
          viewProps: g.viewProps,
        });
      },
    };
    class Jg extends n {
      constructor(l) {
        super(l),
          (this.emitter_ = new M()),
          this.controller_.valueController.value.emitter.on("change", (p) => {
            this.emitter_.emit("change", { event: new a(this, p.rawValue) });
          });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(l) {
        this.controller_.props.set("label", l);
      }
      get options() {
        return this.controller_.valueController.props.get("options");
      }
      set options(l) {
        this.controller_.valueController.props.set("options", l);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(l) {
        this.controller_.valueController.value.rawValue = l;
      }
      on(l, p) {
        const w = p.bind(this);
        return (
          this.emitter_.on(l, (R) => {
            w(R.event);
          }),
          this
        );
      }
    }
    class Qg extends n {
      constructor(l) {
        super(l),
          (this.emitter_ = new M()),
          this.controller_.valueController.value.emitter.on("change", (p) => {
            this.emitter_.emit("change", { event: new a(this, p.rawValue) });
          });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(l) {
        this.controller_.props.set("label", l);
      }
      get maxValue() {
        return this.controller_.valueController.sliderController.props.get(
          "maxValue"
        );
      }
      set maxValue(l) {
        this.controller_.valueController.sliderController.props.set(
          "maxValue",
          l
        );
      }
      get minValue() {
        return this.controller_.valueController.sliderController.props.get(
          "minValue"
        );
      }
      set minValue(l) {
        this.controller_.valueController.sliderController.props.set(
          "minValue",
          l
        );
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(l) {
        this.controller_.valueController.value.rawValue = l;
      }
      on(l, p) {
        const w = p.bind(this);
        return (
          this.emitter_.on(l, (R) => {
            w(R.event);
          }),
          this
        );
      }
    }
    class e0 extends n {
      constructor(l) {
        super(l),
          (this.emitter_ = new M()),
          this.controller_.valueController.value.emitter.on("change", (p) => {
            this.emitter_.emit("change", { event: new a(this, p.rawValue) });
          });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(l) {
        this.controller_.props.set("label", l);
      }
      get formatter() {
        return this.controller_.valueController.props.get("formatter");
      }
      set formatter(l) {
        this.controller_.valueController.props.set("formatter", l);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(l) {
        this.controller_.valueController.value.rawValue = l;
      }
      on(l, p) {
        const w = p.bind(this);
        return (
          this.emitter_.on(l, (R) => {
            w(R.event);
          }),
          this
        );
      }
    }
    const M1 = (function () {
      return {
        id: "list",
        type: "blade",
        accept(g) {
          const l = le,
            p = be(g, {
              options: l.required.custom(ho),
              value: l.required.raw,
              view: l.required.constant("list"),
              label: l.optional.string,
            });
          return p ? { params: p } : null;
        },
        controller(g) {
          const l = new so(Fu(g.params.options)),
            p = Q(g.params.value, { constraint: l }),
            w = new ro(g.document, {
              props: new V({ options: l.values.value("options") }),
              value: p,
              viewProps: g.viewProps,
            });
          return new Zt(g.document, {
            blade: g.blade,
            props: V.fromObject({ label: g.params.label }),
            valueController: w,
          });
        },
        api(g) {
          return !(g.controller instanceof Zt) ||
            !(g.controller.valueController instanceof ro)
            ? null
            : new Jg(g.controller);
        },
      };
    })();
    function T1(g) {
      return g.reduce(
        (l, p) => Object.assign(l, { [p.presetKey]: p.read() }),
        {}
      );
    }
    function E1(g, l) {
      g.forEach((p) => {
        const w = l[p.target.presetKey];
        w !== void 0 && p.writer(p.target, p.reader(w));
      });
    }
    class C1 extends B {
      constructor(l, p) {
        super(l, p);
      }
      get element() {
        return this.controller_.view.element;
      }
      importPreset(l) {
        const p = this.controller_.rackController.rack
          .find(Te)
          .map((w) => w.binding);
        E1(p, l), this.refresh();
      }
      exportPreset() {
        const l = this.controller_.rackController.rack
          .find(Te)
          .map((p) => p.binding.target);
        return T1(l);
      }
      refresh() {
        this.controller_.rackController.rack.find(Te).forEach((l) => {
          l.binding.read();
        }),
          this.controller_.rackController.rack.find(mt).forEach((l) => {
            l.binding.read();
          });
      }
    }
    class D1 extends xt {
      constructor(l, p) {
        super(l, {
          expanded: p.expanded,
          blade: p.blade,
          props: p.props,
          root: !0,
          viewProps: p.viewProps,
        });
      }
    }
    const P1 = {
        id: "slider",
        type: "blade",
        accept(g) {
          const l = le,
            p = be(g, {
              max: l.required.number,
              min: l.required.number,
              view: l.required.constant("slider"),
              format: l.optional.function,
              label: l.optional.string,
              value: l.optional.number,
            });
          return p ? { params: p } : null;
        },
        controller(g) {
          var l, p;
          const w = (l = g.params.value) !== null && l !== void 0 ? l : 0,
            R = new Mr({ max: g.params.max, min: g.params.min }),
            W = new pa(g.document, {
              baseStep: 1,
              parser: jn,
              sliderProps: new V({
                maxValue: R.values.value("max"),
                minValue: R.values.value("min"),
              }),
              textProps: V.fromObject({
                draggingScale: qs(void 0, w),
                formatter:
                  (p = g.params.format) !== null && p !== void 0 ? p : Gd,
              }),
              value: Q(w, { constraint: R }),
              viewProps: g.viewProps,
            });
          return new Zt(g.document, {
            blade: g.blade,
            props: V.fromObject({ label: g.params.label }),
            valueController: W,
          });
        },
        api(g) {
          return !(g.controller instanceof Zt) ||
            !(g.controller.valueController instanceof pa)
            ? null
            : new Qg(g.controller);
        },
      },
      A1 = (function () {
        return {
          id: "text",
          type: "blade",
          accept(g) {
            const l = le,
              p = be(g, {
                parse: l.required.function,
                value: l.required.raw,
                view: l.required.constant("text"),
                format: l.optional.function,
                label: l.optional.string,
              });
            return p ? { params: p } : null;
          },
          controller(g) {
            var l;
            const p = new ua(g.document, {
              parser: g.params.parse,
              props: V.fromObject({
                formatter:
                  (l = g.params.format) !== null && l !== void 0
                    ? l
                    : (w) => String(w),
              }),
              value: Q(g.params.value),
              viewProps: g.viewProps,
            });
            return new Zt(g.document, {
              blade: g.blade,
              props: V.fromObject({ label: g.params.label }),
              valueController: p,
            });
          },
          api(g) {
            return !(g.controller instanceof Zt) ||
              !(g.controller.valueController instanceof ua)
              ? null
              : new e0(g.controller);
          },
        };
      })();
    function L1(g) {
      const l = g.createElement("div");
      return l.classList.add(C("dfw")()), g.body && g.body.appendChild(l), l;
    }
    function t0(g, l, p) {
      if (g.querySelector(`style[data-tp-style=${l}]`)) return;
      const w = g.createElement("style");
      (w.dataset.tpStyle = l), (w.textContent = p), g.head.appendChild(w);
    }
    class R1 extends C1 {
      constructor(l) {
        var p, w;
        const R = l ?? {},
          W = (p = R.document) !== null && p !== void 0 ? p : bt(),
          ae = v1(),
          Ee = new D1(W, {
            expanded: R.expanded,
            blade: rt(),
            props: V.fromObject({ title: R.title }),
            viewProps: Ke.create(),
          });
        super(Ee, ae),
          (this.pool_ = ae),
          (this.containerElem_ =
            (w = R.container) !== null && w !== void 0 ? w : L1(W)),
          this.containerElem_.appendChild(this.element),
          (this.doc_ = W),
          (this.usesDefaultWrapper_ = !R.container),
          this.setUpDefaultPlugins_();
      }
      get document() {
        if (!this.doc_) throw v.alreadyDisposed();
        return this.doc_;
      }
      dispose() {
        const l = this.containerElem_;
        if (!l) throw v.alreadyDisposed();
        if (this.usesDefaultWrapper_) {
          const p = l.parentElement;
          p && p.removeChild(l);
        }
        (this.containerElem_ = null), (this.doc_ = null), super.dispose();
      }
      registerPlugin(l) {
        ("plugin" in l ? [l.plugin] : "plugins" in l ? l.plugins : []).forEach(
          (w) => {
            this.pool_.register(w), this.embedPluginStyle_(w);
          }
        );
      }
      embedPluginStyle_(l) {
        l.css && t0(this.document, `plugin-${l.id}`, l.css);
      }
      setUpDefaultPlugins_() {
        t0(
          this.document,
          "default",
          '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{padding-bottom:var(--cnt-v-p);padding-left:4px;padding-top:var(--cnt-v-p)}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'
        ),
          this.pool_.getAll().forEach((l) => {
            this.embedPluginStyle_(l);
          }),
          this.registerPlugin({ plugins: [P1, M1, Ll, A1] });
      }
    }
    const k1 = new i("3.1.6");
    (t.BladeApi = n),
      (t.ButtonApi = y),
      (t.FolderApi = B),
      (t.InputBindingApi = tt),
      (t.ListApi = Jg),
      (t.MonitorBindingApi = gt),
      (t.Pane = R1),
      (t.SeparatorApi = ki),
      (t.SliderApi = Qg),
      (t.TabApi = Ti),
      (t.TabPageApi = Qt),
      (t.TextApi = e0),
      (t.TpChangeEvent = a),
      (t.VERSION = k1),
      Object.defineProperty(t, "__esModule", { value: !0 });
  });
})(hm, hm.exports);
var OA = hm.exports,
  dm = { exports: {} };
(function (r, e) {
  (function (t, i) {
    i(e);
  })(Lo, function (t) {
    class i {
      constructor(_) {
        this.controller_ = _;
      }
      get element() {
        return this.controller_.view.element;
      }
      get disabled() {
        return this.controller_.viewProps.get("disabled");
      }
      set disabled(_) {
        this.controller_.viewProps.set("disabled", _);
      }
      get hidden() {
        return this.controller_.viewProps.get("hidden");
      }
      set hidden(_) {
        this.controller_.viewProps.set("hidden", _);
      }
      dispose() {
        this.controller_.viewProps.set("disposed", !0);
      }
    }
    class n {
      constructor(_) {
        this.target = _;
      }
    }
    class s extends n {
      constructor(_, S, L, z) {
        super(_), (this.value = S), (this.presetKey = L), (this.last = z ?? !0);
      }
    }
    function a(T) {
      return T;
    }
    function o(T) {
      return T == null;
    }
    const u = {
      alreadydisposed: () => "View has been already disposed",
      invalidparams: (T) => `Invalid parameters for '${T.name}'`,
      nomatchingcontroller: (T) => `No matching controller for '${T.key}'`,
      nomatchingview: (T) =>
        `No matching view for '${JSON.stringify(T.params)}'`,
      notbindable: () => "Value is not bindable",
      propertynotfound: (T) => `Property '${T.name}' not found`,
      shouldneverhappen: () => "This error should never happen",
    };
    class h {
      constructor(_) {
        var S;
        (this.message =
          (S = u[_.type](_.context)) !== null && S !== void 0
            ? S
            : "Unexpected error"),
          (this.name = this.constructor.name),
          (this.stack = new Error(this.message).stack),
          (this.type = _.type);
      }
      static alreadyDisposed() {
        return new h({ type: "alreadydisposed" });
      }
      static notBindable() {
        return new h({ type: "notbindable" });
      }
      static propertyNotFound(_) {
        return new h({ type: "propertynotfound", context: { name: _ } });
      }
      static shouldNeverHappen() {
        return new h({ type: "shouldneverhappen" });
      }
    }
    class f {
      constructor() {
        this.observers_ = {};
      }
      on(_, S) {
        let L = this.observers_[_];
        return L || (L = this.observers_[_] = []), L.push({ handler: S }), this;
      }
      off(_, S) {
        const L = this.observers_[_];
        return (
          L && (this.observers_[_] = L.filter((z) => z.handler !== S)), this
        );
      }
      emit(_, S) {
        const L = this.observers_[_];
        L &&
          L.forEach((z) => {
            z.handler(S);
          });
      }
    }
    const c = "tp";
    function d(T) {
      return (S, L) =>
        [c, "-", T, "v", S ? `_${S}` : "", L ? `-${L}` : ""].join("");
    }
    function m(T, _) {
      return (S) => _(T(S));
    }
    function x(T) {
      return T.rawValue;
    }
    function v(T, _) {
      T.emitter.on("change", m(x, _)), _(T.rawValue);
    }
    function b(T, _, S) {
      v(T.value(_), S);
    }
    function y(T, _, S) {
      S ? T.classList.add(_) : T.classList.remove(_);
    }
    function M(T, _) {
      return (S) => {
        y(T, _, S);
      };
    }
    function D(T, _) {
      v(T, (S) => {
        _.textContent = S ?? "";
      });
    }
    const C = d("btn");
    class A {
      constructor(_, S) {
        (this.element = _.createElement("div")),
          this.element.classList.add(C()),
          S.viewProps.bindClassModifiers(this.element);
        const L = _.createElement("button");
        L.classList.add(C("b")),
          S.viewProps.bindDisabled(L),
          this.element.appendChild(L),
          (this.buttonElement = L);
        const z = _.createElement("div");
        z.classList.add(C("t")),
          D(S.props.value("title"), z),
          this.buttonElement.appendChild(z);
      }
    }
    class I {
      constructor(_, S) {
        (this.emitter = new f()),
          (this.onClick_ = this.onClick_.bind(this)),
          (this.props = S.props),
          (this.viewProps = S.viewProps),
          (this.view = new A(_, {
            props: this.props,
            viewProps: this.viewProps,
          })),
          this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", { sender: this });
      }
    }
    class F {
      constructor(_, S) {
        var L;
        (this.constraint_ = S == null ? void 0 : S.constraint),
          (this.equals_ =
            (L = S == null ? void 0 : S.equals) !== null && L !== void 0
              ? L
              : (z, re) => z === re),
          (this.emitter = new f()),
          (this.rawValue_ = _);
      }
      get constraint() {
        return this.constraint_;
      }
      get rawValue() {
        return this.rawValue_;
      }
      set rawValue(_) {
        this.setRawValue(_, { forceEmit: !1, last: !0 });
      }
      setRawValue(_, S) {
        const L = S ?? { forceEmit: !1, last: !0 },
          z = this.constraint_ ? this.constraint_.constrain(_) : _,
          re = this.rawValue_;
        (this.equals_(re, z) && !L.forceEmit) ||
          (this.emitter.emit("beforechange", { sender: this }),
          (this.rawValue_ = z),
          this.emitter.emit("change", {
            options: L,
            previousRawValue: re,
            rawValue: z,
            sender: this,
          }));
      }
    }
    class P {
      constructor(_) {
        (this.emitter = new f()), (this.value_ = _);
      }
      get rawValue() {
        return this.value_;
      }
      set rawValue(_) {
        this.setRawValue(_, { forceEmit: !1, last: !0 });
      }
      setRawValue(_, S) {
        const L = S ?? { forceEmit: !1, last: !0 },
          z = this.value_;
        (z === _ && !L.forceEmit) ||
          (this.emitter.emit("beforechange", { sender: this }),
          (this.value_ = _),
          this.emitter.emit("change", {
            options: L,
            previousRawValue: z,
            rawValue: this.value_,
            sender: this,
          }));
      }
    }
    function k(T, _) {
      const S = _ == null ? void 0 : _.constraint,
        L = _ == null ? void 0 : _.equals;
      return !S && !L ? new P(T) : new F(T, _);
    }
    class O {
      constructor(_) {
        (this.emitter = new f()), (this.valMap_ = _);
        for (const S in this.valMap_)
          this.valMap_[S].emitter.on("change", () => {
            this.emitter.emit("change", { key: S, sender: this });
          });
      }
      static createCore(_) {
        return Object.keys(_).reduce(
          (L, z) => Object.assign(L, { [z]: k(_[z]) }),
          {}
        );
      }
      static fromObject(_) {
        const S = this.createCore(_);
        return new O(S);
      }
      get(_) {
        return this.valMap_[_].rawValue;
      }
      set(_, S) {
        this.valMap_[_].rawValue = S;
      }
      value(_) {
        return this.valMap_[_];
      }
    }
    function J(T, _) {
      const L = Object.keys(_).reduce((z, re) => {
        if (z === void 0) return;
        const _e = _[re],
          Le = _e(T[re]);
        return Le.succeeded
          ? Object.assign(Object.assign({}, z), { [re]: Le.value })
          : void 0;
      }, {});
      return L;
    }
    function ee(T, _) {
      return T.reduce((S, L) => {
        if (S === void 0) return;
        const z = _(L);
        if (!(!z.succeeded || z.value === void 0)) return [...S, z.value];
      }, []);
    }
    function X(T) {
      return T === null ? !1 : typeof T == "object";
    }
    function j(T) {
      return (_) => (S) => {
        if (!_ && S === void 0) return { succeeded: !1, value: void 0 };
        if (_ && S === void 0) return { succeeded: !0, value: void 0 };
        const L = T(S);
        return L !== void 0
          ? { succeeded: !0, value: L }
          : { succeeded: !1, value: void 0 };
      };
    }
    function Y(T) {
      return {
        custom: (_) => j(_)(T),
        boolean: j((_) => (typeof _ == "boolean" ? _ : void 0))(T),
        number: j((_) => (typeof _ == "number" ? _ : void 0))(T),
        string: j((_) => (typeof _ == "string" ? _ : void 0))(T),
        function: j((_) => (typeof _ == "function" ? _ : void 0))(T),
        constant: (_) => j((S) => (S === _ ? _ : void 0))(T),
        raw: j((_) => _)(T),
        object: (_) =>
          j((S) => {
            if (X(S)) return J(S, _);
          })(T),
        array: (_) =>
          j((S) => {
            if (Array.isArray(S)) return ee(S, _);
          })(T),
      };
    }
    const ie = { optional: Y(!0), required: Y(!1) };
    function Q(T, _) {
      const S = ie.required.object(_)(T);
      return S.succeeded ? S.value : void 0;
    }
    function V(T) {
      console.warn(
        [
          `Missing '${T.key}' of ${T.target} in ${T.place}.`,
          "Please rebuild plugins with the latest core package.",
        ].join(" ")
      );
    }
    function ve(T) {
      return T && T.parentElement && T.parentElement.removeChild(T), null;
    }
    class U {
      constructor(_) {
        this.value_ = _;
      }
      static create(_) {
        return [
          new U(_),
          (S, L) => {
            _.setRawValue(S, L);
          },
        ];
      }
      get emitter() {
        return this.value_.emitter;
      }
      get rawValue() {
        return this.value_.rawValue;
      }
    }
    const oe = d("");
    function ue(T, _) {
      return M(T, oe(void 0, _));
    }
    class fe extends O {
      constructor(_) {
        var S;
        super(_),
          (this.onDisabledChange_ = this.onDisabledChange_.bind(this)),
          (this.onParentChange_ = this.onParentChange_.bind(this)),
          (this.onParentGlobalDisabledChange_ =
            this.onParentGlobalDisabledChange_.bind(this)),
          ([this.globalDisabled_, this.setGlobalDisabled_] = U.create(
            k(this.getGlobalDisabled_())
          )),
          this.value("disabled").emitter.on("change", this.onDisabledChange_),
          this.value("parent").emitter.on("change", this.onParentChange_),
          (S = this.get("parent")) === null ||
            S === void 0 ||
            S.globalDisabled.emitter.on(
              "change",
              this.onParentGlobalDisabledChange_
            );
      }
      static create(_) {
        var S, L, z;
        const re = _ ?? {};
        return new fe(
          O.createCore({
            disabled: (S = re.disabled) !== null && S !== void 0 ? S : !1,
            disposed: !1,
            hidden: (L = re.hidden) !== null && L !== void 0 ? L : !1,
            parent: (z = re.parent) !== null && z !== void 0 ? z : null,
          })
        );
      }
      get globalDisabled() {
        return this.globalDisabled_;
      }
      bindClassModifiers(_) {
        v(this.globalDisabled_, ue(_, "disabled")),
          b(this, "hidden", ue(_, "hidden"));
      }
      bindDisabled(_) {
        v(this.globalDisabled_, (S) => {
          _.disabled = S;
        });
      }
      bindTabIndex(_) {
        v(this.globalDisabled_, (S) => {
          _.tabIndex = S ? -1 : 0;
        });
      }
      handleDispose(_) {
        this.value("disposed").emitter.on("change", (S) => {
          S && _();
        });
      }
      getGlobalDisabled_() {
        const _ = this.get("parent");
        return (_ ? _.globalDisabled.rawValue : !1) || this.get("disabled");
      }
      updateGlobalDisabled_() {
        this.setGlobalDisabled_(this.getGlobalDisabled_());
      }
      onDisabledChange_() {
        this.updateGlobalDisabled_();
      }
      onParentGlobalDisabledChange_() {
        this.updateGlobalDisabled_();
      }
      onParentChange_(_) {
        var S;
        const L = _.previousRawValue;
        L == null ||
          L.globalDisabled.emitter.off(
            "change",
            this.onParentGlobalDisabledChange_
          ),
          (S = this.get("parent")) === null ||
            S === void 0 ||
            S.globalDisabled.emitter.on(
              "change",
              this.onParentGlobalDisabledChange_
            ),
          this.updateGlobalDisabled_();
      }
    }
    function le() {
      return ["veryfirst", "first", "last", "verylast"];
    }
    const be = d(""),
      ce = { veryfirst: "vfst", first: "fst", last: "lst", verylast: "vlst" };
    class He {
      constructor(_) {
        (this.parent_ = null),
          (this.blade = _.blade),
          (this.view = _.view),
          (this.viewProps = _.viewProps);
        const S = this.view.element;
        this.blade.value("positions").emitter.on("change", () => {
          le().forEach((L) => {
            S.classList.remove(be(void 0, ce[L]));
          }),
            this.blade.get("positions").forEach((L) => {
              S.classList.add(be(void 0, ce[L]));
            });
        }),
          this.viewProps.handleDispose(() => {
            ve(S);
          });
      }
      get parent() {
        return this.parent_;
      }
      set parent(_) {
        if (((this.parent_ = _), !("parent" in this.viewProps.valMap_))) {
          V({
            key: "parent",
            target: fe.name,
            place: "BladeController.parent",
          });
          return;
        }
        this.viewProps.set(
          "parent",
          this.parent_ ? this.parent_.viewProps : null
        );
      }
    }
    const Se = "http://www.w3.org/2000/svg";
    function Oe(T) {
      T.offsetHeight;
    }
    function Me(T, _) {
      const S = T.style.transition;
      (T.style.transition = "none"), _(), (T.style.transition = S);
    }
    function Ke(T) {
      return T.ontouchstart !== void 0;
    }
    function Qe(T) {
      for (; T.childNodes.length > 0; ) T.removeChild(T.childNodes[0]);
    }
    function Pe(T) {
      return T.relatedTarget
        ? T.relatedTarget
        : "explicitOriginalTarget" in T
        ? T.explicitOriginalTarget
        : null;
    }
    const ht = d("lbl");
    function wt(T, _) {
      const S = T.createDocumentFragment();
      return (
        _.split(
          `
`
        )
          .map((z) => T.createTextNode(z))
          .forEach((z, re) => {
            re > 0 && S.appendChild(T.createElement("br")), S.appendChild(z);
          }),
        S
      );
    }
    class dt {
      constructor(_, S) {
        (this.element = _.createElement("div")),
          this.element.classList.add(ht()),
          S.viewProps.bindClassModifiers(this.element);
        const L = _.createElement("div");
        L.classList.add(ht("l")),
          b(S.props, "label", (re) => {
            o(re)
              ? this.element.classList.add(ht(void 0, "nol"))
              : (this.element.classList.remove(ht(void 0, "nol")),
                Qe(L),
                L.appendChild(wt(_, re)));
          }),
          this.element.appendChild(L),
          (this.labelElement = L);
        const z = _.createElement("div");
        z.classList.add(ht("v")),
          this.element.appendChild(z),
          (this.valueElement = z);
      }
    }
    class he extends He {
      constructor(_, S) {
        const L = S.valueController.viewProps;
        super(
          Object.assign(Object.assign({}, S), {
            view: new dt(_, { props: S.props, viewProps: L }),
            viewProps: L,
          })
        ),
          (this.props = S.props),
          (this.valueController = S.valueController),
          this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    class Et extends He {
      constructor(_) {
        super(_), (this.value = _.value);
      }
    }
    class ft extends O {
      constructor(_) {
        super(_);
      }
      static create(_) {
        const S = {
            completed: !0,
            expanded: _,
            expandedHeight: null,
            shouldFixHeight: !1,
            temporaryExpanded: null,
          },
          L = O.createCore(S);
        return new ft(L);
      }
      get styleExpanded() {
        var _;
        return (_ = this.get("temporaryExpanded")) !== null && _ !== void 0
          ? _
          : this.get("expanded");
      }
      get styleHeight() {
        if (!this.styleExpanded) return "0";
        const _ = this.get("expandedHeight");
        return this.get("shouldFixHeight") && !o(_) ? `${_}px` : "auto";
      }
      bindExpandedClass(_, S) {
        const L = () => {
          this.styleExpanded ? _.classList.add(S) : _.classList.remove(S);
        };
        b(this, "expanded", L), b(this, "temporaryExpanded", L);
      }
      cleanUpTransition() {
        this.set("shouldFixHeight", !1),
          this.set("expandedHeight", null),
          this.set("completed", !0);
      }
    }
    function Bt(T) {
      return ft.create(T);
    }
    function bt(T, _) {
      let S = 0;
      return (
        Me(_, () => {
          T.set("expandedHeight", null),
            T.set("temporaryExpanded", !0),
            Oe(_),
            (S = _.clientHeight),
            T.set("temporaryExpanded", null),
            Oe(_);
        }),
        S
      );
    }
    function G(T, _) {
      _.style.height = T.styleHeight;
    }
    function N(T, _) {
      T.value("expanded").emitter.on("beforechange", () => {
        T.set("completed", !1),
          o(T.get("expandedHeight")) && T.set("expandedHeight", bt(T, _)),
          T.set("shouldFixHeight", !0),
          Oe(_);
      }),
        T.emitter.on("change", () => {
          G(T, _);
        }),
        G(T, _),
        _.addEventListener("transitionend", (S) => {
          S.propertyName === "height" && T.cleanUpTransition();
        });
    }
    class pe {
      constructor(_, S) {
        const L = d(S.viewName);
        (this.element = _.createElement("div")),
          this.element.classList.add(L()),
          S.viewProps.bindClassModifiers(this.element);
      }
    }
    class xe extends Et {
      constructor(_, S) {
        const L = S.valueController.viewProps;
        super(
          Object.assign(Object.assign({}, S), {
            value: S.valueController.value,
            view: new dt(_, { props: S.props, viewProps: L }),
            viewProps: L,
          })
        ),
          (this.props = S.props),
          (this.valueController = S.valueController),
          this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    class we {
      constructor() {
        (this.disabled = !1), (this.emitter = new f());
      }
      dispose() {}
      tick() {
        this.disabled || this.emitter.emit("tick", { sender: this });
      }
    }
    class Ce {
      constructor(_, S) {
        (this.disabled_ = !1),
          (this.timerId_ = null),
          (this.onTick_ = this.onTick_.bind(this)),
          (this.doc_ = _),
          (this.emitter = new f()),
          (this.interval_ = S),
          this.setTimer_();
      }
      get disabled() {
        return this.disabled_;
      }
      set disabled(_) {
        (this.disabled_ = _),
          this.disabled_ ? this.clearTimer_() : this.setTimer_();
      }
      dispose() {
        this.clearTimer_();
      }
      clearTimer_() {
        if (this.timerId_ === null) return;
        const _ = this.doc_.defaultView;
        _ && _.clearInterval(this.timerId_), (this.timerId_ = null);
      }
      setTimer_() {
        if ((this.clearTimer_(), this.interval_ <= 0)) return;
        const _ = this.doc_.defaultView;
        _ && (this.timerId_ = _.setInterval(this.onTick_, this.interval_));
      }
      onTick_() {
        this.disabled_ || this.emitter.emit("tick", { sender: this });
      }
    }
    class We {
      constructor(_) {
        this.constraints = _;
      }
      constrain(_) {
        return this.constraints.reduce((S, L) => L.constrain(S), _);
      }
    }
    function H(T, _) {
      if (T instanceof _) return T;
      if (T instanceof We) {
        const S = T.constraints.reduce(
          (L, z) => L || (z instanceof _ ? z : null),
          null
        );
        if (S) return S;
      }
      return null;
    }
    class ne {
      constructor(_) {
        this.values = O.fromObject({ max: _.max, min: _.min });
      }
      constrain(_) {
        const S = this.values.get("max"),
          L = this.values.get("min");
        return Math.min(Math.max(_, L), S);
      }
    }
    class Re {
      constructor(_) {
        this.values = O.fromObject({ max: _.max, min: _.min });
      }
      get maxValue() {
        return this.values.get("max");
      }
      get minValue() {
        return this.values.get("min");
      }
      constrain(_) {
        const S = this.values.get("max"),
          L = this.values.get("min");
        let z = _;
        return o(L) || (z = Math.max(z, L)), o(S) || (z = Math.min(z, S)), z;
      }
    }
    class Ae {
      constructor(_, S = 0) {
        (this.step = _), (this.origin = S);
      }
      constrain(_) {
        const S = this.origin % this.step,
          L = Math.round((_ - S) / this.step);
        return S + L * this.step;
      }
    }
    const ke = d("pop");
    class je {
      constructor(_, S) {
        (this.element = _.createElement("div")),
          this.element.classList.add(ke()),
          S.viewProps.bindClassModifiers(this.element),
          v(S.shows, M(this.element, ke(void 0, "v")));
      }
    }
    class Ve {
      constructor(_, S) {
        (this.shows = k(!1)),
          (this.viewProps = S.viewProps),
          (this.view = new je(_, {
            shows: this.shows,
            viewProps: this.viewProps,
          }));
      }
    }
    const rt = d("txt");
    class lt {
      constructor(_, S) {
        (this.onChange_ = this.onChange_.bind(this)),
          (this.element = _.createElement("div")),
          this.element.classList.add(rt()),
          S.viewProps.bindClassModifiers(this.element),
          (this.props_ = S.props),
          this.props_.emitter.on("change", this.onChange_);
        const L = _.createElement("input");
        L.classList.add(rt("i")),
          (L.type = "text"),
          S.viewProps.bindDisabled(L),
          this.element.appendChild(L),
          (this.inputElement = L),
          S.value.emitter.on("change", this.onChange_),
          (this.value_ = S.value),
          this.refresh();
      }
      refresh() {
        const _ = this.props_.get("formatter");
        this.inputElement.value = _(this.value_.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class Ct {
      constructor(_, S) {
        (this.onInputChange_ = this.onInputChange_.bind(this)),
          (this.parser_ = S.parser),
          (this.props = S.props),
          (this.value = S.value),
          (this.viewProps = S.viewProps),
          (this.view = new lt(_, {
            props: S.props,
            value: this.value,
            viewProps: this.viewProps,
          })),
          this.view.inputElement.addEventListener(
            "change",
            this.onInputChange_
          );
      }
      onInputChange_(_) {
        const L = _.currentTarget.value,
          z = this.parser_(L);
        o(z) || (this.value.rawValue = z), this.view.refresh();
      }
    }
    function $(T) {
      return T === "false" ? !1 : !!T;
    }
    class ge {
      constructor(_) {
        this.text = _;
      }
      evaluate() {
        return Number(this.text);
      }
      toString() {
        return this.text;
      }
    }
    const ye = {
      "**": (T, _) => Math.pow(T, _),
      "*": (T, _) => T * _,
      "/": (T, _) => T / _,
      "%": (T, _) => T % _,
      "+": (T, _) => T + _,
      "-": (T, _) => T - _,
      "<<": (T, _) => T << _,
      ">>": (T, _) => T >> _,
      ">>>": (T, _) => T >>> _,
      "&": (T, _) => T & _,
      "^": (T, _) => T ^ _,
      "|": (T, _) => T | _,
    };
    class Ie {
      constructor(_, S, L) {
        (this.left = S), (this.operator = _), (this.right = L);
      }
      evaluate() {
        const _ = ye[this.operator];
        if (!_)
          throw new Error(`unexpected binary operator: '${this.operator}`);
        return _(this.left.evaluate(), this.right.evaluate());
      }
      toString() {
        return [
          "b(",
          this.left.toString(),
          this.operator,
          this.right.toString(),
          ")",
        ].join(" ");
      }
    }
    const Ge = { "+": (T) => T, "-": (T) => -T, "~": (T) => ~T };
    class Mt {
      constructor(_, S) {
        (this.operator = _), (this.expression = S);
      }
      evaluate() {
        const _ = Ge[this.operator];
        if (!_) throw new Error(`unexpected unary operator: '${this.operator}`);
        return _(this.expression.evaluate());
      }
      toString() {
        return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
      }
    }
    function zt(T) {
      return (_, S) => {
        for (let L = 0; L < T.length; L++) {
          const z = T[L](_, S);
          if (z !== "") return z;
        }
        return "";
      };
    }
    function Rt(T, _) {
      var S;
      const L = T.substr(_).match(/^\s+/);
      return (S = L && L[0]) !== null && S !== void 0 ? S : "";
    }
    function tt(T, _) {
      const S = T.substr(_, 1);
      return S.match(/^[1-9]$/) ? S : "";
    }
    function Te(T, _) {
      var S;
      const L = T.substr(_).match(/^[0-9]+/);
      return (S = L && L[0]) !== null && S !== void 0 ? S : "";
    }
    function gt(T, _) {
      const S = Te(T, _);
      if (S !== "") return S;
      const L = T.substr(_, 1);
      if (((_ += 1), L !== "-" && L !== "+")) return "";
      const z = Te(T, _);
      return z === "" ? "" : L + z;
    }
    function mt(T, _) {
      const S = T.substr(_, 1);
      if (((_ += 1), S.toLowerCase() !== "e")) return "";
      const L = gt(T, _);
      return L === "" ? "" : S + L;
    }
    function ze(T, _) {
      const S = T.substr(_, 1);
      if (S === "0") return S;
      const L = tt(T, _);
      return (_ += L.length), L === "" ? "" : L + Te(T, _);
    }
    function yt(T, _) {
      const S = ze(T, _);
      if (((_ += S.length), S === "")) return "";
      const L = T.substr(_, 1);
      if (((_ += L.length), L !== ".")) return "";
      const z = Te(T, _);
      return (_ += z.length), S + L + z + mt(T, _);
    }
    function st(T, _) {
      const S = T.substr(_, 1);
      if (((_ += S.length), S !== ".")) return "";
      const L = Te(T, _);
      return (_ += L.length), L === "" ? "" : S + L + mt(T, _);
    }
    function _t(T, _) {
      const S = ze(T, _);
      return (_ += S.length), S === "" ? "" : S + mt(T, _);
    }
    const B = zt([yt, st, _t]);
    function te(T, _) {
      var S;
      const L = T.substr(_).match(/^[01]+/);
      return (S = L && L[0]) !== null && S !== void 0 ? S : "";
    }
    function de(T, _) {
      const S = T.substr(_, 2);
      if (((_ += S.length), S.toLowerCase() !== "0b")) return "";
      const L = te(T, _);
      return L === "" ? "" : S + L;
    }
    function se(T, _) {
      var S;
      const L = T.substr(_).match(/^[0-7]+/);
      return (S = L && L[0]) !== null && S !== void 0 ? S : "";
    }
    function me(T, _) {
      const S = T.substr(_, 2);
      if (((_ += S.length), S.toLowerCase() !== "0o")) return "";
      const L = se(T, _);
      return L === "" ? "" : S + L;
    }
    function Fe(T, _) {
      var S;
      const L = T.substr(_).match(/^[0-9a-f]+/i);
      return (S = L && L[0]) !== null && S !== void 0 ? S : "";
    }
    function Ne(T, _) {
      const S = T.substr(_, 2);
      if (((_ += S.length), S.toLowerCase() !== "0x")) return "";
      const L = Fe(T, _);
      return L === "" ? "" : S + L;
    }
    const it = zt([de, me, Ne]),
      $e = zt([it, B]);
    function nt(T, _) {
      const S = $e(T, _);
      return (
        (_ += S.length), S === "" ? null : { evaluable: new ge(S), cursor: _ }
      );
    }
    function pt(T, _) {
      const S = T.substr(_, 1);
      if (((_ += S.length), S !== "(")) return null;
      const L = St(T, _);
      if (!L) return null;
      (_ = L.cursor), (_ += Rt(T, _).length);
      const z = T.substr(_, 1);
      return (
        (_ += z.length),
        z !== ")" ? null : { evaluable: L.evaluable, cursor: _ }
      );
    }
    function ot(T, _) {
      var S;
      return (S = nt(T, _)) !== null && S !== void 0 ? S : pt(T, _);
    }
    function xt(T, _) {
      const S = ot(T, _);
      if (S) return S;
      const L = T.substr(_, 1);
      if (((_ += L.length), L !== "+" && L !== "-" && L !== "~")) return null;
      const z = xt(T, _);
      return z
        ? ((_ = z.cursor), { cursor: _, evaluable: new Mt(L, z.evaluable) })
        : null;
    }
    function Ot(T, _, S) {
      S += Rt(_, S).length;
      const L = T.filter((z) => _.startsWith(z, S))[0];
      return L
        ? ((S += L.length), (S += Rt(_, S).length), { cursor: S, operator: L })
        : null;
    }
    function Zt(T, _) {
      return (S, L) => {
        const z = T(S, L);
        if (!z) return null;
        L = z.cursor;
        let re = z.evaluable;
        for (;;) {
          const _e = Ot(_, S, L);
          if (!_e) break;
          L = _e.cursor;
          const Le = T(S, L);
          if (!Le) return null;
          (L = Le.cursor), (re = new Ie(_e.operator, re, Le.evaluable));
        }
        return re ? { cursor: L, evaluable: re } : null;
      };
    }
    const ki = [
      ["**"],
      ["*", "/", "%"],
      ["+", "-"],
      ["<<", ">>>", ">>"],
      ["&"],
      ["^"],
      ["|"],
    ].reduce((T, _) => Zt(T, _), xt);
    function St(T, _) {
      return (_ += Rt(T, _).length), ki(T, _);
    }
    function Je(T) {
      const _ = St(T, 0);
      return !_ || _.cursor + Rt(T, _.cursor).length !== T.length
        ? null
        : _.evaluable;
    }
    function ai(T) {
      var _;
      const S = Je(T);
      return (_ = S == null ? void 0 : S.evaluate()) !== null && _ !== void 0
        ? _
        : null;
    }
    function Jt(T) {
      if (typeof T == "number") return T;
      if (typeof T == "string") {
        const _ = ai(T);
        if (!o(_)) return _;
      }
      return 0;
    }
    function Ut(T) {
      return (_) => _.toFixed(Math.max(Math.min(T, 20), 0));
    }
    const Gn = Ut(0);
    function ni(T) {
      return Gn(T) + "%";
    }
    function un(T) {
      return String(T);
    }
    function Qt(T, _) {
      for (; T.length < _; ) T.push(void 0);
    }
    function Ti(T) {
      const _ = [];
      return Qt(_, T), k(_);
    }
    function yr(T) {
      const _ = T.indexOf(void 0);
      return _ < 0 ? T : T.slice(0, _);
    }
    function Ii(T, _) {
      const S = [...yr(T), _];
      return (
        S.length > T.length
          ? S.splice(0, S.length - T.length)
          : Qt(S, T.length),
        S
      );
    }
    function Hn({ primary: T, secondary: _, forward: S, backward: L }) {
      let z = !1;
      function re(_e) {
        z || ((z = !0), _e(), (z = !1));
      }
      T.emitter.on("change", (_e) => {
        re(() => {
          _.setRawValue(S(T, _), _e.options);
        });
      }),
        _.emitter.on("change", (_e) => {
          re(() => {
            T.setRawValue(L(T, _), _e.options);
          }),
            re(() => {
              _.setRawValue(S(T, _), _e.options);
            });
        }),
        re(() => {
          _.setRawValue(S(T, _), { forceEmit: !1, last: !0 });
        });
    }
    function ys(T, _) {
      const S = T * (_.altKey ? 0.1 : 1) * (_.shiftKey ? 10 : 1);
      return _.upKey ? +S : _.downKey ? -S : 0;
    }
    function Ss(T) {
      return {
        altKey: T.altKey,
        downKey: T.key === "ArrowDown",
        shiftKey: T.shiftKey,
        upKey: T.key === "ArrowUp",
      };
    }
    function Ll(T) {
      return {
        altKey: T.altKey,
        downKey: T.key === "ArrowLeft",
        shiftKey: T.shiftKey,
        upKey: T.key === "ArrowRight",
      };
    }
    function Sd(T) {
      return T === "ArrowUp" || T === "ArrowDown";
    }
    function _u(T) {
      return Sd(T) || T === "ArrowLeft" || T === "ArrowRight";
    }
    function Rl(T, _) {
      var S, L;
      const z = _.ownerDocument.defaultView,
        re = _.getBoundingClientRect();
      return {
        x:
          T.pageX -
          (((S = z && z.scrollX) !== null && S !== void 0 ? S : 0) + re.left),
        y:
          T.pageY -
          (((L = z && z.scrollY) !== null && L !== void 0 ? L : 0) + re.top),
      };
    }
    class la {
      constructor(_) {
        (this.lastTouch_ = null),
          (this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this)),
          (this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this)),
          (this.onMouseDown_ = this.onMouseDown_.bind(this)),
          (this.onTouchEnd_ = this.onTouchEnd_.bind(this)),
          (this.onTouchMove_ = this.onTouchMove_.bind(this)),
          (this.onTouchStart_ = this.onTouchStart_.bind(this)),
          (this.elem_ = _),
          (this.emitter = new f()),
          _.addEventListener("touchstart", this.onTouchStart_, { passive: !1 }),
          _.addEventListener("touchmove", this.onTouchMove_, { passive: !0 }),
          _.addEventListener("touchend", this.onTouchEnd_),
          _.addEventListener("mousedown", this.onMouseDown_);
      }
      computePosition_(_) {
        const S = this.elem_.getBoundingClientRect();
        return {
          bounds: { width: S.width, height: S.height },
          point: _ ? { x: _.x, y: _.y } : null,
        };
      }
      onMouseDown_(_) {
        var S;
        _.preventDefault(),
          (S = _.currentTarget) === null || S === void 0 || S.focus();
        const L = this.elem_.ownerDocument;
        L.addEventListener("mousemove", this.onDocumentMouseMove_),
          L.addEventListener("mouseup", this.onDocumentMouseUp_),
          this.emitter.emit("down", {
            altKey: _.altKey,
            data: this.computePosition_(Rl(_, this.elem_)),
            sender: this,
            shiftKey: _.shiftKey,
          });
      }
      onDocumentMouseMove_(_) {
        this.emitter.emit("move", {
          altKey: _.altKey,
          data: this.computePosition_(Rl(_, this.elem_)),
          sender: this,
          shiftKey: _.shiftKey,
        });
      }
      onDocumentMouseUp_(_) {
        const S = this.elem_.ownerDocument;
        S.removeEventListener("mousemove", this.onDocumentMouseMove_),
          S.removeEventListener("mouseup", this.onDocumentMouseUp_),
          this.emitter.emit("up", {
            altKey: _.altKey,
            data: this.computePosition_(Rl(_, this.elem_)),
            sender: this,
            shiftKey: _.shiftKey,
          });
      }
      onTouchStart_(_) {
        _.preventDefault();
        const S = _.targetTouches.item(0),
          L = this.elem_.getBoundingClientRect();
        this.emitter.emit("down", {
          altKey: _.altKey,
          data: this.computePosition_(
            S ? { x: S.clientX - L.left, y: S.clientY - L.top } : void 0
          ),
          sender: this,
          shiftKey: _.shiftKey,
        }),
          (this.lastTouch_ = S);
      }
      onTouchMove_(_) {
        const S = _.targetTouches.item(0),
          L = this.elem_.getBoundingClientRect();
        this.emitter.emit("move", {
          altKey: _.altKey,
          data: this.computePosition_(
            S ? { x: S.clientX - L.left, y: S.clientY - L.top } : void 0
          ),
          sender: this,
          shiftKey: _.shiftKey,
        }),
          (this.lastTouch_ = S);
      }
      onTouchEnd_(_) {
        var S;
        const L =
            (S = _.targetTouches.item(0)) !== null && S !== void 0
              ? S
              : this.lastTouch_,
          z = this.elem_.getBoundingClientRect();
        this.emitter.emit("up", {
          altKey: _.altKey,
          data: this.computePosition_(
            L ? { x: L.clientX - z.left, y: L.clientY - z.top } : void 0
          ),
          sender: this,
          shiftKey: _.shiftKey,
        });
      }
    }
    function li(T, _, S, L, z) {
      const re = (T - _) / (S - _);
      return L + re * (z - L);
    }
    function bu(T) {
      return String(T.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
    }
    function Sr(T, _, S) {
      return Math.min(Math.max(T, _), S);
    }
    const hn = d("txt");
    class Md {
      constructor(_, S) {
        (this.onChange_ = this.onChange_.bind(this)),
          (this.props_ = S.props),
          this.props_.emitter.on("change", this.onChange_),
          (this.element = _.createElement("div")),
          this.element.classList.add(hn(), hn(void 0, "num")),
          S.arrayPosition &&
            this.element.classList.add(hn(void 0, S.arrayPosition)),
          S.viewProps.bindClassModifiers(this.element);
        const L = _.createElement("input");
        L.classList.add(hn("i")),
          (L.type = "text"),
          S.viewProps.bindDisabled(L),
          this.element.appendChild(L),
          (this.inputElement = L),
          (this.onDraggingChange_ = this.onDraggingChange_.bind(this)),
          (this.dragging_ = S.dragging),
          this.dragging_.emitter.on("change", this.onDraggingChange_),
          this.element.classList.add(hn()),
          this.inputElement.classList.add(hn("i"));
        const z = _.createElement("div");
        z.classList.add(hn("k")),
          this.element.appendChild(z),
          (this.knobElement = z);
        const re = _.createElementNS(Se, "svg");
        re.classList.add(hn("g")), this.knobElement.appendChild(re);
        const _e = _.createElementNS(Se, "path");
        _e.classList.add(hn("gb")),
          re.appendChild(_e),
          (this.guideBodyElem_ = _e);
        const Le = _.createElementNS(Se, "path");
        Le.classList.add(hn("gh")),
          re.appendChild(Le),
          (this.guideHeadElem_ = Le);
        const It = _.createElement("div");
        It.classList.add(d("tt")()),
          this.knobElement.appendChild(It),
          (this.tooltipElem_ = It),
          S.value.emitter.on("change", this.onChange_),
          (this.value = S.value),
          this.refresh();
      }
      onDraggingChange_(_) {
        if (_.rawValue === null) {
          this.element.classList.remove(hn(void 0, "drg"));
          return;
        }
        this.element.classList.add(hn(void 0, "drg"));
        const S = _.rawValue / this.props_.get("draggingScale"),
          L = S + (S > 0 ? -1 : S < 0 ? 1 : 0),
          z = Sr(-L, -4, 4);
        this.guideHeadElem_.setAttributeNS(
          null,
          "d",
          [`M ${L + z},0 L${L},4 L${L + z},8`, `M ${S},-1 L${S},9`].join(" ")
        ),
          this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${S},4`);
        const re = this.props_.get("formatter");
        (this.tooltipElem_.textContent = re(this.value.rawValue)),
          (this.tooltipElem_.style.left = `${S}px`);
      }
      refresh() {
        const _ = this.props_.get("formatter");
        this.inputElement.value = _(this.value.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class no {
      constructor(_, S) {
        var L;
        (this.originRawValue_ = 0),
          (this.onInputChange_ = this.onInputChange_.bind(this)),
          (this.onInputKeyDown_ = this.onInputKeyDown_.bind(this)),
          (this.onInputKeyUp_ = this.onInputKeyUp_.bind(this)),
          (this.onPointerDown_ = this.onPointerDown_.bind(this)),
          (this.onPointerMove_ = this.onPointerMove_.bind(this)),
          (this.onPointerUp_ = this.onPointerUp_.bind(this)),
          (this.baseStep_ = S.baseStep),
          (this.parser_ = S.parser),
          (this.props = S.props),
          (this.sliderProps_ =
            (L = S.sliderProps) !== null && L !== void 0 ? L : null),
          (this.value = S.value),
          (this.viewProps = S.viewProps),
          (this.dragging_ = k(null)),
          (this.view = new Md(_, {
            arrayPosition: S.arrayPosition,
            dragging: this.dragging_,
            props: this.props,
            value: this.value,
            viewProps: this.viewProps,
          })),
          this.view.inputElement.addEventListener(
            "change",
            this.onInputChange_
          ),
          this.view.inputElement.addEventListener(
            "keydown",
            this.onInputKeyDown_
          ),
          this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
        const z = new la(this.view.knobElement);
        z.emitter.on("down", this.onPointerDown_),
          z.emitter.on("move", this.onPointerMove_),
          z.emitter.on("up", this.onPointerUp_);
      }
      constrainValue_(_) {
        var S, L;
        const z =
            (S = this.sliderProps_) === null || S === void 0
              ? void 0
              : S.get("minValue"),
          re =
            (L = this.sliderProps_) === null || L === void 0
              ? void 0
              : L.get("maxValue");
        let _e = _;
        return (
          z !== void 0 && (_e = Math.max(_e, z)),
          re !== void 0 && (_e = Math.min(_e, re)),
          _e
        );
      }
      onInputChange_(_) {
        const L = _.currentTarget.value,
          z = this.parser_(L);
        o(z) || (this.value.rawValue = this.constrainValue_(z)),
          this.view.refresh();
      }
      onInputKeyDown_(_) {
        const S = ys(this.baseStep_, Ss(_));
        S !== 0 &&
          this.value.setRawValue(
            this.constrainValue_(this.value.rawValue + S),
            { forceEmit: !1, last: !1 }
          );
      }
      onInputKeyUp_(_) {
        ys(this.baseStep_, Ss(_)) !== 0 &&
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0,
          });
      }
      onPointerDown_() {
        (this.originRawValue_ = this.value.rawValue),
          (this.dragging_.rawValue = 0);
      }
      computeDraggingValue_(_) {
        if (!_.point) return null;
        const S = _.point.x - _.bounds.width / 2;
        return this.constrainValue_(
          this.originRawValue_ + S * this.props.get("draggingScale")
        );
      }
      onPointerMove_(_) {
        const S = this.computeDraggingValue_(_.data);
        S !== null &&
          (this.value.setRawValue(S, { forceEmit: !1, last: !1 }),
          (this.dragging_.rawValue =
            this.value.rawValue - this.originRawValue_));
      }
      onPointerUp_(_) {
        const S = this.computeDraggingValue_(_.data);
        S !== null &&
          (this.value.setRawValue(S, { forceEmit: !0, last: !0 }),
          (this.dragging_.rawValue = null));
      }
    }
    function En(T, _) {
      T.write(_);
    }
    function Mr(T) {
      const _ = T ? H(T, Ae) : null;
      return _ ? _.step : null;
    }
    function so(T, _) {
      const S = T && H(T, Ae);
      return S ? bu(S.step) : Math.max(bu(_), 2);
    }
    function kl(T) {
      const _ = Mr(T);
      return _ ?? 1;
    }
    function ca(T, _) {
      var S;
      const L = T && H(T, Ae),
        z = Math.abs(
          (S = L == null ? void 0 : L.step) !== null && S !== void 0 ? S : _
        );
      return z === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(z)) - 1);
    }
    function Tr(T) {
      return [T[0], T[1], T[2]];
    }
    function xu(T) {
      const _ = Sr(Math.floor(T), 0, 255).toString(16);
      return _.length === 1 ? `0${_}` : _;
    }
    function ro(T, _ = "#") {
      const S = Tr(T.getComponents("rgb")).map(xu).join("");
      return `${_}${S}`;
    }
    function wu(T, _ = "#") {
      const S = T.getComponents("rgb"),
        L = [S[0], S[1], S[2], S[3] * 255].map(xu).join("");
      return `${_}${L}`;
    }
    function Td(T, _) {
      const S = Ut(_ === "float" ? 2 : 0);
      return `rgb(${Tr(T.getComponents("rgb", _))
        .map((z) => S(z))
        .join(", ")})`;
    }
    function yu(T) {
      return (_) => Td(_, T);
    }
    function Su(T, _) {
      const S = Ut(2),
        L = Ut(_ === "float" ? 2 : 0);
      return `rgba(${T.getComponents("rgb", _)
        .map((re, _e) => (_e === 3 ? S : L)(re))
        .join(", ")})`;
    }
    function Ed(T) {
      return (_) => Su(_, T);
    }
    function ua(T) {
      const _ = [Ut(0), ni, ni];
      return `hsl(${Tr(T.getComponents("hsl"))
        .map((L, z) => _[z](L))
        .join(", ")})`;
    }
    function Cd(T) {
      const _ = [Ut(0), ni, ni, Ut(2)];
      return `hsla(${T.getComponents("hsl")
        .map((L, z) => _[z](L))
        .join(", ")})`;
    }
    function Mu(T, _) {
      const S = Ut(_ === "float" ? 2 : 0),
        L = ["r", "g", "b"];
      return `{${Tr(T.getComponents("rgb", _))
        .map((re, _e) => `${L[_e]}: ${S(re)}`)
        .join(", ")}}`;
    }
    function Tu(T) {
      return (_) => Mu(_, T);
    }
    function Dd(T, _) {
      const S = Ut(2),
        L = Ut(_ === "float" ? 2 : 0),
        z = ["r", "g", "b", "a"];
      return `{${T.getComponents("rgb", _)
        .map((_e, Le) => {
          const It = Le === 3 ? S : L;
          return `${z[Le]}: ${It(_e)}`;
        })
        .join(", ")}}`;
    }
    function Pd(T) {
      return (_) => Dd(_, T);
    }
    [
      ...["int", "float"].reduce(
        (T, _) => [
          ...T,
          {
            format: { alpha: !1, mode: "rgb", notation: "func", type: _ },
            stringifier: yu(_),
          },
          {
            format: { alpha: !0, mode: "rgb", notation: "func", type: _ },
            stringifier: Ed(_),
          },
          {
            format: { alpha: !1, mode: "rgb", notation: "object", type: _ },
            stringifier: Tu(_),
          },
          {
            format: { alpha: !0, mode: "rgb", notation: "object", type: _ },
            stringifier: Pd(_),
          },
        ],
        []
      ),
    ];
    class Ad {
      constructor(_) {
        (this.components = _.components), (this.asm_ = _.assembly);
      }
      constrain(_) {
        const S = this.asm_.toComponents(_).map((L, z) => {
          var re, _e;
          return (_e =
            (re = this.components[z]) === null || re === void 0
              ? void 0
              : re.constrain(L)) !== null && _e !== void 0
            ? _e
            : L;
        });
        return this.asm_.fromComponents(S);
      }
    }
    const Eu = d("pndtxt");
    class Ld {
      constructor(_, S) {
        (this.textViews = S.textViews),
          (this.element = _.createElement("div")),
          this.element.classList.add(Eu()),
          this.textViews.forEach((L) => {
            const z = _.createElement("div");
            z.classList.add(Eu("a")),
              z.appendChild(L.element),
              this.element.appendChild(z);
          });
      }
    }
    function Il(T, _, S) {
      return new no(T, {
        arrayPosition:
          S === 0 ? "fst" : S === _.axes.length - 1 ? "lst" : "mid",
        baseStep: _.axes[S].baseStep,
        parser: _.parser,
        props: _.axes[S].textProps,
        value: k(0, { constraint: _.axes[S].constraint }),
        viewProps: _.viewProps,
      });
    }
    class Gs {
      constructor(_, S) {
        (this.value = S.value),
          (this.viewProps = S.viewProps),
          (this.acs_ = S.axes.map((L, z) => Il(_, S, z))),
          this.acs_.forEach((L, z) => {
            Hn({
              primary: this.value,
              secondary: L.value,
              forward: (re) => S.assembly.toComponents(re.rawValue)[z],
              backward: (re, _e) => {
                const Le = S.assembly.toComponents(re.rawValue);
                return (Le[z] = _e.rawValue), S.assembly.fromComponents(Le);
              },
            });
          }),
          (this.view = new Ld(_, { textViews: this.acs_.map((L) => L.view) }));
      }
    }
    function Rd(T, _) {
      return "step" in T && !o(T.step) ? new Ae(T.step, _) : null;
    }
    function oo(T) {
      return !o(T.max) && !o(T.min)
        ? new ne({ max: T.max, min: T.min })
        : !o(T.max) || !o(T.min)
        ? new Re({ max: T.max, min: T.min })
        : null;
    }
    const kd = { monitor: { defaultInterval: 200, defaultLineCount: 3 } },
      Wn = d("grl");
    class Cu {
      constructor(_, S) {
        (this.onCursorChange_ = this.onCursorChange_.bind(this)),
          (this.onValueUpdate_ = this.onValueUpdate_.bind(this)),
          (this.element = _.createElement("div")),
          this.element.classList.add(Wn()),
          S.viewProps.bindClassModifiers(this.element),
          (this.formatter_ = S.formatter),
          (this.props_ = S.props),
          (this.cursor_ = S.cursor),
          this.cursor_.emitter.on("change", this.onCursorChange_);
        const L = _.createElementNS(Se, "svg");
        L.classList.add(Wn("g")),
          (L.style.height = `calc(var(--bld-us) * ${S.lineCount})`),
          this.element.appendChild(L),
          (this.svgElem_ = L);
        const z = _.createElementNS(Se, "polyline");
        this.svgElem_.appendChild(z), (this.lineElem_ = z);
        const re = _.createElement("div");
        re.classList.add(Wn("t"), d("tt")()),
          this.element.appendChild(re),
          (this.tooltipElem_ = re),
          S.value.emitter.on("change", this.onValueUpdate_),
          (this.value = S.value),
          this.update_();
      }
      get graphElement() {
        return this.svgElem_;
      }
      update_() {
        const _ = this.svgElem_.getBoundingClientRect(),
          S = this.value.rawValue.length - 1,
          L = this.props_.get("minValue"),
          z = this.props_.get("maxValue"),
          re = [];
        this.value.rawValue.forEach((fn, Dt) => {
          if (fn === void 0) return;
          const Es = li(Dt, 0, S, 0, _.width),
            Xd = li(fn, L, z, _.height, 0);
          re.push([Es, Xd].join(","));
        }),
          this.lineElem_.setAttributeNS(null, "points", re.join(" "));
        const _e = this.tooltipElem_,
          Le = this.value.rawValue[this.cursor_.rawValue];
        if (Le === void 0) {
          _e.classList.remove(Wn("t", "a"));
          return;
        }
        const It = li(this.cursor_.rawValue, 0, S, 0, _.width),
          pn = li(Le, L, z, _.height, 0);
        (_e.style.left = `${It}px`),
          (_e.style.top = `${pn}px`),
          (_e.textContent = `${this.formatter_(Le)}`),
          _e.classList.contains(Wn("t", "a")) ||
            (_e.classList.add(Wn("t", "a"), Wn("t", "in")),
            Oe(_e),
            _e.classList.remove(Wn("t", "in")));
      }
      onValueUpdate_() {
        this.update_();
      }
      onCursorChange_() {
        this.update_();
      }
    }
    class Id {
      constructor(_, S) {
        if (
          ((this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this)),
          (this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this)),
          (this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this)),
          (this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this)),
          (this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this)),
          (this.props_ = S.props),
          (this.value = S.value),
          (this.viewProps = S.viewProps),
          (this.cursor_ = k(-1)),
          (this.view = new Cu(_, {
            cursor: this.cursor_,
            formatter: S.formatter,
            lineCount: S.lineCount,
            props: this.props_,
            value: this.value,
            viewProps: this.viewProps,
          })),
          !Ke(_))
        )
          this.view.element.addEventListener(
            "mousemove",
            this.onGraphMouseMove_
          ),
            this.view.element.addEventListener(
              "mouseleave",
              this.onGraphMouseLeave_
            );
        else {
          const L = new la(this.view.element);
          L.emitter.on("down", this.onGraphPointerDown_),
            L.emitter.on("move", this.onGraphPointerMove_),
            L.emitter.on("up", this.onGraphPointerUp_);
        }
      }
      onGraphMouseLeave_() {
        this.cursor_.rawValue = -1;
      }
      onGraphMouseMove_(_) {
        const S = this.view.element.getBoundingClientRect();
        this.cursor_.rawValue = Math.floor(
          li(_.offsetX, 0, S.width, 0, this.value.rawValue.length)
        );
      }
      onGraphPointerDown_(_) {
        this.onGraphPointerMove_(_);
      }
      onGraphPointerMove_(_) {
        if (!_.data.point) {
          this.cursor_.rawValue = -1;
          return;
        }
        this.cursor_.rawValue = Math.floor(
          li(
            _.data.point.x,
            0,
            _.data.bounds.width,
            0,
            this.value.rawValue.length
          )
        );
      }
      onGraphPointerUp_() {
        this.cursor_.rawValue = -1;
      }
    }
    class Du {
      constructor(_) {
        this.controller_ = _;
      }
      get disabled() {
        return this.controller_.viewProps.get("disabled");
      }
      set disabled(_) {
        this.controller_.viewProps.set("disabled", _);
      }
      get title() {
        var _;
        return (_ = this.controller_.props.get("title")) !== null &&
          _ !== void 0
          ? _
          : "";
      }
      set title(_) {
        this.controller_.props.set("title", _);
      }
      on(_, S) {
        const L = S.bind(this);
        return (
          this.controller_.emitter.on(_, () => {
            L(new n(this));
          }),
          this
        );
      }
    }
    class Fd extends n {
      constructor(_, S, L) {
        super(_), (this.cell = S), (this.index = L);
      }
    }
    class Pu extends i {
      constructor(_) {
        super(_), (this.cellToApiMap_ = new Map()), (this.emitter_ = new f());
        const S = this.controller_.valueController;
        S.cellControllers.forEach((L, z) => {
          const re = new Du(L);
          this.cellToApiMap_.set(L, re),
            L.emitter.on("click", () => {
              const _e = z % S.size[0],
                Le = Math.floor(z / S.size[0]);
              this.emitter_.emit("click", {
                event: new Fd(this, re, [_e, Le]),
              });
            });
        });
      }
      cell(_, S) {
        const L = this.controller_.valueController,
          z = L.cellControllers[S * L.size[0] + _];
        return this.cellToApiMap_.get(z);
      }
      on(_, S) {
        const L = S.bind(this);
        return (
          this.emitter_.on(_, (z) => {
            L(z.event);
          }),
          this
        );
      }
    }
    class Fl {
      constructor(_, S) {
        this.size = S.size;
        const [L, z] = this.size,
          re = [];
        for (let _e = 0; _e < z; _e++)
          for (let Le = 0; Le < L; Le++) {
            const It = new I(_, {
              props: O.fromObject(Object.assign({}, S.cellConfig(Le, _e))),
              viewProps: fe.create(),
            });
            re.push(It);
          }
        (this.cellCs_ = re),
          (this.viewProps = fe.create()),
          this.viewProps.handleDispose(() => {
            this.cellCs_.forEach((_e) => {
              _e.viewProps.set("disposed", !0);
            });
          }),
          (this.view = new pe(_, {
            viewProps: this.viewProps,
            viewName: "btngrid",
          })),
          (this.view.element.style.gridTemplateColumns = `repeat(${L}, 1fr)`),
          this.cellCs_.forEach((_e) => {
            this.view.element.appendChild(_e.view.element);
          });
      }
      get cellControllers() {
        return this.cellCs_;
      }
    }
    const Od = {
      id: "buttongrid",
      type: "blade",
      css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}',
      accept(T) {
        const _ = ie,
          S = Q(T, {
            cells: _.required.function,
            size: _.required.array(_.required.number),
            view: _.required.constant("buttongrid"),
            label: _.optional.string,
          });
        return S ? { params: S } : null;
      },
      controller(T) {
        return new he(T.document, {
          blade: T.blade,
          props: O.fromObject({ label: T.params.label }),
          valueController: new Fl(T.document, {
            cellConfig: T.params.cells,
            size: T.params.size,
          }),
        });
      },
      api(T) {
        return !(T.controller instanceof he) ||
          !(T.controller.valueController instanceof Fl)
          ? null
          : new Pu(T.controller);
      },
    };
    class Au extends i {
      get label() {
        return this.controller_.props.get("label");
      }
      set label(_) {
        this.controller_.props.set("label", _);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(_) {
        this.controller_.valueController.value.rawValue = _;
      }
      on(_, S) {
        const L = S.bind(this);
        return (
          this.controller_.valueController.value.emitter.on(_, (z) => {
            L(new s(this, z.rawValue, void 0, z.options.last));
          }),
          this
        );
      }
    }
    function dn(T, _, S) {
      return T * (1 - S) + _ * S;
    }
    const Nd = 20,
      Bd = 0.001,
      Ol = 100;
    function Vd(T, _) {
      let S = 0.25,
        L = 0.5,
        z = -1;
      for (let re = 0; re < Nd; re++) {
        const [_e, Le] = T.curve(L);
        if (
          ((L += S * (_e < _ ? 1 : -1)),
          (z = Le),
          (S *= 0.5),
          Math.abs(_ - _e) < Bd)
        )
          break;
      }
      return z;
    }
    class Ms {
      constructor(_ = 0, S = 0, L = 1, z = 1) {
        (this.cache_ = []), (this.comps_ = [_, S, L, z]);
      }
      get x1() {
        return this.comps_[0];
      }
      get y1() {
        return this.comps_[1];
      }
      get x2() {
        return this.comps_[2];
      }
      get y2() {
        return this.comps_[3];
      }
      static isObject(_) {
        return o(_) || !Array.isArray(_)
          ? !1
          : typeof _[0] == "number" &&
              typeof _[1] == "number" &&
              typeof _[2] == "number" &&
              typeof _[3] == "number";
      }
      static equals(_, S) {
        return _.x1 === S.x1 && _.y1 === S.y1 && _.x2 === S.x2 && _.y2 === S.y2;
      }
      curve(_) {
        const S = dn(0, this.x1, _),
          L = dn(0, this.y1, _),
          z = dn(this.x1, this.x2, _),
          re = dn(this.y1, this.y2, _),
          _e = dn(this.x2, 1, _),
          Le = dn(this.y2, 1, _),
          It = dn(S, z, _),
          pn = dn(L, re, _),
          fn = dn(z, _e, _),
          Dt = dn(re, Le, _);
        return [dn(It, fn, _), dn(pn, Dt, _)];
      }
      y(_) {
        if (this.cache_.length === 0) {
          const S = [];
          for (let L = 0; L < Ol; L++) S.push(Vd(this, li(L, 0, Ol - 1, 0, 1)));
          this.cache_ = S;
        }
        return this.cache_[Math.round(li(Sr(_, 0, 1), 0, 1, 0, Ol - 1))];
      }
      toObject() {
        return [this.comps_[0], this.comps_[1], this.comps_[2], this.comps_[3]];
      }
    }
    const Nl = {
      toComponents: (T) => T.toObject(),
      fromComponents: (T) => new Ms(...T),
    };
    function zd(T) {
      const _ = Ut(2);
      return `cubic-bezier(${T.toObject()
        .map((L) => _(L))
        .join(", ")})`;
    }
    const Bl = [0, 0.5, 0.5, 1];
    function Ud(T) {
      const _ = T.match(
        /^cubic-bezier\s*\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*\)$/
      );
      if (!_) return new Ms(...Bl);
      const S = [_[1], _[2], _[3], _[4]].reduce((L, z) => {
        if (!L) return null;
        const re = Number(z);
        return isNaN(re) ? null : [...L, re];
      }, []);
      return new Ms(...(S ?? Bl));
    }
    const Hs = d("cbz");
    class Lu {
      constructor(_, S) {
        (this.element = _.createElement("div")),
          this.element.classList.add(Hs()),
          S.viewProps.bindClassModifiers(this.element),
          S.foldable.bindExpandedClass(this.element, Hs(void 0, "expanded")),
          b(S.foldable, "completed", M(this.element, Hs(void 0, "cpl")));
        const L = _.createElement("div");
        L.classList.add(Hs("h")), this.element.appendChild(L);
        const z = _.createElement("button");
        z.classList.add(Hs("b")), S.viewProps.bindDisabled(z);
        const re = _.createElementNS(Se, "svg");
        (re.innerHTML = '<path d="M2 13C8 13 8 3 14 3"/>'),
          z.appendChild(re),
          L.appendChild(z),
          (this.buttonElement = z);
        const _e = _.createElement("div");
        if (
          (_e.classList.add(Hs("t")),
          L.appendChild(_e),
          (this.textElement = _e),
          S.pickerLayout === "inline")
        ) {
          const Le = _.createElement("div");
          Le.classList.add(Hs("p")),
            this.element.appendChild(Le),
            (this.pickerElement = Le);
        } else this.pickerElement = null;
      }
    }
    const ha = d("cbzp");
    class Ru {
      constructor(_, S) {
        (this.element = _.createElement("div")),
          this.element.classList.add(ha()),
          S.viewProps.bindClassModifiers(this.element);
        const L = _.createElement("div");
        L.classList.add(ha("g")),
          this.element.appendChild(L),
          (this.graphElement = L);
        const z = _.createElement("div");
        z.classList.add(ha("t")),
          this.element.appendChild(z),
          (this.textElement = z);
      }
    }
    function jn(T, _) {
      const S = new MutationObserver((z) => {
          for (const re of z)
            re.type === "childList" &&
              re.addedNodes.forEach((_e) => {
                _e.contains(_e) && (_(), S.disconnect());
              });
        }),
        L = T.ownerDocument;
      S.observe(L.body, { attributes: !0, childList: !0, subtree: !0 });
    }
    const us = d("cbzg");
    function Gd(T, _) {
      return (S) => _(T(S));
    }
    class gi {
      constructor(_, S) {
        (this.element = _.createElement("div")),
          this.element.classList.add(us()),
          S.viewProps.bindClassModifiers(this.element),
          S.viewProps.bindTabIndex(this.element);
        const L = _.createElement("div");
        L.classList.add(us("p")),
          this.element.appendChild(L),
          (this.previewElement = L);
        const z = _.createElementNS(Se, "svg");
        z.classList.add(us("g")),
          this.element.appendChild(z),
          (this.svgElem_ = z);
        const re = _.createElementNS(Se, "path");
        re.classList.add(us("u")),
          this.svgElem_.appendChild(re),
          (this.guideElem_ = re);
        const _e = _.createElementNS(Se, "polyline");
        _e.classList.add(us("l")),
          this.svgElem_.appendChild(_e),
          (this.lineElem_ = _e),
          (this.handleElems_ = [
            _.createElement("div"),
            _.createElement("div"),
          ]),
          this.handleElems_.forEach((Le) => {
            Le.classList.add(us("h")), this.element.appendChild(Le);
          }),
          (this.vectorElems_ = [
            _.createElementNS(Se, "line"),
            _.createElementNS(Se, "line"),
          ]),
          this.vectorElems_.forEach((Le) => {
            Le.classList.add(us("v")), this.svgElem_.appendChild(Le);
          }),
          (this.value_ = S.value),
          this.value_.emitter.on("change", this.onValueChange_.bind(this)),
          (this.sel_ = S.selection),
          this.handleElems_.forEach((Le, It) => {
            v(
              this.sel_,
              Gd((pn) => pn === It, M(Le, us("h", "sel")))
            );
          }),
          jn(this.element, () => {
            this.refresh();
          });
      }
      getVertMargin_(_) {
        return _ * 0.25;
      }
      valueToPosition(_, S) {
        const L = this.element.getBoundingClientRect(),
          z = L.width,
          re = L.height,
          _e = this.getVertMargin_(re);
        return { x: li(_, 0, 1, 0, z), y: li(S, 0, 1, re - _e, _e) };
      }
      positionToValue(_, S) {
        const L = this.element.getBoundingClientRect(),
          z = L.width,
          re = L.height,
          _e = this.getVertMargin_(re);
        return { x: Sr(li(_, 0, z, 0, 1), 0, 1), y: li(S, re - _e, _e, 0, 1) };
      }
      refresh() {
        this.guideElem_.setAttributeNS(
          null,
          "d",
          [0, 1]
            .map((re) => {
              const _e = this.valueToPosition(0, re),
                Le = this.valueToPosition(1, re);
              return [`M ${_e.x},${_e.y}`, `L ${Le.x},${Le.y}`].join(" ");
            })
            .join(" ")
        );
        const _ = this.value_.rawValue,
          S = [];
        let L = 0;
        for (;;) {
          const re = this.valueToPosition(..._.curve(L));
          if ((S.push([re.x, re.y].join(",")), L >= 1)) break;
          L = Math.min(L + 0.05, 1);
        }
        this.lineElem_.setAttributeNS(null, "points", S.join(" "));
        const z = _.toObject();
        [0, 1].forEach((re) => {
          const _e = this.valueToPosition(re, re),
            Le = this.valueToPosition(z[re * 2], z[re * 2 + 1]),
            It = this.vectorElems_[re];
          It.setAttributeNS(null, "x1", String(_e.x)),
            It.setAttributeNS(null, "y1", String(_e.y)),
            It.setAttributeNS(null, "x2", String(Le.x)),
            It.setAttributeNS(null, "y2", String(Le.y));
          const pn = this.handleElems_[re];
          (pn.style.left = `${Le.x}px`), (pn.style.top = `${Le.y}px`);
        });
      }
      onValueChange_() {
        this.refresh();
      }
    }
    const ku = 24,
      ao = 400,
      Vl = 1e3,
      Ts = d("cbzprv");
    class Er {
      constructor(_, S) {
        (this.stopped_ = !0),
          (this.startTime_ = -1),
          (this.onDispose_ = this.onDispose_.bind(this)),
          (this.onTimer_ = this.onTimer_.bind(this)),
          (this.onValueChange_ = this.onValueChange_.bind(this)),
          (this.element = _.createElement("div")),
          this.element.classList.add(Ts()),
          S.viewProps.bindClassModifiers(this.element);
        const L = _.createElementNS(Se, "svg");
        L.classList.add(Ts("g")),
          this.element.appendChild(L),
          (this.svgElem_ = L);
        const z = _.createElementNS(Se, "path");
        z.classList.add(Ts("t")),
          this.svgElem_.appendChild(z),
          (this.ticksElem_ = z);
        const re = _.createElement("div");
        re.classList.add(Ts("m")),
          this.element.appendChild(re),
          (this.markerElem_ = re),
          (this.value_ = S.value),
          this.value_.emitter.on("change", this.onValueChange_),
          S.viewProps.handleDispose(this.onDispose_),
          jn(this.element, () => {
            this.refresh();
          });
      }
      play() {
        this.stop(),
          this.updateMarker_(0),
          this.markerElem_.classList.add(Ts("m", "a")),
          (this.startTime_ = new Date().getTime() + ao),
          (this.stopped_ = !1),
          requestAnimationFrame(this.onTimer_);
      }
      stop() {
        (this.stopped_ = !0), this.markerElem_.classList.remove(Ts("m", "a"));
      }
      onDispose_() {
        this.stop();
      }
      updateMarker_(_) {
        const S = this.value_.rawValue.y(Sr(_, 0, 1));
        this.markerElem_.style.left = `${S * 100}%`;
      }
      refresh() {
        const _ = this.svgElem_.getBoundingClientRect(),
          S = _.width,
          L = _.height,
          z = [],
          re = this.value_.rawValue;
        for (let _e = 0; _e < ku; _e++) {
          const Le = li(_e, 0, ku - 1, 0, 1),
            It = li(re.y(Le), 0, 1, 0, S);
          z.push(`M ${It},0 v${L}`);
        }
        this.ticksElem_.setAttributeNS(null, "d", z.join(" "));
      }
      onTimer_() {
        if (this.startTime_ === null) return;
        const _ = new Date().getTime() - this.startTime_,
          S = _ / Vl;
        this.updateMarker_(S),
          _ > Vl + ao && this.stop(),
          this.stopped_ || requestAnimationFrame(this.onTimer_);
      }
      onValueChange_() {
        this.refresh(), this.play();
      }
    }
    function Ei(T, _, S, L) {
      const z = S - T,
        re = L - _;
      return Math.sqrt(z * z + re * re);
    }
    function lo(T, _, S, L) {
      const z = Ei(T, _, S, L),
        re = Math.atan2(L - _, S - T),
        _e = (Math.round(re / (Math.PI / 4)) * Math.PI) / 4;
      return { x: T + Math.cos(_e) * z, y: _ + Math.sin(_e) * z };
    }
    class qn {
      constructor(_, S) {
        (this.onKeyDown_ = this.onKeyDown_.bind(this)),
          (this.onKeyUp_ = this.onKeyUp_.bind(this)),
          (this.onPointerDown_ = this.onPointerDown_.bind(this)),
          (this.onPointerMove_ = this.onPointerMove_.bind(this)),
          (this.onPointerUp_ = this.onPointerUp_.bind(this)),
          (this.baseStep_ = S.baseStep),
          (this.value = S.value),
          (this.sel_ = k(0)),
          (this.viewProps = S.viewProps),
          (this.view = new gi(_, {
            selection: this.sel_,
            value: this.value,
            viewProps: this.viewProps,
          })),
          this.view.element.addEventListener("keydown", this.onKeyDown_),
          this.view.element.addEventListener("keyup", this.onKeyUp_),
          (this.prevView_ = new Er(_, {
            value: this.value,
            viewProps: this.viewProps,
          })),
          this.prevView_.element.addEventListener("mousedown", (z) => {
            z.stopImmediatePropagation(),
              z.preventDefault(),
              this.prevView_.play();
          }),
          this.view.previewElement.appendChild(this.prevView_.element);
        const L = new la(this.view.element);
        L.emitter.on("down", this.onPointerDown_),
          L.emitter.on("move", this.onPointerMove_),
          L.emitter.on("up", this.onPointerUp_);
      }
      refresh() {
        this.view.refresh(), this.prevView_.refresh(), this.prevView_.play();
      }
      updateValue_(_, S, L) {
        const z = this.sel_.rawValue,
          re = this.value.rawValue.toObject(),
          _e = this.view.positionToValue(_.x, _.y),
          Le = S ? lo(z, z, _e.x, _e.y) : _e;
        (re[z * 2] = Le.x),
          (re[z * 2 + 1] = Le.y),
          this.value.setRawValue(new Ms(...re), L);
      }
      onPointerDown_(_) {
        const S = _.data;
        if (!S.point) return;
        const L = this.value.rawValue,
          z = this.view.valueToPosition(L.x1, L.y1),
          re = Ei(S.point.x, S.point.y, z.x, z.y),
          _e = this.view.valueToPosition(L.x2, L.y2),
          Le = Ei(S.point.x, S.point.y, _e.x, _e.y);
        (this.sel_.rawValue = re <= Le ? 0 : 1),
          this.updateValue_(S.point, _.shiftKey, { forceEmit: !1, last: !1 });
      }
      onPointerMove_(_) {
        const S = _.data;
        S.point &&
          this.updateValue_(S.point, _.shiftKey, { forceEmit: !1, last: !1 });
      }
      onPointerUp_(_) {
        const S = _.data;
        S.point &&
          this.updateValue_(S.point, _.shiftKey, { forceEmit: !0, last: !0 });
      }
      onKeyDown_(_) {
        _u(_.key) && _.preventDefault();
        const S = this.sel_.rawValue,
          L = this.value.rawValue.toObject();
        (L[S * 2] += ys(this.baseStep_, Ll(_))),
          (L[S * 2 + 1] += ys(this.baseStep_, Ss(_))),
          this.value.setRawValue(new Ms(...L), { forceEmit: !1, last: !1 });
      }
      onKeyUp_(_) {
        _u(_.key) && _.preventDefault();
        const S = ys(this.baseStep_, Ll(_)),
          L = ys(this.baseStep_, Ss(_));
        (S === 0 && L === 0) ||
          this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0,
          });
      }
    }
    class Iu {
      constructor(_, S) {
        (this.value = S.value),
          (this.viewProps = S.viewProps),
          (this.view = new Ru(_, { viewProps: this.viewProps })),
          (this.gc_ = new qn(_, {
            baseStep: S.axis.baseStep,
            value: this.value,
            viewProps: this.viewProps,
          })),
          this.view.graphElement.appendChild(this.gc_.view.element);
        const L = Object.assign(Object.assign({}, S.axis), {
            constraint: new Re({ max: 1, min: 0 }),
          }),
          z = Object.assign(Object.assign({}, S.axis), { constraint: void 0 });
        (this.tc_ = new Gs(_, {
          assembly: Nl,
          axes: [L, z, L, z],
          parser: ai,
          value: this.value,
          viewProps: this.viewProps,
        })),
          this.view.textElement.appendChild(this.tc_.view.element);
      }
      get allFocusableElements() {
        return [
          this.gc_.view.element,
          ...this.tc_.view.textViews.map((_) => _.inputElement),
        ];
      }
      refresh() {
        this.gc_.refresh();
      }
    }
    class da {
      constructor(_, S) {
        (this.onButtonBlur_ = this.onButtonBlur_.bind(this)),
          (this.onButtonClick_ = this.onButtonClick_.bind(this)),
          (this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this)),
          (this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this)),
          (this.value = S.value),
          (this.viewProps = S.viewProps),
          (this.foldable_ = Bt(S.expanded)),
          (this.view = new Lu(_, {
            foldable: this.foldable_,
            pickerLayout: S.pickerLayout,
            viewProps: this.viewProps,
          })),
          this.view.buttonElement.addEventListener("blur", this.onButtonBlur_),
          this.view.buttonElement.addEventListener(
            "click",
            this.onButtonClick_
          ),
          (this.tc_ = new Ct(_, {
            parser: Ud,
            props: O.fromObject({ formatter: zd }),
            value: this.value,
            viewProps: this.viewProps,
          })),
          this.view.textElement.appendChild(this.tc_.view.element),
          (this.popC_ =
            S.pickerLayout === "popup"
              ? new Ve(_, { viewProps: this.viewProps })
              : null);
        const L = new Iu(_, {
          axis: S.axis,
          value: this.value,
          viewProps: this.viewProps,
        });
        L.allFocusableElements.forEach((z) => {
          z.addEventListener("blur", this.onPopupChildBlur_),
            z.addEventListener("keydown", this.onPopupChildKeydown_);
        }),
          (this.pickerC_ = L),
          this.popC_
            ? (this.view.element.appendChild(this.popC_.view.element),
              this.popC_.view.element.appendChild(this.pickerC_.view.element),
              v(this.popC_.shows, (z) => {
                z && L.refresh();
              }),
              Hn({
                primary: this.foldable_.value("expanded"),
                secondary: this.popC_.shows,
                forward: (z) => z.rawValue,
                backward: (z, re) => re.rawValue,
              }))
            : this.view.pickerElement &&
              (this.view.pickerElement.appendChild(this.pickerC_.view.element),
              N(this.foldable_, this.view.pickerElement));
      }
      onButtonBlur_(_) {
        if (!this.popC_) return;
        const S = _.relatedTarget;
        (!S || !this.popC_.view.element.contains(S)) &&
          (this.popC_.shows.rawValue = !1);
      }
      onButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")),
          this.foldable_.get("expanded") &&
            this.pickerC_.allFocusableElements[0].focus();
      }
      onPopupChildBlur_(_) {
        if (!this.popC_) return;
        const S = this.popC_.view.element,
          L = Pe(_);
        (L && S.contains(L)) ||
          (L && L === this.view.buttonElement && !Ke(S.ownerDocument)) ||
          (this.popC_.shows.rawValue = !1);
      }
      onPopupChildKeydown_(_) {
        this.popC_ && _.key === "Escape" && (this.popC_.shows.rawValue = !1);
      }
    }
    function zl() {
      return new Ad({
        assembly: Nl,
        components: [0, 1, 2, 3].map((T) =>
          T % 2 === 0 ? new Re({ min: 0, max: 1 }) : void 0
        ),
      });
    }
    const Ws = {
      id: "cubic-bezier",
      type: "blade",
      css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}',
      accept(T) {
        const _ = ie,
          S = Q(T, {
            value: _.required.array(_.required.number),
            view: _.required.constant("cubicbezier"),
            expanded: _.optional.boolean,
            label: _.optional.string,
            picker: _.optional.custom((L) =>
              L === "inline" || L === "popup" ? L : void 0
            ),
          });
        return S ? { params: S } : null;
      },
      controller(T) {
        var _, S;
        const L = new Ms(...T.params.value),
          z = k(L, { constraint: zl(), equals: Ms.equals }),
          re = new da(T.document, {
            axis: {
              baseStep: 0.1,
              textProps: O.fromObject({
                draggingScale: 0.01,
                formatter: Ut(2),
              }),
            },
            expanded: (_ = T.params.expanded) !== null && _ !== void 0 ? _ : !1,
            pickerLayout:
              (S = T.params.picker) !== null && S !== void 0 ? S : "popup",
            value: z,
            viewProps: T.viewProps,
          });
        return new xe(T.document, {
          blade: T.blade,
          props: O.fromObject({ label: T.params.label }),
          valueController: re,
        });
      },
      api(T) {
        return !(T.controller instanceof xe) ||
          !(T.controller.valueController instanceof da)
          ? null
          : new Au(T.controller);
      },
    };
    class qt extends i {
      begin() {
        this.controller_.valueController.begin();
      }
      end() {
        this.controller_.valueController.end();
      }
    }
    const Ul = 20;
    class ci {
      constructor() {
        (this.start_ = null),
          (this.duration_ = 0),
          (this.fps_ = null),
          (this.frameCount_ = 0),
          (this.timestamps_ = []);
      }
      get duration() {
        return this.duration_;
      }
      get fps() {
        return this.fps_;
      }
      begin(_) {
        this.start_ = _.getTime();
      }
      calculateFps_(_) {
        if (this.timestamps_.length === 0) return null;
        const S = this.timestamps_[0];
        return (1e3 * (this.frameCount_ - S.frameCount)) / (_ - S.time);
      }
      compactTimestamps_() {
        if (this.timestamps_.length <= Ul) return;
        const _ = this.timestamps_.length - Ul;
        this.timestamps_.splice(0, _);
        const S = this.timestamps_[0].frameCount;
        this.timestamps_.forEach((L) => {
          L.frameCount -= S;
        }),
          (this.frameCount_ -= S);
      }
      end(_) {
        if (this.start_ === null) return;
        const S = _.getTime();
        (this.duration_ = S - this.start_),
          (this.start_ = null),
          (this.fps_ = this.calculateFps_(S)),
          this.timestamps_.push({ frameCount: this.frameCount_, time: S }),
          ++this.frameCount_,
          this.compactTimestamps_();
      }
    }
    const Cr = d("fps");
    class $i {
      constructor(_, S) {
        (this.element = _.createElement("div")),
          this.element.classList.add(Cr()),
          S.viewProps.bindClassModifiers(this.element),
          (this.graphElement = _.createElement("div")),
          this.graphElement.classList.add(Cr("g")),
          this.element.appendChild(this.graphElement);
        const L = _.createElement("div");
        L.classList.add(Cr("l")), this.element.appendChild(L);
        const z = _.createElement("span");
        z.classList.add(Cr("v")),
          (z.textContent = "--"),
          L.appendChild(z),
          (this.valueElement = z);
        const re = _.createElement("span");
        re.classList.add(Cr("u")), (re.textContent = "FPS"), L.appendChild(re);
      }
    }
    class Gl {
      constructor(_, S) {
        (this.stopwatch_ = new ci()),
          (this.onTick_ = this.onTick_.bind(this)),
          (this.ticker_ = S.ticker),
          this.ticker_.emitter.on("tick", this.onTick_),
          (this.value_ = S.value),
          (this.viewProps = S.viewProps),
          (this.view = new $i(_, { viewProps: this.viewProps })),
          (this.graphC_ = new Id(_, {
            formatter: Ut(0),
            lineCount: S.lineCount,
            props: O.fromObject({ maxValue: S.maxValue, minValue: S.minValue }),
            value: this.value_,
            viewProps: this.viewProps,
          })),
          this.view.graphElement.appendChild(this.graphC_.view.element),
          this.viewProps.handleDispose(() => {
            this.graphC_.viewProps.set("disposed", !0), this.ticker_.dispose();
          });
      }
      begin() {
        this.stopwatch_.begin(new Date());
      }
      end() {
        this.stopwatch_.end(new Date());
      }
      onTick_() {
        const _ = this.stopwatch_.fps;
        if (_ !== null) {
          const S = this.value_.rawValue;
          (this.value_.rawValue = Ii(S, _)),
            (this.view.valueElement.textContent = _.toFixed(0));
        }
      }
    }
    function co(T, _) {
      return _ === 0 ? new we() : new Ce(T, _ ?? kd.monitor.defaultInterval);
    }
    const Hl = {
      id: "fpsgraph",
      type: "blade",
      accept(T) {
        const _ = ie,
          S = Q(T, {
            view: _.required.constant("fpsgraph"),
            interval: _.optional.number,
            label: _.optional.string,
            lineCount: _.optional.number,
            max: _.optional.number,
            min: _.optional.number,
          });
        return S ? { params: S } : null;
      },
      controller(T) {
        var _, S, L, z;
        const re = (_ = T.params.interval) !== null && _ !== void 0 ? _ : 500;
        return new he(T.document, {
          blade: T.blade,
          props: O.fromObject({ label: T.params.label }),
          valueController: new Gl(T.document, {
            lineCount:
              (S = T.params.lineCount) !== null && S !== void 0 ? S : 2,
            maxValue: (L = T.params.max) !== null && L !== void 0 ? L : 90,
            minValue: (z = T.params.min) !== null && z !== void 0 ? z : 0,
            ticker: co(T.document, re),
            value: Ti(80),
            viewProps: T.viewProps,
          }),
        });
      },
      api(T) {
        return !(T.controller instanceof he) ||
          !(T.controller.valueController instanceof Gl)
          ? null
          : new qt(T.controller);
      },
    };
    class Yi {
      constructor(_, S) {
        (this.min = _), (this.max = S);
      }
      static isObject(_) {
        if (typeof _ != "object" || _ === null) return !1;
        const S = _.min,
          L = _.max;
        return !(typeof S != "number" || typeof L != "number");
      }
      static equals(_, S) {
        return _.min === S.min && _.max === S.max;
      }
      get length() {
        return this.max - this.min;
      }
      toObject() {
        return { min: this.min, max: this.max };
      }
    }
    const Wl = {
      fromComponents: (T) => new Yi(T[0], T[1]),
      toComponents: (T) => [T.min, T.max],
    };
    class uo {
      constructor(_) {
        this.edge = _;
      }
      constrain(_) {
        var S, L, z, re, _e, Le, It, pn;
        if (_.min <= _.max)
          return new Yi(
            (L =
              (S = this.edge) === null || S === void 0
                ? void 0
                : S.constrain(_.min)) !== null && L !== void 0
              ? L
              : _.min,
            (re =
              (z = this.edge) === null || z === void 0
                ? void 0
                : z.constrain(_.max)) !== null && re !== void 0
              ? re
              : _.max
          );
        const fn = (_.min + _.max) / 2;
        return new Yi(
          (Le =
            (_e = this.edge) === null || _e === void 0
              ? void 0
              : _e.constrain(fn)) !== null && Le !== void 0
            ? Le
            : fn,
          (pn =
            (It = this.edge) === null || It === void 0
              ? void 0
              : It.constrain(fn)) !== null && pn !== void 0
            ? pn
            : fn
        );
      }
    }
    const jl = d("rsltxt");
    class pa {
      constructor(_, S) {
        (this.sliderView_ = S.sliderView),
          (this.textView_ = S.textView),
          (this.element = _.createElement("div")),
          this.element.classList.add(jl());
        const L = _.createElement("div");
        L.classList.add(jl("s")),
          L.appendChild(this.sliderView_.element),
          this.element.appendChild(L);
        const z = _.createElement("div");
        z.classList.add(jl("t")),
          z.appendChild(this.textView_.element),
          this.element.appendChild(z);
      }
    }
    const Cn = d("rsl");
    class ho {
      constructor(_, S) {
        (this.onSliderPropsChange_ = this.onSliderPropsChange_.bind(this)),
          (this.onValueChange_ = this.onValueChange_.bind(this)),
          (this.sliderProps_ = S.sliderProps),
          this.sliderProps_.emitter.on("change", this.onSliderPropsChange_),
          (this.element = _.createElement("div")),
          this.element.classList.add(Cn()),
          S.viewProps.bindClassModifiers(this.element),
          (this.value_ = S.value),
          this.value_.emitter.on("change", this.onValueChange_);
        const L = _.createElement("div");
        L.classList.add(Cn("t")),
          this.element.appendChild(L),
          (this.trackElement = L);
        const z = _.createElement("div");
        z.classList.add(Cn("b")), L.appendChild(z), (this.barElement = z);
        const re = ["min", "max"].map((_e) => {
          const Le = _.createElement("div");
          return Le.classList.add(Cn("k"), Cn("k", _e)), L.appendChild(Le), Le;
        });
        (this.knobElements = [re[0], re[1]]), this.update_();
      }
      valueToX_(_) {
        const S = this.sliderProps_.get("minValue"),
          L = this.sliderProps_.get("maxValue");
        return Sr(li(_, S, L, 0, 1), 0, 1) * 100;
      }
      update_() {
        const _ = this.value_.rawValue;
        _.length === 0
          ? this.element.classList.add(Cn(void 0, "zero"))
          : this.element.classList.remove(Cn(void 0, "zero"));
        const S = [this.valueToX_(_.min), this.valueToX_(_.max)];
        (this.barElement.style.left = `${S[0]}%`),
          (this.barElement.style.right = `${100 - S[1]}%`),
          this.knobElements.forEach((L, z) => {
            L.style.left = `${S[z]}%`;
          });
      }
      onSliderPropsChange_() {
        this.update_();
      }
      onValueChange_() {
        this.update_();
      }
    }
    class ql {
      constructor(_, S) {
        (this.grabbing_ = null),
          (this.grabOffset_ = 0),
          (this.onPointerDown_ = this.onPointerDown_.bind(this)),
          (this.onPointerMove_ = this.onPointerMove_.bind(this)),
          (this.onPointerUp_ = this.onPointerUp_.bind(this)),
          (this.sliderProps = S.sliderProps),
          (this.viewProps = S.viewProps),
          (this.value = S.value),
          (this.view = new ho(_, {
            sliderProps: this.sliderProps,
            value: this.value,
            viewProps: S.viewProps,
          }));
        const L = new la(this.view.trackElement);
        L.emitter.on("down", this.onPointerDown_),
          L.emitter.on("move", this.onPointerMove_),
          L.emitter.on("up", this.onPointerUp_);
      }
      ofs_() {
        return this.grabbing_ === "min"
          ? this.view.knobElements[0].getBoundingClientRect().width / 2
          : this.grabbing_ === "max"
          ? -this.view.knobElements[1].getBoundingClientRect().width / 2
          : 0;
      }
      valueFromData_(_) {
        if (!_.point) return null;
        const S = (_.point.x + this.ofs_()) / _.bounds.width,
          L = this.sliderProps.get("minValue"),
          z = this.sliderProps.get("maxValue");
        return li(S, 0, 1, L, z);
      }
      onPointerDown_(_) {
        if (!_.data.point) return;
        const S = _.data.point.x / _.data.bounds.width,
          L = this.value.rawValue,
          z = this.sliderProps.get("minValue"),
          re = this.sliderProps.get("maxValue"),
          _e = li(L.min, z, re, 0, 1),
          Le = li(L.max, z, re, 0, 1);
        Math.abs(Le - S) <= 0.025
          ? (this.grabbing_ = "max")
          : Math.abs(_e - S) <= 0.025
          ? (this.grabbing_ = "min")
          : S >= _e && S <= Le
          ? ((this.grabbing_ = "length"),
            (this.grabOffset_ = li(S - _e, 0, 1, 0, re - z)))
          : S < _e
          ? ((this.grabbing_ = "min"), this.onPointerMove_(_))
          : S > Le && ((this.grabbing_ = "max"), this.onPointerMove_(_));
      }
      applyPointToValue_(_, S) {
        const L = this.valueFromData_(_);
        if (L === null) return;
        const z = this.sliderProps.get("minValue"),
          re = this.sliderProps.get("maxValue");
        if (this.grabbing_ === "min")
          this.value.setRawValue(new Yi(L, this.value.rawValue.max), S);
        else if (this.grabbing_ === "max")
          this.value.setRawValue(new Yi(this.value.rawValue.min, L), S);
        else if (this.grabbing_ === "length") {
          const _e = this.value.rawValue.length;
          let Le = L - this.grabOffset_,
            It = Le + _e;
          Le < z
            ? ((Le = z), (It = z + _e))
            : It > re && ((Le = re - _e), (It = re)),
            this.value.setRawValue(new Yi(Le, It), S);
        }
      }
      onPointerMove_(_) {
        this.applyPointToValue_(_.data, { forceEmit: !1, last: !1 });
      }
      onPointerUp_(_) {
        this.applyPointToValue_(_.data, { forceEmit: !0, last: !0 }),
          (this.grabbing_ = null);
      }
    }
    class hs {
      constructor(_, S) {
        (this.value = S.value),
          (this.viewProps = S.viewProps),
          (this.sc_ = new ql(_, S));
        const L = {
          baseStep: S.baseStep,
          constraint: S.constraint,
          textProps: O.fromObject({
            draggingScale: S.draggingScale,
            formatter: S.formatter,
          }),
        };
        (this.tc_ = new Gs(_, {
          assembly: Wl,
          axes: [L, L],
          parser: S.parser,
          value: this.value,
          viewProps: S.viewProps,
        })),
          (this.view = new pa(_, {
            sliderView: this.sc_.view,
            textView: this.tc_.view,
          }));
      }
      get textController() {
        return this.tc_;
      }
    }
    function Fu(T) {
      return Yi.isObject(T) ? new Yi(T.min, T.max) : new Yi(0, 0);
    }
    function Xl(T, _) {
      T.writeProperty("max", _.max), T.writeProperty("min", _.min);
    }
    function Hd(T) {
      const _ = [],
        S = oo(T);
      S && _.push(S);
      const L = Rd(T);
      return L && _.push(L), new uo(new We(_));
    }
    const fa = {
      id: "input-interval",
      type: "input",
      css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}',
      accept: (T, _) => {
        if (!Yi.isObject(T)) return null;
        const S = ie,
          L = Q(_, {
            format: S.optional.function,
            max: S.optional.number,
            min: S.optional.number,
            step: S.optional.number,
          });
        return L ? { initialValue: new Yi(T.min, T.max), params: L } : null;
      },
      binding: {
        reader: (T) => Fu,
        constraint: (T) => Hd(T.params),
        equals: Yi.equals,
        writer: (T) => Xl,
      },
      controller(T) {
        var _;
        const S = T.value,
          L = T.constraint;
        if (!(L instanceof uo)) throw h.shouldNeverHappen();
        const z = (S.rawValue.min + S.rawValue.max) / 2,
          re =
            (_ = T.params.format) !== null && _ !== void 0
              ? _
              : Ut(so(L.edge, z)),
          _e = L.edge && H(L.edge, ne);
        if (_e)
          return new hs(T.document, {
            baseStep: kl(L.edge),
            constraint: L.edge,
            draggingScale: ca(L.edge, z),
            formatter: re,
            parser: ai,
            sliderProps: new O({
              maxValue: _e.values.value("max"),
              minValue: _e.values.value("min"),
            }),
            value: S,
            viewProps: T.viewProps,
          });
        const Le = {
          baseStep: kl(L.edge),
          constraint: L.edge,
          textProps: O.fromObject({ draggingScale: z, formatter: re }),
        };
        return new Gs(T.document, {
          assembly: Wl,
          axes: [Le, Le],
          parser: ai,
          value: S,
          viewProps: T.viewProps,
        });
      },
    };
    class js {
      constructor(_) {
        this.controller_ = _;
      }
      get disabled() {
        return this.controller_.viewProps.get("disabled");
      }
      set disabled(_) {
        this.controller_.viewProps.set("disabled", _);
      }
      get title() {
        var _;
        return (_ = this.controller_.props.get("title")) !== null &&
          _ !== void 0
          ? _
          : "";
      }
      set title(_) {
        this.controller_.props.set("title", _);
      }
    }
    class qs extends s {
      constructor(_, S, L, z, re) {
        super(_, z, re), (this.cell = S), (this.index = L);
      }
    }
    class po extends i {
      constructor(_) {
        super(_),
          (this.cellToApiMap_ = new Map()),
          this.controller_.valueController.cellControllers.forEach((L) => {
            const z = new js(L);
            this.cellToApiMap_.set(L, z);
          });
      }
      get value() {
        return this.controller_.value;
      }
      cell(_, S) {
        const L = this.controller_.valueController,
          z = L.cellControllers[S * L.size[0] + _];
        return this.cellToApiMap_.get(z);
      }
      on(_, S) {
        const L = S.bind(this);
        this.controller_.value.emitter.on(_, (z) => {
          const re = this.controller_.valueController,
            _e = re.findCellByValue(z.rawValue);
          if (!_e) return;
          const Le = this.cellToApiMap_.get(_e);
          if (!Le) return;
          const It = re.cellControllers.indexOf(_e);
          L(
            new qs(
              this,
              Le,
              [It % re.size[0], Math.floor(It / re.size[0])],
              z.rawValue,
              void 0
            )
          );
        });
      }
    }
    const fo = d("rad");
    class Ou {
      constructor(_, S) {
        (this.element = _.createElement("div")),
          this.element.classList.add(fo()),
          S.viewProps.bindClassModifiers(this.element);
        const L = _.createElement("label");
        L.classList.add(fo("l")), this.element.appendChild(L);
        const z = _.createElement("input");
        z.classList.add(fo("i")),
          (z.name = S.name),
          (z.type = "radio"),
          S.viewProps.bindDisabled(z),
          L.appendChild(z),
          (this.inputElement = z);
        const re = _.createElement("div");
        re.classList.add(fo("b")), L.appendChild(re);
        const _e = _.createElement("div");
        _e.classList.add(fo("t")),
          re.appendChild(_e),
          b(S.props, "title", (Le) => {
            _e.textContent = Le;
          });
      }
    }
    class Nu {
      constructor(_, S) {
        (this.props = S.props),
          (this.viewProps = S.viewProps),
          (this.view = new Ou(_, {
            name: S.name,
            props: this.props,
            viewProps: this.viewProps,
          }));
      }
    }
    class ma {
      constructor(_, S) {
        (this.cellCs_ = []),
          (this.cellValues_ = []),
          (this.onCellInputChange_ = this.onCellInputChange_.bind(this)),
          (this.size = S.size);
        const [L, z] = this.size;
        for (let re = 0; re < z; re++)
          for (let _e = 0; _e < L; _e++) {
            const Le = new Nu(_, {
              name: S.groupName,
              props: O.fromObject(Object.assign({}, S.cellConfig(_e, re))),
              viewProps: fe.create(),
            });
            this.cellCs_.push(Le),
              this.cellValues_.push(S.cellConfig(_e, re).value);
          }
        (this.value = S.value),
          v(this.value, (re) => {
            const _e = this.findCellByValue(re);
            _e && (_e.view.inputElement.checked = !0);
          }),
          (this.viewProps = fe.create()),
          (this.view = new pe(_, {
            viewProps: this.viewProps,
            viewName: "radgrid",
          })),
          (this.view.element.style.gridTemplateColumns = `repeat(${L}, 1fr)`),
          this.cellCs_.forEach((re) => {
            re.view.inputElement.addEventListener(
              "change",
              this.onCellInputChange_
            ),
              this.view.element.appendChild(re.view.element);
          });
      }
      get cellControllers() {
        return this.cellCs_;
      }
      findCellByValue(_) {
        const S = this.cellValues_.findIndex((L) => L === _);
        return S < 0 ? null : this.cellCs_[S];
      }
      onCellInputChange_(_) {
        const S = _.currentTarget,
          L = this.cellCs_.findIndex((z) => z.view.inputElement === S);
        L < 0 || (this.value.rawValue = this.cellValues_[L]);
      }
    }
    const Xs = (function () {
      return {
        id: "radiogrid",
        type: "blade",
        accept(T) {
          const _ = ie,
            S = Q(T, {
              cells: _.required.function,
              groupName: _.required.string,
              size: _.required.array(_.required.number),
              value: _.required.raw,
              view: _.required.constant("radiogrid"),
              label: _.optional.string,
            });
          return S ? { params: S } : null;
        },
        controller(T) {
          return new xe(T.document, {
            blade: T.blade,
            props: O.fromObject({ label: T.params.label }),
            valueController: new ma(T.document, {
              groupName: T.params.groupName,
              cellConfig: T.params.cells,
              size: T.params.size,
              value: k(T.params.value),
            }),
          });
        },
        api(T) {
          return !(T.controller instanceof xe) ||
            !(T.controller.valueController instanceof ma)
            ? null
            : new po(T.controller);
        },
      };
    })();
    function $l(T) {
      return {
        id: "input-radiogrid",
        type: "input",
        accept(_, S) {
          if (!T.isType(_)) return null;
          const L = ie,
            z = Q(S, {
              cells: L.required.function,
              groupName: L.required.string,
              size: L.required.array(L.required.number),
              view: L.required.constant("radiogrid"),
            });
          return z ? { initialValue: _, params: z } : null;
        },
        binding: T.binding,
        controller: (_) =>
          new ma(_.document, {
            cellConfig: _.params.cells,
            groupName: _.params.groupName,
            size: _.params.size,
            value: _.value,
          }),
      };
    }
    const Wd = $l({
        isType: (T) => typeof T == "number",
        binding: { reader: (T) => Jt, writer: (T) => En },
      }),
      jd = $l({
        isType: (T) => typeof T == "string",
        binding: { reader: (T) => un, writer: (T) => En },
      }),
      qd = $l({
        isType: (T) => typeof T == "boolean",
        binding: { reader: (T) => $, writer: (T) => En },
      }),
      Bu = [Od, Ws, Hl, fa, Xs, qd, Wd, jd];
    (t.ButtonCellApi = Du),
      (t.ButtonGridApi = Pu),
      (t.ButtonGridController = Fl),
      (t.CubicBezier = Ms),
      (t.CubicBezierApi = Au),
      (t.CubicBezierAssembly = Nl),
      (t.CubicBezierController = da),
      (t.CubicBezierGraphController = qn),
      (t.CubicBezierGraphView = gi),
      (t.CubicBezierPickerController = Iu),
      (t.CubicBezierPickerView = Ru),
      (t.CubicBezierPreviewView = Er),
      (t.CubicBezierView = Lu),
      (t.FpsGraphBladeApi = qt),
      (t.FpsGraphController = Gl),
      (t.FpsView = $i),
      (t.Fpswatch = ci),
      (t.Interval = Yi),
      (t.IntervalAssembly = Wl),
      (t.IntervalConstraint = uo),
      (t.RadioCellApi = js),
      (t.RadioController = Nu),
      (t.RadioGridApi = po),
      (t.RadioGridController = ma),
      (t.RadioView = Ou),
      (t.RangeSliderController = ql),
      (t.RangeSliderTextController = hs),
      (t.RangeSliderTextView = pa),
      (t.RangeSliderView = ho),
      (t.TpRadioGridChangeEvent = qs),
      (t.plugins = Bu),
      Object.defineProperty(t, "__esModule", { value: !0 });
  });
})(dm, dm.exports);
var pw = dm.exports;
const NA = FA(pw),
  BA = O1({ __proto__: null, default: NA }, [pw]);
const VA = "tp";
function zA(r) {
  return (t, i) =>
    [VA, "-", r, "v", t ? `_${t}` : "", i ? `-${i}` : ""].join("");
}
function UA(r, e) {
  const i = Object.keys(e).reduce((n, s) => {
    if (n === void 0) return;
    const a = e[s],
      o = a(r[s]);
    return o.succeeded
      ? Object.assign(Object.assign({}, n), { [s]: o.value })
      : void 0;
  }, {});
  return i;
}
function GA(r, e) {
  return r.reduce((t, i) => {
    if (t === void 0) return;
    const n = e(i);
    if (!(!n.succeeded || n.value === void 0)) return [...t, n.value];
  }, []);
}
function HA(r) {
  return r === null ? !1 : typeof r == "object";
}
function ir(r) {
  return (e) => (t) => {
    if (!e && t === void 0) return { succeeded: !1, value: void 0 };
    if (e && t === void 0) return { succeeded: !0, value: void 0 };
    const i = r(t);
    return i !== void 0
      ? { succeeded: !0, value: i }
      : { succeeded: !1, value: void 0 };
  };
}
function F_(r) {
  return {
    custom: (e) => ir(e)(r),
    boolean: ir((e) => (typeof e == "boolean" ? e : void 0))(r),
    number: ir((e) => (typeof e == "number" ? e : void 0))(r),
    string: ir((e) => (typeof e == "string" ? e : void 0))(r),
    function: ir((e) => (typeof e == "function" ? e : void 0))(r),
    constant: (e) => ir((t) => (t === e ? e : void 0))(r),
    raw: ir((e) => e)(r),
    object: (e) =>
      ir((t) => {
        if (HA(t)) return UA(t, e);
      })(r),
    array: (e) =>
      ir((t) => {
        if (Array.isArray(t)) return GA(t, e);
      })(r),
  };
}
const fw = { optional: F_(!0), required: F_(!1) };
function WA(r, e) {
  const t = fw.required.object(e)(r);
  return t.succeeded ? t.value : void 0;
}
function qa(r, e, t, i) {
  function n(s) {
    return s instanceof t
      ? s
      : new t(function (a) {
          a(s);
        });
  }
  return new (t || (t = Promise))(function (s, a) {
    function o(f) {
      try {
        h(i.next(f));
      } catch (c) {
        a(c);
      }
    }
    function u(f) {
      try {
        h(i.throw(f));
      } catch (c) {
        a(c);
      }
    }
    function h(f) {
      f.done ? s(f.value) : n(f.value).then(o, u);
    }
    h((i = i.apply(r, e || [])).next());
  });
}
function jA() {
  const r = document.createElement("canvas");
  (r.width = 128), (r.height = 64);
  const e = r.getContext("2d");
  return (
    (e.fillStyle = "#222"),
    e.fillRect(0, 0, r.width, r.height),
    (e.fillStyle = "#ddd"),
    (e.font = "monospaced"),
    (e.textAlign = "center"),
    (e.textBaseline = "middle"),
    e.fillText("No image", r.width * 0.5, r.height * 0.5),
    new Promise((t) => {
      r.toBlob((i) => {
        const n = new Image();
        (n.src = URL.createObjectURL(i)),
          (n.onload = () => {
            t(n);
          });
      });
    })
  );
}
function pf(r) {
  return qa(this, void 0, void 0, function* () {
    const e = new Image();
    return (
      (e.crossOrigin = "anonymous"),
      new Promise((t) => {
        (e.src = r),
          e.decode().then(() => {
            t(e);
          });
      })
    );
  });
}
function O_(r) {
  return new Promise((e) => {
    e(r);
  });
}
const So = zA("img");
class qA {
  constructor(e, t) {
    (this.element = e.createElement("div")),
      this.element.classList.add(So()),
      t.viewProps.bindClassModifiers(this.element),
      (this.input = e.createElement("input")),
      this.input.classList.add(So("input")),
      this.input.setAttribute("type", "file"),
      this.input.setAttribute("accept", t.extensions.join(",")),
      this.element.appendChild(this.input),
      (this.image_ = e.createElement("img")),
      this.image_.classList.add(So("image")),
      this.image_.classList.add(So(`image_${t.imageFit}`)),
      this.element.classList.add(So("area_root")),
      this.element.appendChild(this.image_);
  }
  changeImage(e) {
    this.image_.src = e;
  }
  changeDraggingState(e) {
    const t = this.element;
    e
      ? t == null || t.classList.add(So("area_dragging"))
      : t == null || t.classList.remove(So("area_dragging"));
  }
}
class XA {
  constructor(e, t) {
    (this.placeholderImage = null),
      (this.value = t.value),
      (this.viewProps = t.viewProps),
      (this.view = new qA(e, {
        viewProps: this.viewProps,
        extensions: t.extensions,
        imageFit: t.imageFit,
      })),
      (this.onFile = this.onFile.bind(this)),
      (this.onDrop = this.onDrop.bind(this)),
      (this.onDragOver = this.onDragOver.bind(this)),
      (this.onDragLeave = this.onDragLeave.bind(this)),
      this.view.input.addEventListener("change", this.onFile),
      this.view.element.addEventListener("drop", this.onDrop),
      this.view.element.addEventListener("dragover", this.onDragOver),
      this.view.element.addEventListener("dragleave", this.onDragLeave),
      this.viewProps.handleDispose(() => {
        this.view.input.removeEventListener("change", this.onFile),
          this.view.input.removeEventListener("drop", this.onDrop),
          this.view.input.removeEventListener("dragover", this.onDragOver),
          this.view.input.removeEventListener("dragleave", this.onDragLeave);
      }),
      this.value.emitter.on("change", this.handleValueChange.bind(this)),
      this.handleValueChange();
  }
  onFile(e) {
    const t = (e == null ? void 0 : e.target).files;
    if (!t || !t.length) return;
    const i = t[0],
      n = URL.createObjectURL(i);
    this.setValue(n), this.updateImage(n);
  }
  onDrop(e) {
    return qa(this, void 0, void 0, function* () {
      e.preventDefault();
      try {
        const { dataTransfer: t } = e,
          i = t == null ? void 0 : t.files[0];
        if (i) {
          const n = URL.createObjectURL(i);
          this.updateImage(n), this.setValue(n);
        } else {
          const n = t == null ? void 0 : t.getData("url");
          if (!n) throw new Error("No url");
          pf(n).then((s) =>
            qa(this, void 0, void 0, function* () {
              const a = yield O_(s);
              this.updateImage(a.src), this.setValue(a);
            })
          );
        }
      } catch (t) {
        console.error("Could not parse the dropped image", t);
      } finally {
        this.view.changeDraggingState(!1);
      }
    });
  }
  onDragOver(e) {
    e.preventDefault(), this.view.changeDraggingState(!0);
  }
  onDragLeave() {
    this.view.changeDraggingState(!1);
  }
  handleImage(e) {
    return qa(this, void 0, void 0, function* () {
      if (e instanceof HTMLImageElement)
        O_(e).then((t) => {
          this.updateImage(t.src);
        });
      else if (typeof e == "string") {
        let t = "";
        try {
          if (e === "placeholder") throw new Error("placeholder");
          new URL(e), (t = (yield pf(e)).src);
        } catch {
          t = (yield this.handlePlaceholderImage()).src;
        } finally {
          this.updateImage(t), this.setValue(t);
        }
      }
    });
  }
  updateImage(e) {
    this.view.changeImage(e);
  }
  setValue(e) {
    return qa(this, void 0, void 0, function* () {
      e instanceof HTMLImageElement
        ? this.value.setRawValue(e)
        : e
        ? this.value.setRawValue(yield pf(e))
        : this.value.setRawValue(yield this.handlePlaceholderImage());
    });
  }
  handleValueChange() {
    this.handleImage(this.value.rawValue);
  }
  handlePlaceholderImage() {
    return qa(this, void 0, void 0, function* () {
      return (
        this.placeholderImage || (this.placeholderImage = yield jA()),
        this.placeholderImage
      );
    });
  }
}
const $A = [".jpg", ".png", ".gif"],
  YA = {
    id: "input-image",
    type: "input",
    css: ".tp-imgv{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-imgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-imgv:hover{background-color:var(--in-bg-h)}.tp-imgv:focus{background-color:var(--in-bg-f)}.tp-imgv:active{background-color:var(--in-bg-a)}.tp-imgv:disabled{opacity:0.5}:root{--tp-plugin-image-dragging-color: hsla(230, 100%, 66%, 1.00)}.tp-imgv{cursor:pointer;display:grid;height:calc(var(--bld-us) * 3);overflow:hidden;position:relative}.tp-imgv.tp-v-disabled{opacity:0.5}.tp-imgv_input{width:100%;height:100%;opacity:0}.tp-imgv_image{width:100%;height:100%;position:absolute;pointer-events:none;border:0}.tp-imgv_image_contain{-o-object-fit:contain;object-fit:contain}.tp-imgv_image_cover{-o-object-fit:cover;object-fit:cover}.tp-imgv_area_root{transition:opacity 0.16s ease-in-out}.tp-imgv_area_dragging{border:2px dashed var(--tp-plugin-image-dragging-color);border-radius:6px;opacity:0.6}",
    accept(r, e) {
      if (!(r instanceof HTMLImageElement || typeof r == "string")) return null;
      const t = fw,
        i = WA(e, {
          view: t.required.constant("input-image"),
          acceptUrl: t.optional.boolean,
          imageFit: t.optional.custom((n) =>
            n === "contain" || n === "cover" ? n : void 0
          ),
          extensions: t.optional.array(t.required.string),
        });
      return i ? { initialValue: r, params: i } : null;
    },
    binding: {
      reader(r) {
        return (e) =>
          e instanceof HTMLImageElement
            ? e.src === ""
              ? "placeholder"
              : e.src
            : typeof e == "string"
            ? e
            : "placeholder";
      },
      writer(r) {
        return (e, t) => {
          e.write(t);
        };
      },
    },
    controller(r) {
      let e, t;
      return new XA(r.document, {
        value: r.value,
        imageFit:
          (e = r.params.imageFit) !== null && e !== void 0 ? e : "cover",
        viewProps: r.viewProps,
        extensions: (t = r.params.extensions) !== null && t !== void 0 ? t : $A,
      });
    },
  },
  KA = YA,
  ZA = Object.freeze(
    Object.defineProperty({ __proto__: null, plugin: KA }, Symbol.toStringTag, {
      value: "Module",
    })
  );
var JA = `<div class="gl-box">
  <svg viewBox="0 0 55 60">
    <text x="27" y="56" class="gl-fps">00 FPS</text>
    <text x="28" y="8" class="gl-mem"></text>
    <rect x="0" y="14" rx="4" ry="4" width="55" height="32"></rect>
    <polyline class="gl-chart"></polyline>
  </svg>
  <svg viewBox="0 0 14 60" class="gl-cpu-svg">
    <line x1="7" y1="38" x2="7" y2="11" class="opacity"/>
    <line x1="7" y1="38" x2="7" y2="11" class="gl-cpu" stroke-dasharray="0 27"/>
    <path d="M5.35 43c-.464 0-.812.377-.812.812v1.16c-.783.1972-1.421.812-1.595 1.624h-1.16c-.435 0-.812.348-.812.812s.348.812.812.812h1.102v1.653H1.812c-.464 0-.812.377-.812.812 0 .464.377.812.812.812h1.131c.1943.783.812 1.392 1.595 1.595v1.131c0 .464.377.812.812.812.464 0 .812-.377.812-.812V53.15h1.653v1.073c0 .464.377.812.812.812.464 0 .812-.377.812-.812v-1.131c.783-.1943 1.392-.812 1.595-1.595h1.131c.464 0 .812-.377.812-.812 0-.464-.377-.812-.812-.812h-1.073V48.22h1.102c.435 0 .812-.348.812-.812s-.348-.812-.812-.812h-1.16c-.1885-.783-.812-1.421-1.595-1.624v-1.131c0-.464-.377-.812-.812-.812-.464 0-.812.377-.812.812v1.073H6.162v-1.073c0-.464-.377-.812-.812-.812zm.58 3.48h2.088c.754 0 1.363.609 1.363 1.363v2.088c0 .754-.609 1.363-1.363 1.363H5.93c-.754 0-1.363-.609-1.363-1.363v-2.088c0-.754.609-1.363 1.363-1.363z"/>
  </svg>
  <svg viewBox="0 0 14 60" class="gl-gpu-svg">
    <line x1="7" y1="38" x2="7" y2="11" class="opacity"/>
    <line x1="7" y1="38" x2="7" y2="11" class="gl-gpu" stroke-dasharray="0 27"/>
    <path d="M1.94775 43.3772a.736.736 0 10-.00416 1.472c.58535.00231.56465.1288.6348.3197.07015.18975.04933.43585.04933.43585l-.00653.05405v8.671a.736.736 0 101.472 0v-1.4145c.253.09522.52785.1495.81765.1495h5.267c1.2535 0 2.254-.9752 2.254-2.185v-3.105c0-1.2075-1.00625-2.185-2.254-2.185h-5.267c-.28865 0-.5635.05405-.8165.1495.01806-.16445.04209-.598-.1357-1.0787-.22425-.6072-.9499-1.2765-2.0125-1.2765zm2.9095 3.6455c.42435 0 .7659.36225.7659.8119v2.9785c0 .44965-.34155.8119-.7659.8119s-.7659-.36225-.7659-.8119v-2.9785c0-.44965.34155-.8119.7659-.8119zm4.117 0a2.3 2.3 0 012.3 2.3 2.3 2.3 0 01-2.3 2.3 2.3 2.3 0 01-2.3-2.3 2.3 2.3 0 012.3-2.3z"/>
  </svg>
</div>`,
  QA = `#gl-bench {
  position:absolute;
  left:0;
  top:0;
  z-index:1000;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
}

#gl-bench div {
  position: relative;
  display: block;
  margin: 4px;
  padding: 0 7px 0 10px;
  background: #6c6;
  border-radius: 15px;
  cursor: pointer;
  opacity: 0.9;
}

#gl-bench svg {
  height: 60px;
  margin: 0 -1px;
}

#gl-bench text {
  font-size: 12px;
  font-family: Helvetica,Arial,sans-serif;
  font-weight: 700;
  dominant-baseline: middle;
  text-anchor: middle;
}

#gl-bench .gl-mem {
  font-size: 9px;
}

#gl-bench line {
  stroke-width: 5;
  stroke: #112211;
  stroke-linecap: round;
}

#gl-bench polyline {
  fill: none;
  stroke: #112211;
  stroke-linecap: round;
  stroke-linejoin: round;
  stroke-width: 3.5;
}

#gl-bench rect {
  fill: #448844;
}

#gl-bench .opacity {
  stroke: #448844;
}
`;
class eL {
  constructor(e, t = {}) {
    (this.css = QA),
      (this.svg = JA),
      (this.paramLogger = () => {}),
      (this.chartLogger = () => {}),
      (this.chartLen = 20),
      (this.chartHz = 20),
      (this.names = []),
      (this.cpuAccums = []),
      (this.gpuAccums = []),
      (this.activeAccums = []),
      (this.chart = new Array(this.chartLen)),
      (this.now = () =>
        performance && performance.now ? performance.now() : Date.now()),
      (this.updateUI = () => {
        [].forEach.call(this.nodes["gl-gpu-svg"], (o) => {
          o.style.display = this.trackGPU ? "inline" : "none";
        });
      }),
      Object.assign(this, t),
      (this.detected = 0),
      (this.finished = []),
      (this.isFramebuffer = 0),
      (this.frameId = 0);
    let i,
      n = 0,
      s,
      a = (o) => {
        ++n < 20
          ? (i = requestAnimationFrame(a))
          : ((this.detected = Math.ceil((1e3 * n) / (o - s) / 70)),
            cancelAnimationFrame(i)),
          s || (s = o);
      };
    if ((requestAnimationFrame(a), e)) {
      const o = async (h, f) =>
          Promise.resolve(
            setTimeout(() => {
              e.getError();
              const c = this.now() - h;
              f.forEach((d, m) => {
                d && (this.gpuAccums[m] += c);
              });
            }, 0)
          ),
        u = (h, f, c) =>
          function () {
            const d = f.now();
            h.apply(c, arguments),
              f.trackGPU && f.finished.push(o(d, f.activeAccums.slice(0)));
          };
      [
        "drawArrays",
        "drawElements",
        "drawArraysInstanced",
        "drawBuffers",
        "drawElementsInstanced",
        "drawRangeElements",
      ].forEach((h) => {
        e[h] && (e[h] = u(e[h], this, e));
      }),
        (e.getExtension = ((h, f) =>
          function () {
            let c = h.apply(e, arguments);
            return (
              c &&
                ["drawElementsInstancedANGLE", "drawBuffersWEBGL"].forEach(
                  (d) => {
                    c[d] && (c[d] = u(c[d], f, c));
                  }
                ),
              c
            );
          })(e.getExtension, this));
    }
    if (!this.withoutUI) {
      this.dom || (this.dom = document.body);
      let o = document.createElement("div");
      (o.id = "gl-bench"),
        this.dom.appendChild(o),
        this.dom.insertAdjacentHTML(
          "afterbegin",
          '<style id="gl-bench-style">' + this.css + "</style>"
        ),
        (this.dom = o),
        this.dom.addEventListener("click", () => {
          (this.trackGPU = !this.trackGPU), this.updateUI();
        }),
        (this.paramLogger = ((u, h, f) => {
          const c = [
              "gl-cpu",
              "gl-gpu",
              "gl-mem",
              "gl-fps",
              "gl-gpu-svg",
              "gl-chart",
            ],
            d = Object.assign({}, c);
          return (
            c.forEach((m) => (d[m] = h.getElementsByClassName(m))),
            (this.nodes = d),
            (m, x, v, b, y, M, D) => {
              (d["gl-cpu"][m].style.strokeDasharray =
                (x * 0.27).toFixed(0) + " 100"),
                (d["gl-gpu"][m].style.strokeDasharray =
                  (v * 0.27).toFixed(0) + " 100"),
                (d["gl-mem"][m].innerHTML = f[m]
                  ? f[m]
                  : b
                  ? "mem: " + b.toFixed(0) + "mb"
                  : ""),
                (d["gl-fps"][m].innerHTML = y.toFixed(0) + " FPS"),
                u(f[m], x, v, b, y, M, D);
            }
          );
        })(this.paramLogger, this.dom, this.names)),
        (this.chartLogger = ((u, h) => {
          let f = { "gl-chart": h.getElementsByClassName("gl-chart") };
          return (c, d, m) => {
            let x = "",
              v = d.length;
            for (let b = 0; b < v; b++) {
              let y = (m + b + 1) % v;
              d[y] != null &&
                (x =
                  x +
                  " " +
                  ((55 * b) / (v - 1)).toFixed(1) +
                  "," +
                  (45 - (d[y] * 22) / 60 / this.detected).toFixed(1));
            }
            f["gl-chart"][c].setAttribute("points", x), u(this.names[c], d, m);
          };
        })(this.chartLogger, this.dom));
    }
  }
  addUI(e) {
    this.names.indexOf(e) == -1 &&
      (this.names.push(e),
      this.dom &&
        (this.dom.insertAdjacentHTML("beforeend", this.svg), this.updateUI()),
      this.cpuAccums.push(0),
      this.gpuAccums.push(0),
      this.activeAccums.push(!1));
  }
  nextFrame(e) {
    this.frameId++;
    const t = e || this.now();
    if (this.frameId <= 1)
      (this.paramFrame = this.frameId), (this.paramTime = t);
    else {
      let i = t - this.paramTime;
      if (i >= 1e3) {
        const n = this.frameId - this.paramFrame,
          s = (n / i) * 1e3;
        for (let a = 0; a < this.names.length; a++) {
          const o = (this.cpuAccums[a] / i) * 100,
            u = (this.gpuAccums[a] / i) * 100,
            h =
              performance && performance.memory
                ? performance.memory.usedJSHeapSize / (1 << 20)
                : 0;
          this.paramLogger(a, o, u, h, s, i, n),
            (this.cpuAccums[a] = 0),
            Promise.all(this.finished).then(() => {
              (this.gpuAccums[a] = 0), (this.finished = []);
            });
        }
        (this.paramFrame = this.frameId), (this.paramTime = t);
      }
    }
    if (!this.detected || !this.chartFrame)
      (this.chartFrame = this.frameId),
        (this.chartTime = t),
        (this.circularId = 0);
    else {
      let i = t - this.chartTime,
        n = (this.chartHz * i) / 1e3;
      for (; --n > 0 && this.detected; ) {
        const a = ((this.frameId - this.chartFrame) / i) * 1e3;
        this.chart[this.circularId % this.chartLen] = a;
        for (let o = 0; o < this.names.length; o++)
          this.chartLogger(o, this.chart, this.circularId);
        this.circularId++,
          (this.chartFrame = this.frameId),
          (this.chartTime = t);
      }
    }
  }
  begin(e) {
    this.updateAccums(e);
  }
  end(e) {
    this.updateAccums(e);
  }
  updateAccums(e) {
    let t = this.names.indexOf(e);
    t == -1 && ((t = this.names.length), this.addUI(e));
    const i = this.now(),
      n = i - this.t0;
    for (let s = 0; s < t + 1; s++)
      this.activeAccums[s] && (this.cpuAccums[s] += n);
    (this.activeAccums[t] = !this.activeAccums[t]), (this.t0 = i);
  }
}
class tL extends OA.Pane {
  constructor() {
    super({ title: "Options" });
    q(this, "exportPreset", (t) => {
      const i = {},
        n = (a, o) => {
          if (a.allowExport !== !1 && a.controller_.rackController) {
            const h = a.controller_.rackController.rack.bcSet_.items
              .filter((f) => f.binding)
              .map((f) => f.binding.target)
              .reduce((f, c) => {
                const d = c.read();
                return d instanceof Image
                  ? f
                  : Object.assign(f, { [c.presetKey]: d });
              }, {});
            o || ((o = {}), (i[a._id] = o)),
              (o[a._id] = h),
              a.children.forEach((f) => {
                let c = !1;
                f.children && ((c = {}), (o[f._id] = c)), n(f, c);
              });
          }
        };
      return (
        this.children.forEach((a) => {
          n(a);
        }),
        JSON.stringify(i)
      );
    });
    q(this, "importPreset", (t) => {
      const i = (n, s) => {
        if (n.allowExport !== !1 && n.controller_.rackController) {
          const a = n.controller_.rackController.rack.bcSet_.items
            .filter((o) => o.binding)
            .map((o) => o.binding.target);
          s || (s = t[n._id]),
            a.forEach((o) => {
              const u = o.obj_[o.key],
                h = s[n._id][o.presetKey];
              h !== void 0 && (u.copy ? u.copy(h) : o.write(h));
            }),
            n.children.forEach((o) => {
              i(o, s[o._id]);
            });
        }
      };
      this.children.forEach((n) => {
        i(n);
      }),
        this.refresh();
    });
    this.setTheme(),
      this.containerElem_.addEventListener("wheel", (i) => {
        i.stopPropagation();
      }),
      (this.containerElem_.querySelector("button.tp-rotv_b").style.cursor =
        "move"),
      this.enableDrag(this.containerElem_),
      this.registerPlugin(BA),
      this.registerPlugin(ZA),
      (this.idCount = 0),
      (this.fireChange = !0),
      (this.options = { syncGuiValues: !1, saveState: !1 });
    const t = localStorage.getItem(window.location.href + ".guiSaveState");
    t !== null && (this.options.saveState = t === "true"),
      this.addFps(),
      (this.settingsFolder = this.addFolder({
        title: "Gui Settings",
        expanded: !1,
        allowExport: !1,
      })),
      this.settingsFolder.addInput(this.options, "syncGuiValues"),
      localStorage.setItem(
        window.location.href + ".guiSaveState",
        this.options.saveState
      ),
      this.settingsFolder
        .addInput(this.options, "saveState")
        .on("change", (i) => {
          localStorage.setItem(window.location.href + ".guiSaveState", i.value),
            i.value === !1 &&
              localStorage.removeItem(window.location.href + ".gui");
        }),
      this.addPerf(),
      this.addImportExport();
  }
  addPerf() {
    if (!E.WebGL) return;
    this.initGlBench();
    const t = this.addFolder({
      title: "Performance",
      expanded: !1,
      allowExport: !1,
    });
    t.addMonitor(this.perfStats, "cpu", { label: "cpu (ms)" }),
      t.addMonitor(this.perfStats, "gpu", { label: "gpu (ms)" }),
      t.addMonitor(this.perfStats, "mem", { label: "mem (mb)" }),
      t.addMonitor(E.WebGL.renderer.info.render, "calls", {
        label: "draw calls",
        interval: 500,
      }),
      t.addMonitor(E.WebGL.renderer.info.render, "triangles", {
        interval: 500,
      }),
      t.addMonitor(E.WebGL.renderer.info.memory, "geometries", {
        interval: 1e4,
      }),
      t.addMonitor(E.WebGL.renderer.info.memory, "textures", { interval: 1e4 });
  }
  initGlBench() {
    (this.perfStats = { cpu: 0, gpu: 0, mem: 0 }),
      (this.glBench = new eL(E.WebGL.renderer.getContext(), {
        withoutUI: !0,
        trackGPU: !0,
        paramLogger: (t, i, n, s, a, o, u) => {
          (this.perfStats.cpu = ((i * o) / 1e3 / u).toFixed(3)),
            (this.perfStats.gpu = ((n * o) / 1e4 / u).toFixed(3)),
            (this.perfStats.mem = s.toFixed(1));
        },
      }));
  }
  perfBegin() {
    this.fps.begin(),
      this.glBench.begin(),
      this.refresh(!1),
      E.WebGL.renderer.info.reset();
  }
  perfEnd(t) {
    this.fps.end(), this.glBench.end(), this.glBench.nextFrame(t);
  }
  addFolder(t) {
    const i = super.addFolder(t);
    return (
      (i._id = this.idCount++),
      (i.idCount = 0),
      (i.allowExport = t.allowExport !== void 0 ? t.allowExport : !0),
      (i.addFolder = this.addFolder),
      (i.addInput = this.addInput),
      i
    );
  }
  addInput(t, i, n) {
    return (
      n &&
        !n.presetKey &&
        n.label &&
        (n.presetKey = n.label.replace(" ", "_").replace("-", "_")),
      super.addInput(t, i, n)
    );
  }
  addImportExport() {
    const t = this.settingsFolder.addFolder({
      title: "Import/Export",
      expanded: !0,
      allowExport: !1,
    });
    this.originalData = {};
    const i = document.createElement("div");
    Object.assign(i.style, {
      display: "none",
      flexDirection: "column",
      justifyContent: "center",
      alignItems: "center",
      width: "100vw",
      height: "100vh",
      position: "fixed",
      top: "0px",
      left: "0px",
      zIndex: "99999999",
      backdropFilter: "blur(10px)",
    }),
      i.addEventListener("click", (u) => {
        u.target !== n && (i.style.display = "none");
      });
    const n = document.createElement("textarea");
    (n.placeholder = "Paste exported data here..."),
      Object.assign(n.style, {
        width: "90%",
        height: "90%",
        maxWidth: "400px",
        maxHeight: "300px",
        background: "rgba(0, 0, 0, 0.8)",
        color: "white",
        fontFamily: "monospace",
        fontSize: "11px",
        marginBottom: "2rem",
      }),
      i.appendChild(n);
    const s = document.createElement("button");
    (s.innerHTML = "Apply"),
      s.addEventListener("click", () => {
        n.value &&
          (localStorage.setItem(window.location.href + ".gui", n.value),
          this.importPreset(JSON.parse(n.value)),
          (n.value = ""));
      }),
      i.appendChild(s),
      document.body.appendChild(i),
      t.addButton({ title: "Import" }).on("click", () => {
        (i.style.display = "flex"), n.focus();
      });
    let a;
    const o = t.addButton({ title: "Export" }).on("click", () => {
      o.disabled = !0;
      const u = this.exportPreset();
      localStorage.setItem(window.location.href + ".gui", u),
        navigator.clipboard
          ? navigator.clipboard.writeText(u)
          : ((i.style.display = "flex"),
            (n.value = u),
            n.focus(),
            n.select(),
            document.execCommand("copy"),
            (n.value = ""),
            (i.style.display = "none")),
        (o.title = "Copied to clipboard!"),
        clearTimeout(a),
        setTimeout(() => {
          (o.title = "Export"), (o.disabled = !1);
        }, 2e3);
    });
    t.addButton({ title: "Reset" }).on("click", () => {
      this.importPreset(JSON.parse(this.originalData)),
        localStorage.setItem(window.location.href + ".gui", this.originalData);
    }),
      setTimeout(() => {
        if (
          ((this.originalData = this.exportPreset()), this.options.saveState)
        ) {
          const u = localStorage.getItem(window.location.href + ".gui");
          u && this.importPreset(JSON.parse(u));
        }
      }, 500),
      setInterval(() => {
        this.options.saveState &&
          localStorage.setItem(
            window.location.href + ".gui",
            this.exportPreset()
          );
      }, 5e3);
  }
  refresh(t = !0) {
    this.options.syncGuiValues &&
      ((this.fireChange = t), super.refresh(), (this.fireChange = !0));
  }
  autoAddObject({
    object: t,
    exclude: i = [],
    include: n = [],
    transforms: s = !0,
    expanded: a = !1,
    parentFolder: o = null,
  }) {
    const h = (o || this).addFolder({
      title: t.name ? `${t.type}: ${t.name}` : t.type,
      expanded: a,
    });
    h.addInput(t, "visible", { index: 0 });
    let f = !1;
    s &&
      ((f = h.addFolder({ title: "transforms", expanded: !0 })),
      f.addInput(t, "position"),
      f.addInput(t, "rotation"),
      f.addInput(t, "scale"));
    const c = h.addFolder({ title: "material", expanded: !0 }),
      d = c.addFolder({ title: "options", expanded: !1 });
    d.addInput(t.material, "wireframe"),
      d
        .addBlade({
          view: "list",
          label: "side",
          value: t.material.side,
          options: { front: Bs, back: Bn, double: ru },
        })
        .on("change", (x) => {
          t.material.side = x.value;
        }),
      d
        .addBlade({
          view: "list",
          label: "blending",
          value: t.material.blending,
          options: {
            NoBlending: dr,
            NormalBlending: Oo,
            AdditiveBlending: bf,
            SubtractiveBlending: xf,
            MultiplyBlending: wf,
            CustomBlending: Z_,
          },
        })
        .on("change", (x) => {
          t.material.blending = x.value;
        }),
      d.addInput(t.material, "transparent"),
      d.addInput(t.material, "depthTest"),
      d.addInput(t.material, "depthWrite"),
      d.addInput(t.material, "colorWrite"),
      this.autoAddUniforms(h, t.material.uniforms, i, n);
    const m = [
      "color",
      "bumpMap",
      "bumpScale",
      "displacementBias",
      "displacementMap",
      "displacementScale",
      "emissive",
      "emissiveIntensity",
      "emissiveMap",
      "ior",
      "map",
      "metalness",
      "metalnessMap",
      "normalMap",
      "normalScale",
      "opacity",
      "reflectivity",
      "roughness",
      "roughnessMap",
      "specular",
      "specularColor",
      "specularMap",
      "specularIntensity",
      "specularColorMap",
      "specularIntensityMap",
      "thickness",
      "_transmission",
    ];
    if (
      t.material.type !== "ShaderMaterial" &&
      t.material.type !== "RawShaderMaterial"
    ) {
      for (const x in t.material)
        if (m.includes(x))
          if (t.material[x] === null) {
            if (x.toLowerCase().includes("map")) {
              const v = { tex: new xi() };
              this.addImage(c, v, "tex", x, { wrapping: Zr }, (b) => {
                (t.material[x] = v.tex), (t.material.needsUpdate = !0);
              }),
                c
                  .addInput(v.tex, "repeat", {
                    label: x + " repeat",
                    step: 0.01,
                  })
                  .on("change", (b) => {
                    t.material[x].needsUpdate = !0;
                  });
            }
          } else if (t.material[x].isColor)
            this.addColor(c, t.material, x, x, !1);
          else if (t.material[x].isTexture) {
            if (t.material[x].isDataTexture) continue;
            this.addImage(c, t.material, x, x),
              c
                .addInput(t.material[x], "repeat", {
                  label: x + " repeat",
                  step: 0.01,
                })
                .on("change", (v) => {
                  t.material[x].needsUpdate = !0;
                });
          } else if (x.includes("_")) {
            const v = x.replace("_", "");
            c.addInput(t.material, x).on("change", (b) => {
              (t.material.needsUpdate = !0), (t.material[v] = b.value);
            });
          } else c.addInput(t.material, x, { step: 0.01 });
    }
    return { folder: h, transformsFolder: f, materialFolder: c };
  }
  autoAddUniforms(t, i, n = [], s = []) {
    for (const a in i) {
      if (
        a === "uTime" ||
        a.toUpperCase().includes("FOG") ||
        n.includes(a) ||
        (s.length && !s.includes(a))
      )
        continue;
      const o = i[a];
      if (o.value === null || o.value === void 0) {
        console.error(
          "Error when attempting to auto-add uniform: " + a + " has no value"
        );
        continue;
      }
      o.value.isMatrix4 ||
        o.value.isRenderTargetTexture ||
        (o.value.isColor
          ? this.addColor(t, o, "value", a)
          : o.value.isTexture
          ? this.addImage(t, o, "value", a)
          : t.addInput(o, "value", { label: a, ...o.gui }));
    }
  }
  addColor(t, i, n, s, a = !0, o = []) {
    return (
      a ? this.setupColorUniform(i) : (i.guiValue = "#" + i[n].getHexString()),
      t
        .addInput(i, "guiValue", { label: s, picker: "inline" })
        .on("change", () => {
          if (this.fireChange && (i[n].set(i.guiValue), o && o.length > 0))
            for (const u of o) u[n].set(i.guiValue);
        })
    );
  }
  setupColorUniform(t) {
    t.guiValue = "#" + t.value.getHexString();
  }
  addImage(t, i, n, s, a = {}, o) {
    (i[n].firstLoad = !0),
      i[n].image || (i[n].image = new Image()),
      (a = Object.assign(
        {
          minFilter: i[n].minFilter,
          magFilter: i[n].magFilter,
          wrapping: i[n].wrapS,
          flipY: i[n].flipY,
          encoding: i[n].encoding,
        },
        a
      ));
    const u = t
      .addInput(i[n], "image", { label: s, view: "input-image" })
      .on("change", (h) => {
        if (i[n].firstLoad) {
          i[n].firstLoad = !1;
          return;
        }
        (i[n] = E.WebGL.generateTexture(h.value, a)),
          (i[n].needsUpdate = !0),
          o && o(i[n]);
      });
    u.controller_.binding.read = () => {};
  }
  addFps() {
    (this.fps = this.addBlade({ view: "fpsgraph" })),
      (this.fps.allowExport = !1),
      K.ticker.fps(999);
    const t = document.createElement("div");
    t.classList.add("force-unlocked-fps"), this.containerElem_.appendChild(t);
    const i = document.createElement("style"),
      n = `
			.force-unlocked-fps {
				animation-name: forceUnlockedFps;
				animation-duration: 4s;
				animation-iteration-count: infinite;
			}

			@keyframes forceUnlockedFps {
				from { transform: translateX(-1%) }
				to { transform: translateX(0%) }
			}
			`;
    (i.innerHTML = n), this.containerElem_.appendChild(i);
  }
  setTheme() {
    (this.containerElem_.style.width = "350px"),
      (this.containerElem_.style.position = "fixed"),
      (this.containerElem_.style.maxHeight = "98vh"),
      (this.containerElem_.style.overflowY = "auto"),
      (this.containerElem_.style.zIndex = "9999999"),
      (this.containerElem_.style.backdropFilter = "blur(10px)"),
      (this.containerElem_.firstChild.style.overflow = "hidden");
    const t = document.createElement("style");
    (t.innerHTML = `
			:root {
				--tp-base-background-color: hsla(0, 0%, 10%, 0.80);
				--tp-base-shadow-color: hsla(0, 0%, 0%, 0.2);
				--tp-button-background-color: hsla(0, 0%, 80%, 1.00);
				--tp-button-background-color-active: hsla(0, 0%, 100%, 1.00);
				--tp-button-background-color-focus: hsla(0, 0%, 95%, 1.00);
				--tp-button-background-color-hover: hsla(0, 0%, 85%, 1.00);
				--tp-button-foreground-color: hsla(0, 0%, 0%, 0.80);
				--tp-container-background-color: hsla(0, 0%, 0%, 0.30);
				--tp-container-background-color-active: hsla(0, 0%, 0%, 0.60);
				--tp-container-background-color-focus: hsla(0, 0%, 0%, 0.50);
				--tp-container-background-color-hover: hsla(0, 0%, 0%, 0.40);
				--tp-container-foreground-color: hsla(0, 0%, 100%, 0.50);
				--tp-groove-foreground-color: hsla(0, 0%, 0%, 0.20);
				--tp-input-background-color: hsla(0, 0%, 0%, 0.30);
				--tp-input-background-color-active: hsla(0, 0%, 0%, 0.60);
				--tp-input-background-color-focus: hsla(0, 0%, 0%, 0.50);
				--tp-input-background-color-hover: hsla(0, 0%, 0%, 0.40);
				--tp-input-foreground-color: hsla(0, 0%, 100%, 0.50);
				--tp-label-foreground-color: hsla(0, 0%, 100%, 0.50);
				--tp-monitor-background-color: hsla(0, 0%, 0%, 0.30);
				--tp-monitor-foreground-color: hsla(0, 0%, 100%, 0.30);
			}
			`),
      document.head.appendChild(t);
  }
  enableDrag(t) {
    let i = 0,
      n = 0,
      s = 0,
      a = 0;
    const o = this.containerElem_.querySelector("button.tp-rotv_b");
    o.onmousedown = u;
    function u(c) {
      (c = c || window.event),
        c.preventDefault(),
        (s = c.clientX),
        (a = c.clientY),
        (document.onmouseup = f),
        (document.onmousemove = h);
    }
    function h(c) {
      (c = c || window.event),
        c.preventDefault(),
        (i = s - c.clientX),
        (n = a - c.clientY),
        (s = c.clientX),
        (a = c.clientY),
        (t.style.top = t.offsetTop - n + "px"),
        (t.style.left = t.offsetLeft - i + "px"),
        (o.style.pointerEvents = "none");
    }
    function f() {
      (document.onmouseup = null),
        (document.onmousemove = null),
        (o.style.pointerEvents = "auto");
    }
  }
}
class mw extends tL {
  constructor() {
    super();
    q(this, "buildRocks", (t) => {
      t.last &&
        ((this.count.disabled = !0),
        E.rocksWebGL.scenes.rocks.destroy(),
        E.rocksWebGL.scenes.rocks.buildRocks(),
        requestAnimationFrame(() => {
          E.rocksWebGL.scenes.rocks.start(), (this.count.disabled = !1);
        }));
    });
    q(this, "addRocks", () => {
      if (!E.rocksWebGL.scenes.rocks) return;
      const t = this.addFolder({ title: "Rocks", expanded: !0 });
      (this.count = t
        .addInput(E.rocksWebGL.scenes.rocks.options.rocks, "count", {
          min: 1,
          max: 15,
          step: 1,
        })
        .on("change", this.buildRocks)),
        t
          .addInput(
            E.rocksWebGL.scenes.rocks.components.rocks.options,
            "radius",
            { min: 0, max: 5, step: 0.01 }
          )
          .on(
            "change",
            E.rocksWebGL.scenes.rocks.components.rocks.updateRocksPos
          ),
        t
          .addInput(E.rocksWebGL.scenes.rocks.options.rocks, "baseScale", {
            min: 0.1,
            max: 2,
            step: 0.01,
          })
          .on(
            "change",
            E.rocksWebGL.scenes.rocks.components.rocks.updateRocksPos
          ),
        t
          .addInput(E.rocksWebGL.scenes.rocks.options.rocks, "scaleOffset", {
            min: 0,
            max: 0.5,
            step: 0.01,
          })
          .on(
            "change",
            E.rocksWebGL.scenes.rocks.components.rocks.updateRocksPos
          ),
        t.addInput(E.rocksWebGL.scenes.rocks.options.rocks, "speed", {
          label: "Global rotation speed",
          min: 0.1,
          max: 10,
          step: 0.1,
        }),
        t.addInput(E.rocksWebGL.scenes.rocks.camera, "position", {
          label: "Camera pos",
        }),
        t
          .addInput(E.rocksWebGL.scenes.rocks.camera, "fov", {
            label: "Camera FOV",
          })
          .on("change", () =>
            E.rocksWebGL.scenes.rocks.camera.updateProjectionMatrix()
          ),
        t.addInput(
          E.rocksWebGL.scenes.rocks.components.rocks.uniforms.uRotateSpeed,
          "value",
          { label: "Individual rotation speed", min: 0.1, max: 15, step: 0.1 }
        ),
        this.addInputs(t, E.rocksWebGL.scenes.rocks.options, {
          name: "lightLerp",
          label: "Light lerp",
          min: 0.01,
          max: 1,
          step: 0.01,
        }),
        t.addSeparator(),
        this.addInputs(t, E.rocksWebGL.scenes.rocks.planeRaycast.material, {
          name: "visible",
          label: "Show Plane - Raycaster",
        }),
        t.addSeparator(),
        this.addFog(t),
        this.addRocksLights(t),
        t.addSeparator(),
        this.autoAddObject({
          parentFolder: t,
          object: E.rocksWebGL.scenes.rocks.components.rocks.mesh,
          expanded: !1,
        });
    });
    (this.options.syncGuiValues = !0), this.addTrailCurve(), this.addRocks();
  }
  addInputs(t, i, n) {
    if (Array.isArray(n))
      n.forEach((s) => {
        const a = s.name;
        delete s.name, t.addInput(i, a, s);
      });
    else {
      const s = n.name;
      delete n.name, t.addInput(i, s, n);
    }
  }
  addTrailCurve() {}
  addFog(t) {
    const i = t.addFolder({ title: "Fog", expanded: !1 });
    this.addInputs(i, E.rocksWebGL.scenes.rocks.fog, [
      { name: "near", min: 0, max: 15, step: 0.01 },
      { name: "far", min: 0, max: 15, step: 0.01 },
    ]),
      this.addColor(i, E.rocksWebGL.scenes.rocks.fog, "color", "color", !1);
  }
  addRocksLights(t) {
    const i = t.addFolder({ title: "Ambient Light", expanded: !1 });
    this.addInputs(i, E.rocksWebGL.scenes.rocks.ambient, {
      name: "intensity",
      min: 0,
      max: 50,
      step: 0.01,
    }),
      this.addColor(i, E.rocksWebGL.scenes.rocks.ambient, "color", "color", !1);
    const n = t.addFolder({ title: "Fixed Directional Light", expanded: !1 }),
      s = [
        { name: "intensity", min: 0, max: 25, step: 0.1 },
        { name: "position" },
      ];
    this.addInputs(n, E.rocksWebGL.scenes.rocks.fixedLight, s),
      this.addColor(
        n,
        E.rocksWebGL.scenes.rocks.fixedLight,
        "color",
        "color",
        !1
      );
    const a = t.addFolder({ title: "Moving SpotLight", expanded: !1 }),
      o = [
        { name: "intensity", min: 0, max: 25, step: 0.1 },
        { name: "distance", min: 1, max: 25, step: 0.1 },
        { name: "angle", min: 0, max: Math.PI / 2, step: 0.01 },
        { name: "position" },
      ];
    this.addInputs(a, E.rocksWebGL.scenes.rocks.movingLight, o),
      this.addColor(
        a,
        E.rocksWebGL.scenes.rocks.movingLight,
        "color",
        "color",
        !1
      );
  }
}
const iL = Object.freeze(
    Object.defineProperty({ __proto__: null, Gui: mw }, Symbol.toStringTag, {
      value: "Module",
    })
  ),
  nL = `precision highp float;
precision highp int;
#define GLSLIFY 1

uniform mat4 modelViewMatrix;
uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;

attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec4 color;`,
  sL = `precision highp float;
precision highp int;
#define GLSLIFY 1
`,
  rL = `#define GLSLIFY 1
vec3 objectNormal = vec3( normal );
vec3 transformedNormal = objectNormal;

#ifdef USE_INSTANCING
    mat3 m = mat3( instanceMatrix );
    transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
    transformedNormal = m * transformedNormal;
#endif

transformedNormal = normalMatrix * transformedNormal;

vNormal = normalize( transformedNormal );`,
  oL = `#define GLSLIFY 1
#include <defaultVert>

uniform vec3 uTrailPosition;
uniform float uScale;
uniform float uRotation;

varying vec3 vNormal;
varying vec2 vUv;

mat2 rotate2d(in float radians){
    float c = cos(radians);
    float s = sin(radians);
    return mat2(c, -s, s, c);
}

void main()	{
	vUv = uv;

	#include <normalsVert>

	vec3 newPos = uTrailPosition;
	float scale = uScale;

	vec4 newMvPosition = vec4(position, 1.);
	newMvPosition.xy *= rotate2d(uRotation);
	newMvPosition.xyz *= scale;
	newMvPosition.xyz += newPos.xyz;
	newMvPosition = modelMatrix * newMvPosition;
	newMvPosition = viewMatrix * newMvPosition;
	gl_Position = projectionMatrix * newMvPosition;
}`,
  aL = `#define GLSLIFY 1
#include <defaultFrag>

uniform vec3 uColorLight;
uniform vec3 uColorDark;
uniform float uTransparency;
uniform sampler2D uImage;
uniform float uModeProgress;

varying vec2 vUv;
varying vec3 vNormal;

void main() {
	vec4 tex = texture2D(uImage, vUv);

	// vec3 colorMix = mix(uColorLight, vec3(0), uModeProgress);
	float transparencyMultiplier = mix(0.7, 0.9, uModeProgress);
	// float colorMultiplier = mix(0.2, 0.1, uModeProgress);

	vec3 col = mix(tex.rgb + (uColorLight * vec3(0.2)), tex.rgb * uColorDark, uModeProgress);

    gl_FragColor = vec4(col, uTransparency * transparencyMultiplier);
}
`;
class lL extends rD {
  constructor(e = {}) {
    (e = rg(
      {
        uniforms: {
          uColorLight: { value: new ct(15329507) },
          uColorDark: { value: new ct(9342606) },
          uTransparency: { value: 0.5 },
          uTrailPosition: { value: new Ue(0, 0) },
          uScale: { value: 1 },
          uRotation: { value: 10 },
          uImage: { value: null },
          uModeProgress: { value: 1 },
        },
        defines: {},
      },
      e
    )),
      super({
        vertexShader: oL,
        fragmentShader: aL,
        uniforms: e.uniforms,
        defines: e.defines,
        transparent: !0,
        side: Bs,
      }),
      (this.globalUniforms = e.globalUniforms),
      (this.uniforms = Object.assign(this.uniforms, this.globalUniforms));
  }
  clone(e) {
    const t = super.clone();
    return (
      (t.uniforms = Object.assign(t.uniforms, this.globalUniforms)),
      (t.uniforms = Object.assign(t.uniforms, e)),
      t
    );
  }
}
const cL = `precision highp float;
precision highp int;
#define GLSLIFY 1

attribute vec3 aPos;
attribute float yPosMultiplier;
attribute float opacityPosMultiplier;

varying vec3 vNormal;
varying vec2 vUv;
varying float zPos;
varying float yPos;
varying float opacityMultiplier;

uniform float uTime;
uniform float uRadius;
uniform float uYPosMultiplier;

float map(float value, float min1, float max1, float min2, float max2) {
	return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

void main()	{
    #include <normalsVert>

	opacityMultiplier = opacityPosMultiplier;

    vUv = uv;
    vec3 transformedPosition = position;

	transformedPosition += vec3(aPos.x, aPos.y, aPos.z);

	vec4 newPos = projectionMatrix * modelViewMatrix * vec4( transformedPosition, 1.0 );
	zPos = newPos.z;

	yPos = map(aPos.y, -uRadius, uRadius, 0.0, 1.0);
	yPos = smoothstep(0.05, 0.99, yPos);

    gl_Position = vec4(newPos.x, newPos.y + (uYPosMultiplier * yPosMultiplier), newPos.z, newPos.w);
    // gl_Position = vec4(newPos.x, newPos.y, newPos.z, newPos.w);
}`,
  uL = `#define GLSLIFY 1
#include <defaultFrag>

varying vec3 vNormal;
varying vec2 vUv;
varying float zPos;
varying float yPos;
varying float opacityMultiplier;

uniform float uTime;
uniform vec3 uBaseColor;

void main() {
	float mySin = sin(uTime * opacityMultiplier);
	mySin = (mySin + 1.4) / 2.0;

    gl_FragColor = vec4(vec3(uBaseColor), yPos * mySin);
}`;
class hL extends vr {
  constructor(e = {}) {
    (e = rg(
      {
        uniforms: {
          uTime: E.WebGL.globalUniforms.uTime,
          uBaseColor: { value: new ct(16777215) },
          uRadius: { value: null },
          uYPosMultiplier: { value: -2.5 },
        },
        defines: {},
      },
      e
    )),
      super({
        vertexShader: cL,
        fragmentShader: uL,
        uniforms: e.uniforms,
        defines: e.defines,
        transparent: !0,
      }),
      (this.globalUniforms = e.globalUniforms),
      (this.uniforms = Object.assign(this.uniforms, this.globalUniforms));
  }
  clone(e) {
    const t = super.clone();
    return (
      (t.uniforms = Object.assign(t.uniforms, this.globalUniforms)),
      (t.uniforms = Object.assign(t.uniforms, e)),
      t
    );
  }
}
function dL() {
  (Tt.defaultVert = df(nL)),
    (Tt.defaultFrag = df(sL)),
    (Tt.normalsVert = df(rL));
}
class za extends ts {
  constructor(e, t) {
    super(), (this.imageRangeOffset = e > 0 ? e : ""), (this.indexOffset = t);
  }
  build() {
    (this.planes = []), (this.progress = []), this.createPlanes();
  }
  createPlanes() {
    const e = K.utils.wrap(0, 10);
    for (let t = 0; t < 10; t++) {
      let i = e(t + this.indexOffset);
      i = `${this.imageRangeOffset}` + i;
      const n = K.utils.clamp(
          0,
          335,
          E.WebGL.scenes.vortex.assets.textures[`image${i}`].width
        ),
        s =
          E.WebGL.scenes.vortex.assets.textures[`image${i}`].height /
          E.WebGL.scenes.vortex.assets.textures[`image${i}`].width,
        a = new au(n * 0.005, n * s * 0.005),
        o = new lL({
          transparent: !0,
          uniforms: {
            uImage: {
              value: E.WebGL.scenes.vortex.assets.textures[`image${i}`],
            },
          },
        }),
        u = new Wi(a, o);
      (this.planes[t] = u), (u.visible = !1), this.add(u);
    }
  }
}
class pL extends ts {
  constructor() {
    if (
      (super(),
      (this.curve = new Tb(
        [
          new Z(-7, 1, -8),
          new Z(-6.8, 0.2, -7),
          new Z(-6.4, -0.3, -6),
          new Z(-5.9, -0.7, -5),
          new Z(-5.4, -1, -4),
          new Z(-4.8, -1.2, -3),
          new Z(-3.9, -1.3, -1.8),
          new Z(-2.8, -1, -1),
          new Z(-1.5, -0.6, 0),
          new Z(-1, -0.4, 0),
        ],
        !1,
        "chordal",
        0.5
      )),
      (this.points = this.curve.getPoints(9)),
      (this.debugVortexCurve = !1),
      this.debugVortexCurve)
    ) {
      console.log("wpeoiwopi");
      const e = new dd(0.05),
        t = new cr({ color: 16711680 });
      for (const a of this.points) {
        const o = new Wi(e, t);
        o.position.copy(a), this.add(o);
      }
      const i = new cn().setFromPoints(this.points),
        n = new lu({ color: 16711680 }),
        s = new cu(i, n);
      this.add(s);
    }
  }
}
const N_ = { type: "change" },
  ff = { type: "start" },
  B_ = { type: "end" };
class fL extends ra {
  constructor(e, t) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.domElement.style.touchAction = "none"),
      (this.enabled = !0),
      (this.target = new Z()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      (this.mouseButtons = {
        LEFT: wa.ROTATE,
        MIDDLE: wa.DOLLY,
        RIGHT: wa.PAN,
      }),
      (this.touches = { ONE: ya.ROTATE, TWO: ya.DOLLY_PAN }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this.getPolarAngle = function () {
        return o.phi;
      }),
      (this.getAzimuthalAngle = function () {
        return o.theta;
      }),
      (this.getDistance = function () {
        return this.object.position.distanceTo(this.target);
      }),
      (this.listenToKeyEvents = function (H) {
        H.addEventListener("keydown", bt), (this._domElementKeyEvents = H);
      }),
      (this.saveState = function () {
        i.target0.copy(i.target),
          i.position0.copy(i.object.position),
          (i.zoom0 = i.object.zoom);
      }),
      (this.reset = function () {
        i.target.copy(i.target0),
          i.object.position.copy(i.position0),
          (i.object.zoom = i.zoom0),
          i.object.updateProjectionMatrix(),
          i.dispatchEvent(N_),
          i.update(),
          (s = n.NONE);
      }),
      (this.update = (function () {
        const H = new Z(),
          ne = new ws().setFromUnitVectors(e.up, new Z(0, 1, 0)),
          Re = ne.clone().invert(),
          Ae = new Z(),
          ke = new ws(),
          je = 2 * Math.PI;
        return function () {
          const rt = i.object.position;
          H.copy(rt).sub(i.target),
            H.applyQuaternion(ne),
            o.setFromVector3(H),
            i.autoRotate && s === n.NONE && k(F()),
            i.enableDamping
              ? ((o.theta += u.theta * i.dampingFactor),
                (o.phi += u.phi * i.dampingFactor))
              : ((o.theta += u.theta), (o.phi += u.phi));
          let lt = i.minAzimuthAngle,
            Ct = i.maxAzimuthAngle;
          return (
            isFinite(lt) &&
              isFinite(Ct) &&
              (lt < -Math.PI ? (lt += je) : lt > Math.PI && (lt -= je),
              Ct < -Math.PI ? (Ct += je) : Ct > Math.PI && (Ct -= je),
              lt <= Ct
                ? (o.theta = Math.max(lt, Math.min(Ct, o.theta)))
                : (o.theta =
                    o.theta > (lt + Ct) / 2
                      ? Math.max(lt, o.theta)
                      : Math.min(Ct, o.theta))),
            (o.phi = Math.max(
              i.minPolarAngle,
              Math.min(i.maxPolarAngle, o.phi)
            )),
            o.makeSafe(),
            (o.radius *= h),
            (o.radius = Math.max(
              i.minDistance,
              Math.min(i.maxDistance, o.radius)
            )),
            i.enableDamping === !0
              ? i.target.addScaledVector(f, i.dampingFactor)
              : i.target.add(f),
            H.setFromSpherical(o),
            H.applyQuaternion(Re),
            rt.copy(i.target).add(H),
            i.object.lookAt(i.target),
            i.enableDamping === !0
              ? ((u.theta *= 1 - i.dampingFactor),
                (u.phi *= 1 - i.dampingFactor),
                f.multiplyScalar(1 - i.dampingFactor))
              : (u.set(0, 0, 0), f.set(0, 0, 0)),
            (h = 1),
            c ||
            Ae.distanceToSquared(i.object.position) > a ||
            8 * (1 - ke.dot(i.object.quaternion)) > a
              ? (i.dispatchEvent(N_),
                Ae.copy(i.object.position),
                ke.copy(i.object.quaternion),
                (c = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.dispose = function () {
        i.domElement.removeEventListener("contextmenu", pe),
          i.domElement.removeEventListener("pointerdown", ht),
          i.domElement.removeEventListener("pointercancel", he),
          i.domElement.removeEventListener("wheel", Bt),
          i.domElement.removeEventListener("pointermove", wt),
          i.domElement.removeEventListener("pointerup", dt),
          i._domElementKeyEvents !== null &&
            i._domElementKeyEvents.removeEventListener("keydown", bt);
      });
    const i = this,
      n = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let s = n.NONE;
    const a = 1e-6,
      o = new kv(),
      u = new kv();
    let h = 1;
    const f = new Z();
    let c = !1;
    const d = new Ue(),
      m = new Ue(),
      x = new Ue(),
      v = new Ue(),
      b = new Ue(),
      y = new Ue(),
      M = new Ue(),
      D = new Ue(),
      C = new Ue(),
      A = [],
      I = {};
    function F() {
      return ((2 * Math.PI) / 60 / 60) * i.autoRotateSpeed;
    }
    function P() {
      return Math.pow(0.95, i.zoomSpeed);
    }
    function k(H) {
      u.theta -= H;
    }
    function O(H) {
      u.phi -= H;
    }
    const J = (function () {
        const H = new Z();
        return function (Re, Ae) {
          H.setFromMatrixColumn(Ae, 0), H.multiplyScalar(-Re), f.add(H);
        };
      })(),
      ee = (function () {
        const H = new Z();
        return function (Re, Ae) {
          i.screenSpacePanning === !0
            ? H.setFromMatrixColumn(Ae, 1)
            : (H.setFromMatrixColumn(Ae, 0), H.crossVectors(i.object.up, H)),
            H.multiplyScalar(Re),
            f.add(H);
        };
      })(),
      X = (function () {
        const H = new Z();
        return function (Re, Ae) {
          const ke = i.domElement;
          if (i.object.isPerspectiveCamera) {
            const je = i.object.position;
            H.copy(je).sub(i.target);
            let Ve = H.length();
            (Ve *= Math.tan(((i.object.fov / 2) * Math.PI) / 180)),
              J((2 * Re * Ve) / ke.clientHeight, i.object.matrix),
              ee((2 * Ae * Ve) / ke.clientHeight, i.object.matrix);
          } else
            i.object.isOrthographicCamera
              ? (J(
                  (Re * (i.object.right - i.object.left)) /
                    i.object.zoom /
                    ke.clientWidth,
                  i.object.matrix
                ),
                ee(
                  (Ae * (i.object.top - i.object.bottom)) /
                    i.object.zoom /
                    ke.clientHeight,
                  i.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (i.enablePan = !1));
        };
      })();
    function j(H) {
      i.object.isPerspectiveCamera
        ? (h /= H)
        : i.object.isOrthographicCamera
        ? ((i.object.zoom = Math.max(
            i.minZoom,
            Math.min(i.maxZoom, i.object.zoom * H)
          )),
          i.object.updateProjectionMatrix(),
          (c = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (i.enableZoom = !1));
    }
    function Y(H) {
      i.object.isPerspectiveCamera
        ? (h *= H)
        : i.object.isOrthographicCamera
        ? ((i.object.zoom = Math.max(
            i.minZoom,
            Math.min(i.maxZoom, i.object.zoom / H)
          )),
          i.object.updateProjectionMatrix(),
          (c = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (i.enableZoom = !1));
    }
    function ie(H) {
      d.set(H.clientX, H.clientY);
    }
    function Q(H) {
      M.set(H.clientX, H.clientY);
    }
    function V(H) {
      v.set(H.clientX, H.clientY);
    }
    function ve(H) {
      m.set(H.clientX, H.clientY),
        x.subVectors(m, d).multiplyScalar(i.rotateSpeed);
      const ne = i.domElement;
      k((2 * Math.PI * x.x) / ne.clientHeight),
        O((2 * Math.PI * x.y) / ne.clientHeight),
        d.copy(m),
        i.update();
    }
    function U(H) {
      D.set(H.clientX, H.clientY),
        C.subVectors(D, M),
        C.y > 0 ? j(P()) : C.y < 0 && Y(P()),
        M.copy(D),
        i.update();
    }
    function oe(H) {
      b.set(H.clientX, H.clientY),
        y.subVectors(b, v).multiplyScalar(i.panSpeed),
        X(y.x, y.y),
        v.copy(b),
        i.update();
    }
    function ue(H) {
      H.deltaY < 0 ? Y(P()) : H.deltaY > 0 && j(P()), i.update();
    }
    function fe(H) {
      let ne = !1;
      switch (H.code) {
        case i.keys.UP:
          H.ctrlKey || H.metaKey || H.shiftKey
            ? O((2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : X(0, i.keyPanSpeed),
            (ne = !0);
          break;
        case i.keys.BOTTOM:
          H.ctrlKey || H.metaKey || H.shiftKey
            ? O((-2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : X(0, -i.keyPanSpeed),
            (ne = !0);
          break;
        case i.keys.LEFT:
          H.ctrlKey || H.metaKey || H.shiftKey
            ? k((2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : X(i.keyPanSpeed, 0),
            (ne = !0);
          break;
        case i.keys.RIGHT:
          H.ctrlKey || H.metaKey || H.shiftKey
            ? k((-2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : X(-i.keyPanSpeed, 0),
            (ne = !0);
          break;
      }
      ne && (H.preventDefault(), i.update());
    }
    function le() {
      if (A.length === 1) d.set(A[0].pageX, A[0].pageY);
      else {
        const H = 0.5 * (A[0].pageX + A[1].pageX),
          ne = 0.5 * (A[0].pageY + A[1].pageY);
        d.set(H, ne);
      }
    }
    function be() {
      if (A.length === 1) v.set(A[0].pageX, A[0].pageY);
      else {
        const H = 0.5 * (A[0].pageX + A[1].pageX),
          ne = 0.5 * (A[0].pageY + A[1].pageY);
        v.set(H, ne);
      }
    }
    function ce() {
      const H = A[0].pageX - A[1].pageX,
        ne = A[0].pageY - A[1].pageY,
        Re = Math.sqrt(H * H + ne * ne);
      M.set(0, Re);
    }
    function He() {
      i.enableZoom && ce(), i.enablePan && be();
    }
    function Se() {
      i.enableZoom && ce(), i.enableRotate && le();
    }
    function Oe(H) {
      if (A.length == 1) m.set(H.pageX, H.pageY);
      else {
        const Re = We(H),
          Ae = 0.5 * (H.pageX + Re.x),
          ke = 0.5 * (H.pageY + Re.y);
        m.set(Ae, ke);
      }
      x.subVectors(m, d).multiplyScalar(i.rotateSpeed);
      const ne = i.domElement;
      k((2 * Math.PI * x.x) / ne.clientHeight),
        O((2 * Math.PI * x.y) / ne.clientHeight),
        d.copy(m);
    }
    function Me(H) {
      if (A.length === 1) b.set(H.pageX, H.pageY);
      else {
        const ne = We(H),
          Re = 0.5 * (H.pageX + ne.x),
          Ae = 0.5 * (H.pageY + ne.y);
        b.set(Re, Ae);
      }
      y.subVectors(b, v).multiplyScalar(i.panSpeed), X(y.x, y.y), v.copy(b);
    }
    function Ke(H) {
      const ne = We(H),
        Re = H.pageX - ne.x,
        Ae = H.pageY - ne.y,
        ke = Math.sqrt(Re * Re + Ae * Ae);
      D.set(0, ke),
        C.set(0, Math.pow(D.y / M.y, i.zoomSpeed)),
        j(C.y),
        M.copy(D);
    }
    function Qe(H) {
      i.enableZoom && Ke(H), i.enablePan && Me(H);
    }
    function Pe(H) {
      i.enableZoom && Ke(H), i.enableRotate && Oe(H);
    }
    function ht(H) {
      i.enabled !== !1 &&
        (A.length === 0 &&
          (i.domElement.setPointerCapture(H.pointerId),
          i.domElement.addEventListener("pointermove", wt),
          i.domElement.addEventListener("pointerup", dt)),
        xe(H),
        H.pointerType === "touch" ? G(H) : Et(H));
    }
    function wt(H) {
      i.enabled !== !1 && (H.pointerType === "touch" ? N(H) : ft(H));
    }
    function dt(H) {
      we(H),
        A.length === 0 &&
          (i.domElement.releasePointerCapture(H.pointerId),
          i.domElement.removeEventListener("pointermove", wt),
          i.domElement.removeEventListener("pointerup", dt)),
        i.dispatchEvent(B_),
        (s = n.NONE);
    }
    function he(H) {
      we(H);
    }
    function Et(H) {
      let ne;
      switch (H.button) {
        case 0:
          ne = i.mouseButtons.LEFT;
          break;
        case 1:
          ne = i.mouseButtons.MIDDLE;
          break;
        case 2:
          ne = i.mouseButtons.RIGHT;
          break;
        default:
          ne = -1;
      }
      switch (ne) {
        case wa.DOLLY:
          if (i.enableZoom === !1) return;
          Q(H), (s = n.DOLLY);
          break;
        case wa.ROTATE:
          if (H.ctrlKey || H.metaKey || H.shiftKey) {
            if (i.enablePan === !1) return;
            V(H), (s = n.PAN);
          } else {
            if (i.enableRotate === !1) return;
            ie(H), (s = n.ROTATE);
          }
          break;
        case wa.PAN:
          if (H.ctrlKey || H.metaKey || H.shiftKey) {
            if (i.enableRotate === !1) return;
            ie(H), (s = n.ROTATE);
          } else {
            if (i.enablePan === !1) return;
            V(H), (s = n.PAN);
          }
          break;
        default:
          s = n.NONE;
      }
      s !== n.NONE && i.dispatchEvent(ff);
    }
    function ft(H) {
      switch (s) {
        case n.ROTATE:
          if (i.enableRotate === !1) return;
          ve(H);
          break;
        case n.DOLLY:
          if (i.enableZoom === !1) return;
          U(H);
          break;
        case n.PAN:
          if (i.enablePan === !1) return;
          oe(H);
          break;
      }
    }
    function Bt(H) {
      i.enabled === !1 ||
        i.enableZoom === !1 ||
        s !== n.NONE ||
        (H.preventDefault(), i.dispatchEvent(ff), ue(H), i.dispatchEvent(B_));
    }
    function bt(H) {
      i.enabled === !1 || i.enablePan === !1 || fe(H);
    }
    function G(H) {
      switch ((Ce(H), A.length)) {
        case 1:
          switch (i.touches.ONE) {
            case ya.ROTATE:
              if (i.enableRotate === !1) return;
              le(), (s = n.TOUCH_ROTATE);
              break;
            case ya.PAN:
              if (i.enablePan === !1) return;
              be(), (s = n.TOUCH_PAN);
              break;
            default:
              s = n.NONE;
          }
          break;
        case 2:
          switch (i.touches.TWO) {
            case ya.DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1) return;
              He(), (s = n.TOUCH_DOLLY_PAN);
              break;
            case ya.DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1) return;
              Se(), (s = n.TOUCH_DOLLY_ROTATE);
              break;
            default:
              s = n.NONE;
          }
          break;
        default:
          s = n.NONE;
      }
      s !== n.NONE && i.dispatchEvent(ff);
    }
    function N(H) {
      switch ((Ce(H), s)) {
        case n.TOUCH_ROTATE:
          if (i.enableRotate === !1) return;
          Oe(H), i.update();
          break;
        case n.TOUCH_PAN:
          if (i.enablePan === !1) return;
          Me(H), i.update();
          break;
        case n.TOUCH_DOLLY_PAN:
          if (i.enableZoom === !1 && i.enablePan === !1) return;
          Qe(H), i.update();
          break;
        case n.TOUCH_DOLLY_ROTATE:
          if (i.enableZoom === !1 && i.enableRotate === !1) return;
          Pe(H), i.update();
          break;
        default:
          s = n.NONE;
      }
    }
    function pe(H) {
      i.enabled !== !1 && H.preventDefault();
    }
    function xe(H) {
      A.push(H);
    }
    function we(H) {
      delete I[H.pointerId];
      for (let ne = 0; ne < A.length; ne++)
        if (A[ne].pointerId == H.pointerId) {
          A.splice(ne, 1);
          return;
        }
    }
    function Ce(H) {
      let ne = I[H.pointerId];
      ne === void 0 && ((ne = new Ue()), (I[H.pointerId] = ne)),
        ne.set(H.pageX, H.pageY);
    }
    function We(H) {
      const ne = H.pointerId === A[0].pointerId ? A[1] : A[0];
      return I[ne.pointerId];
    }
    i.domElement.addEventListener("contextmenu", pe),
      i.domElement.addEventListener("pointerdown", ht),
      i.domElement.addEventListener("pointercancel", he),
      i.domElement.addEventListener("wheel", Bt, { passive: !1 }),
      this.update();
  }
}
class og extends WC {
  constructor(e, t = {}) {
    super(),
      (this.options = Object.assign({
        controls: E.urlParams.has("controls"),
        cameraZOffset: 10,
        mouseMoveAngle: new Ue(0.1, 0.1),
        pointerNormalize1: 0.04,
        pointerNormalize2: 0.03,
        cameraZPos: 10,
        cameraMultiplier: 0,
      })),
      (this.cameraLookAt = new Z(0, 0, 0)),
      (this.smoothMouse = [new Ue(), new Ue()]),
      (this._quaternion = new ws()),
      (this._euler = new Cl()),
      (this.name = e || E.sceneName),
      (this.camera = new Gi(45, E.window.w / E.window.h, 0.1, 50)),
      (this.camera.position.z = 10),
      this.add(this.camera),
      (this.cameraHelper = new OD(this.camera)),
      (this.cameraHelper.visible = !1),
      this.add(this.cameraHelper),
      (this.devCamera = new Gi(45, E.window.w / E.window.h, 1, 1e3)),
      (this.devCamera.position.z = 10),
      (this.devCamera.position.y = 3),
      this.add(this.devCamera),
      (this.controls = new fL(this.devCamera, E.WebGL.renderer.domElement)),
      this.controls.target.set(0, 0, 0),
      (this.controls.enabled = this.options.controls),
      (this.controls.enableDamping = !0),
      this.breakpointTest();
  }
  updateCamera() {
    this.controls.enabled ||
      E.isTouch ||
      (this.camera.translateZ(-this.options.cameraZOffset),
      this._euler.set(
        this.smoothMouse[0].y *
          (this.options.mouseMoveAngle.y + this.options.cameraMultiplier),
        -this.smoothMouse[0].x *
          (this.options.mouseMoveAngle.x + this.options.cameraMultiplier),
        0
      ),
      this._quaternion.setFromEuler(this._euler),
      this.camera.quaternion.multiply(this._quaternion),
      this._euler.set(
        0,
        0,
        (this.smoothMouse[0].x - this.smoothMouse[1].x) * -0.05
      ),
      this._quaternion.setFromEuler(this._euler),
      this.camera.quaternion.multiply(this._quaternion),
      this.camera.translateZ(this.options.cameraZOffset),
      this.camera.updateMatrixWorld());
  }
  breakpointTest() {}
  easeHelper(e) {
    const t = e.getPoints(20),
      i = new cn().setFromPoints(t),
      n = new lu({ color: 16711680 }),
      s = new cu(i, n);
    this.add(s);
  }
}
class mL extends og {
  constructor() {
    super();
    q(this, "enableDarkMode", () => {
      this.trails.forEach((t, i) => {
        t.planes.forEach((n, s) => {
          K.to(n.material.uniforms.uModeProgress, { value: 1, duration: 0.2 });
        });
      });
    });
    q(this, "disableDarkMode", () => {
      this.trails.forEach((t, i) => {
        t.planes.forEach((n, s) => {
          K.to(n.material.uniforms.uModeProgress, { value: 0, duration: 0.2 });
        });
      });
    });
    q(this, "onPointerDown", () => {
      (this.mouseDown = !0),
        (this.startPoint.x = E.pointer.x),
        (this.startPoint.y = E.pointer.y),
        (this.topHalf = -1),
        this.startPoint.y < E.window.h * 0.5 && (this.topHalf = 1);
    });
    q(this, "onPointerUp", () => {
      (this.startPoint.x = 0), (this.startPoint.y = 0), (this.mouseDown = !1);
    });
    q(this, "touchDrag", (t, i) => {
      this.mouseArgs = i;
    });
    q(this, "onRaf", () => {
      if (!this.pausedRaf) {
        if (
          (this.controls.enabled && this.controls.update(),
          this.camera.position.set(0, 0, this.options.cameraZPos),
          this.camera.lookAt(this.cameraLookAt),
          this.smoothMouse[0].lerp(E.pointer.glNormalized, 0.02),
          this.smoothMouse[1].lerp(E.pointer.glNormalized, 0.02),
          this.mouseDown && this.mouseArgs)
        ) {
          (this.x = E.pointer.x - this.startPoint.x),
            (this.y = E.pointer.y - this.startPoint.y),
            (this.prevTime = this.currentTime),
            (this.currentTime = new Date().getTime()),
            (this.deltaTime = this.currentTime - this.prevTime),
            (this.distance = Math.sqrt(this.x * this.x + this.y * this.y));
          const t = ((this.distance * 2) / this.deltaTime) * 2;
          (this.tweenParams.mouseSpeedMultiplier =
            Math.abs(this.distance) * t * 1e-7),
            (this.tweenParams.mouseSpeedMultiplier = K.utils.clamp(
              0,
              0.01,
              this.tweenParams.mouseSpeedMultiplier
            ));
        } else
          (this.tweenParams.mouseSpeedMultiplier = this.lerp(
            this.tweenParams.mouseSpeedMultiplier,
            0,
            0.05
          )),
            (this.options.cameraMultiplier = this.lerp(
              this.options.cameraMultiplier,
              0,
              0.05
            ));
        (this.options.cameraMultiplier +=
          this.tweenParams.mouseSpeedMultiplier *
          0.09 *
          E.WebGL.normalizeDelta),
          this.updateCamera();
        for (let t = 0; t < 10; t++) {
          this.vortexPlaying &&
            this.progress[t] < 0.05 &&
            ((this.trails[0].planes[t].visible = !0),
            (this.trails[1].planes[t].visible = !0),
            (this.trails[2].planes[t].visible = !0),
            (this.trails[3].planes[t].visible = !0),
            (this.trails[4].planes[t].visible = !0),
            (this.trails[5].planes[t].visible = !0)),
            (this.progress[t] += 0.0018 * E.WebGL.normalizeDelta),
            (this.progress[t] +=
              this.tweenParams.speedMultiplier * E.WebGL.normalizeDelta),
            (this.progress[t] +=
              this.tweenParams.mouseSpeedMultiplier * E.WebGL.normalizeDelta),
            this.loopVortex
              ? (this.progress[t] = this.progressWrap(this.progress[t]))
              : (this.progress[t] = K.utils.clamp(0, 1, this.progress[t]));
          const i = Math.pow(this.progress[t], 1.7);
          this.curve.getPointAt(i, this.positions[t]),
            this.scaleEase.getPointAt(i, this.scaleProgress[t]),
            this.opacityEase.getPointAt(
              this.progress[t],
              this.opacityProgress[t]
            ),
            this.rotationEase.getPointAt(
              this.progress[t],
              this.rotationProgress[t]
            ),
            this.trails.forEach((n, s) => {
              (n.planes[t].material.uniforms.uTrailPosition.value =
                this.positions[t]),
                (n.planes[t].material.uniforms.uScale.value =
                  this.scaleProgress[t].y),
                (n.planes[t].material.uniforms.uTransparency.value =
                  this.opacityProgress[t].y *
                  this.tweenParams.opacityMultiplier),
                (n.planes[t].material.uniforms.uRotation.value =
                  this.rotationProgress[t].y + this.rotationOffsets[s]);
            });
        }
        this.vortexGroup.scale.set(
          this.tweenParams.groupScale,
          this.tweenParams.groupScale,
          this.tweenParams.groupScale
        ),
          this.options.controls
            ? E.WebGL.renderer.render(this, this.devCamera)
            : E.WebGL.renderer.render(this, this.camera);
      }
    });
    q(this, "onResize", () => {
      (this.camera.aspect = E.window.w / E.window.h),
        this.camera.updateProjectionMatrix(),
        (this.devCamera.aspect = E.window.w / E.window.h),
        this.devCamera.updateProjectionMatrix();
    });
    (this.origOptions = { ...this.options }),
      (this.mouseDown = !1),
      (this.options.resposive = { cameraPositions: { sm: 7, md: 8, lg: 10 } }),
      (this.startPoint = { x: 0, y: 0 }),
      (this.options.cameraZOffset = this.options.resposive.cameraPositions.sm),
      (this.options.cameraZPos = this.options.resposive.cameraPositions.sm),
      (this.trailCurve = new pL()),
      (this.curve = this.trailCurve.curve),
      this.createEasings(),
      (this.positions = []),
      (this.progress = []),
      (this.positionProgress = []),
      (this.scaleProgress = []),
      (this.opacityProgress = []),
      (this.rotationProgress = []),
      (this.progressWrap = K.utils.wrap(0, 1)),
      (this.components = {
        imageTrail1: new za(0, 0),
        imageTrail2: new za(1, 0),
        imageTrail3: new za(0, 4),
        imageTrail4: new za(1, 4),
        imageTrail5: new za(0, 7),
        imageTrail6: new za(1, 7),
      }),
      (this.pausedRaf = !1),
      (this.loopVortex = !0),
      (this.vortexPlaying = !1),
      this.load(),
      (this.currentTime = new Date().getTime());
  }
  start() {
    (this.pausedRaf = !1),
      (this.loopVortex = !0),
      K.timeline()
        .set(E.WebGL.canvas.vortex, { autoAlpha: 1 })
        .to(
          E.WebGL.scenes.vortex.tweenParams,
          {
            speedMultiplier: 0,
            opacityMultiplier: 1,
            groupScale: 1,
            duration: 2,
            ease: "power1.inOut",
          },
          0.05
        ),
      this.addEvents();
  }
  stop() {
    K.to(E.WebGL.canvas.vortex, { autoAlpha: 0 }),
      this.setupPositions(),
      this.removeEvents();
  }
  startVortex() {
    (this.vortexPlaying = !0), this.buildIntro();
  }
  createEasings() {
    (this.scaleEase = new Tb(
      [
        new Z(0, 1, 0),
        new Z(0.5, 0.95, 0),
        new Z(0.999999, 0.6, 0),
        new Z(1, 0, 0),
      ],
      !1,
      "catmullrom",
      0.1
    )),
      (this.opacityEase = new nD(
        new Ue(0, 0),
        new Ue(0.01, 0.2),
        new Ue(0.8, 0.99),
        new Ue(1, 1)
      )),
      (this.rotationEase = new sD([new Ue(0, -0.1), new Ue(1, 0.7)]));
  }
  build() {
    for (const i in this.components)
      this.components[i].build(this.objectData), this.add(this.components[i]);
    this.setupPositions(),
      (this.trails = [
        this.components.imageTrail1,
        this.components.imageTrail2,
        this.components.imageTrail3,
        this.components.imageTrail4,
        this.components.imageTrail5,
        this.components.imageTrail6,
      ]),
      (this.vortexGroup = new ts()),
      this.add(this.vortexGroup);
    const t = [0, -60, -120, -180, -240, -300];
    (this.rotationOffsets = [0, 0, 0, 90, 180, -90]),
      this.trails.forEach((i, n) => {
        (i.rotation.z = Bo.degToRad(t[n])), this.vortexGroup.add(i);
      });
  }
  buildIntro() {
    return K.timeline().to(this.tweenParams, {
      speedMultiplier: 0,
      opacityMultiplier: 1,
      groupScale: 1,
      duration: 2,
      ease: "power1.inOut",
    });
  }
  setupPositions() {
    (this.tweenParams = {
      speedMultiplier: 0.0018 * 15,
      opacityMultiplier: 0.3,
      groupScale: 0.7,
      mouseSpeedMultiplier: 0,
    }),
      (this.progress = []),
      (this.positions = []),
      (this.positionProgress = []),
      (this.scaleProgress = []),
      (this.opacityProgress = []),
      (this.rotationProgress = []);
    for (let t = 0; t < 10; t++)
      this.progress.push(t * 0.1),
        this.positions.push(new Z()),
        this.positionProgress.push(new Ue()),
        this.scaleProgress.push(new Ue()),
        this.opacityProgress.push(new Ue()),
        this.rotationProgress.push(new Ue());
  }
  addEvents() {
    De.on(Ze.RESIZE, this.onResize),
      De.on("DarkMode:enabled", this.enableDarkMode),
      De.on("DarkMode:disabled", this.disableDarkMode),
      E.RAFCollection.add(this.onRaf, 1),
      this.startVortex(),
      De.on(Ze.POINTERDOWN, this.onPointerDown),
      De.on(Ze.POINTERUP, this.onPointerUp),
      De.on(Ze.MOUSEDRAG, this.touchDrag);
  }
  startRaf() {
    E.RAFCollection.add(this.onRaf, 1);
  }
  removeEvents() {
    De.off(Ze.RESIZE, this.onResize),
      De.off("DarkMode:enabled", this.enableDarkMode),
      De.off("DarkMode:disabled", this.disableDarkMode),
      E.RAFCollection.remove(this.onRaf),
      (this.vortexPlaying = !1),
      De.off(Ze.POINTERDOWN, this.onPointerDown),
      De.off(Ze.POINTERUP, this.onPointerUp),
      De.off(Ze.MOUSEDRAG, this.touchDrag);
  }
  lerp(t, i, n) {
    return (1 - n) * t + n * i;
  }
  stopRaf() {
    E.RAFCollection.remove(this.onRaf);
  }
  load() {
    this.assets = { textures: {}, models: {} };
    for (let t = 0; t < 20; t++)
      E.AssetLoader.loadTexture(window.globalData.vortexImages[t]).then((i) => {
        (this.assets.textures[`image${t}`] = i),
          (this.assets.textures[`image${t}`].width = i.image.width),
          (this.assets.textures[`image${t}`].height = i.image.height);
      });
  }
  destroy() {
    this.stop();
    for (const t in this.components)
      this.components[t].destroy && this.components[t].destroy();
    Object.assign(this.options, this.origOptions);
  }
}
class jt {
  constructor(e) {
    q(this, "stCollection", []);
    q(this, "el", null);
    q(this, "dom", {});
    q(this, "_eventStack", []);
    this.el = e;
  }
  populateDom() {
    this.dom = {};
    const e = `${this.constructor.selector.replace(/[.#]/g, "")}`,
      t = od(`[class^="${e}:"], [class*=" ${e}:"]`, this.el);
    if (t.length)
      for (let i = 0; i < t.length; i++) {
        const n = t[i].classList.value.match(new RegExp(`${e}[:-]([^ ]+)`));
        if (n) {
          if (
            (this.dom[n[1]] || (this.dom[n[1]] = t[i]),
            !this.dom[n[1] + "Array"])
          ) {
            this.dom[n[1] + "Array"] = [t[i]];
            continue;
          }
          this.dom[n[1] + "Array"].push(t[i]);
        }
      }
  }
  on(e, t, i, n) {
    De.on(e, t, i, n),
      this._eventStack.push({ event: e, el: t, callback: i, options: n });
  }
  delegate(e, t, i) {
    De.delegate(e, t, i),
      this._eventStack.push({ event: e, el: t, callback: i, options: void 0 });
  }
  off(e, t, i, n) {
    De.off(e, t, i, n);
  }
  emit(e, ...t) {
    De.emit(e, ...t);
  }
  destroy() {
    for (let e = 0; e < this._eventStack.length; e++) {
      const { event: t, el: i, callback: n, options: s } = this._eventStack[e];
      this.off(t, i, n, s);
    }
    (this._eventStack = []),
      this.stCollection.length > 0 &&
        (this.stCollection.forEach((e) => e.kill()), (this.stCollection = []));
  }
}
q(jt, "selector", null), q(jt, "isSingleton", !1);
class gw extends jt {
  constructor(t) {
    super(t);
    q(this, "toggle", () => {
      this.isOpen() ? this.close() : this.open();
    });
    const i = this.el.getAttribute("aria-controls");
    if (
      ((this.target = at(`#${i}`)),
      (this.openProp = Ao(this.el, "aria-expanded") || "false"),
      this.target === null)
    )
      throw new Error(
        `The Toggle element must have a valid aria-controls attribute and a matching target element within the DOM. "#${i}" could not be found.`
      );
    Ao(this.el, "aria-expanded") === null &&
      Ao(this.el, "aria-expanded", "false"),
      this.on("click", this.el, this.toggle);
  }
  open() {
    return new Promise((t) => {
      this.onOpen(t);
    }).then(() => {
      (this.openProp = "true"), Ao(this.el, "aria-expanded", "true");
    });
  }
  onOpen(t) {
    (this.target.style.display = "block"), t();
  }
  close() {
    return new Promise((t) => {
      this.onClose(t);
    }).then(() => {
      (this.openProp = "false"), Ao(this.el, "aria-expanded", "false");
    });
  }
  onClose(t) {
    (this.target.style.display = "none"), t();
  }
  isOpen() {
    return this.openProp === "true";
  }
}
q(gw, "selector", ".js-toggle");
class vw extends jt {
  constructor(t) {
    super(t);
    q(this, "hostname", null);
    q(this, "includeSubDomains", !1);
    q(this, "acceptBtn", null);
    q(this, "onAccept", () => {
      this.setCookie("true"),
        this.enableAnalytics(),
        this.updateStore(),
        this.hide();
    });
    q(this, "onReject", () => {
      this.setCookie("false"), this.updateStore(), this.hide();
    });
    this.hostname === null && (this.hostname = window.location.hostname),
      (this.acceptBtn = at(".js-cookie-notice-accept", this.el)),
      this.updateStore(),
      document.cookie.match(/cookie_notice_accepted/)
        ? this.hide()
        : (this.on("click", this.acceptBtn, this.onAccept), this.show());
  }
  hide() {
    this.el.classList.remove("is-open"), (this.el.style.display = "none");
  }
  show() {
    this.el.classList.add("is-open"), this.el.classList.remove("d-none");
  }
  setCookie(t) {
    const i = new Date();
    i.setMonth(i.getMonth() + 1);
    let n = `cookie_notice_accepted=${t};expires=${i.toUTCString()};path=/`;
    this.includeSubDomains === !0 && (n += `;domain=${this.hostname}`),
      (document.cookie = n);
  }
  enableAnalytics() {
    window.gtag &&
      window.gtag("consent", "default", {
        ad_storage: "granted",
        analytics_storage: "granted",
      });
  }
  updateStore() {
    (E.cookieNoticeAccepted = document.cookie
      .split(";")
      .some((t) => t.includes("cookie_notice_accepted=true"))),
      E.cookieNoticeAccepted === !0 && this.emit("cookienotice:accepted");
  }
}
q(vw, "selector", ".js-cookie-notice");
class _w extends jt {
  constructor(t, i = {}) {
    super(t);
    q(this, "last", { x: 0, y: 0 });
    q(this, "follow", () => {
      const t = E.pointer.x - this.last.x - this.xOffset,
        i = E.pointer.y - this.last.y - this.yOffset;
      (Math.abs(t) >= 0.05 || Math.abs(i) >= 0.05) &&
        ((this.last.x += t * this.ease),
        (this.last.y += i * this.ease),
        (this.el.style.transform = `translate(${this.last.x}px, ${this.last.y}px)`));
    });
    q(this, "onMouseEnter", (t) => {
      this[t.currentTarget.dataset.cursor](t);
    });
    q(this, "onMouseleave", (t) => {
      this.default(t);
    });
    !(E.mq.touch.matches && !i.enableOnTouch) &&
      ((this.ease = i.ease || 0.05),
      this.updateOffset(...(i.offset || [0, 0])),
      this.populateDom(),
      this.on(Ze.RAF, this.follow),
      this.delegate("mouseenter", "[data-cursor]", this.onMouseEnter),
      this.delegate("mouseleave", "[data-cursor]", this.onMouseleave));
  }
  updateOffset(t, i) {
    (this.rect = this.el.getBoundingClientRect()),
      (this.xOffset = this.rect.width * t),
      (this.yOffset = this.rect.width * i);
  }
  default() {}
}
q(_w, "selector", ".js-custom-cursor");
class na extends jt {
  constructor(t) {
    super(t);
    q(this, "onResize", () => {
      this.ctx.revert(),
        this.ctx.kill(),
        (this.ctx = K.context(() => {
          this.setup(), this.buildTimeline(), this.tl.pause().seek(1.5).play();
        }));
    });
    this.populateDom(),
      (this.container = this.el.closest(".js-dynamic-text-container")),
      (this.ctx = K.context(() => {
        this.setup(), this.buildTimeline();
      }));
  }
  setup() {
    (this.widths = []),
      this.dom.textArray.forEach((t, i) => {
        this.widths.push(t.getBoundingClientRect().width),
          i > 0 &&
            K.set(t, { opacity: 0, position: "absolute", top: 0, left: 0 });
      }),
      (this.progressWrap = K.utils.wrap(0, this.dom.textArray.length)),
      (this.dom.border.style.width = this.widths[0] + "px"),
      (this.current = 0),
      (this.next = 1);
  }
  buildTimeline() {
    this.tl = K.timeline({ repeat: -1 });
    for (let t = 0; t < this.dom.textArray.length; t++) {
      const i = this.widths[this.current] - this.widths[this.next];
      this.tl.to(
        this.dom.border,
        { width: "-=" + i, duration: 0.5, ease: "expo.inOut" },
        (t + 1) * 1.5
      ),
        this.container && this.tl.set(this.container, { x: 0 }, 0),
        this.tl
          .to(
            this.dom.textArray[this.current],
            { opacity: 0, duration: 0.5, ease: "expo.out" },
            (t + 1) * 1.5
          )
          .to(
            this.dom.textArray[this.next],
            { opacity: 1, overwrite: "auto", duration: 0.5, ease: "expo.in" },
            (t + 1) * 1.5
          ),
        this.container &&
          this.tl.to(
            this.container,
            { x: "+=" + i * 0.5, duration: 0.5, ease: "expo.inOut" },
            (t + 1) * 1.5
          ),
        this.current++,
        (this.current = this.progressWrap(this.current)),
        this.next++,
        (this.next = this.progressWrap(this.next));
    }
    this.tl.pause(), this.tl.seek(1.5);
  }
  destroy() {
    this.ctx.kill(), super.destroy();
  }
}
q(na, "selector", ".js-dynamic-text");
class ag extends jt {
  constructor(t) {
    super(t);
    q(this, "waitlistLoading", () => {
      K.to(
        this.dom.waitlistLoading,
        { rotate: 360, duration: 1, repeat: -1, ease: "linear" },
        0
      ),
        (this.waitlistLoadingTL = K.timeline({ defaults: { duration: 0.3 } })
          .to(this.dom.submitText, { opacity: 0 })
          .to(this.dom.waitlistLoadingContainer, { opacity: 1 }, 0.2));
    });
    q(this, "returnToPreviousState", () => {
      K.timeline({ defaults: { duration: 0.3 } })
        .to(this.dom.submitText, { opacity: 1 }, 0.2)
        .to(this.dom.secondaryLoading, { opacity: 0 }, 0)
        .set(this.dom.waitlistLoading, { rotate: 0, overwrite: "auto" });
    });
    q(this, "returnToPreviousStateSecondary", () => {
      this.dom.secondaryInputEl.classList.remove("hide-placeholder"),
        K.timeline({ defaults: { duration: 0.3 } })
          .to(this.dom.answerSubmitText, { opacity: 1 }, 0.2)
          .to(this.dom.secondaryLoading, { opacity: 0 }, 0)
          .to(this.dom.secondarySubmit, { opacity: 1, overwrite: "auto" })
          .to(this.dom.closeSecondaryForm, { autoAlpha: 1 }, 0)
          .set(this.dom.secondaryLoading, { rotate: 0, overwrite: "auto" });
    });
    q(this, "formSubmissionSuccess", () => {
      (this.flowStarted = !0),
        (this.waitlistSubmitted = !0),
        K.timeline({ defaults: { ease: "expo.inOut", duration: 0.6 } })
          .call(() => {
            this.dom.inputEl.classList.add("hide-placeholder"),
              this.dom.confirmationText.classList.remove("d-none");
          }, 0)
          .to(
            [this.dom.confirmationText, this.dom.inputBorder],
            { opacity: 1, duration: 0.5, pointerEvents: "none" },
            0
          )
          .to(
            [this.dom.tickMask, this.dom.tickSvg],
            { xPercent: 0, duration: 1 },
            0
          )
          .to(
            this.dom.submit,
            {
              width: "2.8125rem",
              padding: 0,
              duration: 1,
              pointerEvents: "none",
            },
            0
          )
          .to(
            [this.dom.waitlistLoadingContainer],
            { opacity: 0, duration: 0.2 },
            0
          )
          .set(this.dom.waitlistLoading, { rotate: 0, overwrite: "auto" }, 0.2)
          .call(
            () => {
              this.showSecondaryForm(), this.dom.secondaryInputEl.focus();
            },
            null,
            2
          )
          .set(this.dom.secondaryForm, { pointerEvents: "auto" }, 2);
    });
    q(this, "showSecondaryForm", () => {
      this.dom.submit.classList.add("footer-form-submitted"),
        this.dom.submit.classList.add("hide-glow"),
        this.dom.tickSvg.classList.add("footer-form-submitted"),
        K.timeline({ defaults: { ease: "expo.in", duration: 0.8 } })
          .to(
            this.dom.inputContainer,
            {
              width: 0,
              duration: 0.4,
              ease: "linear",
              transformOrigin: "0 50%",
            },
            0
          )
          .to(
            [this.dom.inputEl, this.dom.confirmationText, this.dom.inputBorder],
            { opacity: 0, duration: 0.4, ease: "linear" },
            0
          )
          .to(
            this.dom.secondaryForm,
            {
              opacity: 1,
              yPercent: 0,
              duration: 1.2,
              ease: "customIn",
              overwrite: "auto",
            },
            0.1
          )
          .set(this.dom.inputEl, { pointerEvents: "none" })
          .set(this.dom.waitlistError, {
            yPercent: 470,
            xPercent: -50,
            opacity: 0,
            pointerEvents: "none",
          });
    });
    q(this, "secondaryWaiting", () => {
      K.to(this.dom.secondaryLoading, {
        rotate: 360,
        duration: 1,
        repeat: -1,
        ease: "linear",
      }),
        (this.secondaryWaitingTL = K.timeline({
          defaults: { duration: 0.3 },
          onStart: () => {
            this.dom.secondaryInputEl.blur(),
              this.dom.secondaryInputEl.classList.add("hide-placeholder");
          },
        })
          .to(this.dom.secondarySubmit, { opacity: 0 })
          .to(this.dom.closeSecondaryForm, { autoAlpha: 0 }, 0)
          .to(this.dom.secondaryLoading, { opacity: 1 }, 0.2));
    });
    q(this, "secondaryComplete", () => {
      K.timeline({ defaults: { ease: "expo.inOut", duration: 0.6 } })
        .set(this.dom.answerSubmitText, { opacity: 0 })
        .to(this.dom.secondaryLoading, { opacity: 0, duration: 0.2 }, 0)
        .set(this.dom.secondaryLoading, { rotate: 0, overwrite: "auto" }, 0.2)
        .to(
          [this.dom.secondaryTickMask, this.dom.secondaryTickSvg],
          { xPercent: 0, duration: 1 },
          0.1
        )
        .then(() => {
          this.resetForm();
        });
    });
    q(this, "resetForm", () => {
      K.timeline({ defaults: { duration: 0.6, ease: "power2.inOut" } })
        .to(this.dom.secondaryForm, { autoAlpha: 0, yPercent: 20 }, 0)
        .set(this.dom.secondaryForm, { pointerEvents: "none" })
        .to(
          this.dom.inputContainer,
          {
            width: "auto",
            duration: 0.4,
            ease: "linear",
            transformOrigin: "0 50%",
          },
          0
        )
        .to(
          [this.dom.inputEl, this.dom.confirmationText, this.dom.inputBorder],
          { opacity: 1, duration: 0.4, ease: "linear" },
          0
        )
        .call(
          () => {
            this.dom.submit.classList.remove("footer-form-submitted"),
              this.dom.tickSvg.classList.remove("footer-form-submitted");
          },
          null,
          0.3
        );
    });
    q(this, "hideText", () => {
      this.waitlistSubmitted &&
        K.to([this.dom.confirmationText, this.dom.inputBorder], {
          opacity: 0,
          duration: 0.3,
        });
    });
    q(this, "showText", () => {
      this.waitlistSubmitted &&
        K.to([this.dom.confirmationText, this.dom.inputBorder], {
          opacity: 1,
          duration: 0.3,
        });
    });
    q(this, "onInputChange", () => {
      this.dom.secondaryInputEl.value.length > 16
        ? K.to(this.dom.answerSubmitText, { opacity: 0, duration: 0.26 })
        : K.to(this.dom.answerSubmitText, { opacity: 1, duration: 0.26 });
    });
    this.populateDom(),
      this.on("click", this.dom.closeSecondaryForm, this.resetForm),
      this.on("FooterForm:HideText", this.hideText),
      this.on("FooterForm:ShowText", this.showText),
      this.on("input", this.dom.secondaryInputEl, this.onInputChange),
      (this.waitlistSubmitted = !1),
      this.setInitialPositions();
  }
  setInitialPositions() {
    K.timeline()
      .set([this.dom.tickContainer, this.dom.secondaryTickContainer], {
        pointerEvents: "none",
      })
      .set([this.dom.tickMask, this.dom.secondaryTickMask], { xPercent: -103 })
      .set([this.dom.tickSvg, this.dom.secondaryTickSvg], { xPercent: 103 })
      .set(this.dom.secondaryForm, {
        pointerEvents: "none",
        opacity: 0,
        yPercent: 20,
      })
      .set(
        [
          this.dom.waitlistLoadingContainer,
          this.dom.secondaryLoading,
          this.dom.confirmationText,
        ],
        { opacity: 0 }
      )
      .set(this.dom.waitlistError, {
        yPercent: -20,
        xPercent: -50,
        opacity: 0,
        pointerEvents: "none",
      });
  }
  showError() {
    K.to(this.dom.waitlistError, {
      yPercent: "+=20",
      opacity: 1,
      overwrite: "auto",
      xPercent: -50,
    });
  }
  hideError() {
    K.to(this.dom.waitlistError, {
      yPercent: "+=-20",
      opacity: 0,
      overwrite: "auto",
      xPercent: -50,
    });
  }
  destroy() {
    super.destroy();
  }
}
q(ag, "selector", ".js-cta-footer");
class lg extends jt {
  constructor(t) {
    super(t);
    q(this, "GRADIENT_OPACITY", 0.7);
    q(this, "GLOW_OPACITY", 0.8);
    q(this, "GLOW_OPACITY_HOVER", 1);
    q(this, "onMouseEnter", () => {
      (this.isHovering = !0),
        (this.bounding = this.el.getBoundingClientRect()),
        K.to(this.gradient, { opacity: this.GRADIENT_OPACITY, duration: 0.1 }),
        K.to(this.glowPanels, {
          filter: "blur(20px)",
          opacity: this.GLOW_OPACITY_HOVER,
          duration: 0.3,
        }),
        this.on("mousemove", this.el, this.onMouseMove);
    });
    q(this, "onMouseMove", (t) => {
      if (!this.isHovering) return;
      const i = t.x - Math.floor(this.bounding.left),
        n = t.y - Math.floor(this.bounding.top),
        s = (i / Math.floor(this.bounding.width)) * 2 - 1,
        a = (n / Math.floor(this.bounding.height)) * 2 - 1;
      this.glowXTo(20 * s),
        this.glowYTo(7 * a),
        this.leftTo(i),
        this.topTo(t.y - this.bounding.top),
        this.rotateTo((i / this.el.offsetWidth) * 270);
    });
    q(this, "onMouseLeave", () => {
      (this.isHovering = !1),
        this.off("mousemove", this.el, this.onMouseMove),
        K.to(this.glowPanels, {
          filter: "blur(15px)",
          opacity: this.GLOW_OPACITY,
          duration: 0.3,
        }),
        this.glowXTo(0),
        this.glowYTo(0),
        K.to(this.gradient, { opacity: 0, duration: 0.1 });
    });
    !(this.el.classList.contains("has-overlay") || E.mq.touch.matches) &&
      (this.createOverlay(),
      this.el.classList.add("relative", "overflow-hidden", "has-overlay"),
      this.el.classList.remove("overflow-hidden"),
      (this.leftTo = K.quickTo(this.gradient, "left", {
        duration: 0.1,
        ease: "linear",
      })),
      (this.topTo = K.quickTo(this.gradient, "top", {
        duration: 0.1,
        ease: "linear",
      })),
      (this.rotateTo = K.quickTo(this.gradient, "rotation", {
        duration: 0.1,
        ease: "linear",
      })),
      (this.glowPanel1 = this.createGlowPanel({ left: 4 }, 1)),
      (this.glowPanel2 = this.createGlowPanel({ right: 4 }, 2)),
      (this.glowPanels = [this.glowPanel1, this.glowPanel2]),
      (this.glowXTo = K.quickTo(this.glowPanels, "x", {
        duration: 0.3,
        ease: "linear",
      })),
      (this.glowYTo = K.quickTo(this.glowPanels, "y", {
        duration: 0.3,
        ease: "linear",
      })),
      this.addEvents());
  }
  createOverlay() {
    K.set(this.el, { position: "relative" }),
      (this.overlay = document.createElement("div")),
      (this.gradient = document.createElement("div")),
      this.overlay.classList.add(
        "button__overlay",
        "absolute",
        "fill",
        "overflow-hidden",
        "rounded-15"
      ),
      this.gradient.classList.add("button__overlay__inner", "absolute"),
      this.overlay.appendChild(this.gradient),
      this.el.appendChild(this.overlay);
  }
  createGlowPanel(t, i) {
    const n = document.createElement("div"),
      s = document.createElement("div");
    return (
      n.classList.add("button__glow"),
      s.classList.add("button__glow__panel", `button__glow__panel--${i}`),
      K.set(n, t),
      n.appendChild(s),
      this.el.appendChild(n),
      s
    );
  }
  hideGlowPanels() {
    K.to(this.glowPanels, { opacity: 0 });
  }
  showGlowPanels() {
    K.to(this.glowPanels, { opacity: this.GLOW_OPACITY });
  }
  addEvents() {
    this.on("mouseenter", this.el, this.onMouseEnter),
      this.on("mouseleave", this.el, this.onMouseLeave);
  }
}
q(lg, "selector", "button.dark\\:bg-off-white");
class cg extends jt {
  constructor(t) {
    super(t);
    q(this, "createDummyST", () => {
      var t;
      (t = this.st) == null || t.kill(),
        E.body.classList.contains("home") ||
        E.body.classList.contains("page-template-manifesto")
          ? ((this.dummy.style.height = "0px"),
            (this.st = ut.create({
              trigger: this.dummy,
              start: "top bottom+=1px",
              end: "top bottom",
              onEnter: () => {
                E.scrollToActive ||
                  ((E.scrollToActive = !0),
                  requestAnimationFrame(() => {
                    var i;
                    (i = E.SmoothScroll) == null || i.lock(),
                      E.SmoothScroll.scrollbar.hide(),
                      E.mq.touch.matches &&
                        (at(".scroll-container").style.overscrollBehavior =
                          "auto"),
                      clearTimeout(this.scrollTimeout),
                      (this.scrollTimeout = setTimeout(() => {
                        var n;
                        (n = E.SmoothScroll) == null || n.unlock(),
                          (this.dummy.style.height = this.dummyHeight),
                          (E.scrollToActive = !1),
                          E.mq.md.matches && this.createParallax();
                      }, 200));
                  }, 0));
              },
              onLeave: () => {
                this.el.style.opacity = "1";
              },
              onEnterBack: () => {
                clearTimeout(this.scrollTimeout),
                  (this.el.style.opacity = "0"),
                  this.revertParallaxes();
              },
              onLeaveBack: () => {
                clearTimeout(this.scrollTimeout),
                  (this.dummy.style.height = "0px"),
                  this.revertParallaxes(),
                  E.mq.touch.matches &&
                    (at(".scroll-container").style.overscrollBehavior = "none");
              },
            })))
          : (this.st = ut.create({
              trigger: this.dummy,
              start: "top bottom+=2%",
              end: "bottom bottom",
              onEnter: () => {
                this.el.style.opacity = "1";
              },
              onLeaveBack: () => {
                this.el.style.opacity = "0";
              },
            }));
    });
    q(this, "createParallax", () => {
      this.parallaxTweens.push(
        K.from(this.dom.inner, {
          yPercent: 115,
          ease: "power2.in",
          scrollTrigger: {
            trigger: this.dummy,
            start: "top bottom+=20%",
            end: "bottom bottom",
            scrub: !0,
          },
        })
      ),
        this.parallaxTweens.push(
          K.from(this.dom.logo, {
            yPercent: 60,
            ease: "power2.in",
            scrollTrigger: {
              trigger: this.dummy,
              start: "top bottom+=20%",
              end: "bottom bottom",
              scrub: !0,
            },
          })
        );
    });
    q(this, "revertParallaxes", () => {
      this.parallaxTweens.forEach((t) => {
        t.revert();
      });
    });
    q(this, "onResize", () => {
      (this.dummyHeight = this.el.getBoundingClientRect().height + "px"),
        !E.body.classList.contains("home") &&
          !E.body.classList.contains("page-template-manifesto") &&
          (this.dummy.style.height =
            this.el.getBoundingClientRect().height + "px"),
        this.revertParallaxes(),
        this.createDummyST(),
        E.mq.md.matches &&
          !E.body.classList.contains("home") &&
          !E.body.classList.contains("page-template-manifesto") &&
          this.createParallax();
    });
    this.populateDom(),
      (this.el.style.opacity = "0"),
      (this.parallaxTweens = []),
      (this.dummyHeight = 0),
      (this.dummy = at(".js-dummmy-footer", E.body)),
      this.on(Ze.RESIZE, this.onResize),
      this.onResize(),
      this.createDummyST(),
      E.mq.touch.matches &&
        (at(".scroll-container").style.overscrollBehavior = "none");
  }
  destroy() {
    var t;
    super.destroy(),
      (t = this.st) == null || t.kill(),
      this.parallaxTweens.forEach((i) => {
        i.kill();
      });
  }
}
q(cg, "selector", ".js-footer");
class pu extends um {
  initialLoad() {
    (this.isInitialLoad = !0),
      (E.WebGL.scenes.vortex = new mL()),
      (this.pageTransition = at(".js-page-transition")),
      K.set(this.pageTransition, { autoAlpha: 0 }),
      this.onEnter(),
      E.AssetLoader.loaded.then(() => {
        E.urlParams.has("nowebgl") || E.WebGL.scenes.vortex.build(),
          this.onEnterCompleted();
      });
  }
  onEnter() {
    var e;
    E.SmoothScroll.Lenis.scrollTo(0, { immediate: !0, force: !0 }),
      this.registerAdditionalWebgl(),
      this.registerAdditionalComponents(),
      (e = E.ScrollAnimations) == null || e.build(this.content),
      E.AssetLoader.load({ element: this.content }).then(() => {
        E.components.add(na, ag, lg, cg),
          (this.CTAfooter = at(".js-cta-footer")),
          this.CTAfooter &&
            (this.footerForm = E.FormsManager.make(this.CTAfooter, !1)),
          E.urlParams.has("gui") &&
            IA(() => Promise.resolve().then(() => iL), void 0).then(
              ({ GUI: t }) => {
                E.Gui = new mw();
              }
            );
      });
  }
  onEnterCompleted() {
    var e, t;
    (this.pageTransition = at(".js-page-transition")),
      K.to(this.pageTransition, {
        autoAlpha: 0,
        duration: 1,
        onComplete: () => {
          this.isInitialLoad ||
            ((this.isInitialLoad = !1),
            document.body.classList.remove("loader-active"));
        },
      }),
      (e = E.ScrollAnimations) == null || e.enable(),
      E.urlParams.has("nowebgl") || E.WebGL.start(),
      this.scrollToAnchor(),
      (t = E.SmoothScroll) == null || t.unlock();
  }
  onLeave() {
    var e, t;
    (e = E.ScrollAnimations) == null || e.destroy(),
      (t = E.SmoothScroll) == null || t.lock(),
      K.set(".js-scroll-prompt", { clearProps: "all" }),
      E.urlParams.has("nowebgl") || E.WebGL.stop();
  }
  onLeaveCompleted() {
    for (const e of E.components) e.destroy();
  }
  registerAdditionalWebgl() {}
  registerAdditionalComponents() {}
  scrollToAnchor() {
    if (window.location.hash) {
      const e = document.querySelector(window.location.hash);
      e && fl.scrollTo(e, { force: !0 });
    }
  }
}
class gL extends cm {
  constructor({ wrapper: e }) {
    super({ wrapper: e }), (this.pageTransition = at(".js-page-transition"));
  }
  onLeave({ from: e, trigger: t, done: i }) {
    document.body.classList.add("loader-active"),
      K.to(this.pageTransition, { autoAlpha: 1 }).then(() => i());
  }
  onEnter({ to: e, trigger: t, done: i }) {
    E.AssetLoader.loaded.then(() => {
      i();
    });
  }
}
const vL = {
    mainGrid: {
      gridIntro: { trigger: ".js-home-landing", start: "top top-=5%" },
      transformGrid: {
        trigger: ".js-home-landing",
        start: "bottom center",
        endTrigger: ".js-main-grid-st",
        end: {
          default: "bottom center",
          sm: "bottom center",
          md: "bottom top",
        },
      },
      textTransition: {
        trigger: ".js-home-landing",
        start: "bottom center",
        endTrigger: ".js-main-grid-st",
        end: { default: "bottom top+=25%", sm: "bottom top", md: "bottom top" },
      },
      extensionMenu: {
        trigger: ".js-main-grid-st",
        start: {
          default: "bottom center",
          sm: "bottom center",
          md: "bottom top",
        },
        endTrigger: ".js-main-grid",
        end: {
          default: "bottom bottom",
          sm: "bottom bottom",
          md: "bottom center",
        },
      },
      loop: {
        trigger: {
          default: ".js-main-grid",
          sm: ".js-main-grid",
          md: ".js-main-grid-st",
        },
        start: {
          default: "bottom bottom+=10%",
          sm: "bottom bottom+=10%",
          md: "bottom top-=5%",
        },
        endTrigger: ".js-main-grid",
        end: "bottom center",
      },
    },
    appGrid: {
      scrubbedTransition: {
        trigger: ".js-main-grid",
        start: {
          default: "bottom top+=75%",
          sm: "bottom bottom",
          md: "bottom center",
        },
        endTrigger: {
          default: ".js-app-grid",
          sm: ".js-app-grid",
          md: ".js-app-grid",
        },
        end: { default: "top top", sm: "top top", md: "bottom bottom" },
      },
      sectionText: {
        trigger: ".js-app-grid",
        start: {
          default: "bottom bottom+=180%",
          sm: "bottom bottom+=180%",
          md: "bottom bottom+=180%",
        },
        end: {
          default: "top top+=10%",
          sm: "top top+=10%",
          md: "bottom bottom-=20%",
        },
      },
      gridText: {
        trigger: ".js-main-grid",
        start: {
          default: "bottom top+=75%",
          sm: "bottom bottom",
          md: "bottom center",
        },
        endTrigger: {
          default: ".js-app-grid",
          sm: ".js-app-grid",
          md: ".js-app-grid",
        },
        end: {
          default: "top top+=60%",
          sm: "top top+=60%",
          md: "bottom bottom",
        },
      },
    },
    taggingSystem: {
      section: {
        trigger: ".js-app-grid",
        start: "bottom bottom",
        endTrigger: ".js-tagging-system",
        end: "top top",
      },
      video: {
        trigger: ".js-tagging-system",
        start: {
          default: "top top+=35%",
          sm: "top top+=35%",
          md: "top top+=90%",
          tablet: "top top+=25%",
        },
      },
      switch: { trigger: ".js-tagging-system", start: "top top" },
      text: {
        trigger: ".js-tagging-system",
        start: {
          default: "top top+=150%",
          sm: "top top+=150%",
          md: "top top+=75%",
          tablet: "top top+=75%",
        },
        end: "top top+=15%",
      },
      tags: {
        trigger: ".js-tagging-system",
        start: "bottom bottom",
        end: "bottom top+=10%",
      },
      hideTags: {
        trigger: ".js-tagging-system",
        start: "top bottom",
        end: "top top+=60%",
      },
      out: {
        trigger: ".js-tagging-system",
        start: "bottom bottom",
        end: "bottom top",
      },
    },
    searchSection: {
      scrubbed: {
        trigger: ".js-search-section",
        endTrigger: ".js-search-section",
        start: "top bottom",
        end: "top top",
      },
      queryText: {
        trigger: ".js-search-section",
        start: "top bottom",
        end: "top top+=10%",
      },
      cluster: {
        trigger: ".js-search-section",
        start: "top bottom",
        end: "top top",
      },
      sectionText: {
        trigger: ".js-search-section",
        start: "top bottom",
        end: { default: "top top", sm: "top top-=20%", md: "top top-=20%" },
      },
    },
    particleGlobe: {
      scrubbed: {
        trigger: ".js-search-section",
        endTrigger: ".js-search-section",
        start: "bottom bottom",
        end: "bottom top",
      },
      section: { trigger: ".js-globe-section", start: "top bottom" },
      text: {
        trigger: ".js-globe-section",
        start: "top bottom",
        end: { default: "top top", sm: "top top-=30%", md: "top top-=30%" },
      },
      imageSlider: { trigger: ".js-globe-section", start: "top bottom" },
      particleScrubbed: {
        trigger: ".js-globe-section",
        start: "top bottom",
        end: "top top+=10%",
      },
    },
    appPreview: {
      text: {
        trigger: ".js-app-preview",
        start: "top bottom",
        end: { default: "top top", sm: "top top-=20%", md: "top top-=20%" },
      },
    },
  },
  Xe = { scrollTriggers: vL };
let Ua = "default";
class fu extends jt {
  constructor(t) {
    super(t);
    q(this, "gridIntro", () => {
      this.gridIntroTL = K.timeline({
        defaults: { duration: 0.8, ease: "customIn" },
        onStart: () => {
          var t;
          (t = E.SmoothScroll) == null || t.lock(),
            E.mq.sm.matches && this.emit("ModeToggle:CollapseToggle");
        },
      })
        .call(
          () => {
            E.WebGL.scenes.vortex.loopVortex = !1;
          },
          null,
          0
        )
        .to(".js-scroll-prompt", { opacity: 0 }, 0)
        .to(
          E.WebGL.scenes.vortex.tweenParams,
          { speedMultiplier: 1, duration: 1.5, ease: "expo.in" },
          0
        )
        .to(
          E.WebGL.scenes.vortex.tweenParams,
          { groupScale: 0, duration: 1, ease: "expo.in" },
          0
        )
        .to(
          E.WebGL.scenes.vortex.tweenParams,
          { opacityMultiplier: 0, duration: 1.1, ease: "expo.in" },
          0
        )
        .to(this.homeLandingInner, { scale: 0, duration: 1, force3D: !1 }, 0)
        .call(
          () => {
            this.dynamicText.tl.pause(), this.dynamicText.tl.seek(1.5);
          },
          null,
          1
        )
        .to(this.homeLanding, { autoAlpha: 0, duration: 0.6 }, 0)
        .to(
          [E.WebGL.canvas.vortex, ".vortex-vignette"],
          { autoAlpha: 0, duration: 0.3 },
          0.6
        )
        .to(this.headerWordmark, { autoAlpha: 1, duration: 0.2 }, 0.6)
        .call(
          () => {
            (E.WebGL.scenes.vortex.pausedRaf = !0),
              (E.WebGL.scenes.vortex.loopVortex = !0),
              E.WebGL.scenes.vortex.setupPositions();
          },
          null,
          1.4
        )
        .to(
          this.dom.itemArray,
          {
            x: 0,
            y: 0,
            scale: 1,
            opacity: 1,
            ease: "power2.out",
            duration: 0.6,
            force3D: !1,
            onComplete: () => {
              var t;
              (t = E.SmoothScroll) == null || t.unlock();
            },
          },
          0.9
        )
        .to(
          this.dom.title,
          { opacity: 1, ease: "expo.out", duration: 0.95 },
          0.9
        )
        .titleIn(this.dom.title, null, 0.2)
        .transformUp(this.dom.subtitle, null, 1)
        .call(() => {
          this.dynamicTextGrid.tl.play();
        });
    });
    q(this, "returnToVortex", () => {
      this.returnToVortexTL = K.timeline({
        onStart: () => {
          var t;
          (t = E.SmoothScroll) == null || t.lock(),
            E.mq.sm.matches && this.emit("ModeToggle:ExpandToggle");
        },
        onComplete: () => {
          var t;
          (t = E.SmoothScroll) == null || t.unlock();
        },
      })
        .to(this.headerWordmark, { autoAlpha: 0, duration: 0.2 }, 0)
        .to(
          this.dom.itemArray,
          {
            x: (t) => this.positions[t][Ua][0] + "rem",
            y: (t) => this.positions[t][Ua][1] + "rem",
            scale: 0.8,
            force3D: !1,
            ease: "expo.in",
            duration: 1,
          },
          0
        )
        .to(
          [this.dom.itemArray, this.dom.title, this.dom.subtitle],
          { opacity: 0, ease: "expo.in", duration: 1 },
          0
        )
        .to(this.homeLanding, { autoAlpha: 1, duration: 0.6 }, 1)
        .to(this.homeLandingInner, { scale: 1, duration: 0.6 }, 1)
        .call(
          () => {
            this.dynamicTextGrid.tl.pause(),
              this.dynamicTextGrid.tl.seek(1.5),
              this.dynamicText.tl.play();
          },
          null,
          1.6
        )
        .call(
          () => {
            (E.WebGL.scenes.vortex.pausedRaf = !1),
              (E.WebGL.scenes.vortex.loopVortex = !0);
          },
          null,
          1
        )
        .to(
          [E.WebGL.canvas.vortex, ".vortex-vignette"],
          { autoAlpha: 1, duration: 0.4 },
          1.05
        )
        .to(
          E.WebGL.scenes.vortex.tweenParams,
          {
            speedMultiplier: 0,
            opacityMultiplier: 1,
            groupScale: 1,
            duration: 2,
            ease: "power1.inOut",
          },
          1.05
        )
        .to(".js-scroll-prompt", { opacity: 1 }, 0.2);
    });
    q(this, "onResize", () => {
      this.setInitialPositions(),
        this.buildST(),
        this.reset(),
        window.requestAnimationFrame(() => {
          this.dynamicTextGrid.onResize(), this.dynamicText.onResize();
        });
    });
    q(this, "reset", () => {
      (E.WebGL.scenes.vortex.pausedRaf = !1),
        E.mq.sm.matches && this.emit("ModeToggle:ExpandToggle"),
        K.timeline()
          .set(E.WebGL.canvas.vortex, { autoAlpha: 1 })
          .set(E.WebGL.scenes.vortex.tweenParams, {
            speedMultiplier: 0,
            opacityMultiplier: 1,
            groupScale: 1,
          })
          .set([this.dom.itemArray, this.dom.title, this.dom.subtitle], {
            opacity: 0,
          })
          .set(this.homeLanding, { autoAlpha: 1 })
          .set(this.homeLandingInner, { scale: 1 });
    });
    q(this, "onRaf", () => {
      this.allowItemMovement &&
        (this.current.lerp(
          E.pointer.glNormalized,
          0.1 * E.WebGL.normalizeDelta
        ),
        (this.dom.itemInnerArray[0].style.transform = `translate(${
          this.current.x * 45
        }px, ${-this.current.y * 45}px)`),
        (this.dom.itemInnerArray[1].style.transform = `translate(${
          this.current.x * 60
        }px, ${-this.current.y * 60}px)`),
        (this.dom.itemInnerArray[2].style.transform = `translate(${
          this.current.x * 55
        }px, ${-this.current.y * 55}px)`),
        (this.dom.itemInnerArray[3].style.transform = `translate(${
          this.current.x * 45
        }px, ${-this.current.y * 45}px)`),
        (this.dom.itemInnerArray[4].style.transform = `translate(${
          this.current.x * 60
        }px, ${-this.current.y * 60}px)`),
        (this.dom.itemInnerArray[5].style.transform = `translate(${
          this.current.x * 30 * this.tweenParams.amountMultiplier
        }px, ${-this.current.y * 30 * this.tweenParams.amountMultiplier}px)`),
        (this.dom.itemInnerArray[6].style.transform = `translate(${
          this.current.x * 50
        }px, ${-this.current.y * 50}px)`),
        (this.dom.itemInnerArray[7].style.transform = `translate(${
          this.current.x * 60
        }px, ${-this.current.y * 60}px)`),
        (this.dom.itemInnerArray[8].style.transform = `translate(${
          this.current.x * 60
        }px, ${-this.current.y * 60}px)`));
    });
    this.populateDom(),
      this.buildST(),
      (E.mainGridItems = this.dom.itemArray),
      (this.homeLanding = at(".js-home-landing")),
      (this.homeLandingInner = at(".js-home-landing > div")),
      (this.headerWordmark = at(".js-header-wordmark")),
      K.set(this.headerWordmark, { autoAlpha: 0 }),
      (this.positions = {
        0: { default: [4, 6], sm: [10, 10], md: [10, 10] },
        1: { default: [7, -5], sm: [7, -5], md: [7, -5] },
        2: { default: [-1, 5], sm: [4, 12], md: [4, 12] },
        3: { default: [4, -8], sm: [4, -8], md: [4, -8] },
        4: { default: [-2, -11], sm: [-2, -11], md: [-2, -11] },
        5: { default: [-4, -5], sm: [-4, -5], md: [-13, 1] },
        6: { default: [-24, -16], sm: [-24, -16], md: [-24, -16] },
        7: { default: [-18, 0], sm: [-18, 0], md: [-18, 0] },
        8: { default: [0, 0], sm: [-4, 8], md: [-4, 8] },
      }),
      (this.current = new Ue(0, 0)),
      E.mq.md.matches && (this.allowItemMovement = !0),
      (this.tweenParams = { amountMultiplier: 1 }),
      E.isTouch || E.RAFCollection.add(this.onRaf, 4),
      (this.scrollPrompt = at(".js-scroll-prompt")),
      this.on("click", this.scrollPrompt, () => fl.scrollTo(E.window.h * 0.06)),
      this.setInitialPositions(),
      E.mq.sm.matches && (Ua = "sm"),
      E.mq.md.matches && (Ua = "md"),
      (this.dynamicText = E.components.get(na).get(0)),
      (this.dynamicTextGrid = E.components.get(na).get(1));
  }
  setInitialPositions() {
    K.timeline()
      .set(this.dom.itemArray, {
        x: (t) => this.positions[t][Ua][0] + "rem",
        y: (t) => this.positions[t][Ua][1] + "rem",
        scale: 0.8,
        force3D: !1,
      })
      .set([this.dom.title, this.dom.subtitle], { opacity: 0 });
  }
  buildST() {
    (this.st = ut.create({
      trigger: Xe.scrollTriggers.mainGrid.gridIntro.trigger,
      start: Xe.scrollTriggers.mainGrid.gridIntro.start,
      onEnter: this.gridIntro,
      onLeaveBack: this.returnToVortex,
    })),
      this.dom.inner.classList.remove("d-none");
  }
  destroy() {
    super.destroy(),
      E.isTouch || E.RAFCollection.remove(this.onRaf, 4),
      this.st.kill();
  }
}
q(fu, "selector", ".js-main-grid");
let Vi = "default";
class eu extends jt {
  constructor(t) {
    super(t);
    q(this, "onResize", () => {
      (Vi = "default"),
        E.mq.sm.matches && (Vi = "sm"),
        E.mq.md.matches && (Vi = "md"),
        (this.el.style.opacity = "0"),
        K.set([this.highlightedImage, this.dom.cursor], { clearProps: "all" }),
        this.transformGridTL.kill(),
        this.textST.kill(),
        this.loopedTL.kill(),
        this.menuTL.kill(),
        this.loopST.kill(),
        (this.highlightedImageBCR =
          this.highlightedImage.getBoundingClientRect()),
        (this.imageXPos =
          this.highlightedImageBCR.left -
          E.window.w * 0.5 +
          this.highlightedImageBCR.width * this.settings.imageScale[Vi] * 0.5),
        (this.imageYPos = this.highlightedImageBCR.top - E.window.h * 0.5),
        (this.imageXPos = E.mq.md.matches ? 0 : this.imageXPos),
        clearTimeout(this.timeout),
        (this.timeout = setTimeout(() => {
          this.setInitialPositions(),
            this.buildTransformGridTL(),
            this.textTransitionTL(),
            this.extensionMenuTL(),
            this.buildLoopedTL(),
            (this.el.style.opacity = "1");
        }, 100));
    });
    E.mq.sm.matches && (Vi = "sm"),
      E.mq.md.matches && (Vi = "md"),
      this.populateDom(),
      (this.highlightedImage = at(".js-extension-image")),
      (this.imageTranslate = at(".js-image-translate", this.highlightedImg)),
      (this.highlightedImageBCR =
        this.highlightedImage.getBoundingClientRect()),
      (this.settings = {
        imageScale: { default: 1.5, sm: 1.3, md: 1.1 },
        imageYPos: { default: 0, sm: "-2vh", md: "-10vh" },
        contentSpacing: { default: 33, sm: 49, md: 0 },
        xPosMultiplier: { default: 0.75, sm: 0.86 },
        topPos: { default: "70vh", sm: "70vh", md: "50vh" },
        cursorYPos: { default: 70, sm: 70, md: 50 },
      }),
      (this.imageXPos =
        this.highlightedImageBCR.left -
        E.window.w * 0.5 +
        this.highlightedImageBCR.width * this.settings.imageScale[Vi] * 0.5),
      (this.imageYPos = this.highlightedImageBCR.top - E.window.h * 0.5),
      (this.imageXPos = E.mq.md.matches ? 0 : this.imageXPos),
      (this.mainGrid = E.components.get(fu).first()),
      (this.dynamicTextGrid = E.components.get(na).get(1)),
      this.setInitialPositions(),
      this.buildTransformGridTL(),
      this.textTransitionTL(),
      this.extensionMenuTL(),
      this.buildLoopedTL(),
      this.on(Ze.RESIZE, this.onResize);
  }
  setInitialPositions() {
    K.timeline()
      .set([this.dom.title, this.dom.iconArray], { opacity: 0, y: 0 })
      .set(this.dom.content, { opacity: 1 })
      .set(this.dom.outer, { yPercent: -105 })
      .set(this.dom.inner, { yPercent: 105 })
      .set(this.mainGrid.tweenParams, { amountMultiplier: 1 })
      .set(this.dom.cursor, { opacity: 0 });
  }
  buildTransformGridTL() {
    (this.transformGridTL = K.timeline({
      paused: !0,
      defaults: { ease: "linear", duration: 1, force3D: !1 },
      scrollTrigger: {
        trigger: Xe.scrollTriggers.mainGrid.transformGrid.trigger,
        endTrigger: Xe.scrollTriggers.mainGrid.transformGrid.endTrigger,
        start: Xe.scrollTriggers.mainGrid.transformGrid.start,
        end: Xe.scrollTriggers.mainGrid.transformGrid.end[Vi],
        scrub: !0,
        onEnterBack: () => {
          var t;
          (t = this.dynamicTextGrid.tl) == null || t.play();
        },
        onLeave: () => {
          var t, i;
          (t = this.dynamicTextGrid.tl) == null || t.pause(),
            (i = this.dynamicTextGrid.tl) == null || i.seek(1.5);
        },
      },
    })
      .set(this.highlightedImage, { y: 0 }, 0)
      .to(this.mainGrid.dom.itemArray, { y: "-=10vh" }, 0)),
      this.stCollection.push(this.transformGridTL);
  }
  textTransitionTL() {
    (this.textST = K.timeline({
      scrollTrigger: {
        trigger: Xe.scrollTriggers.mainGrid.textTransition.trigger,
        start: Xe.scrollTriggers.mainGrid.textTransition.start,
        endTrigger: Xe.scrollTriggers.mainGrid.textTransition.endTrigger,
        end: Xe.scrollTriggers.mainGrid.textTransition.end[Vi],
        scrub: !0,
      },
      defaults: { force3D: !1 },
    })
      .to(this.mainGrid.dom.content, {
        y: "-12rem",
        opacity: 0,
        ease: "linear",
      })
      .titleIn(this.dom.title, null, 0)
      .to(this.dom.title, { opacity: 1, overwrite: "true", ease: "linear" }, 0)
      .to(
        this.dom.iconArray,
        {
          opacity: 1,
          stagger: 0.03,
          overwrite: "true",
          duration: 0.07,
          ease: "linear",
        },
        0.77
      )),
      this.stCollection.push(this.textST);
  }
  extensionMenuTL() {
    (this.menuTL = K.timeline({
      scrollTrigger: {
        trigger: Xe.scrollTriggers.mainGrid.extensionMenu.trigger,
        start: Xe.scrollTriggers.mainGrid.extensionMenu.start[Vi],
        endTrigger: Xe.scrollTriggers.mainGrid.extensionMenu.endTrigger,
        end: Xe.scrollTriggers.mainGrid.extensionMenu.end[Vi],
        scrub: !0,
      },
      defaults: { ease: "linear" },
    })
      .to(this.mainGrid.tweenParams, { amountMultiplier: 0 }, 0)
      .to(this.mainGrid.dom.itemArray, { opacity: 0.2, duration: 0.6 }, 0)
      .to(this.highlightedImage, { opacity: 1, overwrite: "auto" }, 0)
      .to(
        this.highlightedImage,
        {
          scale: this.settings.imageScale[Vi],
          y: E.mq.md.matches ? 0 : -this.imageYPos,
          transformOrigin: "0 0",
          force3D: !1,
          x: E.mq.md.matches ? 0 : "-=" + this.imageXPos,
        },
        0
      )
      .to(".js-image-overlay", { opacity: 0 }, 0)),
      this.stCollection.push(this.transformGridTL);
  }
  buildLoopedTL() {
    const t = {
      x: { default: 400, sm: 400, md: 540 },
      y: { default: 455, sm: 460, md: 600 },
    };
    (this.loopedTL = K.timeline({
      paused: !0,
      repeatDelay: 0.8,
      repeat: -1,
      defaults: { force3D: !1 },
      onStart: () => {},
      onComplete: () => {},
    })
      .to([this.dom.cursor, this.dom.outer], { opacity: 1, duration: 0.4 }, 0)
      .to(
        this.dom.cursorOuter,
        { scale: 1.6, opacity: 0, duration: 0.3, ease: "customOut" },
        0.4
      )
      .set(this.dom.cursorOuter, { scale: 0, opacity: 1 }, 0.8)
      .to(
        this.dom.cursorOuter,
        { scale: 1, duration: 0.3, ease: "expo.out" },
        0.81
      )
      .to(
        [this.dom.outer, this.dom.inner],
        { yPercent: 0, ease: "customIn", duration: 1 },
        0.4
      )
      .to(
        this.dom.cursor,
        { xPercent: t.x[Vi], yPercent: t.y[Vi], duration: 1, ease: "customIn" },
        1
      )
      .call(
        () => {
          this.dom.text.classList.add("active");
        },
        null,
        1.8
      )
      .to(
        this.dom.cursorOuter,
        { scale: 1.6, opacity: 0, duration: 0.3, ease: "customOut" },
        2
      )
      .set(this.dom.cursorOuter, { scale: 0, opacity: 1 }, 2.4)
      .to(
        this.dom.cursorOuter,
        { scale: 1, duration: 0.3, ease: "expo.out" },
        2.41
      )
      .to(this.dom.cursor, { opacity: 0, duration: 0.6 }, 2.3)
      .to(this.dom.outer, { yPercent: -105, duration: 0.6 }, 2.3)
      .to(this.dom.inner, { yPercent: 105, duration: 0.6 }, 2.3)
      .set(this.dom.cursor, { xPercent: 0, yPercent: 0 })
      .call(
        () => {
          this.dom.text.classList.remove("active");
        },
        null,
        2.3
      )),
      (this.loopST = K.timeline({
        scrollTrigger: {
          trigger: Xe.scrollTriggers.mainGrid.loop.trigger[Vi],
          start: Xe.scrollTriggers.mainGrid.loop.start[Vi],
          endTrigger: Xe.scrollTriggers.mainGrid.loop.endTrigger,
          end: Xe.scrollTriggers.mainGrid.loop.end,
          toggleActions: "play none none reverse",
          onEnter: () => {
            this.loopedTL.play();
          },
          onLeave: () => {},
          onLeaveBack: () => {
            this.loopedTL.pause(),
              K.to([this.dom.cursor, this.dom.outer], {
                opacity: 0,
                duration: 0.2,
                onComplete: () => {
                  this.loopedTL.progress(0);
                },
              });
          },
          onEnterBack: () => {
            this.loopedTL.play();
          },
        },
      })),
      this.stCollection.push(this.loopST);
  }
}
q(eu, "selector", ".js-extension");
let gn = "default";
class mu extends jt {
  constructor(t) {
    super(t);
    q(this, "onResize", () => {
      (gn = "default"),
        E.mq.sm.matches && (gn = "sm"),
        E.mq.md.matches && (gn = "md"),
        K.set(this.dom.grid, { y: 0 }),
        K.set(
          [
            this.dom.itemArray,
            this.dom.grid,
            this.dom.dummyImage,
            this.dom.canvasPlaceholder,
            this.dom.canvasInner,
          ],
          { clearProps: "all" }
        ),
        this.calcPositions(),
        this.buildScrubbedTL(),
        this.buildTitleTextST(),
        this.animateGridText();
    });
    E.mq.sm.matches && (gn = "sm"),
      E.mq.md.matches && (gn = "md"),
      this.populateDom(),
      (this.highlightedImg = at(".js-extension-image")),
      (this.highlightedImgInner = at(".js-extension-image > div")),
      (this.imageTranslate = at(".js-image-translate", this.highlightedImg)),
      (this.settings = {
        imageScale: { default: 1.5, sm: 1.3, md: 1.1 },
        itemTranslateValues: [145, 160, 155, 145, 160, 130, 150, 160, 160],
        appGridItemStart: [5, 10, 10, 20, 20, 30, 30],
      }),
      this.calcPositions(),
      (this.extensionSection = E.components.get(eu).first()),
      (this.mainGrid = E.components.get(fu).first()),
      (this.itemArray = [...this.mainGrid.dom.itemArray]),
      this.itemArray.splice(
        this.mainGrid.dom.itemArray.indexOf(this.highlightedImg),
        1
      ),
      this.buildScrubbedTL(),
      this.buildTitleTextST(),
      this.animateGridText(),
      E.mq.md.matches &&
        (K.set(this.dom.itemArray, {
          y: (i) => this.settings.appGridItemStart[i] + "vh",
        }),
        K.set(this.dom.canvasInner, {
          y: (i) => this.settings.appGridItemStart[6] + "vh",
        }));
  }
  calcPositions() {
    (this.highlightedImgBCR = this.highlightedImg.getBoundingClientRect()),
      (this.gridBCR = this.dom.grid.getBoundingClientRect()),
      (this.dummyImgBCR = this.dom.dummyImage.getBoundingClientRect()),
      (this.highlightedImg.width = this.highlightedImgBCR.width),
      (this.highlightedImg.height = this.highlightedImgBCR.height),
      E.mq.md.matches
        ? (this.dom.dummyImage.style.opacity = 0)
        : (this.dom.dummyImage.style.opacity = 1),
      (this.imgTop = this.dummyImgBCR.top - this.highlightedImgBCR.top),
      (this.imgLeft = this.dummyImgBCR.left - this.highlightedImgBCR.left),
      (this.scale =
        this.dom.dummyImage.getBoundingClientRect().width /
        (this.highlightedImgBCR.width * this.settings.imageScale[gn])),
      (this.gridTranslate = E.window.h - this.gridBCR.top),
      E.mq.md.matches && K.set(this.dom.grid, { y: this.gridTranslate });
  }
  buildScrubbedTL() {
    (this.menu = E.components.get(eu).first()),
      (this.forward = !1),
      (this.scrubbedTL = K.timeline({
        paused: !0,
        defaults: { ease: "linear", duration: 1 },
        scrollTrigger: {
          trigger: Xe.scrollTriggers.appGrid.scrubbedTransition.trigger,
          start: Xe.scrollTriggers.appGrid.scrubbedTransition.start[gn],
          endTrigger:
            Xe.scrollTriggers.appGrid.scrubbedTransition.endTrigger[gn],
          end: Xe.scrollTriggers.appGrid.scrubbedTransition.end[gn],
          scrub: !0,
        },
        onStart: () => {
          this.forward = !0;
        },
        onComplete: () => {
          this.forward = !1;
        },
        onReverseComplete: () => {
          this.forward = !1;
        },
      })
        .to(
          this.highlightedImg,
          {
            x: E.mq.md.matches ? this.imgLeft : "+=0",
            y: E.mq.md.matches ? this.imgTop : "+=0",
            ease: E.mq.md.matches ? "sine.inOut" : "sine.out",
            force3D: !1,
          },
          0
        )
        .to(
          this.extensionSection.dom.translate,
          {
            x: E.mq.md.matches ? this.imgLeft : "+=0",
            y: E.mq.md.matches ? this.imgTop : "+=0",
            ease: E.mq.md.matches ? "sine.inOut" : "sine.out",
          },
          0
        )
        .to(
          this.imageTranslate,
          {
            scale: E.mq.md.matches ? this.scale : 1,
            transformOrigin: "0% 0%",
            ease: "linear",
          },
          0
        )
        .to(this.dom.grid, { y: 0, force3D: !1 }, 0)),
      E.mq.md.matches &&
        this.scrubbedTL.to(
          [
            this.extensionSection.dom.cursorOpacity,
            this.extensionSection.dom.inner,
          ],
          {
            opacity: 0,
            duration: 0.2,
            onComplete: () => {
              this.extensionSection.loopedTL.pause().progress(0),
                (this.forward = !1);
            },
          },
          0.3
        ),
      this.scrubbedTL
        .call(
          () => {
            this.forward || this.extensionSection.loopedTL.play();
          },
          null,
          0.49
        )
        .to(
          this.itemArray,
          {
            y: (t) =>
              E.mq.md.matches
                ? -this.settings.itemTranslateValues[t] + "vh"
                : "+=0",
            autoAlpha: 0,
            duration: E.mq.md.matches ? 0.75 : 1,
            force3D: !1,
          },
          0
        )
        .to(
          [this.dom.itemArray, this.dom.canvasInner],
          { y: 0, force3D: !1, duration: 1 },
          0
        ),
      E.mq.md.matches &&
        this.scrubbedTL
          .set(this.highlightedImg, { autoAlpha: 0 }, 1)
          .set(this.dom.dummyImage, { autoAlpha: 1 }, 1),
      this.stCollection.push(this.scrubbedTL);
  }
  animateGridText() {
    (this.gridTextTL = K.timeline({
      scrollTrigger: {
        trigger: Xe.scrollTriggers.appGrid.gridText.trigger,
        start: Xe.scrollTriggers.appGrid.gridText.start[gn],
        endTrigger: Xe.scrollTriggers.appGrid.gridText.endTrigger[gn],
        end: Xe.scrollTriggers.appGrid.gridText.end[gn],
        scrub: !0,
      },
      defaults: { ease: "linear", force3D: !1 },
    })
      .to(
        [this.extensionSection.dom.title, this.extensionSection.dom.iconArray],
        {
          y: E.mq.md.matches ? "-200vh" : "+=0",
          duration: 1,
          ease: E.mq.md.matches ? "linear" : "sine.out",
        },
        0
      )
      .to(
        [this.extensionSection.dom.title, this.extensionSection.dom.iconArray],
        { opacity: 0, duration: E.mq.md.matches ? 0.2 : 1 },
        0
      )),
      E.mq.md.matches ||
        this.gridTextTL
          .to(
            [
              this.extensionSection.dom.cursorOpacity,
              this.extensionSection.dom.inner,
              this.highlightedImg,
            ],
            {
              opacity: 0,
              duration: 0.8,
              onComplete: () => {
                this.extensionSection.loopedTL.pause().progress(0),
                  (this.forward = !1);
              },
            },
            0
          )
          .to(
            ".main-grid__item--4",
            { opacity: 0, duration: 0.2, overwrite: "auto" },
            0
          ),
      this.stCollection.push(this.gridTextTL);
  }
  buildTitleTextST() {
    (this.titleTextST = K.timeline({
      scrollTrigger: {
        trigger: Xe.scrollTriggers.appGrid.sectionText.trigger,
        start: Xe.scrollTriggers.appGrid.sectionText.start[gn],
        end: Xe.scrollTriggers.appGrid.sectionText.end[gn],
        scrub: !0,
      },
    })
      .titleIn(this.dom.title, null, 0)
      .paragraphIn(this.dom.text, null, 0.1)),
      this.stCollection.push(this.titleTextST);
  }
  destroy() {
    super.destroy();
  }
}
q(mu, "selector", ".js-app-grid");
/*!
 * paths 3.12.1
 * https://greensock.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var _L = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
  bL = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi,
  xL = Math.PI / 180,
  Eh = Math.sin,
  Ch = Math.cos,
  Oc = Math.abs,
  fc = Math.sqrt,
  wL = function (e) {
    return typeof e == "number";
  },
  V_ = 1e5,
  Br = function (e) {
    return Math.round(e * V_) / V_ || 0;
  };
function yL(r, e, t, i, n, s, a) {
  for (var o = r.length, u, h, f, c, d; --o > -1; )
    for (u = r[o], h = u.length, f = 0; f < h; f += 2)
      (c = u[f]),
        (d = u[f + 1]),
        (u[f] = c * e + d * i + s),
        (u[f + 1] = c * t + d * n + a);
  return (r._dirty = 1), r;
}
function SL(r, e, t, i, n, s, a, o, u) {
  if (!(r === o && e === u)) {
    (t = Oc(t)), (i = Oc(i));
    var h = (n % 360) * xL,
      f = Ch(h),
      c = Eh(h),
      d = Math.PI,
      m = d * 2,
      x = (r - o) / 2,
      v = (e - u) / 2,
      b = f * x + c * v,
      y = -c * x + f * v,
      M = b * b,
      D = y * y,
      C = M / (t * t) + D / (i * i);
    C > 1 && ((t = fc(C) * t), (i = fc(C) * i));
    var A = t * t,
      I = i * i,
      F = (A * I - A * D - I * M) / (A * D + I * M);
    F < 0 && (F = 0);
    var P = (s === a ? -1 : 1) * fc(F),
      k = P * ((t * y) / i),
      O = P * -((i * b) / t),
      J = (r + o) / 2,
      ee = (e + u) / 2,
      X = J + (f * k - c * O),
      j = ee + (c * k + f * O),
      Y = (b - k) / t,
      ie = (y - O) / i,
      Q = (-b - k) / t,
      V = (-y - O) / i,
      ve = Y * Y + ie * ie,
      U = (ie < 0 ? -1 : 1) * Math.acos(Y / fc(ve)),
      oe =
        (Y * V - ie * Q < 0 ? -1 : 1) *
        Math.acos((Y * Q + ie * V) / fc(ve * (Q * Q + V * V)));
    isNaN(oe) && (oe = d),
      !a && oe > 0 ? (oe -= m) : a && oe < 0 && (oe += m),
      (U %= m),
      (oe %= m);
    var ue = Math.ceil(Oc(oe) / (m / 4)),
      fe = [],
      le = oe / ue,
      be = ((4 / 3) * Eh(le / 2)) / (1 + Ch(le / 2)),
      ce = f * t,
      He = c * t,
      Se = c * -i,
      Oe = f * i,
      Me;
    for (Me = 0; Me < ue; Me++)
      (n = U + Me * le),
        (b = Ch(n)),
        (y = Eh(n)),
        (Y = Ch((n += le))),
        (ie = Eh(n)),
        fe.push(b - be * y, y + be * b, Y + be * ie, ie - be * Y, Y, ie);
    for (Me = 0; Me < fe.length; Me += 2)
      (b = fe[Me]),
        (y = fe[Me + 1]),
        (fe[Me] = b * ce + y * Se + X),
        (fe[Me + 1] = b * He + y * Oe + j);
    return (fe[Me - 2] = o), (fe[Me - 1] = u), fe;
  }
}
function ML(r) {
  var e =
      (r + "")
        .replace(bL, function (k) {
          var O = +k;
          return O < 1e-4 && O > -1e-4 ? 0 : O;
        })
        .match(_L) || [],
    t = [],
    i = 0,
    n = 0,
    s = 2 / 3,
    a = e.length,
    o = 0,
    u = "ERROR: malformed path: " + r,
    h,
    f,
    c,
    d,
    m,
    x,
    v,
    b,
    y,
    M,
    D,
    C,
    A,
    I,
    F,
    P = function (O, J, ee, X) {
      (M = (ee - O) / 3),
        (D = (X - J) / 3),
        v.push(O + M, J + D, ee - M, X - D, ee, X);
    };
  if (!r || !isNaN(e[0]) || isNaN(e[1])) return console.log(u), t;
  for (h = 0; h < a; h++)
    if (
      ((A = m),
      isNaN(e[h]) ? ((m = e[h].toUpperCase()), (x = m !== e[h])) : h--,
      (c = +e[h + 1]),
      (d = +e[h + 2]),
      x && ((c += i), (d += n)),
      h || ((b = c), (y = d)),
      m === "M")
    )
      v && (v.length < 8 ? (t.length -= 1) : (o += v.length)),
        (i = b = c),
        (n = y = d),
        (v = [c, d]),
        t.push(v),
        (h += 2),
        (m = "L");
    else if (m === "C")
      v || (v = [0, 0]),
        x || (i = n = 0),
        v.push(
          c,
          d,
          i + e[h + 3] * 1,
          n + e[h + 4] * 1,
          (i += e[h + 5] * 1),
          (n += e[h + 6] * 1)
        ),
        (h += 6);
    else if (m === "S")
      (M = i),
        (D = n),
        (A === "C" || A === "S") &&
          ((M += i - v[v.length - 4]), (D += n - v[v.length - 3])),
        x || (i = n = 0),
        v.push(M, D, c, d, (i += e[h + 3] * 1), (n += e[h + 4] * 1)),
        (h += 4);
    else if (m === "Q")
      (M = i + (c - i) * s),
        (D = n + (d - n) * s),
        x || (i = n = 0),
        (i += e[h + 3] * 1),
        (n += e[h + 4] * 1),
        v.push(M, D, i + (c - i) * s, n + (d - n) * s, i, n),
        (h += 4);
    else if (m === "T")
      (M = i - v[v.length - 4]),
        (D = n - v[v.length - 3]),
        v.push(
          i + M,
          n + D,
          c + (i + M * 1.5 - c) * s,
          d + (n + D * 1.5 - d) * s,
          (i = c),
          (n = d)
        ),
        (h += 2);
    else if (m === "H") P(i, n, (i = c), n), (h += 1);
    else if (m === "V") P(i, n, i, (n = c + (x ? n - i : 0))), (h += 1);
    else if (m === "L" || m === "Z")
      m === "Z" && ((c = b), (d = y), (v.closed = !0)),
        (m === "L" || Oc(i - c) > 0.5 || Oc(n - d) > 0.5) &&
          (P(i, n, c, d), m === "L" && (h += 2)),
        (i = c),
        (n = d);
    else if (m === "A") {
      if (
        ((I = e[h + 4]),
        (F = e[h + 5]),
        (M = e[h + 6]),
        (D = e[h + 7]),
        (f = 7),
        I.length > 1 &&
          (I.length < 3
            ? ((D = M), (M = F), f--)
            : ((D = F), (M = I.substr(2)), (f -= 2)),
          (F = I.charAt(1)),
          (I = I.charAt(0))),
        (C = SL(
          i,
          n,
          +e[h + 1],
          +e[h + 2],
          +e[h + 3],
          +I,
          +F,
          (x ? i : 0) + M * 1,
          (x ? n : 0) + D * 1
        )),
        (h += f),
        C)
      )
        for (f = 0; f < C.length; f++) v.push(C[f]);
      (i = v[v.length - 2]), (n = v[v.length - 1]);
    } else console.log(u);
  return (
    (h = v.length),
    h < 6
      ? (t.pop(), (h = 0))
      : v[0] === v[h - 2] && v[1] === v[h - 1] && (v.closed = !0),
    (t.totalPoints = o + h),
    t
  );
}
function TL(r) {
  wL(r[0]) && (r = [r]);
  var e = "",
    t = r.length,
    i,
    n,
    s,
    a;
  for (n = 0; n < t; n++) {
    for (
      a = r[n],
        e += "M" + Br(a[0]) + "," + Br(a[1]) + " C",
        i = a.length,
        s = 2;
      s < i;
      s++
    )
      e +=
        Br(a[s++]) +
        "," +
        Br(a[s++]) +
        " " +
        Br(a[s++]) +
        "," +
        Br(a[s++]) +
        " " +
        Br(a[s++]) +
        "," +
        Br(a[s]) +
        " ";
    a.closed && (e += "z");
  }
  return e;
}
/*!
 * CustomEase 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var _n,
  bw,
  xw = function () {
    return (
      _n ||
      (typeof window < "u" && (_n = window.gsap) && _n.registerPlugin && _n)
    );
  },
  z_ = function () {
    (_n = xw()),
      _n
        ? (_n.registerEase("_CE", As.create), (bw = 1))
        : console.warn("Please gsap.registerPlugin(CustomEase)");
  },
  EL = 1e20,
  Dh = function (e) {
    return ~~(e * 1e3 + (e < 0 ? -0.5 : 0.5)) / 1e3;
  },
  CL = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
  DL = /[cLlsSaAhHvVtTqQ]/g,
  PL = function (e) {
    var t = e.length,
      i = EL,
      n;
    for (n = 1; n < t; n += 6) +e[n] < i && (i = +e[n]);
    return i;
  },
  AL = function (e, t, i) {
    !i && i !== 0 && (i = Math.max(+e[e.length - 1], +e[1]));
    var n = +e[0] * -1,
      s = -i,
      a = e.length,
      o = 1 / (+e[a - 2] + n),
      u =
        -t ||
        (Math.abs(+e[a - 1] - +e[1]) < 0.01 * (+e[a - 2] - +e[0])
          ? PL(e) + s
          : +e[a - 1] + s),
      h;
    for (u ? (u = 1 / u) : (u = -o), h = 0; h < a; h += 2)
      (e[h] = (+e[h] + n) * o), (e[h + 1] = (+e[h + 1] + s) * u);
  },
  LL = function r(e, t, i, n, s, a, o, u, h, f, c) {
    var d = (e + i) / 2,
      m = (t + n) / 2,
      x = (i + s) / 2,
      v = (n + a) / 2,
      b = (s + o) / 2,
      y = (a + u) / 2,
      M = (d + x) / 2,
      D = (m + v) / 2,
      C = (x + b) / 2,
      A = (v + y) / 2,
      I = (M + C) / 2,
      F = (D + A) / 2,
      P = o - e,
      k = u - t,
      O = Math.abs((i - o) * k - (n - u) * P),
      J = Math.abs((s - o) * k - (a - u) * P),
      ee;
    return (
      f ||
        ((f = [
          { x: e, y: t },
          { x: o, y: u },
        ]),
        (c = 1)),
      f.splice(c || f.length - 1, 0, { x: I, y: F }),
      (O + J) * (O + J) > h * (P * P + k * k) &&
        ((ee = f.length),
        r(e, t, d, m, M, D, I, F, h, f, c),
        r(I, F, C, A, b, y, o, u, h, f, c + 1 + (f.length - ee))),
      f
    );
  },
  As = (function () {
    function r(t, i, n) {
      bw || z_(), (this.id = t), this.setData(i, n);
    }
    var e = r.prototype;
    return (
      (e.setData = function (i, n) {
        (n = n || {}), (i = i || "0,0,1,1");
        var s = i.match(CL),
          a = 1,
          o = [],
          u = [],
          h = n.precision || 1,
          f = h <= 1,
          c,
          d,
          m,
          x,
          v,
          b,
          y,
          M,
          D;
        if (
          ((this.data = i),
          (DL.test(i) || (~i.indexOf("M") && i.indexOf("C") < 0)) &&
            (s = ML(i)[0]),
          (c = s.length),
          c === 4)
        )
          s.unshift(0, 0), s.push(1, 1), (c = 8);
        else if ((c - 2) % 6) throw "Invalid CustomEase";
        for (
          (+s[0] != 0 || +s[c - 2] != 1) && AL(s, n.height, n.originY),
            this.segment = s,
            x = 2;
          x < c;
          x += 6
        )
          (d = { x: +s[x - 2], y: +s[x - 1] }),
            (m = { x: +s[x + 4], y: +s[x + 5] }),
            o.push(d, m),
            LL(
              d.x,
              d.y,
              +s[x],
              +s[x + 1],
              +s[x + 2],
              +s[x + 3],
              m.x,
              m.y,
              1 / (h * 2e5),
              o,
              o.length - 1
            );
        for (c = o.length, x = 0; x < c; x++)
          (y = o[x]),
            (M = o[x - 1] || y),
            (y.x > M.x || (M.y !== y.y && M.x === y.x) || y === M) && y.x <= 1
              ? ((M.cx = y.x - M.x),
                (M.cy = y.y - M.y),
                (M.n = y),
                (M.nx = y.x),
                f &&
                  x > 1 &&
                  Math.abs(M.cy / M.cx - o[x - 2].cy / o[x - 2].cx) > 2 &&
                  (f = 0),
                M.cx < a &&
                  (M.cx
                    ? (a = M.cx)
                    : ((M.cx = 0.001),
                      x === c - 1 &&
                        ((M.x -= 0.001), (a = Math.min(a, 0.001)), (f = 0)))))
              : (o.splice(x--, 1), c--);
        if (((c = (1 / a + 1) | 0), (v = 1 / c), (b = 0), (y = o[0]), f)) {
          for (x = 0; x < c; x++)
            (D = x * v),
              y.nx < D && (y = o[++b]),
              (d = y.y + ((D - y.x) / y.cx) * y.cy),
              (u[x] = { x: D, cx: v, y: d, cy: 0, nx: 9 }),
              x && (u[x - 1].cy = d - u[x - 1].y);
          u[c - 1].cy = o[o.length - 1].y - d;
        } else {
          for (x = 0; x < c; x++) y.nx < x * v && (y = o[++b]), (u[x] = y);
          b < o.length - 1 && (u[x - 1] = o[o.length - 2]);
        }
        return (
          (this.ease = function (C) {
            var A = u[(C * c) | 0] || u[c - 1];
            return A.nx < C && (A = A.n), A.y + ((C - A.x) / A.cx) * A.cy;
          }),
          (this.ease.custom = this),
          this.id && _n && _n.registerEase(this.id, this.ease),
          this
        );
      }),
      (e.getSVGData = function (i) {
        return r.getSVGData(this, i);
      }),
      (r.create = function (i, n, s) {
        return new r(i, n, s).ease;
      }),
      (r.register = function (i) {
        (_n = i), z_();
      }),
      (r.get = function (i) {
        return _n.parseEase(i);
      }),
      (r.getSVGData = function (i, n) {
        n = n || {};
        var s = n.width || 100,
          a = n.height || 100,
          o = n.x || 0,
          u = (n.y || 0) + a,
          h = _n.utils.toArray(n.path)[0],
          f,
          c,
          d,
          m,
          x,
          v,
          b,
          y,
          M,
          D;
        if (
          (n.invert && ((a = -a), (u = 0)),
          typeof i == "string" && (i = _n.parseEase(i)),
          i.custom && (i = i.custom),
          i instanceof r)
        )
          f = TL(yL([i.segment], s, 0, 0, -a, o, u));
        else {
          for (
            f = [o, u],
              b = Math.max(5, (n.precision || 1) * 200),
              m = 1 / b,
              b += 2,
              y = 5 / b,
              M = Dh(o + m * s),
              D = Dh(u + i(m) * -a),
              c = (D - u) / (M - o),
              d = 2;
            d < b;
            d++
          )
            (x = Dh(o + d * m * s)),
              (v = Dh(u + i(d * m) * -a)),
              (Math.abs((v - D) / (x - M) - c) > y || d === b - 1) &&
                (f.push(M, D), (c = (v - D) / (x - M))),
              (M = x),
              (D = v);
          f = "M" + f.join(",");
        }
        return h && h.setAttribute("d", f), f;
      }),
      r
    );
  })();
xw() && _n.registerPlugin(As);
As.version = "3.12.1";
var zr = Xi.registerPlugin(tg) || Xi;
zr.core.Tween;
let nr = "default";
class bd extends jt {
  constructor(e) {
    super(e),
      E.mq.sm.matches && (nr = "sm"),
      E.mq.md.matches && (nr = "md"),
      E.mq.md.matches && E.mq.touch.matches && (nr = "tablet"),
      this.populateDom(),
      (this.settings = { appGridItemEnd: [10, -20, 10, -10, 10, 5] }),
      (this.appGrid = E.components.get(mu).first()),
      this.setup(),
      this.setInitialPositions(),
      E.mq.md.matches && this.buildScrubbedTL(),
      this.buildTextST(),
      (this.dom.video.currentTime = 0),
      (this.dom.video.playbackRate = 2),
      (this.taggingVideo.currentTime = 0),
      (this.taggingVideo.playbackRate = 2);
  }
  setup() {
    (this.placeholderBCR = this.dom.video.getBoundingClientRect()),
      (this.canvasBCR = this.appGrid.dom.canvas.getBoundingClientRect()),
      (this.leftTranslate = this.placeholderBCR.left - this.canvasBCR.left),
      (this.topTranslate =
        this.appGrid.dom.inner.clientHeight -
        (this.canvasBCR.top -
          this.appGrid.gridTranslate -
          this.dom.placeholder.offsetTop)),
      (this.scale = this.placeholderBCR.width / this.canvasBCR.width),
      (this.taggingVideo = at(".js-tagging-video", E.body)),
      (this.taggingVideoBCR = this.taggingVideo.getBoundingClientRect()),
      (this.aspect = this.taggingVideoBCR.height / this.taggingVideoBCR.width),
      !E.mq.md.matches || E.mq.touch.matches
        ? this.dom.video.classList.remove("opacity-0")
        : this.dom.video.classList.contains("opacity-0") ||
          this.dom.video.classList.add("opacity-0");
  }
  setInitialPositions() {
    const e = zr
      .timeline()
      .set([this.dom.tagInnerArray, this.appGrid.dom.tagInnerArray], {
        opacity: 0,
        scale: 0,
      });
    E.mq.md.matches &&
      !E.mq.touch.matches &&
      e
        .set([this.dom.tagContainer], { opacity: 0 })
        .set(this.appGrid.dom.canvas, {
          position: "fixed",
          x: 0,
          y: 0,
          width: this.canvasBCR.width,
          height: this.canvasBCR.width * this.aspect,
        })
        .set(this.appGrid.dom.canvasPlaceholder, {
          width: this.canvasBCR.width,
          height: this.canvasBCR.width * this.aspect,
        });
  }
  buildScrubbedTL() {
    (this.scrubbedTL = zr
      .timeline({
        paused: !0,
        defaults: { ease: "linear", duration: 1, force3D: !1 },
        scrollTrigger: {
          trigger: Xe.scrollTriggers.taggingSystem.section.trigger,
          endTrigger: Xe.scrollTriggers.taggingSystem.section.endTrigger,
          start: Xe.scrollTriggers.taggingSystem.section.start,
          end: Xe.scrollTriggers.taggingSystem.section.end,
          scrub: !0,
        },
      })
      .to(this.appGrid.dom.inner, { y: -this.appGrid.dom.inner.clientHeight })
      .to(
        this.appGrid.dom.tagArray,
        {
          scale: this.canvasBCR.width / this.placeholderBCR.width,
          duration: 0.2,
          transformOrigin: "0 0",
        },
        0
      )
      .to(this.appGrid.dom.gridText, { opacity: 0, duration: 0.2 }, 0.2)
      .to(
        [this.appGrid.dom.itemArray, this.appGrid.dom.dummyImage],
        { opacity: 0, y: (e) => "+=" + this.settings.appGridItemEnd[e] + "vh" },
        0
      )),
      E.mq.touch.matches ||
        this.scrubbedTL.to(
          this.appGrid.dom.canvas,
          {
            y: this.topTranslate,
            x: this.leftTranslate,
            scale: this.scale,
            transformOrigin: "0 0",
            duration: 0.9,
            ease: "sine.inOut",
          },
          0.1
        ),
      this.stCollection.push(this.scrubbedTL);
  }
  buildTextST() {
    (this.titleTextST = zr
      .timeline({
        scrollTrigger: {
          trigger: Xe.scrollTriggers.taggingSystem.text.trigger,
          start: Xe.scrollTriggers.taggingSystem.text.start[nr],
          end: Xe.scrollTriggers.taggingSystem.text.end,
          scrub: !0,
        },
      })
      .to([this.dom.title, this.dom.text], {
        opacity: 1,
        duration: 0.1,
        overwrite: "auto",
      })
      .titleIn(this.dom.title, null, 0)
      .paragraphIn(this.dom.text, null, 0.1)),
      (this.videoST = zr.timeline({
        scrollTrigger: {
          trigger: Xe.scrollTriggers.taggingSystem.video.trigger,
          start: Xe.scrollTriggers.taggingSystem.video.start[nr],
          toggleActions: "restart none none reverse",
          onEnter: () => {
            E.mq.md.matches && !E.mq.touch.matches
              ? this.taggingVideo.play()
              : this.dom.video.play();
          },
        },
      })),
      E.mq.md.matches && !E.mq.touch.matches
        ? this.videoST.to(
            this.appGrid.dom.tagInnerArray,
            {
              stagger: -0.1,
              scale: 1,
              duration: 0.3,
              delay: this.taggingVideo.duration * 0.5 * 0.25,
            },
            0
          )
        : this.videoST.to(
            this.dom.tagInnerArray,
            {
              opacity: 1,
              stagger: -0.1,
              scale: 1,
              duration: 0.3,
              delay: this.taggingVideo.duration * 0.5 * 0.25,
            },
            0
          ),
      (this.hideTagsTL = zr.timeline({
        scrollTrigger: {
          trigger: Xe.scrollTriggers.taggingSystem.hideTags.trigger,
          start: Xe.scrollTriggers.taggingSystem.hideTags.start,
          end: Xe.scrollTriggers.taggingSystem.hideTags.end,
          scrub: !0,
        },
        defaults: { ease: "linear" },
      })),
      E.mq.md.matches &&
        this.hideTagsTL.to(this.appGrid.dom.tagInnerArray, { opacity: 1 }, 0),
      (this.outroTL = zr.timeline({
        scrollTrigger: {
          trigger: Xe.scrollTriggers.taggingSystem.out.trigger,
          start: Xe.scrollTriggers.taggingSystem.out.start,
          end: Xe.scrollTriggers.taggingSystem.out.end,
          scrub: !0,
        },
        defaults: { ease: "linear" },
      })),
      E.mq.md.matches &&
        this.outroTL.to(
          this.appGrid.dom.canvas,
          { y: "-=" + E.window.h, force3D: !1 },
          0
        ),
      this.stCollection.push(
        this.titleTextST,
        this.videoST,
        this.outroTL,
        this.hideTagsTL
      );
  }
  onResize() {
    (nr = "default"),
      E.mq.sm.matches && (nr = "sm"),
      E.mq.md.matches && (nr = "md"),
      E.mq.md.matches && E.mq.touch.matches && (nr = "tablet"),
      zr.set(
        [
          this.taggingVideo,
          this.dom.video,
          this.dom.tagContainer,
          this.appGrid.dom.itemArray,
          this.appGrid.dom.canvas,
          this.appGrid.dom.canvasPlaceholder,
        ],
        { clearProps: "all" }
      ),
      this.setup(),
      clearTimeout(this.timeout),
      (this.timeout = setTimeout(() => {
        this.setInitialPositions(),
          E.mq.md.matches && this.buildScrubbedTL(),
          this.buildTextST();
      }, 100));
  }
  destroy() {
    super.destroy();
  }
}
q(bd, "selector", ".js-tagging-system");
let mf = "default";
class xd extends jt {
  constructor(e) {
    super(e),
      E.mq.sm.matches && (mf = "sm"),
      E.mq.md.matches && (mf = "md"),
      this.populateDom(),
      (this.taggingSystem = E.components.get(bd).first()),
      (this.appGrid = E.components.get(mu).first()),
      (this.startPositions = {
        0: ["+=0", "+=200"],
        1: ["-=200", "+=0"],
        2: ["-=120", "-=200"],
        3: ["+=0", "-=200"],
        4: ["+=120", "-=200"],
        5: ["+=120", "+=200"],
      }),
      (this.delay = [0.2, 0, 0.1, 0, 0.1, 0]),
      (this.ctx = K.context(() => {
        (this.querySplit = new xr(this.dom.query, {
          type: "chars",
          charsClass: "split-chars",
        })),
          K.set(this.querySplit.chars, { opacity: 0 }),
          K.set(this.dom.searchBar, { scale: 1.5 }),
          this.buildQueryTL(),
          this.buildTextTL(),
          this.buildClusterTL();
      }));
  }
  buildQueryTL() {
    (this.queryTextTL = K.timeline({
      scrollTrigger: {
        trigger: Xe.scrollTriggers.searchSection.queryText.trigger,
        start: Xe.scrollTriggers.searchSection.queryText.start,
        end: Xe.scrollTriggers.searchSection.queryText.end,
        scrub: !0,
      },
    }).set(
      this.querySplit.chars,
      { opacity: 1, stagger: 0.1, duration: 0.2 },
      0.8
    )),
      this.stCollection.push(this.queryTextTL);
  }
  buildTextTL() {
    (this.textTL = K.timeline({
      scrollTrigger: {
        trigger: Xe.scrollTriggers.searchSection.sectionText.trigger,
        start: Xe.scrollTriggers.searchSection.sectionText.start,
        end: Xe.scrollTriggers.searchSection.sectionText.end[mf],
        scrub: !0,
      },
    })
      .titleIn(this.dom.title, null, 0)
      .paragraphIn(this.dom.text, null, 0.2)),
      this.stCollection.push(this.textTL);
  }
  buildClusterTL() {
    (this.clusterTL = K.timeline({
      scrollTrigger: {
        trigger: Xe.scrollTriggers.searchSection.cluster.trigger,
        start: Xe.scrollTriggers.searchSection.cluster.start,
        end: Xe.scrollTriggers.searchSection.cluster.end,
        toggleActions: "play none none reverse",
        scrub: !0,
      },
      defaults: { duration: 1.5, ease: "linear" },
    })
      .to(this.dom.searchBar, { scale: 1 }, 0)
      .from(this.dom.imageArray, { opacity: 0, duration: 1.3 }, 0.2)),
      this.stCollection.push(this.clusterTL),
      E.mq.sm.matches &&
        this.clusterTL.from(
          this.dom.imageArray,
          {
            x: (e) =>
              this.startPositions[this.dom.imageArray[e].dataset.index][0],
            y: (e) =>
              this.startPositions[this.dom.imageArray[e].dataset.index][1],
            force3D: !1,
          },
          0
        );
  }
  onResize() {
    setTimeout(() => {
      this.ctx.revert(),
        (this.ctx = K.context(() => {
          (this.querySplit = new xr(this.dom.query, {
            type: "chars",
            charsClass: "split-chars",
          })),
            K.set(this.querySplit.chars, { opacity: 0 }),
            K.set(this.dom.searchBar, { scale: 1.5 }),
            this.buildQueryTL(),
            this.buildTextTL(),
            this.buildClusterTL();
        }));
    }, 1);
  }
}
q(xd, "selector", ".js-search-section");
class ww extends jt {
  constructor(t) {
    super(t);
    q(this, "onResize", () => {
      this.headerHideST(), this.buildTextTL();
    });
    this.populateDom(),
      this.headerHideST(),
      this.buildTextTL(),
      (this.footerComp = E.components.get(cg).first()),
      (this.footerComp.dummy.style.height = "0px"),
      (this.dom.inputEl = at(".js-cta-footer\\:inputEl")),
      (this.dom.submitContainer = at(".js-cta-footer\\:submitContainer")),
      (this.dom.submitBorder = at(".js-cta-footer\\:inputBorder")),
      (this.dom.confirmationText = at(".js-cta-footer\\:confirmationText")),
      K.set(this.dom.inputEl, { opacity: 0 }),
      K.set(this.dom.submitContainer, { opacity: 0 }),
      this.on(Ze.RESIZE, this.onResize);
  }
  headerHideST() {
    var t;
    (t = this.headerSt) == null || t.kill(),
      (this.headerSt = ut.create({
        trigger: this.el,
        start: "top 20%",
        invalidateOnRefresh: !0,
        onEnter: () => {
          this.emit("ShyHeader:hide"),
            this.emit("FooterForm:ShowText"),
            K.to([this.dom.inputEl, this.dom.submitContainer], {
              opacity: 1,
              duration: 0.3,
              overwrite: !1,
            });
        },
        onLeaveBack: () => {
          this.emit("ShyHeader:show"),
            this.emit("FooterForm:HideText"),
            K.to([this.dom.inputEl, this.dom.submitContainer], {
              opacity: 0,
              duration: 0.3,
              overwrite: !1,
            });
        },
      })),
      this.stCollection.push(this.headerSt);
  }
  buildTextTL() {
    var t;
    (t = this.textTl) == null || t.kill(),
      (this.textTl = K.timeline({
        scrollTrigger: {
          trigger: this.el,
          start: "top bottom",
          end: "top top",
          scrub: !0,
        },
      })
        .paragraphIn(this.dom.text, null, 0)
        .titleIn(this.dom.title, null, 0.1)),
      this.stCollection.push(this.textTl);
  }
}
q(ww, "selector", ".js-rocks-section");
const Qa = class Qa extends jt {
  constructor(t) {
    super(t);
    q(this, "VISIBLE_SLIDES", 3);
    q(this, "onPointerDown", () => {
      (this.preventDrag = !1), (this.yDragTotal = 0), (this.xDragTotal = 0);
    });
    q(this, "onPointerUp", () => {
      (this.preventDrag = !1), (this.yDragTotal = 0), (this.xDragTotal = 0);
    });
    q(this, "touchDrag", (t, i) => {
      this.el.classList.remove("is-clickable"),
        this.timeout && window.clearTimeout(this.timeout),
        E.mq.touch.matches &&
          ((this.yDragTotal += Math.abs(i.deltaY)),
          (this.xDragTotal += Math.abs(i.deltaX)),
          this.yDragTotal > 5 &&
            this.xDragTotal < 20 &&
            (this.preventDrag = !0)),
        (this.reversed = i.deltaX < 0),
        E.pointer.isDragging &&
          this.parentSection.contains(t.target) &&
          !this.preventDrag &&
          (Qa.hasDragged ||
            ((Qa.hasDragged = !0), this.emit("ImageSlider:drag")),
          (this.delta.x = i.deltaX),
          clearTimeout(this.timeout),
          (this.timeout = setTimeout(() => {
            this.delta.x = 0;
          }, 400))),
        (this.timeout = setTimeout(() => {
          this.el.classList.add("is-clickable");
        }, 300));
    });
    q(this, "onRaf", () => {
      if (this.enabled) {
        (this.delta.x = K.utils.clamp(-30, 30, this.delta.x)),
          this.current.lerp(this.delta, 0.05);
        for (let t = 0; t < this.progress.length; t++)
          (this.progress[t] +=
            this.current.x * 0.00165 * E.WebGL.normalizeDelta),
            (this.progress[t] = this.progressWrap(this.progress[t])),
            this.timelines[t].progress(this.progress[t]);
        this.reversed
          ? (E.globeWebGL.scenes.globe.globeGroup.rotation.y -= 0.001)
          : (E.globeWebGL.scenes.globe.globeGroup.rotation.y += 0.001),
          (E.globeWebGL.scenes.globe.globeGroup.rotation.y += Bo.radToDeg(
            this.current.x * 6e-5 * E.WebGL.normalizeDelta
          ));
      }
    });
    q(this, "onResize", () => {
      this.ctx.revert(),
        this.ctx.kill(),
        this.dom.slideArray.forEach((t) => {
          t.classList.remove("reveal-text");
        }),
        this.initValues();
    });
    (this.enabled = !1),
      E.RAFCollection.add(this.onRaf, 5),
      this.populateDom(),
      this.initValues();
  }
  createSlides() {
    this.dom.slideArray.forEach((t, i) => {
      (t.style.width = this.maxWidth / this.VISIBLE_SLIDES + "px"),
        this.setInitialPositions(t, i),
        this.buildSlideTimeline(t, i),
        this.progress.push(i * this.progressInteger),
        this.originalProgress.push(i * this.progressInteger);
    });
  }
  addEvents() {
    this.on(Ze.MOUSEDRAG, this.touchDrag),
      this.on(Ze.TOUCHDRAG, this.touchDrag),
      this.on(Ze.POINTERDOWN, this.onPointerDown),
      this.on(Ze.POINTERUP, this.onPointerUp),
      this.on(Ze.RESIZE, this.onResize);
  }
  removeEvents() {
    this.off(Ze.MOUSEDRAG, this.touchDrag),
      this.off(Ze.TOUCHDRAG, this.touchDrag),
      this.off(Ze.POINTERDOWN, this.onPointerDown),
      this.off(Ze.POINTERUP, this.onPointerUp),
      this.off(Ze.RESIZE, this.onResize);
  }
  resetTimelines() {
    for (let t = 0; t < this.progress.length; t++) {
      const i = this.originalProgress[t] + 0.12;
      (this.progress[t] = i), this.timelines[t].progress(i);
    }
  }
  setInitialPositions(t, i) {
    const n = K.utils.wrap([-20, 60, 0, -50, 30]);
    K.timeline()
      .set(t, { x: 0 }, 0)
      .set(this.el, { xPercent: -20 })
      .set(
        this.dom.slideInnerArray[i],
        { y: () => (E.mq.sm.matches ? n(i) : 0), scale: 0 },
        0
      )
      .set(this.dom.slideIntroAnimArray, {
        xPercent: -120,
        scale: 0.4,
        opacity: 0,
        transformOrigin: "center center",
      })
      .set(this.dom.textArray, { opacity: 0 });
  }
  buildSlideTimeline(t, i) {
    const n = this.dom.slideArray.length * 0.1,
      s = this.VISIBLE_SLIDES * 0.1,
      a = K.timeline({ paused: !0, defaults: { duration: n, ease: "linear" } })
        .to(
          t,
          {
            x: this.maxWidth,
            force3D: !1,
            duration: this.VISIBLE_SLIDES * 0.1,
            ease: "linear",
          },
          0
        )
        .call(
          () => {
            t.classList.toggle("reveal-text");
          },
          null,
          s * 0.1
        )
        .to(
          this.dom.slideInnerArray[i],
          { scale: 1, duration: s * 0.2, ease: "power1.inOut" },
          0
        )
        .to(
          this.dom.slideInnerArray[i],
          { scale: 0, duration: s * 0.2, ease: "power1.inOut" },
          s * 0.8
        )
        .call(
          () => {
            t.classList.toggle("reveal-text");
          },
          null,
          s * 0.9
        )
        .to(
          t,
          { x: 0, force3D: !1, duration: this.remainder * 0.1 },
          this.VISIBLE_SLIDES * 0.1
        );
    this.timelines.push(a);
  }
  initValues() {
    E.mq.md.matches ? (this.VISIBLE_SLIDES = 4) : (this.VISIBLE_SLIDES = 3),
      (this.maxWidth = this.el.clientWidth),
      (this.current = new Ue(0, 0)),
      (this.delta = new Ue(0, 0)),
      (this.progress = 0),
      (this.yDragTotal = 0),
      (this.xDragTotal = 0),
      (this.preventDrag = !1),
      (this.timelines = []),
      (this.progress = []),
      (this.originalProgress = []),
      (this.parentSection = at(".js-globe-section")),
      (this.progressInteger = 1 / this.dom.slideArray.length),
      (this.remainder = this.dom.slideArray.length - this.VISIBLE_SLIDES),
      (this.ctx = K.context(() => {
        this.createSlides();
      }));
    for (let t = 0; t < this.progress.length; t++) this.progress[t] += 0.06;
    (this.tweenParams = { animateInMultiplier: 0 }),
      (this.progressWrap = K.utils.wrap(0, 1)),
      (this.reversed = !1);
  }
  destroy() {
    super.destroy(),
      (this.preventDrag = !1),
      E.RAFCollection.remove(this.onRaf, 5);
  }
};
q(Qa, "selector", ".js-image-slider"), q(Qa, "hasDragged", !1);
let xl = Qa,
  gf = "default";
class ug extends jt {
  constructor(t) {
    super(t);
    q(this, "hideDragPrompt", () => {
      K.to(this.dom.dragPrompt.parentElement, { opacity: 0 });
    });
    q(this, "onGlobeSceneResize", () => {
      this.buildScrubbedTL();
    });
    this.populateDom(),
      E.mq.sm.matches && (gf = "sm"),
      E.mq.md.matches && (gf = "md"),
      (this.searchSection = E.components.get(xd).first()),
      (this.imageSlider = E.components.get(xl).first()),
      (this.ctx = K.context(() => {
        this.buildScrubbedTL(),
          this.buildST(),
          this.buildTextTL(),
          this.buildImageSliderTL();
      })),
      K.set(this.dom.dragPrompt, { opacity: 0 }),
      this.on("ImageSlider:drag", this.hideDragPrompt),
      this.on("GlobeScene:resize", this.onGlobeSceneResize);
  }
  buildScrubbedTL() {
    (this.scrubbedParticleTL = K.timeline({
      defaults: { ease: "linear" },
      scrollTrigger: {
        trigger: Xe.scrollTriggers.particleGlobe.particleScrubbed.trigger,
        start: Xe.scrollTriggers.particleGlobe.particleScrubbed.start,
        end: Xe.scrollTriggers.particleGlobe.particleScrubbed.end,
        scrub: !0,
      },
    }).to(E.globeWebGL.scenes.globe.material.uniforms.uYPosMultiplier, {
      value: 0,
    })),
      this.stCollection.push(this.scrubbedParticleTL);
  }
  buildST() {
    (this.st = ut.create({
      trigger: Xe.scrollTriggers.particleGlobe.section.trigger,
      start: Xe.scrollTriggers.particleGlobe.section.start,
      onEnter: () => {
        (this.imageSlider.enabled = !0),
          E.globeWebGL.scenes.globe.start(),
          this.imageSlider.addEvents();
      },
      onLeaveBack: () => {
        E.globeWebGL.scenes.globe.stop(),
          (this.imageSlider.enabled = !1),
          this.imageSlider.removeEvents(),
          this.imageSlider.resetTimelines();
      },
      onLeave: () => {
        (this.imageSlider.enabled = !1),
          E.globeWebGL.scenes.globe.stop(),
          this.imageSlider.removeEvents();
      },
      onEnterBack: () => {
        (this.imageSlider.enabled = !0),
          E.globeWebGL.scenes.globe.start(),
          this.imageSlider.addEvents();
      },
    })),
      this.stCollection.push(this.st);
  }
  buildTextTL() {
    (this.textTl = K.timeline({
      scrollTrigger: {
        trigger: Xe.scrollTriggers.particleGlobe.text.trigger,
        start: Xe.scrollTriggers.particleGlobe.text.start,
        end: Xe.scrollTriggers.particleGlobe.text.end[gf],
        scrub: !0,
      },
    })
      .titleIn(this.dom.title, null, 0)
      .paragraphIn(this.dom.text, null, 0.1)),
      xl.hasDragged || this.textTl.to(this.dom.dragPrompt, { opacity: 1 }, 0.8),
      this.stCollection.push(this.textTl);
  }
  buildImageSliderTL() {
    const t = [...this.imageSlider.dom.slideIntroAnimArray],
      i = t.slice(0, this.imageSlider.VISIBLE_SLIDES),
      n = [...this.imageSlider.dom.textArray],
      s = n.slice(0, this.imageSlider.VISIBLE_SLIDES);
    (this.sliderST = K.timeline({
      scrollTrigger: {
        trigger: Xe.scrollTriggers.particleGlobe.imageSlider.trigger,
        start: Xe.scrollTriggers.particleGlobe.imageSlider.start,
        toggleActions: "restart none none none",
        onLeaveBack: (a) => a.disable(),
      },
    })
      .to(
        i,
        {
          xPercent: 0,
          scale: 1,
          duration: 1,
          ease: "power2.inOut",
          stagger: { each: -0.1, ease: "power1.out" },
        },
        0
      )
      .to(
        i,
        {
          opacity: 1,
          ease: "power2.inOut",
          duration: 0.8,
          stagger: { each: -0.1, ease: "power1.out" },
        },
        0.2
      )
      .to(
        s,
        {
          opacity: 1,
          duration: 0.4,
          stagger: { each: -0.1, ease: "power1.out" },
        },
        0.2
      )
      .to(this.imageSlider.el, { xPercent: 0, duration: 1.8 }, 0)
      .set(t, { xPercent: 0, scale: 1, opacity: 1 })
      .set(n, { opacity: 1 })),
      this.stCollection.push(this.sliderST);
  }
  onResize() {
    this.ctx.revert(),
      (this.imageSlider.enabled = !0),
      this.imageSlider.removeEvents(),
      (this.ctx = K.context(() => {
        this.buildST(), this.buildTextTL(), this.buildImageSliderTL();
      }));
  }
  destroy() {
    super.destroy();
  }
}
q(ug, "selector", ".js-globe-section");
class yw extends og {
  constructor() {
    super();
    q(this, "enableDarkMode", () => {
      this.material.uniforms.uBaseColor.value = new ct(16777215);
    });
    q(this, "disableDarkMode", () => {
      this.material.uniforms.uBaseColor.value = new ct(0);
    });
    q(this, "onRaf", () => {
      this.controls.enabled && this.controls.update(),
        this.options.controls
          ? E.globeWebGL.renderer.render(this, this.devCamera)
          : E.globeWebGL.renderer.render(this, this.camera);
    });
    q(this, "onResize", () => {
      (this.camera.aspect = E.window.w / E.window.h),
        this.camera.updateProjectionMatrix();
    });
    (this.origOptions = { ...this.options }), (this.fog = new hd(0, 2, 11));
  }
  build() {
    const t = new dd(0.007);
    (this.instancedGeometry = new SD().copy(t)),
      (this.instanceCount = 800),
      (this.instancedGeometry.maxInstancedCount = this.instanceCount),
      (this.instancedGeometry.instanceCount = this.instanceCount),
      (this.material = new hL()),
      (this.mesh = new Wi(this.instancedGeometry, this.material)),
      (this.currentOrientation = this.checkOrientation()),
      (this.newOrientation = this.currentOrientation),
      (this.initialOrientation = this.currentOrientation),
      this.calculateSceneDimensions(),
      this.calcParticlePositions(),
      (this.globeGroup = new ts()),
      this.globeGroup.add(this.mesh),
      this.add(this.globeGroup),
      this.addEvents(),
      (this.oldRadius = this.radius),
      (this.newRadius = this.radius);
  }
  checkOrientation() {
    return E.window.w > E.window.h ? "landscape" : "portrait";
  }
  calcParticlePositions() {
    this.aPos = [];
    const t = [],
      i = [];
    this.material.uniforms.uRadius.value = this.radius;
    for (let o = 0; o < this.instanceCount; o++) {
      const u = this.getRandomArbitrary(0.98, 1) * this.radius,
        h = Bo.randFloatSpread(360),
        f = Bo.randFloatSpread(360),
        c = u * Math.sin(h) * Math.cos(f),
        d = u * Math.sin(h) * Math.sin(f),
        m = u * Math.cos(h),
        x = this.getRandomArbitrary(0.1, 3),
        v = this.getRandomArbitrary(2, 6);
      this.aPos.push(c, d, m), t.push(x), i.push(v);
    }
    const n = new Float32Array(this.aPos);
    this.instancedGeometry.setAttribute("aPos", new zo(n, 3, !1));
    const s = new Float32Array(t);
    this.instancedGeometry.setAttribute("yPosMultiplier", new zo(s, 1, !1));
    const a = new Float32Array(i);
    this.instancedGeometry.setAttribute(
      "opacityPosMultiplier",
      new zo(a, 1, !1)
    );
  }
  getRandomArbitrary(t, i) {
    return Math.random() * (i - t) + t;
  }
  calculateSceneDimensions() {
    const t = Bo.degToRad(this.camera.fov);
    (this.sceneHeight = 2 * Math.tan(t / 2) * 5.5),
      (this.sceneHeight *= 0.8),
      (this.sceneWidth = this.sceneHeight * this.camera.aspect);
    const i =
      E.window.w > E.window.h ? this.sceneHeight : this.sceneWidth * 1.1;
    this.radius = i;
  }
  start() {
    E.RAFCollection.add(this.onRaf, 1);
  }
  stop() {
    E.RAFCollection.remove(this.onRaf);
  }
  addEvents() {
    De.on(Ze.RESIZE, this.onResize),
      De.on("DarkMode:enabled", this.enableDarkMode),
      De.on("DarkMode:disabled", this.disableDarkMode);
  }
  removeEvents() {
    De.on(Ze.RESIZE, this.onResize),
      De.off("DarkMode:enabled", this.enableDarkMode),
      De.off("DarkMode:disabled", this.disableDarkMode);
  }
  destroy() {
    this.stop(),
      this.removeEvents(),
      this.traverse((t) => {
        t.isMesh && this.deleteObject(t);
      }),
      this.remove(this.globeGroup);
  }
  deleteObject(t) {
    t.geometry.dispose(),
      t.material instanceof Array
        ? t.material.forEach((i) => i.dispose())
        : t.material.dispose(),
      t.removeFromParent(),
      this.remove(t);
  }
}
class Sw extends jt {
  constructor(t) {
    super(t);
    q(this, "onResize", () => {
      var i, n, s, a, o, u, h, f;
      (i = E.SmoothScroll) == null || i.unlock(),
        ut.killAll(),
        fl.scrollTo(0, { immediate: !0, force: !0 });
      const t = at(".js-header-wordmark");
      K.set(t, { autoAlpha: 0 }),
        (n = E.components.get(fu)) == null || n.first().onResize(),
        (s = E.components.get(eu)) == null || s.first().onResize(),
        (a = E.components.get(mu)) == null || a.first().onResize(),
        (o = E.components.get(bd)) == null || o.first().onResize(),
        (u = E.components.get(xd)) == null || u.first().onResize(),
        (h = E.components.get(ug)) == null || h.first().onResize(),
        (f = E.components.get(xl)) == null || f.first().onResize(),
        (this.footer.style.opacity = 0);
    });
    (this.footer = at(".js-footer", E.body)), this.on(Ze.RESIZE, this.onResize);
  }
  destroy() {
    super.destroy();
  }
}
q(Sw, "selector", ".home");
class Mw {
  constructor(e, t) {
    (this.name = e),
      (this.canvas = t),
      (this.renderer = new Mm({
        alpha: !0,
        antialias: !0,
        canvas: t,
        powerPreference: "high-performance",
        stencil: !1,
      })),
      this.renderer.setPixelRatio(E.window.dpr >= 2 ? 2 : E.window.dpr),
      this.renderer.setSize(E.window.w, E.window.h),
      (this.renderer.info.autoReset = !1),
      this.renderer.setClearColor(0, 0),
      (this.clock = E.WebGL.clock),
      (this.clockDelta = E.WebGL.clockDelta),
      (this.normalizeDelta = E.WebGL.normalizeDelta),
      (this.globalUniforms = E.WebGL.globalUniforms);
  }
  generateTexture(e, t = {}) {
    return (
      e instanceof HTMLImageElement && (e = new xi(e)),
      (e.minFilter = t.minFilter || mr),
      (e.magFilter = t.magFilter || Ui),
      (e.wrapS = e.wrapT = t.wrapping || bn),
      (e.flipY = t.flipY !== void 0 ? t.flipY : !0),
      (e.encoding = t.encoding || gr),
      this.renderer.initTexture(e),
      e
    );
  }
}
class RL extends Mw {
  constructor(t) {
    super("globe", t);
    q(this, "onResize", () => {
      this.renderer.setSize(E.window.w, E.window.h),
        this.scenes.globe.stop(),
        this.scenes.globe.destroy(),
        (this.scenes.globe = new yw()),
        this.scenes.globe.build(),
        De.emit("GlobeScene:resize");
    });
    (this.canvas = t),
      this.renderer.setSize(
        this.canvas.offsetWidth,
        this.canvas.offsetHeight,
        !1
      ),
      (this.scenes = { globe: null });
  }
  start() {
    De.on(Ze.RESIZE, this.onResize);
  }
  stop() {
    De.off(Ze.RESIZE, this.onResize);
  }
  destroy() {
    this.renderer.dispose(), this.scenes.globe.destroy();
  }
}
class kL extends Mw {
  constructor(t) {
    super("rocks", t);
    q(this, "onResize", () => {
      this.renderer.setSize(E.window.w, E.window.h);
    });
    (this.canvas = t),
      this.renderer.setSize(
        this.canvas.offsetWidth,
        this.canvas.offsetHeight,
        !1
      ),
      (this.scenes = { rocks: null });
  }
  start() {
    De.on(Ze.RESIZE, this.onResize);
  }
  stop() {
    De.off(Ze.RESIZE, this.onResize);
  }
  destroy() {
    this.renderer.dispose(), this.scenes.rocks.destroy();
  }
}
class IL extends ts {
  constructor(t = {}) {
    super();
    q(this, "updateRocksPos", () => {
      for (let t = 0; t < this.options.count; t++)
        this.updateDummyValues(t),
          this.dummy.updateMatrix(),
          this.mesh.setMatrixAt(t, this.dummy.matrix),
          (this.mesh.instanceMatrix.needsUpdate = !0);
    });
    q(this, "onRAF", (t) => {
      (this.rotation.y = t * 0.1 * this.options.speed + this.options.scrollY),
        (this.uniforms.uScrollY.value = this.options.scrollY);
    });
    q(this, "onBeforeCompileRocks", (t) => {
      (t.uniforms = {
        ...t.uniforms,
        ...E.WebGL.globalUniforms,
        ...this.uniforms,
      }),
        (t.vertexShader = t.vertexShader.replace(
          "varying vec3 vViewPosition;",
          `
				varying vec3 vViewPosition;
				attribute vec3 aAxis;
				attribute float aAngle;
				uniform float uTime;
				uniform float uScrollY;
				uniform float uRotateSpeed;

				mat4 rotationMatrix(vec3 axis, float angle){
					axis = normalize(axis);
					float s = sin(angle);
					float c = cos(angle);
					float oc = 1.0 - c;

					return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
						oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
						oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
						0.0,                                0.0,                                0.0,                                1.0);
				}
			`
        )),
        (t.vertexShader = t.vertexShader.replace(
          "#include <beginnormal_vertex>",
          `
				#include <beginnormal_vertex>

				float angle = (uTime * 0.01 * uRotateSpeed + aAngle) * 20. + uScrollY * 5.;
				mat4 rotateMatrix = rotationMatrix(aAxis, angle);

				objectNormal = (rotateMatrix * vec4(objectNormal, 1.0)).xyz;
			`
        )),
        (t.vertexShader = t.vertexShader.replace(
          "#include <begin_vertex>",
          `
				#include <begin_vertex>

				transformed = (rotateMatrix * vec4(transformed, 1.0)).xyz;
			`
        )),
        (t.fragmentShader = t.fragmentShader.replace(
          "#include <map_pars_fragment>",
          `
				#include <map_pars_fragment>
				uniform sampler2D uLightRockDiffuse;
				uniform float uLightModeProgress;
			`
        )),
        (t.fragmentShader = t.fragmentShader.replace(
          "#include <map_fragment>",
          `
				#ifdef USE_MAP

					vec4 sampledDiffuseColor = texture2D( map, vUv );

					vec4 lightRockDiffuseColor = texture2D( uLightRockDiffuse, vUv );

					sampledDiffuseColor = sampledDiffuseColor * (1. - uLightModeProgress) + lightRockDiffuseColor * uLightModeProgress;

					#ifdef DECODE_VIDEO_TEXTURE

						// inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)

						sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );

					#endif

					diffuseColor *= sampledDiffuseColor;

				#endif
			`
        ));
    });
    (this.name = "rocks"),
      (this.options = t),
      (this.params = {
        base: { radius: 1.2, baseScale: 0.7 },
        sm: { radius: 1.25, baseScale: 0.8 },
        md: { radius: this.options.radius, baseScale: this.options.baseScale },
      }),
      (this.uniforms = {
        uScrollY: { value: 0 },
        uRotateSpeed: { value: 1 },
        uLightRockDiffuse: { value: null },
        uLightModeProgress: { value: 0 },
      });
  }
  build(t) {
    this.buildMaterial();
    const i = E.rocksWebGL.scenes.rocks.assets.models.rocks.geometry.clone();
    (this.mesh = new yb(i, this.rocksMaterial, this.options.count)),
      (this.dummy = new ei()),
      this.updateRocksPos();
    const n = new Float32Array(this.options.count * 3),
      s = new Float32Array(this.options.count);
    for (let a = 0; a < this.options.count; a++)
      (n[a * 3] = Math.random()),
        (n[a * 3 + 1] = Math.random()),
        (n[a * 3 + 2] = Math.random()),
        (s[a] = Math.random());
    this.mesh.geometry.setAttribute("aAxis", new zo(n, 3)),
      this.mesh.geometry.setAttribute("aAngle", new zo(s, 1)),
      this.add(this.mesh),
      (this.uniforms.uLightRockDiffuse.value =
        E.rocksWebGL.scenes.rocks.assets.textures.rocksLightModeDiffuse),
      De.on(Ze.RESIZE, this.updateRocksPos);
  }
  buildMaterial() {
    (this.rocksMaterial = new pd({
      map: E.rocksWebGL.scenes.rocks.assets.textures.rocksDiffuse,
      normalMap: E.rocksWebGL.scenes.rocks.assets.textures.rocksNormal,
      roughnessMap: E.rocksWebGL.scenes.rocks.assets.textures.rocksRoughness,
    })),
      (this.rocksMaterial.onBeforeCompile = this.onBeforeCompileRocks);
  }
  updateDummyValues(t) {
    let i = this.params.base;
    E.mq.md.matches
      ? (i = this.params.md)
      : E.mq.sm.matches && (i = this.params.sm);
    const n = (Math.PI * 2) / this.options.count;
    (this.dummy.position.x = Math.cos(n * t) * i.radius),
      (this.dummy.position.z = Math.sin(n * t) * i.radius),
      (this.dummy.rotation.x = Math.random() * 2 * Math.PI),
      (this.dummy.rotation.y = Math.random() * 2 * Math.PI),
      (this.dummy.rotation.z = Math.random() * 2 * Math.PI),
      (this.dummy.scale.x =
        this.dummy.scale.y =
        this.dummy.scale.z =
          i.baseScale -
          this.options.scaleOffset +
          Math.random() * this.options.scaleOffset * 2);
  }
  start() {
    this.addEvents();
  }
  stop() {
    this.removeEvents();
  }
  addEvents() {
    E.RAFCollection.add(this.onRAF, 3);
  }
  removeEvents() {
    E.RAFCollection.remove(this.onRAF);
  }
  destroy() {
    E.RAFCollection.remove(this.onRAF),
      De.off(Ze.RESIZE, this.updateRocksPos),
      E.rocksWebGL.scenes.rocks.remove(this),
      this.mesh.geometry.dispose(),
      this.rocksMaterial.dispose(),
      (this.mesh = void 0),
      (this.rocksMaterial = void 0);
  }
}
class FL extends og {
  constructor() {
    super();
    q(this, "switchModeDuration", 0.2);
    q(this, "onPointerMove", (t) => {
      (this.pointer.x = (t.clientX / E.window.w) * 2 - 1),
        (this.pointer.y = -((t.clientY - this.canvasTop) / E.window.h) * 2 + 1);
    });
    q(this, "onDarkModeEnabled", () => {
      var t;
      (t = this.fogTl) == null || t.kill(),
        K.to(this.ambient, { intensity: 1, duration: this.switchModeDuration }),
        K.to(this.fixedLight, {
          intensity: 1,
          duration: this.switchModeDuration,
        }),
        K.to(this.movingLight, {
          intensity: 4.7,
          duration: this.switchModeDuration,
        }),
        K.to(this.ambient.color, {
          r: this.darkModeAmbientColor.r,
          g: this.darkModeAmbientColor.g,
          b: this.darkModeAmbientColor.b,
          duration: this.switchModeDuration,
        }),
        K.to(this.components.rocks.uniforms.uLightModeProgress, {
          value: 0,
          duration: this.switchModeDuration,
        }),
        (this.fogTl = K.timeline()),
        this.fogTl
          .to(this.fog, {
            near: this.fogOptions.far,
            duration: this.switchModeDuration,
          })
          .set(this.fog, {
            near: this.fogOptions.far + 5,
            far: this.fogOptions.far + 5,
          });
    });
    q(this, "onLightModeEnabled", () => {
      var t;
      (t = this.fogTl) == null || t.kill(),
        K.to(this.ambient, {
          intensity: 2.17,
          duration: this.switchModeDuration,
        }),
        K.to(this.fixedLight, {
          intensity: 0.5,
          duration: this.switchModeDuration,
        }),
        K.to(this.movingLight, {
          intensity: 0.6,
          duration: this.switchModeDuration,
        }),
        K.to(this.ambient.color, {
          r: this.lightModeAmbientColor.r,
          g: this.lightModeAmbientColor.g,
          b: this.lightModeAmbientColor.b,
          duration: this.switchModeDuration,
        }),
        K.to(this.components.rocks.uniforms.uLightModeProgress, {
          value: 1,
          duration: this.switchModeDuration,
        }),
        (this.fogTl = K.timeline()),
        this.fogTl
          .set(this.fog, {
            near: this.fogOptions.far,
            far: this.fogOptions.far,
            duration: this.switchModeDuration,
          })
          .to(this.fog, { near: this.fogOptions.near });
    });
    q(this, "onRAF", () => {
      this.controls.enabled && this.controls.update(),
        this.options.controls
          ? this.raycaster.setFromCamera(this.pointer, this.devCamera)
          : this.raycaster.setFromCamera(this.pointer, this.camera);
      const t = this.raycaster.intersectObject(this.planeRaycast);
      if (t.length > 0) {
        const { point: i } = t[0];
        this.movingLightPos.setX(i.x),
          this.movingLightPos.setZ(i.z),
          this.movingLight.position.lerp(
            this.movingLightPos,
            this.options.lightLerp
          ),
          this.lightTarget.position.lerp(i, this.options.lightLerp),
          this.movingLight.position.clamp(this.lightMinPos, this.lightMaxPos),
          this.lightTarget.position.clamp(
            this.lightTargetMinPos,
            this.lightTargetMaxPos
          );
      }
      this.options.controls
        ? E.rocksWebGL.renderer.render(this, this.devCamera)
        : E.rocksWebGL.renderer.render(this, this.camera);
    });
    q(this, "onResize", () => {
      (this.camera.aspect = E.window.w / E.window.h),
        this.camera.updateProjectionMatrix(),
        (this.devCamera.aspect = E.window.w / E.window.h),
        this.devCamera.updateProjectionMatrix(),
        this.setCameraPos(),
        this.stop(),
        this.buildScrollTriggerRender();
    });
    (this.options = Object.assign(this.options, {
      rocks: {
        count: 6,
        scrollY: 0,
        speed: 1,
        radius: 1.62,
        baseScale: 0.91,
        scaleOffset: 0.08,
      },
      lightLerp: 0.03,
    })),
      (this.fogOptions = { near: 4.89, far: 7.5 }),
      (this.cameraOptions = { y: 1.8, z: 5.1 }),
      (this.camera.fov = 40),
      this.camera.updateProjectionMatrix(),
      this.setCameraPos(),
      (this.canvasEl = at(".webgl-rocks")),
      (this.origOptions = { ...this.options }),
      (this.components = { rocks: new IL(this.options.rocks) }),
      this.load();
  }
  setCameraPos() {
    let t = -0.15;
    E.mq.md.matches ? (t = 0) : E.mq.sm.matches && (t = -0.1),
      (this.camera.position.y = this.cameraOptions.y),
      (this.camera.position.z = this.cameraOptions.z),
      this.camera.lookAt(new Z()),
      (this.camera.position.y = this.cameraOptions.y + t);
  }
  start() {
    for (const t in this.components) this.components[t].start();
    this.addDynamicEvents();
  }
  stop() {
    for (const t in this.components) this.components[t].stop();
    this.removeDynamicEvents();
  }
  build() {
    this.buildScrollTriggerRender(),
      this.buildFog(),
      this.buildRocks(),
      this.buildLights(),
      this.buildRaycaster(),
      De.on(Ze.RESIZE, this.onResize),
      De.on("DarkMode:enabled", this.onDarkModeEnabled),
      De.on("DarkMode:disabled", this.onLightModeEnabled);
  }
  buildScrollTriggerRender() {
    this.st = ut.create({
      trigger: this.canvasEl,
      start: "top bottom",
      end: "bottom top",
      onEnter: () => {
        E.urlParams.has("nowebgl") || this.start();
      },
      onEnterBack: () => {
        E.urlParams.has("nowebgl") || this.start();
      },
      onLeave: () => {
        E.urlParams.has("nowebgl") || this.stop();
      },
      onLeaveBack: () => {
        E.urlParams.has("nowebgl") || this.stop();
      },
      onUpdate: (t) => {
        window.clearTimeout(this.timeout),
          (this.options.rocks.scrollY +=
            K.utils.clamp(-1500, 1500, t.getVelocity()) * 1e-5),
          (this.timeout = window.setTimeout(() => {
            this.canvasTop = this.canvasEl.getBoundingClientRect().top;
          }, 100));
      },
    });
  }
  buildFog() {
    this.fog = new hd(
      "#E9E8E3",
      this.fogOptions.far + 5,
      this.fogOptions.far + 5
    );
  }
  buildRocks() {
    for (const t in this.components)
      this.components[t].build(this.objectData), this.add(this.components[t]);
  }
  buildLights() {
    (this.darkModeAmbientColor = new ct("#080808")),
      (this.lightModeAmbientColor = new ct("#5e5d5d")),
      (this.ambient = new yD(this.darkModeAmbientColor, 1)),
      this.add(this.ambient),
      (this.fixedLight = new Rb("#FFF", 1)),
      this.fixedLight.position.set(0, 5, 0.4),
      this.add(this.fixedLight),
      (this.movingLight = new Lb("#FFF", 4.7, 4.1, Math.PI / 2)),
      this.movingLight.position.set(0, 2, 0.4),
      (this.lightTarget = new ei()),
      (this.movingLight.target = this.lightTarget),
      (this.movingLightPos = new Z(0, this.movingLight.position.y, 0)),
      this.add(this.movingLight);
  }
  buildRaycaster() {
    const t = this.options.rocks.radius * 2.5 + 200;
    (this.planeRaycast = new Wi(
      new au(t, t, 1, 1),
      new cr({ color: "blue", visible: !1 })
    )),
      this.planeRaycast.rotateX(-Math.PI / 2),
      (this.lightMinPos = new Z(-3, this.movingLight.position.y, -3)),
      (this.lightMaxPos = new Z(3, this.movingLight.position.y, 3)),
      (this.lightTargetMinPos = new Z(-3, this.lightTarget.position.y, -3)),
      (this.lightTargetMaxPos = new Z(3, this.lightTarget.position.y, 3)),
      this.add(this.planeRaycast),
      (this.raycaster = new FD()),
      (this.pointer = new Ue());
  }
  addDynamicEvents() {
    De.on(Ze.POINTERMOVE, this.onPointerMove),
      E.RAFCollection.add(this.onRAF, 2);
  }
  removeDynamicEvents() {
    De.off(Ze.POINTERMOVE, this.onPointerMove),
      E.RAFCollection.remove(this.onRAF);
  }
  load() {
    this.assets = { textures: {}, models: {} };
    const t = {
      rocksDiffuse: "rocks_diffuse.jpg",
      rocksNormal: "rocks_normal.jpg",
      rocksRoughness: "rocks_roughness.jpg",
      rocksLightModeDiffuse: "light_rocks_diffuse.jpg",
    };
    E.AssetLoader.loadGltf(`${E.publicUrl}webgl/models/rocks.glb`).then((i) => {
      (this.assets.models.rocks = i.scene.children[0].clone()),
        (this.assets.models.rocks.geometry =
          this.assets.models.rocks.geometry.clone()),
        this.assets.models.rocks.geometry.scale(0.01, 0.01, 0.01);
    });
    for (const i in t)
      E.AssetLoader.loadTexture(`${E.publicUrl}webgl/textures/rocks/${t[i]}`, {
        wrapping: Zr,
        flipY: !1,
      }).then((n) => {
        this.assets.textures[i] = n;
      });
  }
  destroy() {
    this.stop(),
      this.st.kill(),
      Object.assign(this.options, this.origOptions),
      De.off(Ze.RESIZE, this.onResize),
      De.off("DarkMode:enabled", this.onDarkModeEnabled),
      De.off("DarkMode:disabled", this.onLightModeEnabled),
      this.traverse((t) => {
        t.isMesh && this.deleteObject(t);
      });
  }
  deleteObject(t) {
    t.geometry.dispose(),
      t.material instanceof Array
        ? t.material.forEach((i) => i.dispose())
        : t.material.dispose(),
      t.removeFromParent(),
      this.remove(t);
  }
}
let vf = "default";
class Tw extends jt {
  constructor(t) {
    super(t);
    q(this, "onResize", () => {
      var t;
      (t = this.ctx) == null || t.revert(), this.createContext();
    });
    this.populateDom(),
      E.mq.sm.matches && (vf = "sm"),
      E.mq.md.matches && (vf = "md"),
      this.createContext(),
      this.on(Ze.RESIZE, this.onResize),
      K.set(this.dom.btn, { opacity: 0 });
  }
  createContext() {
    this.ctx = K.context(() => {
      this.buildTextTL(), E.mq.md.matches && this.buildDevicesParallax();
    });
  }
  buildTextTL() {
    (this.textTl = K.timeline({
      scrollTrigger: {
        trigger: Xe.scrollTriggers.appPreview.text.trigger,
        start: Xe.scrollTriggers.appPreview.text.start,
        end: Xe.scrollTriggers.appPreview.text.end[vf],
        scrub: !0,
      },
    })
      .titleIn(this.dom.title, null, 0)
      .paragraphIn(this.dom.text, null, 0.1)
      .to(this.dom.btn, { opacity: 1 }, 0.8)),
      this.stCollection.push(this.textTl);
  }
  buildDevicesParallax() {
    (this.devicesTl = K.timeline({
      scrollTrigger: {
        trigger: this.dom.el,
        start: "top bottom",
        end: "bottom top",
        scrub: !0,
      },
    })
      .to(this.dom.tablet, { y: 30 })
      .fromTo(this.dom.mobile, { y: 15 }, { y: -20 }, 0)),
      this.stCollection.push(this.devicesTl);
  }
}
q(Tw, "selector", ".js-app-preview");
class OL extends pu {
  initialLoad() {
    super.initialLoad();
  }
  onEnter() {
    super.onEnter(),
      E.components.add(Sw),
      K.set(".vortex-vignette", { autoAlpha: 1 }),
      E.AssetLoader.loaded.then(() => {
        E.urlParams.has("nowebgl") ||
          (E.globeWebGL.scenes.globe.build(),
          E.globeWebGL.start(),
          E.rocksWebGL.scenes.rocks.build(),
          E.rocksWebGL.start(),
          E.rocksWebGL.scenes.rocks.onRAF());
      }),
      E.urlParams.has("limitScroll") &&
        (E.SmoothScroll.Lenis.virtualScroll.wheelMultiplier =
          E.urlParams.get("limitScroll"));
  }
  onEnterCompleted() {
    super.onEnterCompleted(),
      E.AssetLoader.loaded.then(() => {
        E.components.add(fu, eu, mu, bd, xd, xl, ug, Tw, ww),
          K.set(E.mainGridItems, { opacity: 0, overwrite: "auto" }),
          (this.dynamicText = E.components.get(na).get(0)),
          E.Taxi.isTransitioning && this.dynamicText.tl.play();
      }),
      E.urlParams.has("nowebgl") || E.WebGL.scenes.vortex.start();
  }
  onLeave() {
    super.onLeave(),
      E.urlParams.has("nowebgl") ||
        (E.WebGL.scenes.vortex.stop(),
        E.globeWebGL.scenes.globe.stop(),
        E.rocksWebGL.scenes.rocks.stop());
  }
  onLeaveCompleted() {
    super.onLeaveCompleted();
    const e = at(".js-header-wordmark");
    K.set(e, { autoAlpha: 1 }),
      K.set(".vortex-vignette", { autoAlpha: 0 }),
      E.globeWebGL.destroy(),
      E.rocksWebGL.destroy();
  }
  registerAdditionalWebgl() {
    (E.globeWebGL = new RL(at(".webgl-globe"))),
      (E.globeWebGL.scenes.globe = new yw()),
      (E.rocksWebGL = new kL(at(".webgl-rocks"))),
      (E.rocksWebGL.scenes.rocks = new FL());
  }
}
var tu = {};
/*!
 *  howler.js v2.2.3
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */ (function (r) {
  (function () {
    var e = function () {
      this.init();
    };
    e.prototype = {
      init: function () {
        var c = this || t;
        return (
          (c._counter = 1e3),
          (c._html5AudioPool = []),
          (c.html5PoolSize = 10),
          (c._codecs = {}),
          (c._howls = []),
          (c._muted = !1),
          (c._volume = 1),
          (c._canPlayEvent = "canplaythrough"),
          (c._navigator =
            typeof window < "u" && window.navigator ? window.navigator : null),
          (c.masterGain = null),
          (c.noAudio = !1),
          (c.usingWebAudio = !0),
          (c.autoSuspend = !0),
          (c.ctx = null),
          (c.autoUnlock = !0),
          c._setup(),
          c
        );
      },
      volume: function (c) {
        var d = this || t;
        if (
          ((c = parseFloat(c)),
          d.ctx || f(),
          typeof c < "u" && c >= 0 && c <= 1)
        ) {
          if (((d._volume = c), d._muted)) return d;
          d.usingWebAudio &&
            d.masterGain.gain.setValueAtTime(c, t.ctx.currentTime);
          for (var m = 0; m < d._howls.length; m++)
            if (!d._howls[m]._webAudio)
              for (
                var x = d._howls[m]._getSoundIds(), v = 0;
                v < x.length;
                v++
              ) {
                var b = d._howls[m]._soundById(x[v]);
                b && b._node && (b._node.volume = b._volume * c);
              }
          return d;
        }
        return d._volume;
      },
      mute: function (c) {
        var d = this || t;
        d.ctx || f(),
          (d._muted = c),
          d.usingWebAudio &&
            d.masterGain.gain.setValueAtTime(
              c ? 0 : d._volume,
              t.ctx.currentTime
            );
        for (var m = 0; m < d._howls.length; m++)
          if (!d._howls[m]._webAudio)
            for (var x = d._howls[m]._getSoundIds(), v = 0; v < x.length; v++) {
              var b = d._howls[m]._soundById(x[v]);
              b && b._node && (b._node.muted = c ? !0 : b._muted);
            }
        return d;
      },
      stop: function () {
        for (var c = this || t, d = 0; d < c._howls.length; d++)
          c._howls[d].stop();
        return c;
      },
      unload: function () {
        for (var c = this || t, d = c._howls.length - 1; d >= 0; d--)
          c._howls[d].unload();
        return (
          c.usingWebAudio &&
            c.ctx &&
            typeof c.ctx.close < "u" &&
            (c.ctx.close(), (c.ctx = null), f()),
          c
        );
      },
      codecs: function (c) {
        return (this || t)._codecs[c.replace(/^x-/, "")];
      },
      _setup: function () {
        var c = this || t;
        if (
          ((c.state = (c.ctx && c.ctx.state) || "suspended"),
          c._autoSuspend(),
          !c.usingWebAudio)
        )
          if (typeof Audio < "u")
            try {
              var d = new Audio();
              typeof d.oncanplaythrough > "u" && (c._canPlayEvent = "canplay");
            } catch {
              c.noAudio = !0;
            }
          else c.noAudio = !0;
        try {
          var d = new Audio();
          d.muted && (c.noAudio = !0);
        } catch {}
        return c.noAudio || c._setupCodecs(), c;
      },
      _setupCodecs: function () {
        var c = this || t,
          d = null;
        try {
          d = typeof Audio < "u" ? new Audio() : null;
        } catch {
          return c;
        }
        if (!d || typeof d.canPlayType != "function") return c;
        var m = d.canPlayType("audio/mpeg;").replace(/^no$/, ""),
          x = c._navigator ? c._navigator.userAgent : "",
          v = x.match(/OPR\/([0-6].)/g),
          b = v && parseInt(v[0].split("/")[1], 10) < 33,
          y = x.indexOf("Safari") !== -1 && x.indexOf("Chrome") === -1,
          M = x.match(/Version\/(.*?) /),
          D = y && M && parseInt(M[1], 10) < 15;
        return (
          (c._codecs = {
            mp3: !!(
              !b &&
              (m || d.canPlayType("audio/mp3;").replace(/^no$/, ""))
            ),
            mpeg: !!m,
            opus: !!d
              .canPlayType('audio/ogg; codecs="opus"')
              .replace(/^no$/, ""),
            ogg: !!d
              .canPlayType('audio/ogg; codecs="vorbis"')
              .replace(/^no$/, ""),
            oga: !!d
              .canPlayType('audio/ogg; codecs="vorbis"')
              .replace(/^no$/, ""),
            wav: !!(
              d.canPlayType('audio/wav; codecs="1"') ||
              d.canPlayType("audio/wav")
            ).replace(/^no$/, ""),
            aac: !!d.canPlayType("audio/aac;").replace(/^no$/, ""),
            caf: !!d.canPlayType("audio/x-caf;").replace(/^no$/, ""),
            m4a: !!(
              d.canPlayType("audio/x-m4a;") ||
              d.canPlayType("audio/m4a;") ||
              d.canPlayType("audio/aac;")
            ).replace(/^no$/, ""),
            m4b: !!(
              d.canPlayType("audio/x-m4b;") ||
              d.canPlayType("audio/m4b;") ||
              d.canPlayType("audio/aac;")
            ).replace(/^no$/, ""),
            mp4: !!(
              d.canPlayType("audio/x-mp4;") ||
              d.canPlayType("audio/mp4;") ||
              d.canPlayType("audio/aac;")
            ).replace(/^no$/, ""),
            weba: !!(
              !D &&
              d.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")
            ),
            webm: !!(
              !D &&
              d.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")
            ),
            dolby: !!d
              .canPlayType('audio/mp4; codecs="ec-3"')
              .replace(/^no$/, ""),
            flac: !!(
              d.canPlayType("audio/x-flac;") || d.canPlayType("audio/flac;")
            ).replace(/^no$/, ""),
          }),
          c
        );
      },
      _unlockAudio: function () {
        var c = this || t;
        if (!(c._audioUnlocked || !c.ctx)) {
          (c._audioUnlocked = !1),
            (c.autoUnlock = !1),
            !c._mobileUnloaded &&
              c.ctx.sampleRate !== 44100 &&
              ((c._mobileUnloaded = !0), c.unload()),
            (c._scratchBuffer = c.ctx.createBuffer(1, 1, 22050));
          var d = function (m) {
            for (; c._html5AudioPool.length < c.html5PoolSize; )
              try {
                var x = new Audio();
                (x._unlocked = !0), c._releaseHtml5Audio(x);
              } catch {
                c.noAudio = !0;
                break;
              }
            for (var v = 0; v < c._howls.length; v++)
              if (!c._howls[v]._webAudio)
                for (
                  var b = c._howls[v]._getSoundIds(), y = 0;
                  y < b.length;
                  y++
                ) {
                  var M = c._howls[v]._soundById(b[y]);
                  M &&
                    M._node &&
                    !M._node._unlocked &&
                    ((M._node._unlocked = !0), M._node.load());
                }
            c._autoResume();
            var D = c.ctx.createBufferSource();
            (D.buffer = c._scratchBuffer),
              D.connect(c.ctx.destination),
              typeof D.start > "u" ? D.noteOn(0) : D.start(0),
              typeof c.ctx.resume == "function" && c.ctx.resume(),
              (D.onended = function () {
                D.disconnect(0),
                  (c._audioUnlocked = !0),
                  document.removeEventListener("touchstart", d, !0),
                  document.removeEventListener("touchend", d, !0),
                  document.removeEventListener("click", d, !0),
                  document.removeEventListener("keydown", d, !0);
                for (var C = 0; C < c._howls.length; C++)
                  c._howls[C]._emit("unlock");
              });
          };
          return (
            document.addEventListener("touchstart", d, !0),
            document.addEventListener("touchend", d, !0),
            document.addEventListener("click", d, !0),
            document.addEventListener("keydown", d, !0),
            c
          );
        }
      },
      _obtainHtml5Audio: function () {
        var c = this || t;
        if (c._html5AudioPool.length) return c._html5AudioPool.pop();
        var d = new Audio().play();
        return (
          d &&
            typeof Promise < "u" &&
            (d instanceof Promise || typeof d.then == "function") &&
            d.catch(function () {
              console.warn(
                "HTML5 Audio pool exhausted, returning potentially locked audio object."
              );
            }),
          new Audio()
        );
      },
      _releaseHtml5Audio: function (c) {
        var d = this || t;
        return c._unlocked && d._html5AudioPool.push(c), d;
      },
      _autoSuspend: function () {
        var c = this;
        if (
          !(
            !c.autoSuspend ||
            !c.ctx ||
            typeof c.ctx.suspend > "u" ||
            !t.usingWebAudio
          )
        ) {
          for (var d = 0; d < c._howls.length; d++)
            if (c._howls[d]._webAudio) {
              for (var m = 0; m < c._howls[d]._sounds.length; m++)
                if (!c._howls[d]._sounds[m]._paused) return c;
            }
          return (
            c._suspendTimer && clearTimeout(c._suspendTimer),
            (c._suspendTimer = setTimeout(function () {
              if (c.autoSuspend) {
                (c._suspendTimer = null), (c.state = "suspending");
                var x = function () {
                  (c.state = "suspended"),
                    c._resumeAfterSuspend &&
                      (delete c._resumeAfterSuspend, c._autoResume());
                };
                c.ctx.suspend().then(x, x);
              }
            }, 3e4)),
            c
          );
        }
      },
      _autoResume: function () {
        var c = this;
        if (!(!c.ctx || typeof c.ctx.resume > "u" || !t.usingWebAudio))
          return (
            c.state === "running" &&
            c.ctx.state !== "interrupted" &&
            c._suspendTimer
              ? (clearTimeout(c._suspendTimer), (c._suspendTimer = null))
              : c.state === "suspended" ||
                (c.state === "running" && c.ctx.state === "interrupted")
              ? (c.ctx.resume().then(function () {
                  c.state = "running";
                  for (var d = 0; d < c._howls.length; d++)
                    c._howls[d]._emit("resume");
                }),
                c._suspendTimer &&
                  (clearTimeout(c._suspendTimer), (c._suspendTimer = null)))
              : c.state === "suspending" && (c._resumeAfterSuspend = !0),
            c
          );
      },
    };
    var t = new e(),
      i = function (c) {
        var d = this;
        if (!c.src || c.src.length === 0) {
          console.error(
            "An array of source files must be passed with any new Howl."
          );
          return;
        }
        d.init(c);
      };
    i.prototype = {
      init: function (c) {
        var d = this;
        return (
          t.ctx || f(),
          (d._autoplay = c.autoplay || !1),
          (d._format = typeof c.format != "string" ? c.format : [c.format]),
          (d._html5 = c.html5 || !1),
          (d._muted = c.mute || !1),
          (d._loop = c.loop || !1),
          (d._pool = c.pool || 5),
          (d._preload =
            typeof c.preload == "boolean" || c.preload === "metadata"
              ? c.preload
              : !0),
          (d._rate = c.rate || 1),
          (d._sprite = c.sprite || {}),
          (d._src = typeof c.src != "string" ? c.src : [c.src]),
          (d._volume = c.volume !== void 0 ? c.volume : 1),
          (d._xhr = {
            method: c.xhr && c.xhr.method ? c.xhr.method : "GET",
            headers: c.xhr && c.xhr.headers ? c.xhr.headers : null,
            withCredentials:
              c.xhr && c.xhr.withCredentials ? c.xhr.withCredentials : !1,
          }),
          (d._duration = 0),
          (d._state = "unloaded"),
          (d._sounds = []),
          (d._endTimers = {}),
          (d._queue = []),
          (d._playLock = !1),
          (d._onend = c.onend ? [{ fn: c.onend }] : []),
          (d._onfade = c.onfade ? [{ fn: c.onfade }] : []),
          (d._onload = c.onload ? [{ fn: c.onload }] : []),
          (d._onloaderror = c.onloaderror ? [{ fn: c.onloaderror }] : []),
          (d._onplayerror = c.onplayerror ? [{ fn: c.onplayerror }] : []),
          (d._onpause = c.onpause ? [{ fn: c.onpause }] : []),
          (d._onplay = c.onplay ? [{ fn: c.onplay }] : []),
          (d._onstop = c.onstop ? [{ fn: c.onstop }] : []),
          (d._onmute = c.onmute ? [{ fn: c.onmute }] : []),
          (d._onvolume = c.onvolume ? [{ fn: c.onvolume }] : []),
          (d._onrate = c.onrate ? [{ fn: c.onrate }] : []),
          (d._onseek = c.onseek ? [{ fn: c.onseek }] : []),
          (d._onunlock = c.onunlock ? [{ fn: c.onunlock }] : []),
          (d._onresume = []),
          (d._webAudio = t.usingWebAudio && !d._html5),
          typeof t.ctx < "u" && t.ctx && t.autoUnlock && t._unlockAudio(),
          t._howls.push(d),
          d._autoplay &&
            d._queue.push({
              event: "play",
              action: function () {
                d.play();
              },
            }),
          d._preload && d._preload !== "none" && d.load(),
          d
        );
      },
      load: function () {
        var c = this,
          d = null;
        if (t.noAudio) {
          c._emit("loaderror", null, "No audio support.");
          return;
        }
        typeof c._src == "string" && (c._src = [c._src]);
        for (var m = 0; m < c._src.length; m++) {
          var x, v;
          if (c._format && c._format[m]) x = c._format[m];
          else {
            if (((v = c._src[m]), typeof v != "string")) {
              c._emit(
                "loaderror",
                null,
                "Non-string found in selected audio sources - ignoring."
              );
              continue;
            }
            (x = /^data:audio\/([^;,]+);/i.exec(v)),
              x || (x = /\.([^.]+)$/.exec(v.split("?", 1)[0])),
              x && (x = x[1].toLowerCase());
          }
          if (
            (x ||
              console.warn(
                'No file extension was found. Consider using the "format" property or specify an extension.'
              ),
            x && t.codecs(x))
          ) {
            d = c._src[m];
            break;
          }
        }
        if (!d) {
          c._emit(
            "loaderror",
            null,
            "No codec support for selected audio sources."
          );
          return;
        }
        return (
          (c._src = d),
          (c._state = "loading"),
          window.location.protocol === "https:" &&
            d.slice(0, 5) === "http:" &&
            ((c._html5 = !0), (c._webAudio = !1)),
          new n(c),
          c._webAudio && a(c),
          c
        );
      },
      play: function (c, d) {
        var m = this,
          x = null;
        if (typeof c == "number") (x = c), (c = null);
        else {
          if (typeof c == "string" && m._state === "loaded" && !m._sprite[c])
            return null;
          if (typeof c > "u" && ((c = "__default"), !m._playLock)) {
            for (var v = 0, b = 0; b < m._sounds.length; b++)
              m._sounds[b]._paused &&
                !m._sounds[b]._ended &&
                (v++, (x = m._sounds[b]._id));
            v === 1 ? (c = null) : (x = null);
          }
        }
        var y = x ? m._soundById(x) : m._inactiveSound();
        if (!y) return null;
        if (
          (x && !c && (c = y._sprite || "__default"), m._state !== "loaded")
        ) {
          (y._sprite = c), (y._ended = !1);
          var M = y._id;
          return (
            m._queue.push({
              event: "play",
              action: function () {
                m.play(M);
              },
            }),
            M
          );
        }
        if (x && !y._paused) return d || m._loadQueue("play"), y._id;
        m._webAudio && t._autoResume();
        var D = Math.max(0, y._seek > 0 ? y._seek : m._sprite[c][0] / 1e3),
          C = Math.max(0, (m._sprite[c][0] + m._sprite[c][1]) / 1e3 - D),
          A = (C * 1e3) / Math.abs(y._rate),
          I = m._sprite[c][0] / 1e3,
          F = (m._sprite[c][0] + m._sprite[c][1]) / 1e3;
        (y._sprite = c), (y._ended = !1);
        var P = function () {
          (y._paused = !1),
            (y._seek = D),
            (y._start = I),
            (y._stop = F),
            (y._loop = !!(y._loop || m._sprite[c][2]));
        };
        if (D >= F) {
          m._ended(y);
          return;
        }
        var k = y._node;
        if (m._webAudio) {
          var O = function () {
            (m._playLock = !1), P(), m._refreshBuffer(y);
            var j = y._muted || m._muted ? 0 : y._volume;
            k.gain.setValueAtTime(j, t.ctx.currentTime),
              (y._playStart = t.ctx.currentTime),
              typeof k.bufferSource.start > "u"
                ? y._loop
                  ? k.bufferSource.noteGrainOn(0, D, 86400)
                  : k.bufferSource.noteGrainOn(0, D, C)
                : y._loop
                ? k.bufferSource.start(0, D, 86400)
                : k.bufferSource.start(0, D, C),
              A !== 1 / 0 &&
                (m._endTimers[y._id] = setTimeout(m._ended.bind(m, y), A)),
              d ||
                setTimeout(function () {
                  m._emit("play", y._id), m._loadQueue();
                }, 0);
          };
          t.state === "running" && t.ctx.state !== "interrupted"
            ? O()
            : ((m._playLock = !0), m.once("resume", O), m._clearTimer(y._id));
        } else {
          var J = function () {
            (k.currentTime = D),
              (k.muted = y._muted || m._muted || t._muted || k.muted),
              (k.volume = y._volume * t.volume()),
              (k.playbackRate = y._rate);
            try {
              var j = k.play();
              if (
                (j &&
                typeof Promise < "u" &&
                (j instanceof Promise || typeof j.then == "function")
                  ? ((m._playLock = !0),
                    P(),
                    j
                      .then(function () {
                        (m._playLock = !1),
                          (k._unlocked = !0),
                          d ? m._loadQueue() : m._emit("play", y._id);
                      })
                      .catch(function () {
                        (m._playLock = !1),
                          m._emit(
                            "playerror",
                            y._id,
                            "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                          ),
                          (y._ended = !0),
                          (y._paused = !0);
                      }))
                  : d || ((m._playLock = !1), P(), m._emit("play", y._id)),
                (k.playbackRate = y._rate),
                k.paused)
              ) {
                m._emit(
                  "playerror",
                  y._id,
                  "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                );
                return;
              }
              c !== "__default" || y._loop
                ? (m._endTimers[y._id] = setTimeout(m._ended.bind(m, y), A))
                : ((m._endTimers[y._id] = function () {
                    m._ended(y),
                      k.removeEventListener("ended", m._endTimers[y._id], !1);
                  }),
                  k.addEventListener("ended", m._endTimers[y._id], !1));
            } catch (Y) {
              m._emit("playerror", y._id, Y);
            }
          };
          k.src ===
            "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" &&
            ((k.src = m._src), k.load());
          var ee =
            (window && window.ejecta) ||
            (!k.readyState && t._navigator.isCocoonJS);
          if (k.readyState >= 3 || ee) J();
          else {
            (m._playLock = !0), (m._state = "loading");
            var X = function () {
              (m._state = "loaded"),
                J(),
                k.removeEventListener(t._canPlayEvent, X, !1);
            };
            k.addEventListener(t._canPlayEvent, X, !1), m._clearTimer(y._id);
          }
        }
        return y._id;
      },
      pause: function (c) {
        var d = this;
        if (d._state !== "loaded" || d._playLock)
          return (
            d._queue.push({
              event: "pause",
              action: function () {
                d.pause(c);
              },
            }),
            d
          );
        for (var m = d._getSoundIds(c), x = 0; x < m.length; x++) {
          d._clearTimer(m[x]);
          var v = d._soundById(m[x]);
          if (
            v &&
            !v._paused &&
            ((v._seek = d.seek(m[x])),
            (v._rateSeek = 0),
            (v._paused = !0),
            d._stopFade(m[x]),
            v._node)
          )
            if (d._webAudio) {
              if (!v._node.bufferSource) continue;
              typeof v._node.bufferSource.stop > "u"
                ? v._node.bufferSource.noteOff(0)
                : v._node.bufferSource.stop(0),
                d._cleanBuffer(v._node);
            } else
              (!isNaN(v._node.duration) || v._node.duration === 1 / 0) &&
                v._node.pause();
          arguments[1] || d._emit("pause", v ? v._id : null);
        }
        return d;
      },
      stop: function (c, d) {
        var m = this;
        if (m._state !== "loaded" || m._playLock)
          return (
            m._queue.push({
              event: "stop",
              action: function () {
                m.stop(c);
              },
            }),
            m
          );
        for (var x = m._getSoundIds(c), v = 0; v < x.length; v++) {
          m._clearTimer(x[v]);
          var b = m._soundById(x[v]);
          b &&
            ((b._seek = b._start || 0),
            (b._rateSeek = 0),
            (b._paused = !0),
            (b._ended = !0),
            m._stopFade(x[v]),
            b._node &&
              (m._webAudio
                ? b._node.bufferSource &&
                  (typeof b._node.bufferSource.stop > "u"
                    ? b._node.bufferSource.noteOff(0)
                    : b._node.bufferSource.stop(0),
                  m._cleanBuffer(b._node))
                : (!isNaN(b._node.duration) || b._node.duration === 1 / 0) &&
                  ((b._node.currentTime = b._start || 0),
                  b._node.pause(),
                  b._node.duration === 1 / 0 && m._clearSound(b._node))),
            d || m._emit("stop", b._id));
        }
        return m;
      },
      mute: function (c, d) {
        var m = this;
        if (m._state !== "loaded" || m._playLock)
          return (
            m._queue.push({
              event: "mute",
              action: function () {
                m.mute(c, d);
              },
            }),
            m
          );
        if (typeof d > "u")
          if (typeof c == "boolean") m._muted = c;
          else return m._muted;
        for (var x = m._getSoundIds(d), v = 0; v < x.length; v++) {
          var b = m._soundById(x[v]);
          b &&
            ((b._muted = c),
            b._interval && m._stopFade(b._id),
            m._webAudio && b._node
              ? b._node.gain.setValueAtTime(
                  c ? 0 : b._volume,
                  t.ctx.currentTime
                )
              : b._node && (b._node.muted = t._muted ? !0 : c),
            m._emit("mute", b._id));
        }
        return m;
      },
      volume: function () {
        var c = this,
          d = arguments,
          m,
          x;
        if (d.length === 0) return c._volume;
        if (d.length === 1 || (d.length === 2 && typeof d[1] > "u")) {
          var v = c._getSoundIds(),
            b = v.indexOf(d[0]);
          b >= 0 ? (x = parseInt(d[0], 10)) : (m = parseFloat(d[0]));
        } else
          d.length >= 2 && ((m = parseFloat(d[0])), (x = parseInt(d[1], 10)));
        var y;
        if (typeof m < "u" && m >= 0 && m <= 1) {
          if (c._state !== "loaded" || c._playLock)
            return (
              c._queue.push({
                event: "volume",
                action: function () {
                  c.volume.apply(c, d);
                },
              }),
              c
            );
          typeof x > "u" && (c._volume = m), (x = c._getSoundIds(x));
          for (var M = 0; M < x.length; M++)
            (y = c._soundById(x[M])),
              y &&
                ((y._volume = m),
                d[2] || c._stopFade(x[M]),
                c._webAudio && y._node && !y._muted
                  ? y._node.gain.setValueAtTime(m, t.ctx.currentTime)
                  : y._node && !y._muted && (y._node.volume = m * t.volume()),
                c._emit("volume", y._id));
        } else
          return (y = x ? c._soundById(x) : c._sounds[0]), y ? y._volume : 0;
        return c;
      },
      fade: function (c, d, m, x) {
        var v = this;
        if (v._state !== "loaded" || v._playLock)
          return (
            v._queue.push({
              event: "fade",
              action: function () {
                v.fade(c, d, m, x);
              },
            }),
            v
          );
        (c = Math.min(Math.max(0, parseFloat(c)), 1)),
          (d = Math.min(Math.max(0, parseFloat(d)), 1)),
          (m = parseFloat(m)),
          v.volume(c, x);
        for (var b = v._getSoundIds(x), y = 0; y < b.length; y++) {
          var M = v._soundById(b[y]);
          if (M) {
            if ((x || v._stopFade(b[y]), v._webAudio && !M._muted)) {
              var D = t.ctx.currentTime,
                C = D + m / 1e3;
              (M._volume = c),
                M._node.gain.setValueAtTime(c, D),
                M._node.gain.linearRampToValueAtTime(d, C);
            }
            v._startFadeInterval(M, c, d, m, b[y], typeof x > "u");
          }
        }
        return v;
      },
      _startFadeInterval: function (c, d, m, x, v, b) {
        var y = this,
          M = d,
          D = m - d,
          C = Math.abs(D / 0.01),
          A = Math.max(4, C > 0 ? x / C : x),
          I = Date.now();
        (c._fadeTo = m),
          (c._interval = setInterval(function () {
            var F = (Date.now() - I) / x;
            (I = Date.now()),
              (M += D * F),
              (M = Math.round(M * 100) / 100),
              D < 0 ? (M = Math.max(m, M)) : (M = Math.min(m, M)),
              y._webAudio ? (c._volume = M) : y.volume(M, c._id, !0),
              b && (y._volume = M),
              ((m < d && M <= m) || (m > d && M >= m)) &&
                (clearInterval(c._interval),
                (c._interval = null),
                (c._fadeTo = null),
                y.volume(m, c._id),
                y._emit("fade", c._id));
          }, A));
      },
      _stopFade: function (c) {
        var d = this,
          m = d._soundById(c);
        return (
          m &&
            m._interval &&
            (d._webAudio &&
              m._node.gain.cancelScheduledValues(t.ctx.currentTime),
            clearInterval(m._interval),
            (m._interval = null),
            d.volume(m._fadeTo, c),
            (m._fadeTo = null),
            d._emit("fade", c)),
          d
        );
      },
      loop: function () {
        var c = this,
          d = arguments,
          m,
          x,
          v;
        if (d.length === 0) return c._loop;
        if (d.length === 1)
          if (typeof d[0] == "boolean") (m = d[0]), (c._loop = m);
          else return (v = c._soundById(parseInt(d[0], 10))), v ? v._loop : !1;
        else d.length === 2 && ((m = d[0]), (x = parseInt(d[1], 10)));
        for (var b = c._getSoundIds(x), y = 0; y < b.length; y++)
          (v = c._soundById(b[y])),
            v &&
              ((v._loop = m),
              c._webAudio &&
                v._node &&
                v._node.bufferSource &&
                ((v._node.bufferSource.loop = m),
                m &&
                  ((v._node.bufferSource.loopStart = v._start || 0),
                  (v._node.bufferSource.loopEnd = v._stop),
                  c.playing(b[y]) && (c.pause(b[y], !0), c.play(b[y], !0)))));
        return c;
      },
      rate: function () {
        var c = this,
          d = arguments,
          m,
          x;
        if (d.length === 0) x = c._sounds[0]._id;
        else if (d.length === 1) {
          var v = c._getSoundIds(),
            b = v.indexOf(d[0]);
          b >= 0 ? (x = parseInt(d[0], 10)) : (m = parseFloat(d[0]));
        } else
          d.length === 2 && ((m = parseFloat(d[0])), (x = parseInt(d[1], 10)));
        var y;
        if (typeof m == "number") {
          if (c._state !== "loaded" || c._playLock)
            return (
              c._queue.push({
                event: "rate",
                action: function () {
                  c.rate.apply(c, d);
                },
              }),
              c
            );
          typeof x > "u" && (c._rate = m), (x = c._getSoundIds(x));
          for (var M = 0; M < x.length; M++)
            if (((y = c._soundById(x[M])), y)) {
              c.playing(x[M]) &&
                ((y._rateSeek = c.seek(x[M])),
                (y._playStart = c._webAudio
                  ? t.ctx.currentTime
                  : y._playStart)),
                (y._rate = m),
                c._webAudio && y._node && y._node.bufferSource
                  ? y._node.bufferSource.playbackRate.setValueAtTime(
                      m,
                      t.ctx.currentTime
                    )
                  : y._node && (y._node.playbackRate = m);
              var D = c.seek(x[M]),
                C =
                  (c._sprite[y._sprite][0] + c._sprite[y._sprite][1]) / 1e3 - D,
                A = (C * 1e3) / Math.abs(y._rate);
              (c._endTimers[x[M]] || !y._paused) &&
                (c._clearTimer(x[M]),
                (c._endTimers[x[M]] = setTimeout(c._ended.bind(c, y), A))),
                c._emit("rate", y._id);
            }
        } else return (y = c._soundById(x)), y ? y._rate : c._rate;
        return c;
      },
      seek: function () {
        var c = this,
          d = arguments,
          m,
          x;
        if (d.length === 0) c._sounds.length && (x = c._sounds[0]._id);
        else if (d.length === 1) {
          var v = c._getSoundIds(),
            b = v.indexOf(d[0]);
          b >= 0
            ? (x = parseInt(d[0], 10))
            : c._sounds.length &&
              ((x = c._sounds[0]._id), (m = parseFloat(d[0])));
        } else
          d.length === 2 && ((m = parseFloat(d[0])), (x = parseInt(d[1], 10)));
        if (typeof x > "u") return 0;
        if (typeof m == "number" && (c._state !== "loaded" || c._playLock))
          return (
            c._queue.push({
              event: "seek",
              action: function () {
                c.seek.apply(c, d);
              },
            }),
            c
          );
        var y = c._soundById(x);
        if (y)
          if (typeof m == "number" && m >= 0) {
            var M = c.playing(x);
            M && c.pause(x, !0),
              (y._seek = m),
              (y._ended = !1),
              c._clearTimer(x),
              !c._webAudio &&
                y._node &&
                !isNaN(y._node.duration) &&
                (y._node.currentTime = m);
            var D = function () {
              M && c.play(x, !0), c._emit("seek", x);
            };
            if (M && !c._webAudio) {
              var C = function () {
                c._playLock ? setTimeout(C, 0) : D();
              };
              setTimeout(C, 0);
            } else D();
          } else if (c._webAudio) {
            var A = c.playing(x) ? t.ctx.currentTime - y._playStart : 0,
              I = y._rateSeek ? y._rateSeek - y._seek : 0;
            return y._seek + (I + A * Math.abs(y._rate));
          } else return y._node.currentTime;
        return c;
      },
      playing: function (c) {
        var d = this;
        if (typeof c == "number") {
          var m = d._soundById(c);
          return m ? !m._paused : !1;
        }
        for (var x = 0; x < d._sounds.length; x++)
          if (!d._sounds[x]._paused) return !0;
        return !1;
      },
      duration: function (c) {
        var d = this,
          m = d._duration,
          x = d._soundById(c);
        return x && (m = d._sprite[x._sprite][1] / 1e3), m;
      },
      state: function () {
        return this._state;
      },
      unload: function () {
        for (var c = this, d = c._sounds, m = 0; m < d.length; m++)
          d[m]._paused || c.stop(d[m]._id),
            c._webAudio ||
              (c._clearSound(d[m]._node),
              d[m]._node.removeEventListener("error", d[m]._errorFn, !1),
              d[m]._node.removeEventListener(t._canPlayEvent, d[m]._loadFn, !1),
              d[m]._node.removeEventListener("ended", d[m]._endFn, !1),
              t._releaseHtml5Audio(d[m]._node)),
            delete d[m]._node,
            c._clearTimer(d[m]._id);
        var x = t._howls.indexOf(c);
        x >= 0 && t._howls.splice(x, 1);
        var v = !0;
        for (m = 0; m < t._howls.length; m++)
          if (
            t._howls[m]._src === c._src ||
            c._src.indexOf(t._howls[m]._src) >= 0
          ) {
            v = !1;
            break;
          }
        return (
          s && v && delete s[c._src],
          (t.noAudio = !1),
          (c._state = "unloaded"),
          (c._sounds = []),
          (c = null),
          null
        );
      },
      on: function (c, d, m, x) {
        var v = this,
          b = v["_on" + c];
        return (
          typeof d == "function" &&
            b.push(x ? { id: m, fn: d, once: x } : { id: m, fn: d }),
          v
        );
      },
      off: function (c, d, m) {
        var x = this,
          v = x["_on" + c],
          b = 0;
        if ((typeof d == "number" && ((m = d), (d = null)), d || m))
          for (b = 0; b < v.length; b++) {
            var y = m === v[b].id;
            if ((d === v[b].fn && y) || (!d && y)) {
              v.splice(b, 1);
              break;
            }
          }
        else if (c) x["_on" + c] = [];
        else {
          var M = Object.keys(x);
          for (b = 0; b < M.length; b++)
            M[b].indexOf("_on") === 0 &&
              Array.isArray(x[M[b]]) &&
              (x[M[b]] = []);
        }
        return x;
      },
      once: function (c, d, m) {
        var x = this;
        return x.on(c, d, m, 1), x;
      },
      _emit: function (c, d, m) {
        for (var x = this, v = x["_on" + c], b = v.length - 1; b >= 0; b--)
          (!v[b].id || v[b].id === d || c === "load") &&
            (setTimeout(
              function (y) {
                y.call(this, d, m);
              }.bind(x, v[b].fn),
              0
            ),
            v[b].once && x.off(c, v[b].fn, v[b].id));
        return x._loadQueue(c), x;
      },
      _loadQueue: function (c) {
        var d = this;
        if (d._queue.length > 0) {
          var m = d._queue[0];
          m.event === c && (d._queue.shift(), d._loadQueue()), c || m.action();
        }
        return d;
      },
      _ended: function (c) {
        var d = this,
          m = c._sprite;
        if (
          !d._webAudio &&
          c._node &&
          !c._node.paused &&
          !c._node.ended &&
          c._node.currentTime < c._stop
        )
          return setTimeout(d._ended.bind(d, c), 100), d;
        var x = !!(c._loop || d._sprite[m][2]);
        if (
          (d._emit("end", c._id),
          !d._webAudio && x && d.stop(c._id, !0).play(c._id),
          d._webAudio && x)
        ) {
          d._emit("play", c._id),
            (c._seek = c._start || 0),
            (c._rateSeek = 0),
            (c._playStart = t.ctx.currentTime);
          var v = ((c._stop - c._start) * 1e3) / Math.abs(c._rate);
          d._endTimers[c._id] = setTimeout(d._ended.bind(d, c), v);
        }
        return (
          d._webAudio &&
            !x &&
            ((c._paused = !0),
            (c._ended = !0),
            (c._seek = c._start || 0),
            (c._rateSeek = 0),
            d._clearTimer(c._id),
            d._cleanBuffer(c._node),
            t._autoSuspend()),
          !d._webAudio && !x && d.stop(c._id, !0),
          d
        );
      },
      _clearTimer: function (c) {
        var d = this;
        if (d._endTimers[c]) {
          if (typeof d._endTimers[c] != "function")
            clearTimeout(d._endTimers[c]);
          else {
            var m = d._soundById(c);
            m &&
              m._node &&
              m._node.removeEventListener("ended", d._endTimers[c], !1);
          }
          delete d._endTimers[c];
        }
        return d;
      },
      _soundById: function (c) {
        for (var d = this, m = 0; m < d._sounds.length; m++)
          if (c === d._sounds[m]._id) return d._sounds[m];
        return null;
      },
      _inactiveSound: function () {
        var c = this;
        c._drain();
        for (var d = 0; d < c._sounds.length; d++)
          if (c._sounds[d]._ended) return c._sounds[d].reset();
        return new n(c);
      },
      _drain: function () {
        var c = this,
          d = c._pool,
          m = 0,
          x = 0;
        if (!(c._sounds.length < d)) {
          for (x = 0; x < c._sounds.length; x++) c._sounds[x]._ended && m++;
          for (x = c._sounds.length - 1; x >= 0; x--) {
            if (m <= d) return;
            c._sounds[x]._ended &&
              (c._webAudio &&
                c._sounds[x]._node &&
                c._sounds[x]._node.disconnect(0),
              c._sounds.splice(x, 1),
              m--);
          }
        }
      },
      _getSoundIds: function (c) {
        var d = this;
        if (typeof c > "u") {
          for (var m = [], x = 0; x < d._sounds.length; x++)
            m.push(d._sounds[x]._id);
          return m;
        } else return [c];
      },
      _refreshBuffer: function (c) {
        var d = this;
        return (
          (c._node.bufferSource = t.ctx.createBufferSource()),
          (c._node.bufferSource.buffer = s[d._src]),
          c._panner
            ? c._node.bufferSource.connect(c._panner)
            : c._node.bufferSource.connect(c._node),
          (c._node.bufferSource.loop = c._loop),
          c._loop &&
            ((c._node.bufferSource.loopStart = c._start || 0),
            (c._node.bufferSource.loopEnd = c._stop || 0)),
          c._node.bufferSource.playbackRate.setValueAtTime(
            c._rate,
            t.ctx.currentTime
          ),
          d
        );
      },
      _cleanBuffer: function (c) {
        var d = this,
          m = t._navigator && t._navigator.vendor.indexOf("Apple") >= 0;
        if (
          t._scratchBuffer &&
          c.bufferSource &&
          ((c.bufferSource.onended = null), c.bufferSource.disconnect(0), m)
        )
          try {
            c.bufferSource.buffer = t._scratchBuffer;
          } catch {}
        return (c.bufferSource = null), d;
      },
      _clearSound: function (c) {
        var d = /MSIE |Trident\//.test(t._navigator && t._navigator.userAgent);
        d ||
          (c.src =
            "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
      },
    };
    var n = function (c) {
      (this._parent = c), this.init();
    };
    n.prototype = {
      init: function () {
        var c = this,
          d = c._parent;
        return (
          (c._muted = d._muted),
          (c._loop = d._loop),
          (c._volume = d._volume),
          (c._rate = d._rate),
          (c._seek = 0),
          (c._paused = !0),
          (c._ended = !0),
          (c._sprite = "__default"),
          (c._id = ++t._counter),
          d._sounds.push(c),
          c.create(),
          c
        );
      },
      create: function () {
        var c = this,
          d = c._parent,
          m = t._muted || c._muted || c._parent._muted ? 0 : c._volume;
        return (
          d._webAudio
            ? ((c._node =
                typeof t.ctx.createGain > "u"
                  ? t.ctx.createGainNode()
                  : t.ctx.createGain()),
              c._node.gain.setValueAtTime(m, t.ctx.currentTime),
              (c._node.paused = !0),
              c._node.connect(t.masterGain))
            : t.noAudio ||
              ((c._node = t._obtainHtml5Audio()),
              (c._errorFn = c._errorListener.bind(c)),
              c._node.addEventListener("error", c._errorFn, !1),
              (c._loadFn = c._loadListener.bind(c)),
              c._node.addEventListener(t._canPlayEvent, c._loadFn, !1),
              (c._endFn = c._endListener.bind(c)),
              c._node.addEventListener("ended", c._endFn, !1),
              (c._node.src = d._src),
              (c._node.preload = d._preload === !0 ? "auto" : d._preload),
              (c._node.volume = m * t.volume()),
              c._node.load()),
          c
        );
      },
      reset: function () {
        var c = this,
          d = c._parent;
        return (
          (c._muted = d._muted),
          (c._loop = d._loop),
          (c._volume = d._volume),
          (c._rate = d._rate),
          (c._seek = 0),
          (c._rateSeek = 0),
          (c._paused = !0),
          (c._ended = !0),
          (c._sprite = "__default"),
          (c._id = ++t._counter),
          c
        );
      },
      _errorListener: function () {
        var c = this;
        c._parent._emit(
          "loaderror",
          c._id,
          c._node.error ? c._node.error.code : 0
        ),
          c._node.removeEventListener("error", c._errorFn, !1);
      },
      _loadListener: function () {
        var c = this,
          d = c._parent;
        (d._duration = Math.ceil(c._node.duration * 10) / 10),
          Object.keys(d._sprite).length === 0 &&
            (d._sprite = { __default: [0, d._duration * 1e3] }),
          d._state !== "loaded" &&
            ((d._state = "loaded"), d._emit("load"), d._loadQueue()),
          c._node.removeEventListener(t._canPlayEvent, c._loadFn, !1);
      },
      _endListener: function () {
        var c = this,
          d = c._parent;
        d._duration === 1 / 0 &&
          ((d._duration = Math.ceil(c._node.duration * 10) / 10),
          d._sprite.__default[1] === 1 / 0 &&
            (d._sprite.__default[1] = d._duration * 1e3),
          d._ended(c)),
          c._node.removeEventListener("ended", c._endFn, !1);
      },
    };
    var s = {},
      a = function (c) {
        var d = c._src;
        if (s[d]) {
          (c._duration = s[d].duration), h(c);
          return;
        }
        if (/^data:[^;]+;base64,/.test(d)) {
          for (
            var m = atob(d.split(",")[1]), x = new Uint8Array(m.length), v = 0;
            v < m.length;
            ++v
          )
            x[v] = m.charCodeAt(v);
          u(x.buffer, c);
        } else {
          var b = new XMLHttpRequest();
          b.open(c._xhr.method, d, !0),
            (b.withCredentials = c._xhr.withCredentials),
            (b.responseType = "arraybuffer"),
            c._xhr.headers &&
              Object.keys(c._xhr.headers).forEach(function (y) {
                b.setRequestHeader(y, c._xhr.headers[y]);
              }),
            (b.onload = function () {
              var y = (b.status + "")[0];
              if (y !== "0" && y !== "2" && y !== "3") {
                c._emit(
                  "loaderror",
                  null,
                  "Failed loading audio file with status: " + b.status + "."
                );
                return;
              }
              u(b.response, c);
            }),
            (b.onerror = function () {
              c._webAudio &&
                ((c._html5 = !0),
                (c._webAudio = !1),
                (c._sounds = []),
                delete s[d],
                c.load());
            }),
            o(b);
        }
      },
      o = function (c) {
        try {
          c.send();
        } catch {
          c.onerror();
        }
      },
      u = function (c, d) {
        var m = function () {
            d._emit("loaderror", null, "Decoding audio data failed.");
          },
          x = function (v) {
            v && d._sounds.length > 0 ? ((s[d._src] = v), h(d, v)) : m();
          };
        typeof Promise < "u" && t.ctx.decodeAudioData.length === 1
          ? t.ctx.decodeAudioData(c).then(x).catch(m)
          : t.ctx.decodeAudioData(c, x, m);
      },
      h = function (c, d) {
        d && !c._duration && (c._duration = d.duration),
          Object.keys(c._sprite).length === 0 &&
            (c._sprite = { __default: [0, c._duration * 1e3] }),
          c._state !== "loaded" &&
            ((c._state = "loaded"), c._emit("load"), c._loadQueue());
      },
      f = function () {
        if (t.usingWebAudio) {
          try {
            typeof AudioContext < "u"
              ? (t.ctx = new AudioContext())
              : typeof webkitAudioContext < "u"
              ? (t.ctx = new webkitAudioContext())
              : (t.usingWebAudio = !1);
          } catch {
            t.usingWebAudio = !1;
          }
          t.ctx || (t.usingWebAudio = !1);
          var c = /iP(hone|od|ad)/.test(t._navigator && t._navigator.platform),
            d =
              t._navigator &&
              t._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
            m = d ? parseInt(d[1], 10) : null;
          if (c && m && m < 9) {
            var x = /safari/.test(
              t._navigator && t._navigator.userAgent.toLowerCase()
            );
            t._navigator && !x && (t.usingWebAudio = !1);
          }
          t.usingWebAudio &&
            ((t.masterGain =
              typeof t.ctx.createGain > "u"
                ? t.ctx.createGainNode()
                : t.ctx.createGain()),
            t.masterGain.gain.setValueAtTime(
              t._muted ? 0 : t._volume,
              t.ctx.currentTime
            ),
            t.masterGain.connect(t.ctx.destination)),
            t._setup();
        }
      };
    (r.Howler = t),
      (r.Howl = i),
      typeof Lo < "u"
        ? ((Lo.HowlerGlobal = e),
          (Lo.Howler = t),
          (Lo.Howl = i),
          (Lo.Sound = n))
        : typeof window < "u" &&
          ((window.HowlerGlobal = e),
          (window.Howler = t),
          (window.Howl = i),
          (window.Sound = n));
  })();
  /*!
   *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
   *
   *  howler.js v2.2.3
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   */ (function () {
    (HowlerGlobal.prototype._pos = [0, 0, 0]),
      (HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0]),
      (HowlerGlobal.prototype.stereo = function (t) {
        var i = this;
        if (!i.ctx || !i.ctx.listener) return i;
        for (var n = i._howls.length - 1; n >= 0; n--) i._howls[n].stereo(t);
        return i;
      }),
      (HowlerGlobal.prototype.pos = function (t, i, n) {
        var s = this;
        if (!s.ctx || !s.ctx.listener) return s;
        if (
          ((i = typeof i != "number" ? s._pos[1] : i),
          (n = typeof n != "number" ? s._pos[2] : n),
          typeof t == "number")
        )
          (s._pos = [t, i, n]),
            typeof s.ctx.listener.positionX < "u"
              ? (s.ctx.listener.positionX.setTargetAtTime(
                  s._pos[0],
                  Howler.ctx.currentTime,
                  0.1
                ),
                s.ctx.listener.positionY.setTargetAtTime(
                  s._pos[1],
                  Howler.ctx.currentTime,
                  0.1
                ),
                s.ctx.listener.positionZ.setTargetAtTime(
                  s._pos[2],
                  Howler.ctx.currentTime,
                  0.1
                ))
              : s.ctx.listener.setPosition(s._pos[0], s._pos[1], s._pos[2]);
        else return s._pos;
        return s;
      }),
      (HowlerGlobal.prototype.orientation = function (t, i, n, s, a, o) {
        var u = this;
        if (!u.ctx || !u.ctx.listener) return u;
        var h = u._orientation;
        if (
          ((i = typeof i != "number" ? h[1] : i),
          (n = typeof n != "number" ? h[2] : n),
          (s = typeof s != "number" ? h[3] : s),
          (a = typeof a != "number" ? h[4] : a),
          (o = typeof o != "number" ? h[5] : o),
          typeof t == "number")
        )
          (u._orientation = [t, i, n, s, a, o]),
            typeof u.ctx.listener.forwardX < "u"
              ? (u.ctx.listener.forwardX.setTargetAtTime(
                  t,
                  Howler.ctx.currentTime,
                  0.1
                ),
                u.ctx.listener.forwardY.setTargetAtTime(
                  i,
                  Howler.ctx.currentTime,
                  0.1
                ),
                u.ctx.listener.forwardZ.setTargetAtTime(
                  n,
                  Howler.ctx.currentTime,
                  0.1
                ),
                u.ctx.listener.upX.setTargetAtTime(
                  s,
                  Howler.ctx.currentTime,
                  0.1
                ),
                u.ctx.listener.upY.setTargetAtTime(
                  a,
                  Howler.ctx.currentTime,
                  0.1
                ),
                u.ctx.listener.upZ.setTargetAtTime(
                  o,
                  Howler.ctx.currentTime,
                  0.1
                ))
              : u.ctx.listener.setOrientation(t, i, n, s, a, o);
        else return h;
        return u;
      }),
      (Howl.prototype.init = (function (t) {
        return function (i) {
          var n = this;
          return (
            (n._orientation = i.orientation || [1, 0, 0]),
            (n._stereo = i.stereo || null),
            (n._pos = i.pos || null),
            (n._pannerAttr = {
              coneInnerAngle:
                typeof i.coneInnerAngle < "u" ? i.coneInnerAngle : 360,
              coneOuterAngle:
                typeof i.coneOuterAngle < "u" ? i.coneOuterAngle : 360,
              coneOuterGain: typeof i.coneOuterGain < "u" ? i.coneOuterGain : 0,
              distanceModel:
                typeof i.distanceModel < "u" ? i.distanceModel : "inverse",
              maxDistance: typeof i.maxDistance < "u" ? i.maxDistance : 1e4,
              panningModel:
                typeof i.panningModel < "u" ? i.panningModel : "HRTF",
              refDistance: typeof i.refDistance < "u" ? i.refDistance : 1,
              rolloffFactor: typeof i.rolloffFactor < "u" ? i.rolloffFactor : 1,
            }),
            (n._onstereo = i.onstereo ? [{ fn: i.onstereo }] : []),
            (n._onpos = i.onpos ? [{ fn: i.onpos }] : []),
            (n._onorientation = i.onorientation
              ? [{ fn: i.onorientation }]
              : []),
            t.call(this, i)
          );
        };
      })(Howl.prototype.init)),
      (Howl.prototype.stereo = function (t, i) {
        var n = this;
        if (!n._webAudio) return n;
        if (n._state !== "loaded")
          return (
            n._queue.push({
              event: "stereo",
              action: function () {
                n.stereo(t, i);
              },
            }),
            n
          );
        var s =
          typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
        if (typeof i > "u")
          if (typeof t == "number") (n._stereo = t), (n._pos = [t, 0, 0]);
          else return n._stereo;
        for (var a = n._getSoundIds(i), o = 0; o < a.length; o++) {
          var u = n._soundById(a[o]);
          if (u)
            if (typeof t == "number")
              (u._stereo = t),
                (u._pos = [t, 0, 0]),
                u._node &&
                  ((u._pannerAttr.panningModel = "equalpower"),
                  (!u._panner || !u._panner.pan) && e(u, s),
                  s === "spatial"
                    ? typeof u._panner.positionX < "u"
                      ? (u._panner.positionX.setValueAtTime(
                          t,
                          Howler.ctx.currentTime
                        ),
                        u._panner.positionY.setValueAtTime(
                          0,
                          Howler.ctx.currentTime
                        ),
                        u._panner.positionZ.setValueAtTime(
                          0,
                          Howler.ctx.currentTime
                        ))
                      : u._panner.setPosition(t, 0, 0)
                    : u._panner.pan.setValueAtTime(t, Howler.ctx.currentTime)),
                n._emit("stereo", u._id);
            else return u._stereo;
        }
        return n;
      }),
      (Howl.prototype.pos = function (t, i, n, s) {
        var a = this;
        if (!a._webAudio) return a;
        if (a._state !== "loaded")
          return (
            a._queue.push({
              event: "pos",
              action: function () {
                a.pos(t, i, n, s);
              },
            }),
            a
          );
        if (
          ((i = typeof i != "number" ? 0 : i),
          (n = typeof n != "number" ? -0.5 : n),
          typeof s > "u")
        )
          if (typeof t == "number") a._pos = [t, i, n];
          else return a._pos;
        for (var o = a._getSoundIds(s), u = 0; u < o.length; u++) {
          var h = a._soundById(o[u]);
          if (h)
            if (typeof t == "number")
              (h._pos = [t, i, n]),
                h._node &&
                  ((!h._panner || h._panner.pan) && e(h, "spatial"),
                  typeof h._panner.positionX < "u"
                    ? (h._panner.positionX.setValueAtTime(
                        t,
                        Howler.ctx.currentTime
                      ),
                      h._panner.positionY.setValueAtTime(
                        i,
                        Howler.ctx.currentTime
                      ),
                      h._panner.positionZ.setValueAtTime(
                        n,
                        Howler.ctx.currentTime
                      ))
                    : h._panner.setPosition(t, i, n)),
                a._emit("pos", h._id);
            else return h._pos;
        }
        return a;
      }),
      (Howl.prototype.orientation = function (t, i, n, s) {
        var a = this;
        if (!a._webAudio) return a;
        if (a._state !== "loaded")
          return (
            a._queue.push({
              event: "orientation",
              action: function () {
                a.orientation(t, i, n, s);
              },
            }),
            a
          );
        if (
          ((i = typeof i != "number" ? a._orientation[1] : i),
          (n = typeof n != "number" ? a._orientation[2] : n),
          typeof s > "u")
        )
          if (typeof t == "number") a._orientation = [t, i, n];
          else return a._orientation;
        for (var o = a._getSoundIds(s), u = 0; u < o.length; u++) {
          var h = a._soundById(o[u]);
          if (h)
            if (typeof t == "number")
              (h._orientation = [t, i, n]),
                h._node &&
                  (h._panner ||
                    (h._pos || (h._pos = a._pos || [0, 0, -0.5]),
                    e(h, "spatial")),
                  typeof h._panner.orientationX < "u"
                    ? (h._panner.orientationX.setValueAtTime(
                        t,
                        Howler.ctx.currentTime
                      ),
                      h._panner.orientationY.setValueAtTime(
                        i,
                        Howler.ctx.currentTime
                      ),
                      h._panner.orientationZ.setValueAtTime(
                        n,
                        Howler.ctx.currentTime
                      ))
                    : h._panner.setOrientation(t, i, n)),
                a._emit("orientation", h._id);
            else return h._orientation;
        }
        return a;
      }),
      (Howl.prototype.pannerAttr = function () {
        var t = this,
          i = arguments,
          n,
          s,
          a;
        if (!t._webAudio) return t;
        if (i.length === 0) return t._pannerAttr;
        if (i.length === 1)
          if (typeof i[0] == "object")
            (n = i[0]),
              typeof s > "u" &&
                (n.pannerAttr ||
                  (n.pannerAttr = {
                    coneInnerAngle: n.coneInnerAngle,
                    coneOuterAngle: n.coneOuterAngle,
                    coneOuterGain: n.coneOuterGain,
                    distanceModel: n.distanceModel,
                    maxDistance: n.maxDistance,
                    refDistance: n.refDistance,
                    rolloffFactor: n.rolloffFactor,
                    panningModel: n.panningModel,
                  }),
                (t._pannerAttr = {
                  coneInnerAngle:
                    typeof n.pannerAttr.coneInnerAngle < "u"
                      ? n.pannerAttr.coneInnerAngle
                      : t._coneInnerAngle,
                  coneOuterAngle:
                    typeof n.pannerAttr.coneOuterAngle < "u"
                      ? n.pannerAttr.coneOuterAngle
                      : t._coneOuterAngle,
                  coneOuterGain:
                    typeof n.pannerAttr.coneOuterGain < "u"
                      ? n.pannerAttr.coneOuterGain
                      : t._coneOuterGain,
                  distanceModel:
                    typeof n.pannerAttr.distanceModel < "u"
                      ? n.pannerAttr.distanceModel
                      : t._distanceModel,
                  maxDistance:
                    typeof n.pannerAttr.maxDistance < "u"
                      ? n.pannerAttr.maxDistance
                      : t._maxDistance,
                  refDistance:
                    typeof n.pannerAttr.refDistance < "u"
                      ? n.pannerAttr.refDistance
                      : t._refDistance,
                  rolloffFactor:
                    typeof n.pannerAttr.rolloffFactor < "u"
                      ? n.pannerAttr.rolloffFactor
                      : t._rolloffFactor,
                  panningModel:
                    typeof n.pannerAttr.panningModel < "u"
                      ? n.pannerAttr.panningModel
                      : t._panningModel,
                }));
          else
            return (
              (a = t._soundById(parseInt(i[0], 10))),
              a ? a._pannerAttr : t._pannerAttr
            );
        else i.length === 2 && ((n = i[0]), (s = parseInt(i[1], 10)));
        for (var o = t._getSoundIds(s), u = 0; u < o.length; u++)
          if (((a = t._soundById(o[u])), a)) {
            var h = a._pannerAttr;
            h = {
              coneInnerAngle:
                typeof n.coneInnerAngle < "u"
                  ? n.coneInnerAngle
                  : h.coneInnerAngle,
              coneOuterAngle:
                typeof n.coneOuterAngle < "u"
                  ? n.coneOuterAngle
                  : h.coneOuterAngle,
              coneOuterGain:
                typeof n.coneOuterGain < "u"
                  ? n.coneOuterGain
                  : h.coneOuterGain,
              distanceModel:
                typeof n.distanceModel < "u"
                  ? n.distanceModel
                  : h.distanceModel,
              maxDistance:
                typeof n.maxDistance < "u" ? n.maxDistance : h.maxDistance,
              refDistance:
                typeof n.refDistance < "u" ? n.refDistance : h.refDistance,
              rolloffFactor:
                typeof n.rolloffFactor < "u"
                  ? n.rolloffFactor
                  : h.rolloffFactor,
              panningModel:
                typeof n.panningModel < "u" ? n.panningModel : h.panningModel,
            };
            var f = a._panner;
            f
              ? ((f.coneInnerAngle = h.coneInnerAngle),
                (f.coneOuterAngle = h.coneOuterAngle),
                (f.coneOuterGain = h.coneOuterGain),
                (f.distanceModel = h.distanceModel),
                (f.maxDistance = h.maxDistance),
                (f.refDistance = h.refDistance),
                (f.rolloffFactor = h.rolloffFactor),
                (f.panningModel = h.panningModel))
              : (a._pos || (a._pos = t._pos || [0, 0, -0.5]), e(a, "spatial"));
          }
        return t;
      }),
      (Sound.prototype.init = (function (t) {
        return function () {
          var i = this,
            n = i._parent;
          (i._orientation = n._orientation),
            (i._stereo = n._stereo),
            (i._pos = n._pos),
            (i._pannerAttr = n._pannerAttr),
            t.call(this),
            i._stereo
              ? n.stereo(i._stereo)
              : i._pos && n.pos(i._pos[0], i._pos[1], i._pos[2], i._id);
        };
      })(Sound.prototype.init)),
      (Sound.prototype.reset = (function (t) {
        return function () {
          var i = this,
            n = i._parent;
          return (
            (i._orientation = n._orientation),
            (i._stereo = n._stereo),
            (i._pos = n._pos),
            (i._pannerAttr = n._pannerAttr),
            i._stereo
              ? n.stereo(i._stereo)
              : i._pos
              ? n.pos(i._pos[0], i._pos[1], i._pos[2], i._id)
              : i._panner &&
                (i._panner.disconnect(0),
                (i._panner = void 0),
                n._refreshBuffer(i)),
            t.call(this)
          );
        };
      })(Sound.prototype.reset));
    var e = function (t, i) {
      (i = i || "spatial"),
        i === "spatial"
          ? ((t._panner = Howler.ctx.createPanner()),
            (t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle),
            (t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle),
            (t._panner.coneOuterGain = t._pannerAttr.coneOuterGain),
            (t._panner.distanceModel = t._pannerAttr.distanceModel),
            (t._panner.maxDistance = t._pannerAttr.maxDistance),
            (t._panner.refDistance = t._pannerAttr.refDistance),
            (t._panner.rolloffFactor = t._pannerAttr.rolloffFactor),
            (t._panner.panningModel = t._pannerAttr.panningModel),
            typeof t._panner.positionX < "u"
              ? (t._panner.positionX.setValueAtTime(
                  t._pos[0],
                  Howler.ctx.currentTime
                ),
                t._panner.positionY.setValueAtTime(
                  t._pos[1],
                  Howler.ctx.currentTime
                ),
                t._panner.positionZ.setValueAtTime(
                  t._pos[2],
                  Howler.ctx.currentTime
                ))
              : t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]),
            typeof t._panner.orientationX < "u"
              ? (t._panner.orientationX.setValueAtTime(
                  t._orientation[0],
                  Howler.ctx.currentTime
                ),
                t._panner.orientationY.setValueAtTime(
                  t._orientation[1],
                  Howler.ctx.currentTime
                ),
                t._panner.orientationZ.setValueAtTime(
                  t._orientation[2],
                  Howler.ctx.currentTime
                ))
              : t._panner.setOrientation(
                  t._orientation[0],
                  t._orientation[1],
                  t._orientation[2]
                ))
          : ((t._panner = Howler.ctx.createStereoPanner()),
            t._panner.pan.setValueAtTime(t._stereo, Howler.ctx.currentTime)),
        t._panner.connect(t._node),
        t._paused || t._parent.pause(t._id, !0).play(t._id, !0);
    };
  })();
})(tu);
var _f;
let Ew =
  ((_f = class extends jt {
    constructor(t) {
      super(t);
      q(this, "getCrunchDuration", () => {
        this.crunch.play(),
          (this.crunchDuration = this.crunch.duration()),
          this.crunch.pause(),
          this.off("click", document.body, this.getCrunchDuration, !0);
      });
      this.buildAudio(),
        this.on("click", document.body, this.getCrunchDuration, !0),
        this.on("visibilitychange", document, () => {
          document.visibilityState === "visible"
            ? this.playWhenVisibleAgain && this.sound.play()
            : this.sound.playing()
            ? ((this.playWhenVisibleAgain = !0), this.sound.pause())
            : (this.playWhenVisibleAgain = !1);
        });
    }
    buildAudio() {
      (this.sound = new tu.Howl({
        src: `${E.publicUrl}audio/ambient-audio.mp3`,
        volume: 0.7,
      })),
        (this.crunch = new tu.Howl({
          src: `${E.publicUrl}audio/crunch-full-length.mp3`,
        }));
    }
    stop() {
      this.sound.stop(), this.crunch.stop();
    }
  }),
  q(_f, "selector", ".js-audio"),
  _f);
class pm extends jt {
  constructor(t) {
    super(t);
    q(this, "isAudioContextReady", !1);
    q(this, "isMusicPlaying", !1);
    q(this, "previousScroll", 0);
    q(this, "buildIntro", () => {
      (this.introTl = K.timeline({ paused: !0 })),
        this.introTl
          .titleIn(this.dom.title, null)
          .fromTo(
            this.dom.canvas,
            { opacity: 0, scale: 0.9 },
            {
              opacity: 0.15,
              scale: 1,
              duration: 1,
              ease: "power2.out",
              onComplete: () => {
                this.buildStCanvas();
              },
            },
            0.2
          )
          .from(this.dom.headphone, { opacity: 0 }, 0.2),
        tu.Howler.ctx.state !== "running" &&
          this.introTl.to(this.dom.audioText, { opacity: 1 }, 0.2);
    });
    q(this, "playAudio", (t) => {
      this.isMusicPlaying
        ? (this.audio.sound.pause(),
          K.to(this.dom.soundSpeaker, { fill: "#5B5A55" }),
          K.to(this.dom.soundWave, { opacity: 0 }),
          K.to(this.dom.soundCross, { opacity: 1 }))
        : (this.audio.sound.play(),
          K.to(this.dom.soundSpeaker, { fill: "#E3E2E0" }),
          K.to(this.dom.soundWave, { opacity: 1 }),
          K.to(this.dom.soundCross, { opacity: 0 })),
        (this.isMusicPlaying = !this.isMusicPlaying);
    });
    q(this, "onResize", () => {
      this.maxScrollSpeed =
        this.el.offsetHeight / (this.audio.crunchDuration || 10);
    });
    q(this, "onBodyClick", () => {
      this.skipBodyClick ||
        ((this.isAudioContextReady = !0),
        (this.maxScrollSpeed =
          this.el.offsetHeight / this.audio.crunchDuration),
        K.to(this.dom.audioText, { opacity: 0 }),
        this.playAudio(),
        this.off("click", document.body, this.onBodyClick));
    });
    this.populateDom(),
      (this.header = at(".js-header")),
      (this.footer = at(".js-footer")),
      (this.scrollPrompt = at(".js-scroll-prompt")),
      K.set(this.dom.readTimeContainer, { autoAlpha: 0 }),
      (this.maxScrollSpeed = this.el.offsetHeight / 10),
      (this.audio = E.staticComponents.get(Ew).first()),
      this.addEvents(),
      tu.Howler.ctx.state === "running" && this.onBodyClick(),
      this.dom.blockArray.shift(),
      this.buildStScrollPrompt(),
      this.buildParallax(),
      this.buildReadTime(),
      this.buildStHero(),
      this.buildScrollText(),
      this.buildStScroll(),
      this.buildIntro(),
      this.on("Loader:completed", () => this.introTl.play());
  }
  buildStScrollPrompt() {
    const t = ut.create({
      trigger: this.dom.container,
      start: "top bottom",
      onEnter: () => {
        K.to(this.scrollPrompt, { autoAlpha: 0, overwrite: !0 }),
          K.to(this.dom.readTimeContainer, {
            autoAlpha: 1,
            delay: 0.2,
            overwrite: !0,
          });
      },
      onLeaveBack: () => {
        K.to(this.scrollPrompt, { autoAlpha: 1, delay: 0.2, overwrite: !0 }),
          K.to(this.dom.readTimeContainer, { autoAlpha: 0, overwrite: !0 });
      },
    });
    this.stCollection.push(t);
  }
  buildReadTime() {
    (this.readProgressCircumference = this.dom.readProgress.getTotalLength()),
      K.set(this.dom.readProgress, {
        strokeDasharray: `${this.readProgressCircumference} ${this.readProgressCircumference}`,
        strokeDashoffset: this.readProgressCircumference,
      });
    const t = ut.create({
      trigger: this.dom.container,
      start: "top top+=25%",
      end: "bottom bottom-=20%",
      onUpdate: ({ progress: i }) => {
        this.setProgress(i * 100);
      },
    });
    this.stCollection.push(t);
  }
  buildStHero() {
    const t = K.to(this.dom.audioNotice, {
      scrollTrigger: {
        trigger: this.dom.hero,
        start: "top top",
        end: "top+=20% top",
        scrub: !0,
      },
      opacity: 0,
    });
    this.stCollection.push(t);
  }
  buildParallax() {
    E.mq.sm.matches &&
      this.dom.blockArray.forEach((t) => {
        const i = at(".js-block-inner", t),
          n = K.to(i, {
            scrollTrigger: {
              trigger: t,
              start: "top bottom",
              end: "bottom top",
              scrub: !0,
              invalidateOnRefresh: !0,
            },
            y: () => {
              const s = E.mq.md.matches,
                a = 0.1;
              return (
                (s ? (Math.random() - 0.5) * 2 : Math.random()) * E.window.h * a
              );
            },
            ease: "linear",
          });
        this.stCollection.push(n);
      });
  }
  buildScrollText() {
    const t = [];
    this.dom.textArray.forEach((s) => {
      const a = new xr(s, { type: "words" });
      t.push(...a.words);
      const o = K.fromTo(
        a.words,
        { willChange: "opacity", opacity: 0.1 },
        {
          ease: "none",
          opacity: 1,
          stagger: 0.05,
          scrollTrigger: {
            trigger: s,
            start: "top 90%",
            end: "bottom 90%",
            scrub: !0,
          },
        }
      );
      this.stCollection.push(o);
    });
    const i = 225,
      n = Math.ceil(t.length / i);
    this.dom.readTime.innerText = `${n} mins`;
  }
  buildStCanvas() {
    const t = K.fromTo(
        this.dom.canvas,
        { opacity: 0.6 },
        {
          opacity: 0.3,
          scrollTrigger: {
            trigger: this.dom.ctaSection,
            start: "top bottom",
            end: "bottom bottom",
            scrub: !0,
          },
        }
      ),
      i = K.fromTo(
        this.dom.canvas,
        { opacity: 0.4 },
        {
          opacity: 0.6,
          scrollTrigger: {
            trigger: this.dom.secondSection,
            start: "top top",
            endTrigger: this.dom.blocksContainer,
            end: "top top",
            scrub: !0,
          },
        }
      ),
      n = K.fromTo(
        this.dom.canvas,
        { opacity: 0.15 },
        {
          opacity: 0.4,
          scrollTrigger: {
            trigger: this.dom.hero,
            start: "top top",
            endTrigger: this.dom.secondSection,
            end: "top top",
            scrub: !0,
          },
        }
      );
    this.stCollection.push(t, i, n);
  }
  setProgress(t) {
    this.dom.readProgress.style.strokeDashoffset =
      this.readProgressCircumference -
      (t / 100) * this.readProgressCircumference;
  }
  buildStScroll() {
    (this.st = ut.create({
      trigger: this.el,
      onUpdate: (t) => {
        const i = Math.abs(t.getVelocity());
        if (
          (i > this.maxScrollSpeed
            ? ((E.SmoothScroll.Lenis.virtualScroll.wheelMultiplier =
                ((this.maxScrollSpeed * E.initialWheelMultiplier) / i) * 0.6),
              (E.SmoothScroll.Lenis.virtualScroll.touchMultiplier =
                ((this.maxScrollSpeed * E.initialTouchMultiplier) / i) * 0.6))
            : ((E.SmoothScroll.Lenis.virtualScroll.wheelMultiplier =
                E.initialWheelMultiplier),
              (E.SmoothScroll.Lenis.virtualScroll.touchMultiplier =
                E.initialTouchMultiplier)),
          !this.isMusicPlaying)
        )
          return;
        window.clearTimeout(this.timeout);
        const n = Math.abs(t.progress - this.previousScroll);
        this.audio.crunch.playing() || this.audio.crunch.play(),
          this.audio.crunch.seek(this.audio.crunch.duration() * t.progress),
          this.audio.crunch.volume(Math.min(0.2, n * 75)),
          (this.previousScroll = t.progress),
          (this.timeout = window.setTimeout(
            () => this.audio.crunch.pause(),
            200
          ));
      },
      start: "top top",
      end: "bottom bottom",
      invalidateOnRefresh: !0,
    })),
      this.stCollection.push(this.st);
  }
  addEvents() {
    this.on("click", this.header, (t) => {
      this.skipBodyClick = !0;
    }),
      this.on("click", this.footer, (t) => {
        this.skipBodyClick = !0;
      }),
      this.on("click", document.body, this.onBodyClick),
      this.on("click", this.dom.audioBtn, () => {
        this.isAudioContextReady && this.playAudio();
      }),
      this.on(Ze.RESIZE, this.onResize);
  }
  destroy() {
    super.destroy(), this.audio.stop();
  }
}
q(pm, "selector", ".js-manifesto");
class fm extends jt {
  constructor(t) {
    super(t);
    q(this, "onResize", () => {
      (this.el.width = this.el.offsetWidth),
        (this.el.height = this.el.offsetHeight),
        this.setCanvasParams(),
        this.drawImage();
    });
    q(this, "onTick", () => {
      this.currentId !== this.prevId &&
        (this.drawImage(), (this.prevId = this.currentId));
    });
    (this.imgSeqImgElement = at(".js-img-seq-img")),
      (this.imagesCount = 300),
      (this.frames = []),
      (this.currentId = 0),
      (this.prevId = null),
      (this.scrollProgress = 0),
      (this.context = this.el.getContext("2d")),
      this.load();
  }
  addEvents() {
    this.on(Ze.RAF, this.onTick), this.on(Ze.RESIZE, this.onResize);
  }
  load() {
    for (let t = 0; t < this.imagesCount; t++) {
      const i = new Image();
      this.frames.push(i),
        (i.src = `${E.publicUrl}images/sequence/manifesto${t
          .toString()
          .padStart(3, "0")}.jpg`),
        E.AssetLoader.add(
          E.AssetLoader.retry(
            () =>
              new Promise((n, s) => {
                i.addEventListener("load", () => {
                  n(i);
                }),
                  i.addEventListener(
                    "error",
                    (a) => {
                      (i.src = null),
                        (i.src = `${E.publicUrl}images/sequence/manifesto${t
                          .toString()
                          .padStart(3, "0")}.jpg`),
                        s(new Error("Image not loaded", { cause: a }));
                    },
                    { once: !0 }
                  );
              })
          )
        );
    }
  }
  build() {
    this.onResize(),
      (this.st = ut.create({
        trigger: at(".js-manifesto"),
        onUpdate: (t) => {
          (this.scrollProgress = t.progress), this.updateImage(t.progress);
        },
        start: "top top",
        end: "bottom bottom",
      })),
      this.addEvents();
  }
  updateImage(t) {
    this.currentId = Math.floor(t * (this.imagesCount - 1));
  }
  fit(t) {
    return (i, n, s, a, o = 1, u = 0.5, h = 0.5) => {
      const f = s / a,
        c = i / n;
      let d = i * o,
        m = n * o;
      return (
        (t ? f > c : f < c) ? (m = d / f) : (d = m * f),
        { width: d, height: m, offsetX: (i - d) * u, offsetY: (n - m) * h }
      );
    };
  }
  setCanvasParams() {
    E.mq.md.matches
      ? ((this.scale = 1),
        (this.offsetX = 0.5),
        (this.offsetY = 0.5),
        (this.gradientStartY = 0.9))
      : E.mq.sm.matches
      ? ((this.scale = 0.6),
        (this.offsetX = 0.5),
        (this.offsetY = 0.5),
        (this.gradientStartY = 0.7))
      : ((this.scale = 0.5),
        (this.offsetX = 0.5),
        (this.offsetY = 0.5),
        (this.gradientStartY = 0.65));
  }
  drawImage() {
    this.context.clearRect(0, 0, this.el.width, this.el.height);
    const t = this.fit(!1),
      {
        offsetX: i,
        offsetY: n,
        width: s,
        height: a,
      } = t(
        E.window.w,
        E.window.h,
        this.imgSeqImgElement.width,
        this.imgSeqImgElement.height,
        this.scale,
        this.offsetX,
        this.offsetY
      );
    this.context.drawImage(this.frames[this.currentId], i, n, s, a);
    const o = this.context.createLinearGradient(
      0,
      E.window.h * this.gradientStartY,
      0,
      E.window.h * (this.gradientStartY + 0.1)
    );
    o.addColorStop(0, "rgba(0,0,0,0)"),
      o.addColorStop(1, "#000"),
      (this.context.fillStyle = o),
      this.context.fillRect(i, n, s, a);
  }
  destroy() {
    super.destroy(), this.st.kill();
  }
}
q(fm, "selector", ".js-img-seq-canvas");
var Mn = "top",
  ls = "bottom",
  cs = "right",
  Tn = "left",
  hg = "auto",
  gu = [Mn, ls, cs, Tn],
  wl = "start",
  iu = "end",
  NL = "clippingParents",
  Cw = "viewport",
  mc = "popper",
  BL = "reference",
  U_ = gu.reduce(function (r, e) {
    return r.concat([e + "-" + wl, e + "-" + iu]);
  }, []),
  Dw = [].concat(gu, [hg]).reduce(function (r, e) {
    return r.concat([e, e + "-" + wl, e + "-" + iu]);
  }, []),
  VL = "beforeRead",
  zL = "read",
  UL = "afterRead",
  GL = "beforeMain",
  HL = "main",
  WL = "afterMain",
  jL = "beforeWrite",
  qL = "write",
  XL = "afterWrite",
  $L = [VL, zL, UL, GL, HL, WL, jL, qL, XL];
function zs(r) {
  return r ? (r.nodeName || "").toLowerCase() : null;
}
function Un(r) {
  if (r == null) return window;
  if (r.toString() !== "[object Window]") {
    var e = r.ownerDocument;
    return (e && e.defaultView) || window;
  }
  return r;
}
function sa(r) {
  var e = Un(r).Element;
  return r instanceof e || r instanceof Element;
}
function os(r) {
  var e = Un(r).HTMLElement;
  return r instanceof e || r instanceof HTMLElement;
}
function dg(r) {
  if (typeof ShadowRoot > "u") return !1;
  var e = Un(r).ShadowRoot;
  return r instanceof e || r instanceof ShadowRoot;
}
function YL(r) {
  var e = r.state;
  Object.keys(e.elements).forEach(function (t) {
    var i = e.styles[t] || {},
      n = e.attributes[t] || {},
      s = e.elements[t];
    !os(s) ||
      !zs(s) ||
      (Object.assign(s.style, i),
      Object.keys(n).forEach(function (a) {
        var o = n[a];
        o === !1 ? s.removeAttribute(a) : s.setAttribute(a, o === !0 ? "" : o);
      }));
  });
}
function KL(r) {
  var e = r.state,
    t = {
      popper: {
        position: e.options.strategy,
        left: "0",
        top: "0",
        margin: "0",
      },
      arrow: { position: "absolute" },
      reference: {},
    };
  return (
    Object.assign(e.elements.popper.style, t.popper),
    (e.styles = t),
    e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow),
    function () {
      Object.keys(e.elements).forEach(function (i) {
        var n = e.elements[i],
          s = e.attributes[i] || {},
          a = Object.keys(e.styles.hasOwnProperty(i) ? e.styles[i] : t[i]),
          o = a.reduce(function (u, h) {
            return (u[h] = ""), u;
          }, {});
        !os(n) ||
          !zs(n) ||
          (Object.assign(n.style, o),
          Object.keys(s).forEach(function (u) {
            n.removeAttribute(u);
          }));
      });
    }
  );
}
const ZL = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: YL,
  effect: KL,
  requires: ["computeStyles"],
};
function Ns(r) {
  return r.split("-")[0];
}
var Yo = Math.max,
  ad = Math.min,
  yl = Math.round;
function mm() {
  var r = navigator.userAgentData;
  return r != null && r.brands && Array.isArray(r.brands)
    ? r.brands
        .map(function (e) {
          return e.brand + "/" + e.version;
        })
        .join(" ")
    : navigator.userAgent;
}
function Pw() {
  return !/^((?!chrome|android).)*safari/i.test(mm());
}
function Sl(r, e, t) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  var i = r.getBoundingClientRect(),
    n = 1,
    s = 1;
  e &&
    os(r) &&
    ((n = (r.offsetWidth > 0 && yl(i.width) / r.offsetWidth) || 1),
    (s = (r.offsetHeight > 0 && yl(i.height) / r.offsetHeight) || 1));
  var a = sa(r) ? Un(r) : window,
    o = a.visualViewport,
    u = !Pw() && t,
    h = (i.left + (u && o ? o.offsetLeft : 0)) / n,
    f = (i.top + (u && o ? o.offsetTop : 0)) / s,
    c = i.width / n,
    d = i.height / s;
  return {
    width: c,
    height: d,
    top: f,
    right: h + c,
    bottom: f + d,
    left: h,
    x: h,
    y: f,
  };
}
function pg(r) {
  var e = Sl(r),
    t = r.offsetWidth,
    i = r.offsetHeight;
  return (
    Math.abs(e.width - t) <= 1 && (t = e.width),
    Math.abs(e.height - i) <= 1 && (i = e.height),
    { x: r.offsetLeft, y: r.offsetTop, width: t, height: i }
  );
}
function Aw(r, e) {
  var t = e.getRootNode && e.getRootNode();
  if (r.contains(e)) return !0;
  if (t && dg(t)) {
    var i = e;
    do {
      if (i && r.isSameNode(i)) return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function wr(r) {
  return Un(r).getComputedStyle(r);
}
function JL(r) {
  return ["table", "td", "th"].indexOf(zs(r)) >= 0;
}
function io(r) {
  return ((sa(r) ? r.ownerDocument : r.document) || window.document)
    .documentElement;
}
function wd(r) {
  return zs(r) === "html"
    ? r
    : r.assignedSlot || r.parentNode || (dg(r) ? r.host : null) || io(r);
}
function G_(r) {
  return !os(r) || wr(r).position === "fixed" ? null : r.offsetParent;
}
function QL(r) {
  var e = /firefox/i.test(mm()),
    t = /Trident/i.test(mm());
  if (t && os(r)) {
    var i = wr(r);
    if (i.position === "fixed") return null;
  }
  var n = wd(r);
  for (dg(n) && (n = n.host); os(n) && ["html", "body"].indexOf(zs(n)) < 0; ) {
    var s = wr(n);
    if (
      s.transform !== "none" ||
      s.perspective !== "none" ||
      s.contain === "paint" ||
      ["transform", "perspective"].indexOf(s.willChange) !== -1 ||
      (e && s.willChange === "filter") ||
      (e && s.filter && s.filter !== "none")
    )
      return n;
    n = n.parentNode;
  }
  return null;
}
function vu(r) {
  for (var e = Un(r), t = G_(r); t && JL(t) && wr(t).position === "static"; )
    t = G_(t);
  return t &&
    (zs(t) === "html" || (zs(t) === "body" && wr(t).position === "static"))
    ? e
    : t || QL(r) || e;
}
function fg(r) {
  return ["top", "bottom"].indexOf(r) >= 0 ? "x" : "y";
}
function Nc(r, e, t) {
  return Yo(r, ad(e, t));
}
function eR(r, e, t) {
  var i = Nc(r, e, t);
  return i > t ? t : i;
}
function Lw() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function Rw(r) {
  return Object.assign({}, Lw(), r);
}
function kw(r, e) {
  return e.reduce(function (t, i) {
    return (t[i] = r), t;
  }, {});
}
var tR = function (e, t) {
  return (
    (e =
      typeof e == "function"
        ? e(Object.assign({}, t.rects, { placement: t.placement }))
        : e),
    Rw(typeof e != "number" ? e : kw(e, gu))
  );
};
function iR(r) {
  var e,
    t = r.state,
    i = r.name,
    n = r.options,
    s = t.elements.arrow,
    a = t.modifiersData.popperOffsets,
    o = Ns(t.placement),
    u = fg(o),
    h = [Tn, cs].indexOf(o) >= 0,
    f = h ? "height" : "width";
  if (!(!s || !a)) {
    var c = tR(n.padding, t),
      d = pg(s),
      m = u === "y" ? Mn : Tn,
      x = u === "y" ? ls : cs,
      v =
        t.rects.reference[f] + t.rects.reference[u] - a[u] - t.rects.popper[f],
      b = a[u] - t.rects.reference[u],
      y = vu(s),
      M = y ? (u === "y" ? y.clientHeight || 0 : y.clientWidth || 0) : 0,
      D = v / 2 - b / 2,
      C = c[m],
      A = M - d[f] - c[x],
      I = M / 2 - d[f] / 2 + D,
      F = Nc(C, I, A),
      P = u;
    t.modifiersData[i] = ((e = {}), (e[P] = F), (e.centerOffset = F - I), e);
  }
}
function nR(r) {
  var e = r.state,
    t = r.options,
    i = t.element,
    n = i === void 0 ? "[data-popper-arrow]" : i;
  n != null &&
    ((typeof n == "string" && ((n = e.elements.popper.querySelector(n)), !n)) ||
      (Aw(e.elements.popper, n) && (e.elements.arrow = n)));
}
const sR = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: iR,
  effect: nR,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"],
};
function Ml(r) {
  return r.split("-")[1];
}
var rR = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function oR(r, e) {
  var t = r.x,
    i = r.y,
    n = e.devicePixelRatio || 1;
  return { x: yl(t * n) / n || 0, y: yl(i * n) / n || 0 };
}
function H_(r) {
  var e,
    t = r.popper,
    i = r.popperRect,
    n = r.placement,
    s = r.variation,
    a = r.offsets,
    o = r.position,
    u = r.gpuAcceleration,
    h = r.adaptive,
    f = r.roundOffsets,
    c = r.isFixed,
    d = a.x,
    m = d === void 0 ? 0 : d,
    x = a.y,
    v = x === void 0 ? 0 : x,
    b = typeof f == "function" ? f({ x: m, y: v }) : { x: m, y: v };
  (m = b.x), (v = b.y);
  var y = a.hasOwnProperty("x"),
    M = a.hasOwnProperty("y"),
    D = Tn,
    C = Mn,
    A = window;
  if (h) {
    var I = vu(t),
      F = "clientHeight",
      P = "clientWidth";
    if (
      (I === Un(t) &&
        ((I = io(t)),
        wr(I).position !== "static" &&
          o === "absolute" &&
          ((F = "scrollHeight"), (P = "scrollWidth"))),
      (I = I),
      n === Mn || ((n === Tn || n === cs) && s === iu))
    ) {
      C = ls;
      var k = c && I === A && A.visualViewport ? A.visualViewport.height : I[F];
      (v -= k - i.height), (v *= u ? 1 : -1);
    }
    if (n === Tn || ((n === Mn || n === ls) && s === iu)) {
      D = cs;
      var O = c && I === A && A.visualViewport ? A.visualViewport.width : I[P];
      (m -= O - i.width), (m *= u ? 1 : -1);
    }
  }
  var J = Object.assign({ position: o }, h && rR),
    ee = f === !0 ? oR({ x: m, y: v }, Un(t)) : { x: m, y: v };
  if (((m = ee.x), (v = ee.y), u)) {
    var X;
    return Object.assign(
      {},
      J,
      ((X = {}),
      (X[C] = M ? "0" : ""),
      (X[D] = y ? "0" : ""),
      (X.transform =
        (A.devicePixelRatio || 1) <= 1
          ? "translate(" + m + "px, " + v + "px)"
          : "translate3d(" + m + "px, " + v + "px, 0)"),
      X)
    );
  }
  return Object.assign(
    {},
    J,
    ((e = {}),
    (e[C] = M ? v + "px" : ""),
    (e[D] = y ? m + "px" : ""),
    (e.transform = ""),
    e)
  );
}
function aR(r) {
  var e = r.state,
    t = r.options,
    i = t.gpuAcceleration,
    n = i === void 0 ? !0 : i,
    s = t.adaptive,
    a = s === void 0 ? !0 : s,
    o = t.roundOffsets,
    u = o === void 0 ? !0 : o,
    h = {
      placement: Ns(e.placement),
      variation: Ml(e.placement),
      popper: e.elements.popper,
      popperRect: e.rects.popper,
      gpuAcceleration: n,
      isFixed: e.options.strategy === "fixed",
    };
  e.modifiersData.popperOffsets != null &&
    (e.styles.popper = Object.assign(
      {},
      e.styles.popper,
      H_(
        Object.assign({}, h, {
          offsets: e.modifiersData.popperOffsets,
          position: e.options.strategy,
          adaptive: a,
          roundOffsets: u,
        })
      )
    )),
    e.modifiersData.arrow != null &&
      (e.styles.arrow = Object.assign(
        {},
        e.styles.arrow,
        H_(
          Object.assign({}, h, {
            offsets: e.modifiersData.arrow,
            position: "absolute",
            adaptive: !1,
            roundOffsets: u,
          })
        )
      )),
    (e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-placement": e.placement,
    }));
}
const lR = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: aR,
  data: {},
};
var Ph = { passive: !0 };
function cR(r) {
  var e = r.state,
    t = r.instance,
    i = r.options,
    n = i.scroll,
    s = n === void 0 ? !0 : n,
    a = i.resize,
    o = a === void 0 ? !0 : a,
    u = Un(e.elements.popper),
    h = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return (
    s &&
      h.forEach(function (f) {
        f.addEventListener("scroll", t.update, Ph);
      }),
    o && u.addEventListener("resize", t.update, Ph),
    function () {
      s &&
        h.forEach(function (f) {
          f.removeEventListener("scroll", t.update, Ph);
        }),
        o && u.removeEventListener("resize", t.update, Ph);
    }
  );
}
const uR = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function () {},
  effect: cR,
  data: {},
};
var hR = { left: "right", right: "left", bottom: "top", top: "bottom" };
function Hh(r) {
  return r.replace(/left|right|bottom|top/g, function (e) {
    return hR[e];
  });
}
var dR = { start: "end", end: "start" };
function W_(r) {
  return r.replace(/start|end/g, function (e) {
    return dR[e];
  });
}
function mg(r) {
  var e = Un(r),
    t = e.pageXOffset,
    i = e.pageYOffset;
  return { scrollLeft: t, scrollTop: i };
}
function gg(r) {
  return Sl(io(r)).left + mg(r).scrollLeft;
}
function pR(r, e) {
  var t = Un(r),
    i = io(r),
    n = t.visualViewport,
    s = i.clientWidth,
    a = i.clientHeight,
    o = 0,
    u = 0;
  if (n) {
    (s = n.width), (a = n.height);
    var h = Pw();
    (h || (!h && e === "fixed")) && ((o = n.offsetLeft), (u = n.offsetTop));
  }
  return { width: s, height: a, x: o + gg(r), y: u };
}
function fR(r) {
  var e,
    t = io(r),
    i = mg(r),
    n = (e = r.ownerDocument) == null ? void 0 : e.body,
    s = Yo(
      t.scrollWidth,
      t.clientWidth,
      n ? n.scrollWidth : 0,
      n ? n.clientWidth : 0
    ),
    a = Yo(
      t.scrollHeight,
      t.clientHeight,
      n ? n.scrollHeight : 0,
      n ? n.clientHeight : 0
    ),
    o = -i.scrollLeft + gg(r),
    u = -i.scrollTop;
  return (
    wr(n || t).direction === "rtl" &&
      (o += Yo(t.clientWidth, n ? n.clientWidth : 0) - s),
    { width: s, height: a, x: o, y: u }
  );
}
function vg(r) {
  var e = wr(r),
    t = e.overflow,
    i = e.overflowX,
    n = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(t + n + i);
}
function Iw(r) {
  return ["html", "body", "#document"].indexOf(zs(r)) >= 0
    ? r.ownerDocument.body
    : os(r) && vg(r)
    ? r
    : Iw(wd(r));
}
function Bc(r, e) {
  var t;
  e === void 0 && (e = []);
  var i = Iw(r),
    n = i === ((t = r.ownerDocument) == null ? void 0 : t.body),
    s = Un(i),
    a = n ? [s].concat(s.visualViewport || [], vg(i) ? i : []) : i,
    o = e.concat(a);
  return n ? o : o.concat(Bc(wd(a)));
}
function gm(r) {
  return Object.assign({}, r, {
    left: r.x,
    top: r.y,
    right: r.x + r.width,
    bottom: r.y + r.height,
  });
}
function mR(r, e) {
  var t = Sl(r, !1, e === "fixed");
  return (
    (t.top = t.top + r.clientTop),
    (t.left = t.left + r.clientLeft),
    (t.bottom = t.top + r.clientHeight),
    (t.right = t.left + r.clientWidth),
    (t.width = r.clientWidth),
    (t.height = r.clientHeight),
    (t.x = t.left),
    (t.y = t.top),
    t
  );
}
function j_(r, e, t) {
  return e === Cw ? gm(pR(r, t)) : sa(e) ? mR(e, t) : gm(fR(io(r)));
}
function gR(r) {
  var e = Bc(wd(r)),
    t = ["absolute", "fixed"].indexOf(wr(r).position) >= 0,
    i = t && os(r) ? vu(r) : r;
  return sa(i)
    ? e.filter(function (n) {
        return sa(n) && Aw(n, i) && zs(n) !== "body";
      })
    : [];
}
function vR(r, e, t, i) {
  var n = e === "clippingParents" ? gR(r) : [].concat(e),
    s = [].concat(n, [t]),
    a = s[0],
    o = s.reduce(function (u, h) {
      var f = j_(r, h, i);
      return (
        (u.top = Yo(f.top, u.top)),
        (u.right = ad(f.right, u.right)),
        (u.bottom = ad(f.bottom, u.bottom)),
        (u.left = Yo(f.left, u.left)),
        u
      );
    }, j_(r, a, i));
  return (
    (o.width = o.right - o.left),
    (o.height = o.bottom - o.top),
    (o.x = o.left),
    (o.y = o.top),
    o
  );
}
function Fw(r) {
  var e = r.reference,
    t = r.element,
    i = r.placement,
    n = i ? Ns(i) : null,
    s = i ? Ml(i) : null,
    a = e.x + e.width / 2 - t.width / 2,
    o = e.y + e.height / 2 - t.height / 2,
    u;
  switch (n) {
    case Mn:
      u = { x: a, y: e.y - t.height };
      break;
    case ls:
      u = { x: a, y: e.y + e.height };
      break;
    case cs:
      u = { x: e.x + e.width, y: o };
      break;
    case Tn:
      u = { x: e.x - t.width, y: o };
      break;
    default:
      u = { x: e.x, y: e.y };
  }
  var h = n ? fg(n) : null;
  if (h != null) {
    var f = h === "y" ? "height" : "width";
    switch (s) {
      case wl:
        u[h] = u[h] - (e[f] / 2 - t[f] / 2);
        break;
      case iu:
        u[h] = u[h] + (e[f] / 2 - t[f] / 2);
        break;
    }
  }
  return u;
}
function nu(r, e) {
  e === void 0 && (e = {});
  var t = e,
    i = t.placement,
    n = i === void 0 ? r.placement : i,
    s = t.strategy,
    a = s === void 0 ? r.strategy : s,
    o = t.boundary,
    u = o === void 0 ? NL : o,
    h = t.rootBoundary,
    f = h === void 0 ? Cw : h,
    c = t.elementContext,
    d = c === void 0 ? mc : c,
    m = t.altBoundary,
    x = m === void 0 ? !1 : m,
    v = t.padding,
    b = v === void 0 ? 0 : v,
    y = Rw(typeof b != "number" ? b : kw(b, gu)),
    M = d === mc ? BL : mc,
    D = r.rects.popper,
    C = r.elements[x ? M : d],
    A = vR(sa(C) ? C : C.contextElement || io(r.elements.popper), u, f, a),
    I = Sl(r.elements.reference),
    F = Fw({ reference: I, element: D, strategy: "absolute", placement: n }),
    P = gm(Object.assign({}, D, F)),
    k = d === mc ? P : I,
    O = {
      top: A.top - k.top + y.top,
      bottom: k.bottom - A.bottom + y.bottom,
      left: A.left - k.left + y.left,
      right: k.right - A.right + y.right,
    },
    J = r.modifiersData.offset;
  if (d === mc && J) {
    var ee = J[n];
    Object.keys(O).forEach(function (X) {
      var j = [cs, ls].indexOf(X) >= 0 ? 1 : -1,
        Y = [Mn, ls].indexOf(X) >= 0 ? "y" : "x";
      O[X] += ee[Y] * j;
    });
  }
  return O;
}
function _R(r, e) {
  e === void 0 && (e = {});
  var t = e,
    i = t.placement,
    n = t.boundary,
    s = t.rootBoundary,
    a = t.padding,
    o = t.flipVariations,
    u = t.allowedAutoPlacements,
    h = u === void 0 ? Dw : u,
    f = Ml(i),
    c = f
      ? o
        ? U_
        : U_.filter(function (x) {
            return Ml(x) === f;
          })
      : gu,
    d = c.filter(function (x) {
      return h.indexOf(x) >= 0;
    });
  d.length === 0 && (d = c);
  var m = d.reduce(function (x, v) {
    return (
      (x[v] = nu(r, { placement: v, boundary: n, rootBoundary: s, padding: a })[
        Ns(v)
      ]),
      x
    );
  }, {});
  return Object.keys(m).sort(function (x, v) {
    return m[x] - m[v];
  });
}
function bR(r) {
  if (Ns(r) === hg) return [];
  var e = Hh(r);
  return [W_(r), e, W_(e)];
}
function xR(r) {
  var e = r.state,
    t = r.options,
    i = r.name;
  if (!e.modifiersData[i]._skip) {
    for (
      var n = t.mainAxis,
        s = n === void 0 ? !0 : n,
        a = t.altAxis,
        o = a === void 0 ? !0 : a,
        u = t.fallbackPlacements,
        h = t.padding,
        f = t.boundary,
        c = t.rootBoundary,
        d = t.altBoundary,
        m = t.flipVariations,
        x = m === void 0 ? !0 : m,
        v = t.allowedAutoPlacements,
        b = e.options.placement,
        y = Ns(b),
        M = y === b,
        D = u || (M || !x ? [Hh(b)] : bR(b)),
        C = [b].concat(D).reduce(function (le, be) {
          return le.concat(
            Ns(be) === hg
              ? _R(e, {
                  placement: be,
                  boundary: f,
                  rootBoundary: c,
                  padding: h,
                  flipVariations: x,
                  allowedAutoPlacements: v,
                })
              : be
          );
        }, []),
        A = e.rects.reference,
        I = e.rects.popper,
        F = new Map(),
        P = !0,
        k = C[0],
        O = 0;
      O < C.length;
      O++
    ) {
      var J = C[O],
        ee = Ns(J),
        X = Ml(J) === wl,
        j = [Mn, ls].indexOf(ee) >= 0,
        Y = j ? "width" : "height",
        ie = nu(e, {
          placement: J,
          boundary: f,
          rootBoundary: c,
          altBoundary: d,
          padding: h,
        }),
        Q = j ? (X ? cs : Tn) : X ? ls : Mn;
      A[Y] > I[Y] && (Q = Hh(Q));
      var V = Hh(Q),
        ve = [];
      if (
        (s && ve.push(ie[ee] <= 0),
        o && ve.push(ie[Q] <= 0, ie[V] <= 0),
        ve.every(function (le) {
          return le;
        }))
      ) {
        (k = J), (P = !1);
        break;
      }
      F.set(J, ve);
    }
    if (P)
      for (
        var U = x ? 3 : 1,
          oe = function (be) {
            var ce = C.find(function (He) {
              var Se = F.get(He);
              if (Se)
                return Se.slice(0, be).every(function (Oe) {
                  return Oe;
                });
            });
            if (ce) return (k = ce), "break";
          },
          ue = U;
        ue > 0;
        ue--
      ) {
        var fe = oe(ue);
        if (fe === "break") break;
      }
    e.placement !== k &&
      ((e.modifiersData[i]._skip = !0), (e.placement = k), (e.reset = !0));
  }
}
const wR = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: xR,
  requiresIfExists: ["offset"],
  data: { _skip: !1 },
};
function q_(r, e, t) {
  return (
    t === void 0 && (t = { x: 0, y: 0 }),
    {
      top: r.top - e.height - t.y,
      right: r.right - e.width + t.x,
      bottom: r.bottom - e.height + t.y,
      left: r.left - e.width - t.x,
    }
  );
}
function X_(r) {
  return [Mn, cs, ls, Tn].some(function (e) {
    return r[e] >= 0;
  });
}
function yR(r) {
  var e = r.state,
    t = r.name,
    i = e.rects.reference,
    n = e.rects.popper,
    s = e.modifiersData.preventOverflow,
    a = nu(e, { elementContext: "reference" }),
    o = nu(e, { altBoundary: !0 }),
    u = q_(a, i),
    h = q_(o, n, s),
    f = X_(u),
    c = X_(h);
  (e.modifiersData[t] = {
    referenceClippingOffsets: u,
    popperEscapeOffsets: h,
    isReferenceHidden: f,
    hasPopperEscaped: c,
  }),
    (e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-reference-hidden": f,
      "data-popper-escaped": c,
    }));
}
const SR = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: yR,
};
function MR(r, e, t) {
  var i = Ns(r),
    n = [Tn, Mn].indexOf(i) >= 0 ? -1 : 1,
    s = typeof t == "function" ? t(Object.assign({}, e, { placement: r })) : t,
    a = s[0],
    o = s[1];
  return (
    (a = a || 0),
    (o = (o || 0) * n),
    [Tn, cs].indexOf(i) >= 0 ? { x: o, y: a } : { x: a, y: o }
  );
}
function TR(r) {
  var e = r.state,
    t = r.options,
    i = r.name,
    n = t.offset,
    s = n === void 0 ? [0, 0] : n,
    a = Dw.reduce(function (f, c) {
      return (f[c] = MR(c, e.rects, s)), f;
    }, {}),
    o = a[e.placement],
    u = o.x,
    h = o.y;
  e.modifiersData.popperOffsets != null &&
    ((e.modifiersData.popperOffsets.x += u),
    (e.modifiersData.popperOffsets.y += h)),
    (e.modifiersData[i] = a);
}
const ER = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: TR,
};
function CR(r) {
  var e = r.state,
    t = r.name;
  e.modifiersData[t] = Fw({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement,
  });
}
const DR = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: CR,
  data: {},
};
function PR(r) {
  return r === "x" ? "y" : "x";
}
function AR(r) {
  var e = r.state,
    t = r.options,
    i = r.name,
    n = t.mainAxis,
    s = n === void 0 ? !0 : n,
    a = t.altAxis,
    o = a === void 0 ? !1 : a,
    u = t.boundary,
    h = t.rootBoundary,
    f = t.altBoundary,
    c = t.padding,
    d = t.tether,
    m = d === void 0 ? !0 : d,
    x = t.tetherOffset,
    v = x === void 0 ? 0 : x,
    b = nu(e, { boundary: u, rootBoundary: h, padding: c, altBoundary: f }),
    y = Ns(e.placement),
    M = Ml(e.placement),
    D = !M,
    C = fg(y),
    A = PR(C),
    I = e.modifiersData.popperOffsets,
    F = e.rects.reference,
    P = e.rects.popper,
    k =
      typeof v == "function"
        ? v(Object.assign({}, e.rects, { placement: e.placement }))
        : v,
    O =
      typeof k == "number"
        ? { mainAxis: k, altAxis: k }
        : Object.assign({ mainAxis: 0, altAxis: 0 }, k),
    J = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
    ee = { x: 0, y: 0 };
  if (I) {
    if (s) {
      var X,
        j = C === "y" ? Mn : Tn,
        Y = C === "y" ? ls : cs,
        ie = C === "y" ? "height" : "width",
        Q = I[C],
        V = Q + b[j],
        ve = Q - b[Y],
        U = m ? -P[ie] / 2 : 0,
        oe = M === wl ? F[ie] : P[ie],
        ue = M === wl ? -P[ie] : -F[ie],
        fe = e.elements.arrow,
        le = m && fe ? pg(fe) : { width: 0, height: 0 },
        be = e.modifiersData["arrow#persistent"]
          ? e.modifiersData["arrow#persistent"].padding
          : Lw(),
        ce = be[j],
        He = be[Y],
        Se = Nc(0, F[ie], le[ie]),
        Oe = D
          ? F[ie] / 2 - U - Se - ce - O.mainAxis
          : oe - Se - ce - O.mainAxis,
        Me = D
          ? -F[ie] / 2 + U + Se + He + O.mainAxis
          : ue + Se + He + O.mainAxis,
        Ke = e.elements.arrow && vu(e.elements.arrow),
        Qe = Ke ? (C === "y" ? Ke.clientTop || 0 : Ke.clientLeft || 0) : 0,
        Pe = (X = J == null ? void 0 : J[C]) != null ? X : 0,
        ht = Q + Oe - Pe - Qe,
        wt = Q + Me - Pe,
        dt = Nc(m ? ad(V, ht) : V, Q, m ? Yo(ve, wt) : ve);
      (I[C] = dt), (ee[C] = dt - Q);
    }
    if (o) {
      var he,
        Et = C === "x" ? Mn : Tn,
        ft = C === "x" ? ls : cs,
        Bt = I[A],
        bt = A === "y" ? "height" : "width",
        G = Bt + b[Et],
        N = Bt - b[ft],
        pe = [Mn, Tn].indexOf(y) !== -1,
        xe = (he = J == null ? void 0 : J[A]) != null ? he : 0,
        we = pe ? G : Bt - F[bt] - P[bt] - xe + O.altAxis,
        Ce = pe ? Bt + F[bt] + P[bt] - xe - O.altAxis : N,
        We = m && pe ? eR(we, Bt, Ce) : Nc(m ? we : G, Bt, m ? Ce : N);
      (I[A] = We), (ee[A] = We - Bt);
    }
    e.modifiersData[i] = ee;
  }
}
const LR = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: AR,
  requiresIfExists: ["offset"],
};
function RR(r) {
  return { scrollLeft: r.scrollLeft, scrollTop: r.scrollTop };
}
function kR(r) {
  return r === Un(r) || !os(r) ? mg(r) : RR(r);
}
function IR(r) {
  var e = r.getBoundingClientRect(),
    t = yl(e.width) / r.offsetWidth || 1,
    i = yl(e.height) / r.offsetHeight || 1;
  return t !== 1 || i !== 1;
}
function FR(r, e, t) {
  t === void 0 && (t = !1);
  var i = os(e),
    n = os(e) && IR(e),
    s = io(e),
    a = Sl(r, n, t),
    o = { scrollLeft: 0, scrollTop: 0 },
    u = { x: 0, y: 0 };
  return (
    (i || (!i && !t)) &&
      ((zs(e) !== "body" || vg(s)) && (o = kR(e)),
      os(e)
        ? ((u = Sl(e, !0)), (u.x += e.clientLeft), (u.y += e.clientTop))
        : s && (u.x = gg(s))),
    {
      x: a.left + o.scrollLeft - u.x,
      y: a.top + o.scrollTop - u.y,
      width: a.width,
      height: a.height,
    }
  );
}
function OR(r) {
  var e = new Map(),
    t = new Set(),
    i = [];
  r.forEach(function (s) {
    e.set(s.name, s);
  });
  function n(s) {
    t.add(s.name);
    var a = [].concat(s.requires || [], s.requiresIfExists || []);
    a.forEach(function (o) {
      if (!t.has(o)) {
        var u = e.get(o);
        u && n(u);
      }
    }),
      i.push(s);
  }
  return (
    r.forEach(function (s) {
      t.has(s.name) || n(s);
    }),
    i
  );
}
function NR(r) {
  var e = OR(r);
  return $L.reduce(function (t, i) {
    return t.concat(
      e.filter(function (n) {
        return n.phase === i;
      })
    );
  }, []);
}
function BR(r) {
  var e;
  return function () {
    return (
      e ||
        (e = new Promise(function (t) {
          Promise.resolve().then(function () {
            (e = void 0), t(r());
          });
        })),
      e
    );
  };
}
function VR(r) {
  var e = r.reduce(function (t, i) {
    var n = t[i.name];
    return (
      (t[i.name] = n
        ? Object.assign({}, n, i, {
            options: Object.assign({}, n.options, i.options),
            data: Object.assign({}, n.data, i.data),
          })
        : i),
      t
    );
  }, {});
  return Object.keys(e).map(function (t) {
    return e[t];
  });
}
var $_ = { placement: "bottom", modifiers: [], strategy: "absolute" };
function Y_() {
  for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++)
    e[t] = arguments[t];
  return !e.some(function (i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function zR(r) {
  r === void 0 && (r = {});
  var e = r,
    t = e.defaultModifiers,
    i = t === void 0 ? [] : t,
    n = e.defaultOptions,
    s = n === void 0 ? $_ : n;
  return function (o, u, h) {
    h === void 0 && (h = s);
    var f = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, $_, s),
        modifiersData: {},
        elements: { reference: o, popper: u },
        attributes: {},
        styles: {},
      },
      c = [],
      d = !1,
      m = {
        state: f,
        setOptions: function (y) {
          var M = typeof y == "function" ? y(f.options) : y;
          v(),
            (f.options = Object.assign({}, s, f.options, M)),
            (f.scrollParents = {
              reference: sa(o)
                ? Bc(o)
                : o.contextElement
                ? Bc(o.contextElement)
                : [],
              popper: Bc(u),
            });
          var D = NR(VR([].concat(i, f.options.modifiers)));
          return (
            (f.orderedModifiers = D.filter(function (C) {
              return C.enabled;
            })),
            x(),
            m.update()
          );
        },
        forceUpdate: function () {
          if (!d) {
            var y = f.elements,
              M = y.reference,
              D = y.popper;
            if (Y_(M, D)) {
              (f.rects = {
                reference: FR(M, vu(D), f.options.strategy === "fixed"),
                popper: pg(D),
              }),
                (f.reset = !1),
                (f.placement = f.options.placement),
                f.orderedModifiers.forEach(function (O) {
                  return (f.modifiersData[O.name] = Object.assign({}, O.data));
                });
              for (var C = 0; C < f.orderedModifiers.length; C++) {
                if (f.reset === !0) {
                  (f.reset = !1), (C = -1);
                  continue;
                }
                var A = f.orderedModifiers[C],
                  I = A.fn,
                  F = A.options,
                  P = F === void 0 ? {} : F,
                  k = A.name;
                typeof I == "function" &&
                  (f = I({ state: f, options: P, name: k, instance: m }) || f);
              }
            }
          }
        },
        update: BR(function () {
          return new Promise(function (b) {
            m.forceUpdate(), b(f);
          });
        }),
        destroy: function () {
          v(), (d = !0);
        },
      };
    if (!Y_(o, u)) return m;
    m.setOptions(h).then(function (b) {
      !d && h.onFirstUpdate && h.onFirstUpdate(b);
    });
    function x() {
      f.orderedModifiers.forEach(function (b) {
        var y = b.name,
          M = b.options,
          D = M === void 0 ? {} : M,
          C = b.effect;
        if (typeof C == "function") {
          var A = C({ state: f, name: y, instance: m, options: D }),
            I = function () {};
          c.push(A || I);
        }
      });
    }
    function v() {
      c.forEach(function (b) {
        return b();
      }),
        (c = []);
    }
    return m;
  };
}
var UR = [uR, DR, lR, ZL, ER, wR, LR, sR, SR],
  GR = zR({ defaultModifiers: UR });
class Ow extends jt {
  constructor(t) {
    super(t);
    q(this, "onResize", () => {
      var t;
      (t = this.popper) == null || t.destroy(),
        this.off("mouseenter focus click", this.el, this.onShow),
        this.off("mouseout blur", this.el, this.onHide),
        this.off("click", [this.tooltips], this.onHide),
        this.overlay.classList.remove("is-active"),
        this.tooltips.classList.remove("is-active"),
        this.addEvents(),
        E.mq.touch.matches ||
          (this.popper = GR(this.el, this.tooltip, {
            placement: "right-start",
            modifiers: [
              {
                name: "offset",
                options: { offset: [-this.tooltip.offsetHeight, 0] },
              },
            ],
          }));
    });
    q(this, "onShow", () => {
      (this.isOpen = !0),
        this.overlay.classList.add("is-active"),
        E.mq.touch.matches
          ? (this.tooltips.classList.add("is-active"),
            K.set(this.tooltip, { display: "block" }),
            E.SmoothScroll.lock())
          : this.popper.update(),
        K.to(this.tooltip, { autoAlpha: 1, duration: 0.3 });
    });
    q(this, "onHide", (t) => {
      this.isOpen &&
        ((this.isOpen = !1),
        K.to(this.tooltip, { autoAlpha: 0, duration: 0.3 }),
        this.overlay.classList.remove("is-active"),
        this.tooltips.classList.remove("is-active"),
        E.mq.touch.matches && E.SmoothScroll.unlock());
    });
    (this.tooltip = at(`#${Ao(this.el, "aria-describedby")}`)),
      (this.tooltips = at(".js-tooltips")),
      (this.overlay = at(".js-overlay")),
      (this.isOpen = !1),
      this.on(Ze.RESIZE, this.onResize),
      this.onResize(),
      this.addEvents();
  }
  addEvents() {
    E.mq.touch.matches
      ? (this.on("focus click", this.el, this.onShow),
        this.on("click", [this.tooltips], this.onHide))
      : (this.on("mouseenter focus", this.el, this.onShow),
        this.on("mouseout blur", this.el, this.onHide));
  }
  destroy() {
    var t;
    super.destroy(), (t = this.popper) == null || t.destroy();
  }
}
q(Ow, "selector", ".js-superscript");
class HR extends pu {
  initialLoad() {
    super.initialLoad(), (this.initialLoadManifesto = !0);
  }
  onEnter() {
    var e;
    super.onEnter(),
      (e = E.SmoothScroll) == null || e.lock(),
      (this.modeToggle = at(".js-mode-toggle")),
      (this.modeToggle.style.display = "none"),
      (this.wasLightMode = !E.isDarkMode),
      E.isDarkMode || De.emit("ModeToggle:ToggleState"),
      E.AssetLoader.loaded.then(() => {
        E.components.get(fm).first().build();
      });
  }
  onEnterCompleted() {
    super.onEnterCompleted(),
      this.initialLoadManifesto
        ? (this.initialLoadManifesto = !1)
        : E.components.get(pm).first().introTl.play(),
      De.emit("ShyHeader:enable");
  }
  onLeave() {
    super.onLeave(),
      this.wasLightMode && De.emit("ModeToggle:ToggleState"),
      (E.SmoothScroll.Lenis.virtualScroll.wheelMultiplier =
        E.initialWheelMultiplier),
      (E.SmoothScroll.Lenis.virtualScroll.touchMultiplier =
        E.initialTouchMultiplier);
  }
  onLeaveCompleted() {
    super.onLeaveCompleted(),
      (this.modeToggle.style.display = "block"),
      De.emit("ShyHeader:disable");
  }
  registerAdditionalComponents() {
    super.registerAdditionalComponents(), E.components.add(pm, fm, Ow);
  }
}
class Nw extends jt {
  constructor(t) {
    super(t);
    q(this, "SPEED", 0.05);
    q(this, "MAX_OFFSET", 5);
    q(this, "SCALE_OFFSET", 0.5);
    q(this, "scrollY", 0);
    q(this, "target", 0);
    q(this, "scale", 1);
    q(this, "onResize", () => {
      var t, i;
      (t = this.dragObserver) == null || t.kill(),
        (i = this.wheelObserver) == null || i.kill(),
        (this.dragObserver = null),
        (this.wheelObserver = null),
        this.off(Ze.RAF, this.onRAF),
        E.mq.sm.matches &&
          (K.set(this.dom.carousel, { clearProps: "all" }),
          K.set(this.dom.imageArray, { clearProps: "all" }),
          window.requestAnimationFrame(() => {
            K.set(this.dom.carousel, { willChange: "transform" }),
              this.buildQuickSetters(),
              this.build(),
              this.on(Ze.RAF, this.onRAF);
          }));
    });
    q(this, "onRAF", () => {
      (this.target += this.SPEED * K.ticker.deltaRatio()),
        (this.scrollY = K.utils.interpolate(this.scrollY, this.target, 0.05)),
        this.setRotateCarousel(this.scrollY),
        this.setRotateImages(-this.scrollY),
        K.set(this.dom.imageElArray, {
          scale: (t) => {
            const i =
              1 - Math.abs(((Math.abs(this.scrollY) + t * 60) % 180) - 90) / 90;
            return Math.max(1, 1 + i * this.SCALE_OFFSET);
          },
        });
    });
    this.populateDom(),
      K.set(this.dom.carousel, { willChange: "transform" }),
      this.on(Ze.RESIZE, this.onResize),
      E.mq.sm.matches &&
        (this.buildQuickSetters(), this.build(), this.on(Ze.RAF, this.onRAF));
  }
  build() {
    (this.dragObserver = pi.create({
      target: this.dom.drag,
      onDrag: ({ deltaY: t }) => {
        const i = K.utils.clamp(-this.MAX_OFFSET, this.MAX_OFFSET, -t);
        (this.target += i),
          (this.scale = K.utils.clamp(1, this.MAX_OFFSET, -t));
      },
    })),
      (this.wheelObserver = pi.create({
        target: document.body,
        type: "wheel,touch,scroll,pointer",
        onWheel: ({ deltaY: t }) => {
          const i = K.utils.clamp(-this.MAX_OFFSET, this.MAX_OFFSET, t);
          (this.target += i),
            (this.scale = K.utils.clamp(1, this.MAX_OFFSET, t));
        },
      }));
  }
  buildQuickSetters() {
    (this.setRotateCarousel = K.quickSetter(
      this.dom.carousel,
      "rotate",
      "deg"
    )),
      (this.setRotateImages = K.quickSetter(
        this.dom.imageArray,
        "rotate",
        "deg"
      ));
  }
}
q(Nw, "selector", ".js-careers");
class WR extends pu {
  onEnter() {
    super.onEnter(),
      (this.scrollPrompt = at(".js-scroll-prompt")),
      (this.scrollPrompt.style.display = "none");
  }
  onEnterCompleted() {
    super.onEnterCompleted(), De.emit("ShyHeader:enable");
  }
  onLeave() {
    super.onLeave(), (this.scrollPrompt.style.display = "flex");
  }
  onLeaveCompleted() {
    super.onLeaveCompleted(), De.emit("ShyHeader:disable");
  }
  registerAdditionalComponents() {
    super.registerAdditionalComponents(), E.components.add(Nw);
  }
}
class jR extends pu {
  onEnterCompleted() {
    super.onEnterCompleted();
  }
}
class qR extends LA {
  constructor() {
    super({
      links:
        "a:not([target]):not([href^=\\#]):not([download]):not([data-router-disabled]):not(.sf-dump-toggle):not(.sf-dump-str-toggle):not(#wpadminbar a)",
      renderers: {
        default: pu,
        home: OL,
        manifesto: HR,
        careers: WR,
        notFound: jR,
      },
      transitions: { default: gL },
    }),
      this.setDefaultRenderer("default"),
      this.setDefaultTransition("default"),
      this.on("NAVIGATE_IN", this.onNavigateIn),
      this.on("NAVIGATE_END", this.onNavigateEnd);
  }
  onNavigateIn({ to: e }) {
    e && (document.body.className = e.page.body.className);
  }
  onNavigateEnd({ from: e, to: t }) {
    typeof window.gtag < "u" &&
      window.gtag("event", "page_view", {
        page_title: t.page.title,
        page_location: location.pathname,
        send_to: "G-SVHGSLGW1H",
      });
  }
}
class XR {
  constructor() {
    q(this, "beforeRender", (e) => {
      (this.clockDelta = this.clock.getDelta()),
        (this.globalUniforms.uDelta.value =
          this.clockDelta > 0.016 ? 0.016 : this.clockDelta),
        (this.globalUniforms.uTime.value = e),
        this.renderer.info.reset();
    });
    q(this, "render", (e) => {
      E.Gui && E.Gui.refresh(!1),
        (this.clockDelta = Math.round(this.clock.getDelta() * 1e3) / 1e3),
        (this.clockDelta = Bo.clamp(this.clockDelta, 0, 0.016)),
        (this.normalizeDelta = this.clockDelta / 0.016),
        (this.globalUniforms.uDelta.value = this.clockDelta),
        (this.globalUniforms.uTime.value = e);
    });
    q(this, "onResize", () => {
      this.renderer.setSize(E.window.w, E.window.h);
    });
    (this.canvas = { vortex: at(".webgl-vortex") }),
      (this.renderer = new Mm({
        alpha: !0,
        antialias: !0,
        canvas: this.canvas.vortex,
        powerPreference: "high-performance",
        stencil: !1,
      })),
      this.renderer.setPixelRatio(E.window.dpr >= 2 ? 2 : E.window.dpr),
      this.renderer.setSize(E.window.w, E.window.h),
      (this.renderer.info.autoReset = !1),
      this.renderer.setClearColor(0, 0),
      (this.clock = new TD()),
      (this.clockDelta = 0),
      (this.normalizeDelta = 0),
      (this.globalUniforms = {
        uDelta: { value: 0 },
        uTime: { value: 0 },
        uResolution: {
          value: new Ue(
            E.window.w * this.renderer.getPixelRatio(),
            E.window.h * this.renderer.getPixelRatio()
          ),
        },
      }),
      (this.scenes = { vortex: null }),
      dL();
  }
  start() {
    this.addEvents();
  }
  stop() {
    this.removeEvents();
  }
  addEvents() {
    De.on(Ze.RESIZE, this.onResize), E.RAFCollection.add(this.render, 100);
  }
  removeEvents() {
    De.off(Ze.RESIZE, this.onResize), E.RAFCollection.remove(this.render);
  }
  generateTexture(e, t = {}) {
    return (
      e instanceof HTMLImageElement && (e = new xi(e)),
      (e.minFilter = t.minFilter || mr),
      (e.magFilter = t.magFilter || Ui),
      (e.wrapS = e.wrapT = t.wrapping || bn),
      (e.flipY = t.flipY !== void 0 ? t.flipY : !0),
      (e.encoding = t.encoding || gr),
      this.renderer.initTexture(e),
      e
    );
  }
}
class Bw extends jt {
  constructor(t) {
    super(t);
    q(this, "onAssetsProgress", ({ percent: t }) => {
      this.dom.indicator.textContent = t + "%";
    });
    this.populateDom(),
      this.on("AssetsProgress", this.onAssetsProgress),
      document.body.classList.add("loader-active"),
      this.onAssetsLoaded();
  }
  onAssetsLoaded() {
    (this.isHome = E.body.classList.contains("home")),
      E.AssetLoader.loaded.then(() => {
        (this.dom.indicator.textContent = "100%"),
          (this.dynamicText = E.components.get(na).get(0));
        const t = K.timeline()
          .to(
            this.dom.gradient,
            { scale: 3, ease: "expo.in", duration: 0.8 },
            0.2
          )
          .to(this.dom.text, { opacity: 0, ease: "expo.in", duration: 0.8 }, 0)
          .to(
            this.dom.gradient,
            { opacity: 1, ease: "linear", duration: 0.45 },
            0.2
          );
        return (
          this.isHome &&
            t
              .from(
                ".js-home-landing-byline",
                { yPercent: 100, opacity: 0, duration: 0.6 },
                0.8
              )
              .call(
                () => {
                  this.dynamicText.tl.play();
                },
                null,
                1.4
              ),
          t.to(this.el, { autoAlpha: 0 }, 0.7),
          t.call(
            () => {
              this.isHome && E.WebGL.scenes.vortex.startVortex(),
                document.body.classList.remove("loader-active"),
                this.emit("Loader:completed");
            },
            null,
            1
          ),
          t
        );
      });
  }
  destroy() {
    super.destroy();
  }
}
q(Bw, "selector", ".js-site-loader");
class Vw extends gw {
  constructor(t) {
    super(t);
    q(this, "onResize", () => {
      var t;
      if (E.mq.sm.matches && this.openProp)
        this.reset(),
          (this.openProp = "false"),
          Ao(this.el, "aria-expanded", "false");
      else {
        const i = ((t = this.tl) == null ? void 0 : t.progress()) || 0;
        this.reset(),
          this.buildTl(),
          this.tl.progress(i),
          (this.target.style.display = this.openProp ? "block" : "none");
      }
    });
    (this.closeBtn = at(".js-menu-close")),
      (this.dom = {
        menu: at(".js-menu"),
        menuList: at(".js-menu-list"),
        externalLinksArray: od(".js-menu-external-links"),
        wordmark: at(".js-menu-wordmark"),
      }),
      (this.dom.listItem = od("li", this.dom.menuList)),
      K.set(this.dom.menu, { height: 0 }),
      this.buildTl(),
      this.addEvents(),
      E.Taxi.on("NAVIGATE_OUT", () => {
        E.mq.sm.matches || this.close();
      });
  }
  buildTl() {
    (this.tl = K.timeline({
      paused: !0,
      defaults: { ease: "power3.out", duration: 1 },
    })),
      this.tl
        .fromTo(this.dom.menu, { height: 0 }, { height: window.innerHeight })
        .from(this.dom.menuList, { y: -window.innerHeight / 4 }, 0)
        .from(
          this.dom.listItem,
          { y: (t) => -(50 + (this.dom.listItem.length - 1 - t) * 100) },
          0
        )
        .from(this.dom.externalLinksArray, { y: -180 }, 0)
        .from(this.dom.wordmark, { y: -120 }, 0)
        .from(this.closeBtn, { y: -100, duration: 0.5, rotate: -65 }, 0.5),
      this.tl.duration(1.5);
  }
  onOpen(t) {
    (this.target.style.display = "block"),
      E.SmoothScroll.lock(),
      this.tl.eventCallback("onComplete", () => t()),
      this.tl.duration(1.5),
      this.tl.play();
  }
  onClose(t) {
    E.SmoothScroll.unlock(),
      this.tl.eventCallback("onReverseComplete", () => {
        (this.target.style.display = "none"), t();
      }),
      this.tl.duration(0.3),
      this.tl.reverse();
  }
  reset() {
    var t;
    (t = this.tl) == null || t.kill(),
      (this.tl = null),
      Object.values(this.dom).forEach((i) => {
        K.set(i, { clearProps: !0 });
      }),
      K.set(this.closeBtn, { clearProps: !0 });
  }
  addEvents() {
    this.on("click", this.closeBtn, () => this.close()),
      this.on(Ze.RESIZE, this.onResize);
  }
}
q(Vw, "selector", ".js-menu-toggle");
class yd extends jt {
  constructor(t) {
    super(t);
    q(this, "DIRECTION_UP", -1);
    q(this, "DIRECTION_DOWN", 1);
    q(this, "waitlistLoading", () => {
      (this.dom.waitlistLoadingContainer.style.opacity = "1"),
        K.to(
          this.dom.waitlistLoading,
          { rotate: 360, duration: 1, repeat: -1, ease: "linear" },
          0
        ),
        (this.waitlistLoadingTL = K.timeline({ defaults: { duration: 0.3 } })
          .to(this.dom.submitText, { opacity: 0 })
          .to(this.dom.waitlistLoading, { opacity: 1 }, 0.2)
          .to(
            this.dom.closeForm,
            { opacity: E.mq.sm.matches ? 0 : 0.2, pointerEvents: "none" },
            0
          ));
    });
    q(this, "returnToPreviousStateSecondary", () => {
      this.dom.secondaryInputEl.classList.remove("hide-placeholder"),
        K.timeline({ defaults: { duration: 0.3 } })
          .to(this.dom.answerSubmitText, { opacity: 1 }, 0.2)
          .to(this.dom.secondaryLoading, { opacity: 0 }, 0)
          .to(this.dom.secondarySubmit, { opacity: 1, overwrite: "auto" })
          .to(this.dom.closeSecondaryForm, { autoAlpha: 1 }, 0)
          .set(this.dom.secondaryLoading, { rotate: 0, overwrite: "auto" });
    });
    q(this, "formSubmissionSuccess", () => {
      (this.flowStarted = !0),
        (this.dom.inputEl.value = ""),
        this.emit("ShyHeader:disable"),
        K.timeline({ defaults: { ease: "expo.inOut", duration: 0.6 } })
          .call(() => {
            this.dom.inputEl.classList.add("hide-placeholder");
          }, 0)
          .set(this.dom.formContainer, { pointerEvents: "none" }, 0)
          .to(this.dom.confirmationText, { opacity: 1 }, 0)
          .to(
            this.dom.inputContainer,
            { width: E.mq.sm.matches ? this.confirmationWidth : null },
            0
          )
          .to(
            this.dom.submitContainer,
            { width: E.mq.sm.matches ? null : "3.2rem" },
            0
          )
          .to(
            this.dom.inner,
            { width: E.mq.sm.matches ? this.submitStateWidth : null },
            0
          )
          .to(
            this.dom.submit,
            { opacity: 0, pointerEvents: "none", duration: 0.2 },
            0
          )
          .to(
            this.dom.formContainer,
            { width: E.mq.sm.matches ? this.tickWidth : null },
            0
          )
          .to(
            [this.dom.tickMask, this.dom.tickSvg],
            { xPercent: 0, duration: 1 },
            0
          )
          .to(this.dom.waitlistLoading, { opacity: 0, duration: 0.2 }, 0)
          .set(this.dom.waitlistLoading, { rotate: 0, overwrite: "auto" }, 0.2)
          .set(this.dom.submitText, { opacity: 1 })
          .to(this.dom.closeForm, { opacity: 0 }, 0)
          .call(
            () => {
              this.showSecondaryForm(), this.dom.secondaryInputEl.focus();
            },
            null,
            2
          );
    });
    q(this, "showSecondaryForm", () => {
      K.timeline({ defaults: { ease: "expo.in", duration: 0.8 } })
        .call(() => {
          this.dom.el.classList.add("reduce-padding");
        }, 0)
        .to(
          this.dom.inner,
          {
            width: E.mq.sm.matches ? this.secondFormWidth : null,
            ease: "expo.inOut",
          },
          0
        )
        .to(
          this.dom.el,
          { width: E.mq.sm.matches ? null : "3.55rem", ease: "expo.inOut" },
          0
        )
        .to(
          [this.dom.signInBtnContainer, this.dom.logomarkContainer],
          { width: 0, ease: "expo.inOut" },
          0
        )
        .to(
          [this.dom.inputContainer, this.dom.logomark],
          { opacity: 0, duration: 0.1, ease: "linear" },
          0
        )
        .to(
          this.dom.secondaryForm,
          {
            opacity: 1,
            yPercent: 0,
            duration: 1.2,
            ease: "customIn",
            overwrite: "auto",
          },
          0.1
        )
        .set(this.dom.secondaryForm, { pointerEvents: "auto" })
        .set(this.dom.waitlistError, {
          yPercent: 470,
          xPercent: -50,
          opacity: 0,
          pointerEvents: "none",
        });
    });
    q(this, "secondaryWaiting", () => {
      K.to(this.dom.secondaryLoading, {
        rotate: 360,
        duration: 1,
        repeat: -1,
        ease: "linear",
      }),
        (this.secondaryWaitingTL = K.timeline({
          defaults: { duration: 0.3 },
          onStart: () => {
            this.dom.secondaryInputEl.blur(),
              this.dom.secondaryInputEl.classList.add("hide-placeholder");
          },
        })
          .to(this.dom.secondarySubmit, { opacity: 0 })
          .to(this.dom.closeSecondaryForm, { autoAlpha: 0 }, 0)
          .to(this.dom.secondaryLoadingContainer, { opacity: 1 }, 0.2));
    });
    q(this, "secondaryComplete", () => {
      K.timeline({ defaults: { ease: "expo.inOut", duration: 0.6 } })
        .set(this.dom.answerSubmitText, { opacity: 0 })
        .to(this.dom.secondaryLoading, { opacity: 0, duration: 0.2 }, 0)
        .set(this.dom.secondaryLoading, { rotate: 0, overwrite: "auto" }, 0.2)
        .to(
          [this.dom.secondaryTickMask, this.dom.secondaryTickSvg],
          { xPercent: 0, duration: 1 },
          0.1
        )
        .then(() => {
          this.resetForm();
        });
    });
    q(this, "resetForm", () => {
      this.emit("ShyHeader:enable"),
        (this.flowComplete = !0),
        (this.flowStarted = !1),
        (this.formOpen = !1),
        this.dom.el.classList.remove("mobile-bg"),
        (this.dom.openFormTrigger.disabled = !0),
        this.dom.openFormTrigger.setAttribute("aria-label", "Joined"),
        E.mq.sm.matches ||
          K.to(this.dom.menuIcon, {
            autoAlpha: 1,
            display: "flex",
            delay: 0.5,
          }),
        K.timeline({ defaults: { duration: 0.6, ease: "power2.inOut" } })
          .set(this.dom.navigation, { opacity: 0 })
          .set(this.dom.secondaryForm, { pointerEvents: "none" })
          .to(
            this.dom.inner,
            { width: E.mq.sm.matches ? this.defaultWidth : null },
            0
          )
          .to(
            this.dom.el,
            { width: E.mq.sm.matches ? null : "calc(100% - 2.25rem)" },
            0
          )
          .to(
            this.dom.submitContainer,
            { width: E.mq.sm.matches ? null : this.submitWidth },
            0
          )
          .to(this.dom.logomarkContainer, { width: this.logoWidth }, 0)
          .to(this.dom.signInBtnContainer, { width: this.signInBtnWidth }, 0)
          .to(
            this.dom.formContainer,
            { width: E.mq.md.matches ? this.submitWidth : null },
            0
          )
          .to(
            [
              this.dom.logomark,
              this.dom.navigation,
              this.dom.signInBtn,
              this.dom.openFormTrigger,
            ],
            { opacity: 1, duration: 0.6 },
            0.3
          )
          .to(this.dom.secondaryForm, { opacity: 0, yPercent: 20 }, 0)
          .to(this.dom.tickContainer, { opacity: 0, duration: 0.1 }, 0)
          .set(
            [
              this.dom.openFormTrigger,
              this.dom.signInBtnContainer,
              this.dom.submitContainer,
              this.dom.formContainer,
            ],
            { pointerEvents: "auto", overwrite: "auto" },
            0
          )
          .set([this.dom.inputContainer], { pointerEvents: "none" }, 0)
          .to(this.dom.navigation, { xPercent: 0, overwrite: "true" }, 0)
          .call(
            () => {
              this.dom.el.classList.remove("reduce-padding");
            },
            null,
            0
          )
          .set(this.dom.inputContainer, { opacity: 1, width: this.inputWidth })
          .set(this.dom.input, { xPercent: 100 })
          .set(this.dom.confirmationText, { opacity: 0 })
          .set(this.dom.tickMask, { xPercent: -100 })
          .set(this.dom.tickSvg, { xPercent: 100 })
          .to(this.dom.tickContainer, { opacity: 1 })
          .then(() => {
            this.dom.inputEl.classList.remove("hide-placeholder");
          });
    });
    q(this, "onClickFormToggle", () => {
      window.innerWidth >= 1024
        ? (window.location.href = "https://www.cosmos.so/onboarding")
        : (window.location.href =
            "https://apps.apple.com/us/app/cosmos-curate-your-universe/id1577975475");
    });
    q(this, "closeForm", () => {
      this.formOpen &&
        ((this.formOpen = !1),
        this.formStateTL.reverse(),
        E.mq.sm.matches ||
          K.to(this.dom.menuIcon, {
            autoAlpha: 1,
            display: "flex",
            delay: 0.5,
          }),
        this.dom.el.classList.remove("mobile-bg"));
    });
    q(this, "playFormOpenTL", () => {
      this.formOpen || this.formStateTL.restart();
    });
    q(this, "playFormCloseTL", () => {
      this.formOpen && this.formStateTL.reverse();
    });
    q(this, "onResize", () => {
      if (
        (this.formStateTL.kill(),
        K.set([this.dom.navigation, this.dom.inner, this.dom.signInBtn], {
          clearProps: "all",
        }),
        this.flowComplete)
      ) {
        K.set([this.dom.formContainer, this.dom.signInBtnContainer], {
          clearProps: "all",
        });
        return;
      }
      K.set(this.dom.submit, { opacity: 0 }),
        this.flowStarted
          ? this.resetForm()
          : ((this.formOpen = !1),
            this.getElemWidths(),
            this.setInitialPositions(),
            this.toggleFormState()),
        E.mq.sm.matches
          ? K.set(this.dom.menuIcon, { autoAlpha: 0, display: "none" })
          : this.formOpen ||
            K.set(this.dom.menuIcon, { autoAlpha: 1, display: "flex" });
    });
    q(this, "onScroll", ({ direction: t }) => {});
    q(this, "onInputChange", () => {
      this.dom.secondaryInputEl.value.length > 16
        ? K.to(this.dom.answerSubmitText, { opacity: 0, duration: 0.26 })
        : K.to(this.dom.answerSubmitText, { opacity: 1, duration: 0.26 });
    });
    q(this, "onHeaderHidden", () => {
      this.formOpen && this.closeForm();
    });
    this.populateDom(),
      (this.buttons = new qh(lg).init(t)),
      (this.formOpen = !1),
      (this.flowComplete = !1),
      (this.flowStarted = !1),
      (this.toggleClicked = !1),
      E.AssetLoader.loaded.then(() => {
        this.getElemWidths(),
          this.addEvents(),
          this.setInitialPositions(),
          this.toggleFormState();
      });
  }
  getElemWidths() {
    (this.logoWidth = this.dom.logomarkContainer.getBoundingClientRect().width),
      (this.signInBtnWidth =
        this.dom.signInBtnContainer.getBoundingClientRect().width),
      (this.navWidth = this.dom.navigation.getBoundingClientRect().width),
      (this.inputWidth = this.dom.input.getBoundingClientRect().width),
      (this.submitWidth =
        this.dom.submitContainer.getBoundingClientRect().width),
      (this.confirmationWidth =
        this.dom.confirmationText.getBoundingClientRect().width),
      (this.tickWidth = this.dom.tickContainer.getBoundingClientRect().width),
      (this.formWidth = this.dom.formContainer.getBoundingClientRect().width),
      (this.defaultWidth =
        this.logoWidth +
        this.signInBtnWidth +
        this.navWidth +
        this.submitWidth),
      (this.formWidth = this.logoWidth + this.inputWidth + this.submitWidth),
      (this.submitStateWidth =
        this.logoWidth + this.confirmationWidth + this.tickWidth),
      (this.secondFormWidth = this.tickWidth);
  }
  setInitialPositions() {
    K.timeline()
      .set([this.dom.tickContainer, this.dom.secondaryTickContainer], {
        pointerEvents: "none",
      })
      .set([this.dom.tickMask, this.dom.secondaryTickMask], { xPercent: -100 })
      .set([this.dom.tickSvg, this.dom.secondaryTickSvg], { xPercent: 100 })
      .set(this.dom.secondaryForm, {
        pointerEvents: "none",
        opacity: 0,
        yPercent: 20,
      })
      .set([this.dom.waitlistLoading], { opacity: 0 })
      .set(
        [
          this.dom.waitlistLoadingContainer,
          this.dom.secondaryLoadingContainer,
          this.dom.inputContainer,
        ],
        { pointerEvents: "none", opacity: 0 }
      )
      .set([this.dom.signInBtnContainer], { pointerEvents: "auto" })
      .set(this.dom.closeForm, { opacity: 0, pointerEvents: "none" })
      .set(this.dom.waitlistError, {
        yPercent: -20,
        xPercent: -50,
        opacity: 0,
        pointerEvents: "none",
      })
      .set(this.dom.input, { xPercent: 101 })
      .set(this.dom.openFormTrigger, { opacity: 1 });
  }
  showError() {
    K.to(this.dom.waitlistError, {
      yPercent: "+=20",
      opacity: 1,
      overwrite: "auto",
      xPercent: -50,
    });
  }
  hideError() {
    K.to(this.dom.waitlistError, {
      yPercent: "+=-20",
      opacity: 0,
      overwrite: "auto",
      xPercent: -50,
    });
  }
  toggleFormState() {
    this.formStateTL = K.timeline({
      paused: !0,
      defaults: { duration: 1, ease: "expo.inOut" },
    })
      .to(this.dom.inner, { width: E.mq.sm.matches ? this.formWidth : null })
      .to(this.dom.navigation, { xPercent: 100 }, 0)
      .to(this.dom.input, { xPercent: 0 }, 0)
      .to(this.dom.signInBtn, { opacity: 0, duration: 0.8, ease: "linear" }, 0)
      .to(
        this.dom.closeForm,
        {
          opacity: E.mq.sm.matches ? 0 : 1,
          pointerEvents: E.mq.sm.matches ? "none" : "auto",
        },
        0
      )
      .set(this.dom.submit, { opacity: 1 })
      .set(this.dom.openFormTrigger, { opacity: 0 })
      .set([this.dom.signInBtnContainer], { pointerEvents: "none" }, 0)
      .set(
        [
          this.dom.formContainer,
          this.dom.submitContainer,
          this.dom.inputContainer,
        ],
        { pointerEvents: "auto", opacity: 1 },
        0
      )
      .call(() => {
        this.toggleClicked && this.dom.inputEl.focus();
      });
  }
  returnToPreviousState() {
    K.timeline({ defaults: { duration: 0.3 } })
      .to(this.dom.submitText, { opacity: 1 }, 0.2)
      .to(this.dom.waitlistLoading, { opacity: 0 }, 0)
      .to(
        this.dom.closeForm,
        { opacity: E.mq.sm.matches ? 0 : 1, pointerEvents: "auto" },
        0
      )
      .set(this.dom.waitlistLoading, { rotate: 0, overwrite: "auto" });
  }
  addEvents() {
    this.on("click", this.dom.openFormTrigger, this.onClickFormToggle),
      this.on("click", this.dom.closeForm, this.closeForm),
      this.on("click", this.dom.closeSecondaryForm, this.resetForm),
      this.on("Header:OpenForm", this.playFormOpenTL),
      this.on("Header:CloseForm", this.playFormCloseTL),
      this.on(Ze.RESIZE, this.onResize),
      this.on("input", this.dom.secondaryInputEl, this.onInputChange),
      this.on("ShyHeader:hidden", this.onHeaderHidden),
      E.SmoothScroll.Lenis.on("scroll", this.onScroll);
  }
  destroy() {
    super.destroy(), E.SmoothScroll.Lenis.off("scroll", this.onScroll);
  }
}
q(yd, "selector", ".js-header");
class zw extends jt {
  constructor(t) {
    super(t);
    q(this, "DIRECTION_UP", -1);
    q(this, "DIRECTION_DOWN", 1);
    q(this, "TRIGGER_OFFSET", 20);
    q(this, "isShown", !0);
    q(this, "duration", 0.4);
    q(this, "lastDirection", null);
    q(this, "isManuallyHidden", !1);
    q(this, "calculateY", () => {
      const t = this.header.getBoundingClientRect();
      this.y = t.height + t.top + 5;
    });
    q(this, "hideHeader", () => {
      var t;
      if (((this.isShown = !1), (E.isHeaderHidden = !0), !E.mq.touch.matches))
        for (let i = 0; i < this.headerComponent.buttons.components.length; i++)
          this.headerComponent.buttons.components[i].hideGlowPanels();
      (t = this.tl) == null || t.kill(),
        (this.tl = K.timeline().to(this.header, {
          y: -this.y,
          ease: "power2.in",
          duration: this.duration,
          onComplete: () => this.emit("ShyHeader:hidden"),
        }));
    });
    q(this, "showHeader", () => {
      var t;
      if (((this.isShown = !0), (E.isHeaderHidden = !1), !E.mq.touch.matches))
        for (let i = 0; i < this.headerComponent.buttons.components.length; i++)
          this.headerComponent.buttons.components[i].showGlowPanels();
      (t = this.tl) == null || t.kill(),
        (this.tl = K.timeline().to(this.header, {
          y: 0,
          ease: "power2.out",
          duration: this.duration,
        }));
    });
    q(this, "enableShyHeader", () => {
      E.isShyHeaderActive ||
        (E.SmoothScroll.Lenis.on("scroll", this.onScroll),
        this.on("mouseenter", this.dom.trigger, this.onMouseEnter));
    });
    q(this, "disableShyHeader", () => {
      E.SmoothScroll.Lenis.off("scroll", this.onScroll),
        this.off("mouseenter", this.dom.trigger, this.onMouseEnter),
        E.isHeaderHidden && this.showHeader();
    });
    q(this, "addEvents", () => {
      this.on(Ze.RESIZE, this.onResize),
        this.on("ShyHeader:show", () => {
          (this.isManuallyHidden = !1), this.showHeader();
        }),
        this.on("ShyHeader:hide", () => {
          (this.isManuallyHidden = !0), this.hideHeader();
        }),
        this.on("ShyHeader:enable", () => {
          this.enableShyHeader(), (E.isShyHeaderActive = !0);
        }),
        this.on("ShyHeader:disable", () => {
          this.disableShyHeader(), (E.isShyHeaderActive = !1);
        }),
        E.Taxi.on("NAVIGATE_OUT", () => {
          this.isManuallyHidden = !1;
        });
    });
    q(this, "onResize", () => {
      (this.isManuallyHidden = !1),
        K.set(this.header, { clearProps: "all" }),
        window.requestAnimationFrame(this.calculateY),
        E.isShyHeaderActive ||
          (E.mq.sm.matches ? this.disableShyHeader() : this.enableShyHeader());
    });
    q(this, "onScroll", ({ direction: t, targetScroll: i }) => {
      window.clearTimeout(this.timeout),
        !(i <= 0 || this.isManuallyHidden) &&
          ((this.timeout = window.setTimeout(() => {
            this.lastDirection = null;
          }, 100)),
          t !== this.lastDirection &&
            ((this.lastDirection = t),
            t === this.DIRECTION_DOWN && this.isShown
              ? this.hideHeader()
              : t === this.DIRECTION_UP && !this.isShown && this.showHeader()));
    });
    q(this, "onMouseEnter", () => {
      !this.isShown && this.showHeader();
    });
    this.populateDom(),
      (this.header = this.dom.el),
      (this.headerComponent = E.staticComponents.get(yd).get(0)),
      K.set(this.header, { willChange: "y" }),
      K.set(this.dom.trigger, { height: this.TRIGGER_OFFSET }),
      this.calculateY();
  }
  destroy() {
    var t;
    super.destroy(),
      this.showHeader(),
      (t = this.tl) == null || t.kill(),
      E.SmoothScroll.Lenis.off("scroll", this.onScroll);
  }
}
q(zw, "selector", ".js-shy-header");
class Uw extends jt {
  constructor(t, i = !1) {
    super(t);
    q(this, "formIsSubmitting", !1);
    q(this, "email", null);
    q(this, "onEmailFormSubmit", (t) => {
      t.preventDefault(),
        !this.formIsSubmitting &&
          ((this.formIsSubmitting = !0),
          this.isHeader
            ? (this.header.waitlistLoading(),
              this.header.waitlistLoadingTL.then(() => {
                this.fetchFirstStep();
              }))
            : (this.footer.waitlistLoading(),
              this.footer.waitlistLoadingTL.then(() => {
                this.fetchFirstStep();
              })));
    });
    q(this, "onAnswerFormSubmit", (t) => {
      t.preventDefault(),
        !this.formIsSubmitting &&
          ((this.formIsSubmitting = !0),
          this.isHeader
            ? (this.header.secondaryWaiting(),
              this.header.secondaryWaitingTL.then(() => {
                this.fetchSecondStep();
              }))
            : (this.footer.secondaryWaiting(),
              this.footer.secondaryWaitingTL.then(() => {
                this.fetchSecondStep();
              })));
    });
    q(this, "fetchFirstStep", () => {
      fetch("https://api.www.cosmos.so/graphql", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
        },
        body: JSON.stringify({
          query: `
					mutation ($input: JoinWaitlistInput!) {
						waitlist {
							join(input: $input) {
								success
							}
						}
					}
				`,
          variables: { input: { email: this.dom.email.value } },
        }),
      })
        .then((t) => t.json())
        .then((t) => {
          t.errors
            ? this.handleEmailFormError(t.errors)
            : this.handleEmailFormSuccess();
        })
        .catch(() => {
          this.handleError();
        });
    });
    q(this, "fetchSecondStep", () => {
      fetch("https://api.www.cosmos.so/graphql", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
        },
        body: JSON.stringify({
          query: `
					mutation ($input: SubmitJoinFollowUpAnswerInput!) {
    					waitlist {
        					submitJoinFollowUpAnswer(input: $input) {
            					success
        					}
						}
					}
				`,
          variables: {
            input: {
              email: this.email,
              howHeardAboutUsAnswer: this.dom.answer.value,
            },
          },
        }),
      })
        .then((t) => t.json())
        .then((t) => {
          t.errors
            ? this.handleAnswerFormError(t.errors)
            : this.handleAnswerFormSuccess();
        })
        .catch(() => {
          this.handleError();
        });
    });
    (this.isHeader = t.classList.contains("js-header")),
      (this.isAnswerFormEnabled = i),
      (this.emailSubmitSuccess = !1),
      this.populateDom(),
      this.on("submit", this.dom.emailForm, this.onEmailFormSubmit),
      this.on("submit", this.dom.answerForm, this.onAnswerFormSubmit),
      this.isHeader && (this.header = E.staticComponents.get(yd).first()),
      this.isHeader || (this.footer = E.components.get(ag).first());
  }
  handleError(t = void 0) {
    Array.isArray(t) && t.length > 0 && t[0].message
      ? (this.dom.waitlistError.innerHTML = t[0].message)
      : (this.dom.waitlistError.innerHTML = "Sorry, something went wrong."),
      this.isHeader &&
        (this.header.showError(),
        this.emailSubmitSuccess
          ? this.header.returnToPreviousStateSecondary()
          : this.header.returnToPreviousState(),
        this.dom.emailForm.reset(),
        setTimeout(() => {
          this.header.hideError();
        }, 5e3)),
      this.isHeader ||
        (this.footer.showError(),
        this.emailSubmitSuccess
          ? this.footer.returnToPreviousStateSecondary()
          : this.footer.returnToPreviousState(),
        setTimeout(() => {
          this.footer.hideError();
        }, 5e3));
  }
  handleEmailFormSuccess() {
    (this.formIsSubmitting = !1),
      (this.email = this.dom.email.value),
      this.isAnswerFormEnabled
        ? this.header.formSubmissionSuccess()
        : this.footer.formSubmissionSuccess(),
      (this.emailSubmitSuccess = !0);
  }
  handleEmailFormError(t) {
    this.handleError(t), (this.formIsSubmitting = !1);
  }
  handleAnswerFormSuccess() {
    (this.formIsSubmitting = !1),
      this.isHeader
        ? this.header.secondaryComplete()
        : this.footer.secondaryComplete(),
      this.dom.emailForm.reset(),
      this.dom.answerForm.reset();
  }
  handleAnswerFormError(t) {
    this.handleError(t), (this.formIsSubmitting = !1);
  }
}
q(Uw, "selector", ".js-forms");
class Gw extends jt {
  constructor(t) {
    super(t);
    q(this, "onMouseEnterLight", () => {
      this.el.classList.add("light-hovered");
    });
    q(this, "onMouseLeaveLight", () => {
      this.el.classList.remove("light-hovered");
    });
    q(this, "onMouseEnterDark", () => {
      this.el.classList.add("dark-hovered");
    });
    q(this, "onMouseLeaveDark", () => {
      this.el.classList.remove("dark-hovered");
    });
    q(this, "toggleState", () => {
      this.animating ||
        ((this.animating = !0),
        E.isDarkMode
          ? (De.emit("DarkMode:enabled"),
            De.emit("ModeToggle:toggled"),
            this.dom.darkText.classList.add("active"),
            this.dom.lightText.classList.remove("active"),
            K.timeline({
              onComplete: () => {
                this.animating = !1;
              },
            })
              .to(
                this.dom.iconArray[0],
                { opacity: 1, duration: 0.3, ease: "expo.in" },
                0
              )
              .to(
                this.dom.iconArray[1],
                { opacity: 0, duration: 0.6, ease: "expo.out" },
                0
              ))
          : (De.emit("DarkMode:disabled"),
            this.dom.lightText.classList.add("active"),
            this.dom.darkText.classList.remove("active"),
            K.timeline({
              onComplete: () => {
                this.animating = !1;
              },
            })
              .to(
                this.dom.iconArray[1],
                { opacity: 1, duration: 0.3, ease: "expo.in" },
                0
              )
              .to(
                this.dom.iconArray[0],
                { opacity: 0, duration: 0.6, ease: "expo.out" },
                0
              )));
    });
    q(this, "collapseToggle", () => {
      var t;
      (t = this.tl) == null || t.restart(), (this.collapsed = !0);
    });
    q(this, "expandToggle", () => {
      this.tl.reverse(), (this.collapsed = !1);
    });
    q(this, "onClick", () => {
      this.animating ||
        ((E.isDarkMode = !E.isDarkMode),
        E.isDarkMode
          ? E.html.classList.add("is-dark-mode")
          : E.html.classList.remove("is-dark-mode"),
        this.toggleState());
    });
    q(this, "onResize", () => {
      var t;
      (t = this.tl) == null || t.kill(),
        (this.tl = null),
        K.set(
          [
            this.dom.text,
            this.dom.mask,
            this.dom.maskInner,
            this.dom.icons,
            this.dom.borderArray,
            this.dom.borderInnerArray,
          ],
          { clearProps: "all" }
        ),
        this.dom.borderArray[0].removeAttribute("style"),
        this.dom.borderInnerArray[0].removeAttribute("style"),
        this.dom.borderArray[1].removeAttribute("style"),
        this.dom.borderInnerArray[1].removeAttribute("style"),
        this.setup(),
        this.buildCollapseTimeline(),
        this.toggleState(),
        (!E.mq.sm.matches || this.collapsed) &&
          this.emit("ModeToggle:CollapseToggle");
    });
    this.populateDom(),
      (this.animating = !1),
      this.setup(),
      this.buildCollapseTimeline(),
      this.toggleState(),
      (this.collapsed = !1),
      this.on("click", this.el, this.onClick),
      this.on("ModeToggle:CollapseToggle", this.collapseToggle),
      this.on("ModeToggle:ExpandToggle", this.expandToggle),
      this.on("ModeToggle:ToggleState", this.onClick),
      this.on(Ze.RESIZE, this.onResize),
      this.on("mouseenter", this.dom.lightText, this.onMouseEnterLight),
      this.on("mouseleave", this.dom.lightText, this.onMouseLeaveLight),
      this.on("mouseenter", this.dom.darkText, this.onMouseEnterDark),
      this.on("mouseleave", this.dom.darkText, this.onMouseLeaveDark),
      E.mq.sm.matches || this.emit("ModeToggle:CollapseToggle");
  }
  setup() {
    (this.originalWidth = this.el.getBoundingClientRect().width),
      (this.collapseWidth = this.dom.box.getBoundingClientRect().width),
      (this.dom.borderArray[0].style.width = this.collapseWidth * 0.5 + "px"),
      (this.dom.borderInnerArray[0].style.width = this.originalWidth + "px"),
      (this.dom.borderArray[1].style.width =
        this.originalWidth - this.collapseWidth * 0.5 + "px"),
      (this.dom.borderInnerArray[1].style.width = this.originalWidth + "px"),
      (this.dom.borderInnerArray[1].style.left =
        -(this.collapseWidth * 0.5) + "px"),
      (this.collapseXPos = this.originalWidth - this.collapseWidth);
  }
  buildCollapseTimeline() {
    this.tl = K.timeline({
      paused: !0,
      defaults: { ease: "expo.inOut", duration: 1 },
    })
      .to(this.dom.borderInnerArray[1], { x: -this.collapseXPos }, 0)
      .to(this.dom.mask, { x: -this.collapseXPos }, 0)
      .to(this.dom.maskInner, { x: this.collapseXPos }, 0)
      .to(this.dom.icons, { x: -this.originalWidth }, 0)
      .to(this.dom.text, { x: E.mq.sm.matches ? -this.originalWidth : -100 }, 0)
      .to(this.dom.glowInner, { xPercent: -48 }, 0);
  }
  destroy() {
    super.destroy();
  }
}
q(Gw, "selector", ".js-mode-toggle");
class $R extends _w {
  drag() {
    K.to(this.dom.dot, { opacity: 0, scale: 0 }),
      K.to(this.dom.ew, { opacity: 1, scale: 1 });
  }
  default() {
    K.to(this.dom.dot, { opacity: 1, scale: 1 }),
      K.to(this.dom.ew, { opacity: 0, scale: 0 });
  }
}
window.store = E;
E.isAndroid && E.html.classList.add("is-android");
De.on("DOMContentLoaded", window, function () {
  var r;
  Ze.enablePointerEvents(),
    Ze.enableRAF(K),
    Ze.enableResize(100),
    Ze.detectTouchDevice(),
    Ze.enableDrag(),
    window.history.scrollRestoration &&
      (window.history.scrollRestoration = "manual"),
    document.documentElement.style.setProperty(
      "--vh",
      `${window.innerHeight * 0.01}px`
    ),
    (E.window.fullHeight =
      (r = document.querySelector(".height-div")) == null
        ? void 0
        : r.clientHeight),
    K.registerPlugin(ut, As, xr),
    TA(),
    (E.AssetLoader = new M3()),
    (E.WebGL = new XR()),
    fl.init(),
    (E.initialWheelMultiplier =
      E.SmoothScroll.Lenis.virtualScroll.wheelMultiplier),
    (E.initialTouchMultiplier =
      E.SmoothScroll.Lenis.virtualScroll.touchMultiplier),
    (E.ScrollAnimations = new xA()),
    (E.FormsManager = new qh(Uw)),
    E.staticComponents.add(
      Gw,
      Ew,
      new qh($R).with({ offset: [0.5, 0.5], ease: 0.09 })
    ),
    (E.Taxi = new qR()),
    wA.init(),
    E.staticComponents.add(yd, zw, Bw, Vw, vw),
    (this.header = at(".js-header")),
    (this.headerForm = E.FormsManager.make(this.header, !0)),
    E.mq.touch.matches && An.init(),
    As.create("customIn", "0.45, 0.34, 0.14, 0.99"),
    As.create("vortexIn", "0.29, 0.11, 0.14, 99"),
    As.create(
      "returnEase",
      "M0,0 C0.196,0.598 0.298,1 0.5,1 0.696,1 0.794,0.604 1,0"
    ),
    As.create("imageSlider", "M0,0,C0.498,0.302,0.744,1,1,1"),
    As.create("searchOut", "M0,0 C0.146,0 0.458,0.332 1,1 "),
    As.create("imageOut", "M0,0 C0.194,0 0.18,0.042 1,1");
});
